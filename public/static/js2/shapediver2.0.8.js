// threejs.org/license
(function(l, ya) {
    "object" === typeof exports && "undefined" !== typeof module ? ya(exports) : "function" === typeof define && define.amd ? define(["exports"], ya) : ya(l.THREE = {})
})(this, function(l) {
    function ya() {}

    function z(a, b) {
        this.x = a || 0;
        this.y = b || 0
    }

    function I() {
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
    }

    function fa(a, b, c, d) {
        this._x = a || 0;
        this._y = b || 0;
        this._z = c || 0;
        this._w = void 0 !== d ? d : 1
    }

    function p(a,
        b, c) {
        this.x = a || 0;
        this.y = b || 0;
        this.z = c || 0
    }

    function ra() {
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
    }

    function T(a, b, c, d, e, f, g, h, k, m) {
        Object.defineProperty(this, "id", {
            value: Ef++
        });
        this.uuid = H.generateUUID();
        this.name = "";
        this.image = void 0 !== a ? a : T.DEFAULT_IMAGE;
        this.mipmaps = [];
        this.mapping = void 0 !== b ? b : T.DEFAULT_MAPPING;
        this.wrapS = void 0 !== c ? c : 1001;
        this.wrapT = void 0 !== d ? d : 1001;
        this.magFilter = void 0 !==
            e ? e : 1006;
        this.minFilter = void 0 !== f ? f : 1008;
        this.anisotropy = void 0 !== k ? k : 1;
        this.format = void 0 !== g ? g : 1023;
        this.type = void 0 !== h ? h : 1009;
        this.offset = new z(0, 0);
        this.repeat = new z(1, 1);
        this.center = new z(0, 0);
        this.rotation = 0;
        this.matrixAutoUpdate = !0;
        this.matrix = new ra;
        this.generateMipmaps = !0;
        this.premultiplyAlpha = !1;
        this.flipY = !0;
        this.unpackAlignment = 4;
        this.encoding = void 0 !== m ? m : 3E3;
        this.version = 0;
        this.onUpdate = null
    }

    function V(a, b, c, d) {
        this.x = a || 0;
        this.y = b || 0;
        this.z = c || 0;
        this.w = void 0 !== d ? d : 1
    }

    function fb(a,
        b, c) {
        this.width = a;
        this.height = b;
        this.scissor = new V(0, 0, a, b);
        this.scissorTest = !1;
        this.viewport = new V(0, 0, a, b);
        c = c || {};
        void 0 === c.minFilter && (c.minFilter = 1006);
        this.texture = new T(void 0, void 0, c.wrapS, c.wrapT, c.magFilter, c.minFilter, c.format, c.type, c.anisotropy, c.encoding);
        this.texture.generateMipmaps = void 0 !== c.generateMipmaps ? c.generateMipmaps : !0;
        this.depthBuffer = void 0 !== c.depthBuffer ? c.depthBuffer : !0;
        this.stencilBuffer = void 0 !== c.stencilBuffer ? c.stencilBuffer : !0;
        this.depthTexture = void 0 !== c.depthTexture ?
            c.depthTexture : null
    }

    function Gb(a, b, c) {
        fb.call(this, a, b, c);
        this.activeMipMapLevel = this.activeCubeFace = 0
    }

    function gb(a, b, c, d, e, f, g, h, k, m, q, n) {
        T.call(this, null, f, g, h, k, m, d, e, q, n);
        this.image = {
            data: a,
            width: b,
            height: c
        };
        this.magFilter = void 0 !== k ? k : 1003;
        this.minFilter = void 0 !== m ? m : 1003;
        this.flipY = this.generateMipmaps = !1;
        this.unpackAlignment = 1
    }

    function Sa(a, b) {
        this.min = void 0 !== a ? a : new p(Infinity, Infinity, Infinity);
        this.max = void 0 !== b ? b : new p(-Infinity, -Infinity, -Infinity)
    }

    function Da(a, b) {
        this.center = void 0 !==
            a ? a : new p;
        this.radius = void 0 !== b ? b : 0
    }

    function Ma(a, b) {
        this.normal = void 0 !== a ? a : new p(1, 0, 0);
        this.constant = void 0 !== b ? b : 0
    }

    function md(a, b, c, d, e, f) {
        this.planes = [void 0 !== a ? a : new Ma, void 0 !== b ? b : new Ma, void 0 !== c ? c : new Ma, void 0 !== d ? d : new Ma, void 0 !== e ? e : new Ma, void 0 !== f ? f : new Ma]
    }

    function G(a, b, c) {
        return void 0 === b && void 0 === c ? this.set(a) : this.setRGB(a, b, c)
    }

    function Qd() {
        function a(e, f) {
            !1 !== c && (d(e, f), b.requestAnimationFrame(a))
        }
        var b = null,
            c = !1,
            d = null;
        return {
            start: function() {
                !0 !== c && null !== d && (b.requestAnimationFrame(a),
                    c = !0)
            },
            stop: function() {
                c = !1
            },
            setAnimationLoop: function(a) {
                d = a
            },
            setContext: function(a) {
                b = a
            }
        }
    }

    function Ff(a) {
        function b(b, c) {
            var d = b.array,
                e = b.dynamic ? a.DYNAMIC_DRAW : a.STATIC_DRAW,
                h = a.createBuffer();
            a.bindBuffer(c, h);
            a.bufferData(c, d, e);
            b.onUploadCallback();
            c = a.FLOAT;
            d instanceof Float32Array ? c = a.FLOAT : d instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : d instanceof Uint16Array ? c = a.UNSIGNED_SHORT : d instanceof Int16Array ? c = a.SHORT : d instanceof
            Uint32Array ? c = a.UNSIGNED_INT : d instanceof Int32Array ? c = a.INT : d instanceof Int8Array ? c = a.BYTE : d instanceof Uint8Array && (c = a.UNSIGNED_BYTE);
            return {
                buffer: h,
                type: c,
                bytesPerElement: d.BYTES_PER_ELEMENT,
                version: b.version
            }
        }
        var c = new WeakMap;
        return {
            get: function(a) {
                a.isInterleavedBufferAttribute && (a = a.data);
                return c.get(a)
            },
            remove: function(b) {
                b.isInterleavedBufferAttribute && (b = b.data);
                var d = c.get(b);
                d && (a.deleteBuffer(d.buffer), c.delete(b))
            },
            update: function(d, e) {
                d.isInterleavedBufferAttribute && (d = d.data);
                var f = c.get(d);
                if (void 0 === f) c.set(d, b(d, e));
                else if (f.version < d.version) {
                    var g = d,
                        h = g.array,
                        k = g.updateRange;
                    a.bindBuffer(e, f.buffer);
                    !1 === g.dynamic ? a.bufferData(e, h, a.STATIC_DRAW) : -1 === k.count ? a.bufferSubData(e, 0, h) : 0 === k.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (a.bufferSubData(e, k.offset * h.BYTES_PER_ELEMENT, h.subarray(k.offset, k.offset + k.count)), k.count = -1);
                    f.version = d.version
                }
            }
        }
    }

    function hb(a, b, c, d) {
        this._x = a || 0;
        this._y = b || 0;
        this._z = c || 0;
        this._order = d || hb.DefaultOrder
    }

    function Rd() {
        this.mask = 1
    }

    function D() {
        Object.defineProperty(this, "id", {
            value: Gf++
        });
        this.uuid = H.generateUUID();
        this.name = "";
        this.type = "Object3D";
        this.parent = null;
        this.children = [];
        this.up = D.DefaultUp.clone();
        var a = new p,
            b = new hb,
            c = new fa,
            d = new p(1, 1, 1);
        b.onChange(function() {
            c.setFromEuler(b, !1)
        });
        c.onChange(function() {
            b.setFromQuaternion(c, void 0, !1)
        });
        Object.defineProperties(this, {
            position: {
                enumerable: !0,
                value: a
            },
            rotation: {
                enumerable: !0,
                value: b
            },
            quaternion: {
                enumerable: !0,
                value: c
            },
            scale: {
                enumerable: !0,
                value: d
            },
            modelViewMatrix: {
                value: new I
            },
            normalMatrix: {
                value: new ra
            }
        });
        this.matrix = new I;
        this.matrixWorld = new I;
        this.matrixAutoUpdate = D.DefaultMatrixAutoUpdate;
        this.matrixWorldNeedsUpdate = !1;
        this.layers = new Rd;
        this.visible = !0;
        this.receiveShadow = this.castShadow = !1;
        this.frustumCulled = !0;
        this.renderOrder = 0;
        this.userData = {}
    }

    function Na() {
        D.call(this);
        this.type = "Camera";
        this.matrixWorldInverse =
            new I;
        this.projectionMatrix = new I
    }

    function Hb(a, b, c, d, e, f) {
        Na.call(this);
        this.type = "OrthographicCamera";
        this.zoom = 1;
        this.view = null;
        this.left = a;
        this.right = b;
        this.top = c;
        this.bottom = d;
        this.near = void 0 !== e ? e : .1;
        this.far = void 0 !== f ? f : 2E3;
        this.updateProjectionMatrix()
    }

    function Ta(a, b, c, d, e, f) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.normal = d && d.isVector3 ? d : new p;
        this.vertexNormals = Array.isArray(d) ? d : [];
        this.color = e && e.isColor ? e : new G;
        this.vertexColors = Array.isArray(e) ? e : [];
        this.materialIndex = void 0 !== f ? f : 0
    }

    function R() {
        Object.defineProperty(this,
            "id", {
                value: Hf += 2
            });
        this.uuid = H.generateUUID();
        this.name = "";
        this.type = "Geometry";
        this.vertices = [];
        this.colors = [];
        this.faces = [];
        this.faceVertexUvs = [
            []
        ];
        this.morphTargets = [];
        this.morphNormals = [];
        this.skinWeights = [];
        this.skinIndices = [];
        this.lineDistances = [];
        this.boundingSphere = this.boundingBox = null;
        this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = !1
    }

    function Q(a, b, c) {
        if (Array.isArray(a)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.name = "";
        this.array = a;
        this.itemSize = b;
        this.count = void 0 !== a ? a.length / b : 0;
        this.normalized = !0 === c;
        this.dynamic = !1;
        this.updateRange = {
            offset: 0,
            count: -1
        };
        this.version = 0
    }

    function oc(a, b, c) {
        Q.call(this, new Int8Array(a), b, c)
    }

    function pc(a, b, c) {
        Q.call(this, new Uint8Array(a), b, c)
    }

    function qc(a, b, c) {
        Q.call(this, new Uint8ClampedArray(a), b, c)
    }

    function rc(a, b, c) {
        Q.call(this, new Int16Array(a), b, c)
    }

    function ib(a, b, c) {
        Q.call(this, new Uint16Array(a), b, c)
    }

    function sc(a, b, c) {
        Q.call(this, new Int32Array(a), b, c)
    }

    function jb(a,
        b, c) {
        Q.call(this, new Uint32Array(a), b, c)
    }

    function A(a, b, c) {
        Q.call(this, new Float32Array(a), b, c)
    }

    function tc(a, b, c) {
        Q.call(this, new Float64Array(a), b, c)
    }

    function Ee() {
        this.vertices = [];
        this.normals = [];
        this.colors = [];
        this.uvs = [];
        this.uvs2 = [];
        this.groups = [];
        this.morphTargets = {};
        this.skinWeights = [];
        this.skinIndices = [];
        this.boundingSphere = this.boundingBox = null;
        this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1
    }

    function Fe(a) {
        if (0 === a.length) return -Infinity;
        for (var b = a[0], c = 1, d = a.length; c < d; ++c) a[c] > b && (b = a[c]);
        return b
    }

    function C() {
        Object.defineProperty(this, "id", {
            value: If += 2
        });
        this.uuid = H.generateUUID();
        this.name = "";
        this.type = "BufferGeometry";
        this.index = null;
        this.attributes = {};
        this.morphAttributes = {};
        this.groups = [];
        this.boundingSphere = this.boundingBox = null;
        this.drawRange = {
            start: 0,
            count: Infinity
        };
        this.userData = {}
    }

    function Ib(a, b, c, d, e, f) {
        R.call(this);
        this.type = "BoxGeometry";
        this.parameters = {
            width: a,
            height: b,
            depth: c,
            widthSegments: d,
            heightSegments: e,
            depthSegments: f
        };
        this.fromBufferGeometry(new kb(a, b, c, d, e, f));
        this.mergeVertices()
    }

    function kb(a, b, c, d, e, f) {
        function g(a, b, c, d, e, f, g, l, N, O, Jf) {
            var r = f / N,
                v = g / O,
                P = f / 2,
                y = g / 2,
                w = l / 2;
            g = N + 1;
            var E = O + 1,
                x = f = 0,
                B, z, A = new p;
            for (z = 0; z < E; z++) {
                var D = z * v - y;
                for (B = 0; B < g; B++) A[a] = (B * r - P) * d, A[b] = D * e, A[c] = w, m.push(A.x, A.y, A.z), A[a] = 0, A[b] = 0, A[c] = 0 < l ? 1 : -1, q.push(A.x, A.y, A.z), n.push(B / N), n.push(1 - z / O), f += 1
            }
            for (z = 0; z < O; z++)
                for (B = 0; B < N; B++) a = t + B + g * (z + 1), b = t + (B + 1) + g * (z + 1), c = t + (B + 1) + g * z, k.push(t + B + g * z, a, c), k.push(a, b, c), x +=
                    6;
            h.addGroup(u, x, Jf);
            u += x;
            t += f
        }
        C.call(this);
        this.type = "BoxBufferGeometry";
        this.parameters = {
            width: a,
            height: b,
            depth: c,
            widthSegments: d,
            heightSegments: e,
            depthSegments: f
        };
        var h = this;
        a = a || 1;
        b = b || 1;
        c = c || 1;
        d = Math.floor(d) || 1;
        e = Math.floor(e) || 1;
        f = Math.floor(f) || 1;
        var k = [],
            m = [],
            q = [],
            n = [],
            t = 0,
            u = 0;
        g("z", "y", "x", -1, -1, c, b, a, f, e, 0);
        g("z", "y", "x", 1, -1, c, b, -a, f, e, 1);
        g("x", "z", "y", 1, 1, a, c, b, d, f, 2);
        g("x", "z", "y", 1, -1, a, c, -b, d, f, 3);
        g("x", "y", "z", 1, -1, a, b, c, d, e, 4);
        g("x", "y", "z", -1, -1, a, b, -c, d, e, 5);
        this.setIndex(k);
        this.addAttribute("position",
            new A(m, 3));
        this.addAttribute("normal", new A(q, 3));
        this.addAttribute("uv", new A(n, 2))
    }

    function uc(a, b, c, d) {
        R.call(this);
        this.type = "PlaneGeometry";
        this.parameters = {
            width: a,
            height: b,
            widthSegments: c,
            heightSegments: d
        };
        this.fromBufferGeometry(new lb(a, b, c, d));
        this.mergeVertices()
    }

    function lb(a, b, c, d) {
        C.call(this);
        this.type = "PlaneBufferGeometry";
        this.parameters = {
            width: a,
            height: b,
            widthSegments: c,
            heightSegments: d
        };
        a = a || 1;
        b = b || 1;
        var e = a / 2,
            f = b / 2;
        c = Math.floor(c) || 1;
        d = Math.floor(d) || 1;
        var g = c + 1,
            h = d + 1,
            k = a / c,
            m =
            b / d,
            q = [],
            n = [],
            t = [],
            u = [];
        for (a = 0; a < h; a++) {
            var r = a * m - f;
            for (b = 0; b < g; b++) n.push(b * k - e, -r, 0), t.push(0, 0, 1), u.push(b / c), u.push(1 - a / d)
        }
        for (a = 0; a < d; a++)
            for (b = 0; b < c; b++) e = b + g * (a + 1), f = b + 1 + g * (a + 1), h = b + 1 + g * a, q.push(b + g * a, e, h), q.push(e, f, h);
        this.setIndex(q);
        this.addAttribute("position", new A(n, 3));
        this.addAttribute("normal", new A(t, 3));
        this.addAttribute("uv", new A(u, 2))
    }

    function J() {
        Object.defineProperty(this, "id", {
            value: Kf++
        });
        this.uuid = H.generateUUID();
        this.name = "";
        this.type = "Material";
        this.lights = this.fog = !0;
        this.blending = 1;
        this.side = 0;
        this.flatShading = !1;
        this.vertexColors = 0;
        this.opacity = 1;
        this.transparent = !1;
        this.blendSrc = 204;
        this.blendDst = 205;
        this.blendEquation = 100;
        this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null;
        this.depthFunc = 3;
        this.depthWrite = this.depthTest = !0;
        this.clippingPlanes = null;
        this.clipShadows = this.clipIntersection = !1;
        this.shadowSide = null;
        this.colorWrite = !0;
        this.precision = null;
        this.polygonOffset = !1;
        this.polygonOffsetUnits = this.polygonOffsetFactor = 0;
        this.dithering = !1;
        this.alphaTest = 0;
        this.premultipliedAlpha = !1;
        this.overdraw = 0;
        this.visible = !0;
        this.userData = {};
        this.needsUpdate = !0
    }

    function da(a) {
        J.call(this);
        this.type = "MeshBasicMaterial";
        this.color = new G(16777215);
        this.lightMap = this.map = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.envMap = this.alphaMap = this.specularMap = null;
        this.combine = 0;
        this.reflectivity = 1;
        this.refractionRatio = .98;
        this.wireframe = !1;
        this.wireframeLinewidth = 1;
        this.wireframeLinejoin = this.wireframeLinecap = "round";
        this.lights =
            this.morphTargets = this.skinning = !1;
        this.setValues(a)
    }

    function ta(a) {
        J.call(this);
        this.type = "ShaderMaterial";
        this.defines = {};
        this.uniforms = {};
        this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
        this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
        this.linewidth = 1;
        this.wireframe = !1;
        this.wireframeLinewidth = 1;
        this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1;
        this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        };
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        };
        this.index0AttributeName = void 0;
        this.uniformsNeedUpdate = !1;
        void 0 !== a && (void 0 !== a.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(a))
    }

    function mb(a, b) {
        this.origin = void 0 !== a ? a : new p;
        this.direction = void 0 !== b ? b : new p
    }

    function ja(a, b, c) {
        this.a = void 0 !== a ? a : new p;
        this.b = void 0 !== b ? b : new p;
        this.c =
            void 0 !== c ? c : new p
    }

    function la(a, b) {
        D.call(this);
        this.type = "Mesh";
        this.geometry = void 0 !== a ? a : new C;
        this.material = void 0 !== b ? b : new da({
            color: 16777215 * Math.random()
        });
        this.drawMode = 0;
        this.updateMorphTargets()
    }

    function Lf(a, b, c, d) {
        function e(a, c) {
            b.buffers.color.setClear(a.r, a.g, a.b, c, d)
        }
        var f = new G(0),
            g = 0,
            h, k, m;
        return {
            getClearColor: function() {
                return f
            },
            setClearColor: function(a, b) {
                f.set(a);
                g = void 0 !== b ? b : 1;
                e(f, g)
            },
            getClearAlpha: function() {
                return g
            },
            setClearAlpha: function(a) {
                g = a;
                e(f, g)
            },
            render: function(b,
                d, t, u) {
                d = d.background;
                null === d ? e(f, g) : d && d.isColor && (e(d, 1), u = !0);
                (a.autoClear || u) && a.clear(a.autoClearColor, a.autoClearDepth, a.autoClearStencil);
                d && d.isCubeTexture ? (void 0 === m && (m = new la(new kb(1, 1, 1), new ta({
                        uniforms: nb.cube.uniforms,
                        vertexShader: nb.cube.vertexShader,
                        fragmentShader: nb.cube.fragmentShader,
                        side: 1,
                        depthTest: !0,
                        depthWrite: !1,
                        fog: !1
                    })), m.geometry.removeAttribute("normal"), m.geometry.removeAttribute("uv"), m.onBeforeRender = function(a, b, c) {
                        this.matrixWorld.copyPosition(c.matrixWorld)
                    },
                    c.update(m)), m.material.uniforms.tCube.value = d, b.push(m, m.geometry, m.material, 0, null)) : d && d.isTexture && (void 0 === h && (h = new Hb(-1, 1, 1, -1, 0, 1), k = new la(new lb(2, 2), new da({
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                })), c.update(k)), k.material.map = d, a.renderBufferDirect(h, null, k.geometry, k.material, k, null))
            }
        }
    }

    function Mf(a, b, c, d) {
        var e;
        this.setMode = function(a) {
            e = a
        };
        this.render = function(b, d) {
            a.drawArrays(e, b, d);
            c.update(d, e)
        };
        this.renderInstances = function(f, g, h) {
            if (d.isWebGL2) var k = a;
            else if (k = b.get("ANGLE_instanced_arrays"),
                null === k) {
                console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                return
            }
            k[d.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](e, g, h, f.maxInstancedCount);
            c.update(h, e, f.maxInstancedCount)
        }
    }

    function Nf(a, b, c) {
        function d(b) {
            if ("highp" === b) {
                if (0 < a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.HIGH_FLOAT).precision && 0 < a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.HIGH_FLOAT).precision) return "highp";
                b = "mediump"
            }
            return "mediump" ===
                b && 0 < a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.MEDIUM_FLOAT).precision && 0 < a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.MEDIUM_FLOAT).precision ? "mediump" : "lowp"
        }
        var e, f = "undefined" !== typeof WebGL2RenderingContext && a instanceof WebGL2RenderingContext,
            g = void 0 !== c.precision ? c.precision : "highp",
            h = d(g);
        h !== g && (console.warn("THREE.WebGLRenderer:", g, "not supported, using", h, "instead."), g = h);
        c = !0 === c.logarithmicDepthBuffer;
        h = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS);
        var k = a.getParameter(a.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
            m = a.getParameter(a.MAX_TEXTURE_SIZE),
            q = a.getParameter(a.MAX_CUBE_MAP_TEXTURE_SIZE),
            n = a.getParameter(a.MAX_VERTEX_ATTRIBS),
            t = a.getParameter(a.MAX_VERTEX_UNIFORM_VECTORS),
            u = a.getParameter(a.MAX_VARYING_VECTORS),
            r = a.getParameter(a.MAX_FRAGMENT_UNIFORM_VECTORS),
            l = 0 < k,
            y = f || !!b.get("OES_texture_float");
        return {
            isWebGL2: f,
            getMaxAnisotropy: function() {
                if (void 0 !== e) return e;
                var c = b.get("EXT_texture_filter_anisotropic");
                return e = null !== c ? a.getParameter(c.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
            },
            getMaxPrecision: d,
            precision: g,
            logarithmicDepthBuffer: c,
            maxTextures: h,
            maxVertexTextures: k,
            maxTextureSize: m,
            maxCubemapSize: q,
            maxAttributes: n,
            maxVertexUniforms: t,
            maxVaryings: u,
            maxFragmentUniforms: r,
            vertexTextures: l,
            floatFragmentTextures: y,
            floatVertexTextures: l && y
        }
    }

    function Of() {
        function a() {
            m.value !== d && (m.value = d, m.needsUpdate = 0 < e);
            c.numPlanes = e;
            c.numIntersection = 0
        }

        function b(a, b, d, e) {
            var f = null !== a ? a.length : 0,
                g = null;
            if (0 !== f) {
                g = m.value;
                if (!0 !== e || null === g) {
                    e = d + 4 * f;
                    b = b.matrixWorldInverse;
                    k.getNormalMatrix(b);
                    if (null ===
                        g || g.length < e) g = new Float32Array(e);
                    for (e = 0; e !== f; ++e, d += 4) h.copy(a[e]).applyMatrix4(b, k), h.normal.toArray(g, d), g[d + 3] = h.constant
                }
                m.value = g;
                m.needsUpdate = !0
            }
            c.numPlanes = f;
            return g
        }
        var c = this,
            d = null,
            e = 0,
            f = !1,
            g = !1,
            h = new Ma,
            k = new ra,
            m = {
                value: null,
                needsUpdate: !1
            };
        this.uniform = m;
        this.numIntersection = this.numPlanes = 0;
        this.init = function(a, c, g) {
            var h = 0 !== a.length || c || 0 !== e || f;
            f = c;
            d = b(a, g, 0);
            e = a.length;
            return h
        };
        this.beginShadows = function() {
            g = !0;
            b(null)
        };
        this.endShadows = function() {
            g = !1;
            a()
        };
        this.setState =
            function(c, h, k, u, r, l) {
                if (!f || null === c || 0 === c.length || g && !k) g ? b(null) : a();
                else {
                    k = g ? 0 : e;
                    var n = 4 * k,
                        q = r.clippingState || null;
                    m.value = q;
                    q = b(c, u, n, l);
                    for (c = 0; c !== n; ++c) q[c] = d[c];
                    r.clippingState = q;
                    this.numIntersection = h ? this.numPlanes : 0;
                    this.numPlanes += k
                }
            }
    }

    function Pf(a) {
        var b = {};
        return {
            get: function(c) {
                if (void 0 !== b[c]) return b[c];
                switch (c) {
                    case "WEBGL_depth_texture":
                        var d = a.getExtension("WEBGL_depth_texture") || a.getExtension("MOZ_WEBGL_depth_texture") || a.getExtension("WEBKIT_WEBGL_depth_texture");
                        break;
                    case "EXT_texture_filter_anisotropic":
                        d = a.getExtension("EXT_texture_filter_anisotropic") || a.getExtension("MOZ_EXT_texture_filter_anisotropic") || a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                        break;
                    case "WEBGL_compressed_texture_s3tc":
                        d = a.getExtension("WEBGL_compressed_texture_s3tc") || a.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                        break;
                    case "WEBGL_compressed_texture_pvrtc":
                        d = a.getExtension("WEBGL_compressed_texture_pvrtc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                        break;
                    default:
                        d = a.getExtension(c)
                }
                null === d && console.warn("THREE.WebGLRenderer: " + c + " extension not supported.");
                return b[c] = d
            }
        }
    }

    function Qf(a, b, c) {
        function d(a) {
            var h = a.target;
            a = e[h.id];
            null !== a.index && b.remove(a.index);
            for (var g in a.attributes) b.remove(a.attributes[g]);
            h.removeEventListener("dispose", d);
            delete e[h.id];
            if (g = f[a.id]) b.remove(g), delete f[a.id];
            c.memory.geometries--
        }
        var e = {},
            f = {};
        return {
            get: function(a, b) {
                var f = e[b.id];
                if (f) return f;
                b.addEventListener("dispose", d);
                b.isBufferGeometry ?
                    f = b : b.isGeometry && (void 0 === b._bufferGeometry && (b._bufferGeometry = (new C).setFromObject(a)), f = b._bufferGeometry);
                e[b.id] = f;
                c.memory.geometries++;
                return f
            },
            update: function(c) {
                var d = c.index,
                    e = c.attributes;
                null !== d && b.update(d, a.ELEMENT_ARRAY_BUFFER);
                for (var f in e) b.update(e[f], a.ARRAY_BUFFER);
                c = c.morphAttributes;
                for (f in c) {
                    d = c[f];
                    e = 0;
                    for (var g = d.length; e < g; e++) b.update(d[e], a.ARRAY_BUFFER)
                }
            },
            getWireframeAttribute: function(c) {
                var d = f[c.id];
                if (d) return d;
                d = [];
                var e = c.index,
                    g = c.attributes;
                if (null !==
                    e) {
                    e = e.array;
                    g = 0;
                    for (var q = e.length; g < q; g += 3) {
                        var n = e[g + 0],
                            t = e[g + 1],
                            u = e[g + 2];
                        d.push(n, t, t, u, u, n)
                    }
                } else
                    for (e = g.position.array, g = 0, q = e.length / 3 - 1; g < q; g += 3) n = g + 0, t = g + 1, u = g + 2, d.push(n, t, t, u, u, n);
                d = new(65535 < Fe(d) ? jb : ib)(d, 1);
                b.update(d, a.ELEMENT_ARRAY_BUFFER);
                return f[c.id] = d
            }
        }
    }

    function Rf(a, b, c, d) {
        var e, f, g;
        this.setMode = function(a) {
            e = a
        };
        this.setIndex = function(a) {
            f = a.type;
            g = a.bytesPerElement
        };
        this.render = function(b, d) {
            a.drawElements(e, d, f, b * g);
            c.update(d, e)
        };
        this.renderInstances = function(h, k, m) {
            if (d.isWebGL2) var q =
                a;
            else if (q = b.get("ANGLE_instanced_arrays"), null === q) {
                console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                return
            }
            q[d.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](e, m, f, k * g, h.maxInstancedCount);
            c.update(m, e, h.maxInstancedCount)
        }
    }

    function Sf(a) {
        var b = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };
        return {
            memory: {
                geometries: 0,
                textures: 0
            },
            render: b,
            programs: null,
            autoReset: !0,
            reset: function() {
                b.frame++;
                b.calls = 0;
                b.triangles = 0;
                b.points = 0;
                b.lines = 0
            },
            update: function(c, d, e) {
                e = e || 1;
                b.calls++;
                switch (d) {
                    case a.TRIANGLES:
                        b.triangles += c / 3 * e;
                        break;
                    case a.TRIANGLE_STRIP:
                    case a.TRIANGLE_FAN:
                        b.triangles += e * (c - 2);
                        break;
                    case a.LINES:
                        b.lines += c / 2 * e;
                        break;
                    case a.LINE_STRIP:
                        b.lines += e * (c - 1);
                        break;
                    case a.LINE_LOOP:
                        b.lines += e * c;
                        break;
                    case a.POINTS:
                        b.points += e * c;
                        break;
                    default:
                        console.error("THREE.WebGLInfo: Unknown draw mode:", d)
                }
            }
        }
    }

    function Tf(a, b) {
        return Math.abs(b[1]) - Math.abs(a[1])
    }

    function Uf(a) {
        var b = {},
            c = new Float32Array(8);
        return {
            update: function(d, e, f, g) {
                var h = d.morphTargetInfluences,
                    k = h.length;
                d = b[e.id];
                if (void 0 === d) {
                    d = [];
                    for (var m = 0; m < k; m++) d[m] = [m, 0];
                    b[e.id] = d
                }
                var q = f.morphTargets && e.morphAttributes.position;
                f = f.morphNormals && e.morphAttributes.normal;
                for (m = 0; m < k; m++) {
                    var n = d[m];
                    0 !== n[1] && (q && e.removeAttribute("morphTarget" + m), f && e.removeAttribute("morphNormal" + m))
                }
                for (m = 0; m < k; m++) n = d[m], n[0] = m, n[1] = h[m];
                d.sort(Tf);
                for (m = 0; 8 > m; m++) {
                    if (n = d[m])
                        if (h = n[0], k = n[1]) {
                            q && e.addAttribute("morphTarget" + m, q[h]);
                            f && e.addAttribute("morphNormal" +
                                m, f[h]);
                            c[m] = k;
                            continue
                        }
                    c[m] = 0
                }
                g.getUniforms().setValue(a, "morphTargetInfluences", c)
            }
        }
    }

    function Vf(a, b) {
        var c = {};
        return {
            update: function(d) {
                var e = b.render.frame,
                    f = d.geometry,
                    g = a.get(d, f);
                c[g.id] !== e && (f.isGeometry && g.updateFromObject(d), a.update(g), c[g.id] = e);
                return g
            },
            dispose: function() {
                c = {}
            }
        }
    }

    function Ua(a, b, c, d, e, f, g, h, k, m) {
        a = void 0 !== a ? a : [];
        T.call(this, a, void 0 !== b ? b : 301, c, d, e, f, g, h, k, m);
        this.flipY = !1
    }

    function Jb(a, b, c) {
        var d = a[0];
        if (0 >= d || 0 < d) return a;
        var e = b * c,
            f = Ge[e];
        void 0 === f && (f = new Float32Array(e),
            Ge[e] = f);
        if (0 !== b)
            for (d.toArray(f, 0), d = 1, e = 0; d !== b; ++d) e += c, a[d].toArray(f, e);
        return f
    }

    function ea(a, b) {
        if (a.length !== b.length) return !1;
        for (var c = 0, d = a.length; c < d; c++)
            if (a[c] !== b[c]) return !1;
        return !0
    }

    function qa(a, b) {
        for (var c = 0, d = b.length; c < d; c++) a[c] = b[c]
    }

    function He(a, b) {
        var c = Ie[b];
        void 0 === c && (c = new Int32Array(b), Ie[b] = c);
        for (var d = 0; d !== b; ++d) c[d] = a.allocTextureUnit();
        return c
    }

    function Wf(a, b) {
        var c = this.cache;
        c[0] !== b && (a.uniform1f(this.addr, b), c[0] = b)
    }

    function Xf(a, b) {
        var c = this.cache;
        c[0] !==
            b && (a.uniform1i(this.addr, b), c[0] = b)
    }

    function Yf(a, b) {
        var c = this.cache;
        if (void 0 !== b.x) {
            if (c[0] !== b.x || c[1] !== b.y) a.uniform2f(this.addr, b.x, b.y), c[0] = b.x, c[1] = b.y
        } else ea(c, b) || (a.uniform2fv(this.addr, b), qa(c, b))
    }

    function Zf(a, b) {
        var c = this.cache;
        if (void 0 !== b.x) {
            if (c[0] !== b.x || c[1] !== b.y || c[2] !== b.z) a.uniform3f(this.addr, b.x, b.y, b.z), c[0] = b.x, c[1] = b.y, c[2] = b.z
        } else if (void 0 !== b.r) {
            if (c[0] !== b.r || c[1] !== b.g || c[2] !== b.b) a.uniform3f(this.addr, b.r, b.g, b.b), c[0] = b.r, c[1] = b.g, c[2] = b.b
        } else ea(c, b) || (a.uniform3fv(this.addr,
            b), qa(c, b))
    }

    function $f(a, b) {
        var c = this.cache;
        if (void 0 !== b.x) {
            if (c[0] !== b.x || c[1] !== b.y || c[2] !== b.z || c[3] !== b.w) a.uniform4f(this.addr, b.x, b.y, b.z, b.w), c[0] = b.x, c[1] = b.y, c[2] = b.z, c[3] = b.w
        } else ea(c, b) || (a.uniform4fv(this.addr, b), qa(c, b))
    }

    function ag(a, b) {
        var c = this.cache,
            d = b.elements;
        void 0 === d ? ea(c, b) || (a.uniformMatrix2fv(this.addr, !1, b), qa(c, b)) : ea(c, d) || (Je.set(d), a.uniformMatrix2fv(this.addr, !1, Je), qa(c, d))
    }

    function bg(a, b) {
        var c = this.cache,
            d = b.elements;
        void 0 === d ? ea(c, b) || (a.uniformMatrix3fv(this.addr, !1, b), qa(c, b)) : ea(c, d) || (Ke.set(d), a.uniformMatrix3fv(this.addr, !1, Ke), qa(c, d))
    }

    function cg(a, b) {
        var c = this.cache,
            d = b.elements;
        void 0 === d ? ea(c, b) || (a.uniformMatrix4fv(this.addr, !1, b), qa(c, b)) : ea(c, d) || (Le.set(d), a.uniformMatrix4fv(this.addr, !1, Le), qa(c, d))
    }

    function dg(a, b, c) {
        var d = this.cache,
            e = c.allocTextureUnit();
        d[0] !== e && (a.uniform1i(this.addr, e), d[0] = e);
        c.setTexture2D(b || Me, e)
    }

    function eg(a, b, c) {
        var d = this.cache,
            e = c.allocTextureUnit();
        d[0] !== e && (a.uniform1i(this.addr, e), d[0] = e);
        c.setTextureCube(b ||
            Ne, e)
    }

    function Oe(a, b) {
        var c = this.cache;
        ea(c, b) || (a.uniform2iv(this.addr, b), qa(c, b))
    }

    function Pe(a, b) {
        var c = this.cache;
        ea(c, b) || (a.uniform3iv(this.addr, b), qa(c, b))
    }

    function Qe(a, b) {
        var c = this.cache;
        ea(c, b) || (a.uniform4iv(this.addr, b), qa(c, b))
    }

    function fg(a) {
        switch (a) {
            case 5126:
                return Wf;
            case 35664:
                return Yf;
            case 35665:
                return Zf;
            case 35666:
                return $f;
            case 35674:
                return ag;
            case 35675:
                return bg;
            case 35676:
                return cg;
            case 35678:
            case 36198:
                return dg;
            case 35680:
                return eg;
            case 5124:
            case 35670:
                return Xf;
            case 35667:
            case 35671:
                return Oe;
            case 35668:
            case 35672:
                return Pe;
            case 35669:
            case 35673:
                return Qe
        }
    }

    function gg(a, b) {
        var c = this.cache;
        ea(c, b) || (a.uniform1fv(this.addr, b), qa(c, b))
    }

    function hg(a, b) {
        var c = this.cache;
        ea(c, b) || (a.uniform1iv(this.addr, b), qa(c, b))
    }

    function ig(a, b) {
        var c = this.cache;
        b = Jb(b, this.size, 2);
        ea(c, b) || (a.uniform2fv(this.addr, b), this.updateCache(b))
    }

    function jg(a, b) {
        var c = this.cache;
        b = Jb(b, this.size, 3);
        ea(c, b) || (a.uniform3fv(this.addr, b), this.updateCache(b))
    }

    function kg(a, b) {
        var c = this.cache;
        b = Jb(b, this.size, 4);
        ea(c,
            b) || (a.uniform4fv(this.addr, b), this.updateCache(b))
    }

    function lg(a, b) {
        var c = this.cache;
        b = Jb(b, this.size, 4);
        ea(c, b) || (a.uniformMatrix2fv(this.addr, !1, b), this.updateCache(b))
    }

    function mg(a, b) {
        var c = this.cache;
        b = Jb(b, this.size, 9);
        ea(c, b) || (a.uniformMatrix3fv(this.addr, !1, b), this.updateCache(b))
    }

    function ng(a, b) {
        var c = this.cache;
        b = Jb(b, this.size, 16);
        ea(c, b) || (a.uniformMatrix4fv(this.addr, !1, b), this.updateCache(b))
    }

    function og(a, b, c) {
        var d = this.cache,
            e = b.length,
            f = He(c, e);
        !1 === ea(d, f) && (a.uniform1iv(this.addr,
            f), qa(d, f));
        for (a = 0; a !== e; ++a) c.setTexture2D(b[a] || Me, f[a])
    }

    function pg(a, b, c) {
        var d = this.cache,
            e = b.length,
            f = He(c, e);
        !1 === ea(d, f) && (a.uniform1iv(this.addr, f), qa(d, f));
        for (a = 0; a !== e; ++a) c.setTextureCube(b[a] || Ne, f[a])
    }

    function qg(a) {
        switch (a) {
            case 5126:
                return gg;
            case 35664:
                return ig;
            case 35665:
                return jg;
            case 35666:
                return kg;
            case 35674:
                return lg;
            case 35675:
                return mg;
            case 35676:
                return ng;
            case 35678:
                return og;
            case 35680:
                return pg;
            case 5124:
            case 35670:
                return hg;
            case 35667:
            case 35671:
                return Oe;
            case 35668:
            case 35672:
                return Pe;
            case 35669:
            case 35673:
                return Qe
        }
    }

    function rg(a, b, c) {
        this.id = a;
        this.addr = c;
        this.cache = [];
        this.setValue = fg(b.type)
    }

    function Re(a, b, c) {
        this.id = a;
        this.addr = c;
        this.cache = [];
        this.size = b.size;
        this.setValue = qg(b.type)
    }

    function Se(a) {
        this.id = a;
        this.seq = [];
        this.map = {}
    }

    function Za(a, b, c) {
        this.seq = [];
        this.map = {};
        this.renderer = c;
        c = a.getProgramParameter(b, a.ACTIVE_UNIFORMS);
        for (var d = 0; d < c; ++d) {
            var e = a.getActiveUniform(b, d),
                f = a.getUniformLocation(b, e.name),
                g = this,
                h = e.name,
                k = h.length;
            for (Vd.lastIndex = 0;;) {
                var m =
                    Vd.exec(h),
                    q = Vd.lastIndex,
                    n = m[1],
                    t = m[3];
                "]" === m[2] && (n |= 0);
                if (void 0 === t || "[" === t && q + 2 === k) {
                    h = g;
                    e = void 0 === t ? new rg(n, e, f) : new Re(n, e, f);
                    h.seq.push(e);
                    h.map[e.id] = e;
                    break
                } else t = g.map[n], void 0 === t && (t = new Se(n), n = g, g = t, n.seq.push(g), n.map[g.id] = g), g = t
            }
        }
    }

    function sg(a) {
        a = a.split("\n");
        for (var b = 0; b < a.length; b++) a[b] = b + 1 + ": " + a[b];
        return a.join("\n")
    }

    function Te(a, b, c) {
        var d = a.createShader(b);
        a.shaderSource(d, c);
        a.compileShader(d);
        !1 === a.getShaderParameter(d, a.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile.");
        "" !== a.getShaderInfoLog(d) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", b === a.VERTEX_SHADER ? "vertex" : "fragment", a.getShaderInfoLog(d), sg(c));
        return d
    }

    function Ue(a) {
        switch (a) {
            case 3E3:
                return ["Linear", "( value )"];
            case 3001:
                return ["sRGB", "( value )"];
            case 3002:
                return ["RGBE", "( value )"];
            case 3004:
                return ["RGBM", "( value, 7.0 )"];
            case 3005:
                return ["RGBM", "( value, 16.0 )"];
            case 3006:
                return ["RGBD", "( value, 256.0 )"];
            case 3007:
                return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
            default:
                throw Error("unsupported encoding: " +
                    a);
        }
    }

    function Wd(a, b) {
        b = Ue(b);
        return "vec4 " + a + "( vec4 value ) { return " + b[0] + "ToLinear" + b[1] + "; }"
    }

    function tg(a, b) {
        b = Ue(b);
        return "vec4 " + a + "( vec4 value ) { return LinearTo" + b[0] + b[1] + "; }"
    }

    function ug(a, b) {
        switch (b) {
            case 1:
                b = "Linear";
                break;
            case 2:
                b = "Reinhard";
                break;
            case 3:
                b = "Uncharted2";
                break;
            case 4:
                b = "OptimizedCineon";
                break;
            default:
                throw Error("unsupported toneMapping: " + b);
        }
        return "vec3 " + a + "( vec3 color ) { return " + b + "ToneMapping( color ); }"
    }

    function vg(a, b, c) {
        a = a || {};
        return [a.derivatives ||
            b.envMapCubeUV || b.bumpMap || b.normalMap && !b.objectSpaceNormalMap || b.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (a.fragDepth || b.logarithmicDepthBuffer) && c.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", a.drawBuffers && c.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (a.shaderTextureLOD || b.envMap) && c.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""
        ].filter(vc).join("\n")
    }

    function wg(a) {
        var b = [],
            c;
        for (c in a) {
            var d =
                a[c];
            !1 !== d && b.push("#define " + c + " " + d)
        }
        return b.join("\n")
    }

    function vc(a) {
        return "" !== a
    }

    function Ve(a, b) {
        return a.replace(/NUM_DIR_LIGHTS/g, b.numDirLights).replace(/NUM_SPOT_LIGHTS/g, b.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, b.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, b.numPointLights).replace(/NUM_HEMI_LIGHTS/g, b.numHemiLights)
    }

    function We(a, b) {
        return a.replace(/NUM_CLIPPING_PLANES/g, b.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, b.numClippingPlanes - b.numClipIntersection)
    }

    function Xd(a) {
        return a.replace(/^[ \t]*#include +<([\w\d./]+)>/gm,
            function(a, c) {
                a = S[c];
                if (void 0 === a) throw Error("Can not resolve #include <" + c + ">");
                return Xd(a)
            })
    }

    function Xe(a) {
        return a.replace(/#pragma unroll_loop[\s]+?for \( int i = (\d+); i < (\d+); i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function(a, c, d, e) {
            a = "";
            for (c = parseInt(c); c < parseInt(d); c++) a += e.replace(/\[ i \]/g, "[ " + c + " ]");
            return a
        })
    }

    function xg(a, b, c, d, e, f, g) {
        var h = a.context,
            k = d.defines,
            m = e.vertexShader,
            q = e.fragmentShader,
            n = "SHADOWMAP_TYPE_BASIC";
        1 === f.shadowMapType ? n = "SHADOWMAP_TYPE_PCF" : 2 === f.shadowMapType &&
            (n = "SHADOWMAP_TYPE_PCF_SOFT");
        var t = "ENVMAP_TYPE_CUBE",
            u = "ENVMAP_MODE_REFLECTION",
            r = "ENVMAP_BLENDING_MULTIPLY";
        if (f.envMap) {
            switch (d.envMap.mapping) {
                case 301:
                case 302:
                    t = "ENVMAP_TYPE_CUBE";
                    break;
                case 306:
                case 307:
                    t = "ENVMAP_TYPE_CUBE_UV";
                    break;
                case 303:
                case 304:
                    t = "ENVMAP_TYPE_EQUIREC";
                    break;
                case 305:
                    t = "ENVMAP_TYPE_SPHERE"
            }
            switch (d.envMap.mapping) {
                case 302:
                case 304:
                    u = "ENVMAP_MODE_REFRACTION"
            }
            switch (d.combine) {
                case 0:
                    r = "ENVMAP_BLENDING_MULTIPLY";
                    break;
                case 1:
                    r = "ENVMAP_BLENDING_MIX";
                    break;
                case 2:
                    r = "ENVMAP_BLENDING_ADD"
            }
        }
        var l =
            0 < a.gammaFactor ? a.gammaFactor : 1,
            y = g.isWebGL2 ? "" : vg(d.extensions, f, b),
            p = wg(k),
            w = h.createProgram();
        d.isRawShaderMaterial ? (k = [p].filter(vc).join("\n"), 0 < k.length && (k += "\n"), b = [y, p].filter(vc).join("\n"), 0 < b.length && (b += "\n")) : (k = ["precision " + f.precision + " float;", "precision " + f.precision + " int;", "#define SHADER_NAME " + e.name, p, f.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + l, "#define MAX_BONES " + f.maxBones, f.useFog && f.fog ? "#define USE_FOG" : "", f.useFog && f.fogExp ? "#define FOG_EXP2" :
            "", f.map ? "#define USE_MAP" : "", f.envMap ? "#define USE_ENVMAP" : "", f.envMap ? "#define " + u : "", f.lightMap ? "#define USE_LIGHTMAP" : "", f.aoMap ? "#define USE_AOMAP" : "", f.emissiveMap ? "#define USE_EMISSIVEMAP" : "", f.bumpMap ? "#define USE_BUMPMAP" : "", f.normalMap ? "#define USE_NORMALMAP" : "", f.normalMap && f.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", f.displacementMap && f.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", f.specularMap ? "#define USE_SPECULARMAP" : "", f.roughnessMap ? "#define USE_ROUGHNESSMAP" :
            "", f.metalnessMap ? "#define USE_METALNESSMAP" : "", f.alphaMap ? "#define USE_ALPHAMAP" : "", f.vertexColors ? "#define USE_COLOR" : "", f.flatShading ? "#define FLAT_SHADED" : "", f.skinning ? "#define USE_SKINNING" : "", f.useVertexTexture ? "#define BONE_TEXTURE" : "", f.morphTargets ? "#define USE_MORPHTARGETS" : "", f.morphNormals && !1 === f.flatShading ? "#define USE_MORPHNORMALS" : "", f.doubleSided ? "#define DOUBLE_SIDED" : "", f.flipSided ? "#define FLIP_SIDED" : "", f.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", f.shadowMapEnabled ? "#define " +
            n : "", f.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", f.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", f.logarithmicDepthBuffer && (g.isWebGL2 || b.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;",
            "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif",
            "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"
        ].filter(vc).join("\n"), b = [y, "precision " + f.precision + " float;", "precision " + f.precision + " int;", "#define SHADER_NAME " + e.name, p, f.alphaTest ? "#define ALPHATEST " + f.alphaTest + (f.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + l, f.useFog && f.fog ? "#define USE_FOG" : "", f.useFog && f.fogExp ? "#define FOG_EXP2" : "", f.map ? "#define USE_MAP" : "", f.envMap ? "#define USE_ENVMAP" : "", f.envMap ? "#define " + t : "", f.envMap ? "#define " +
            u : "", f.envMap ? "#define " + r : "", f.lightMap ? "#define USE_LIGHTMAP" : "", f.aoMap ? "#define USE_AOMAP" : "", f.emissiveMap ? "#define USE_EMISSIVEMAP" : "", f.bumpMap ? "#define USE_BUMPMAP" : "", f.normalMap ? "#define USE_NORMALMAP" : "", f.normalMap && f.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", f.specularMap ? "#define USE_SPECULARMAP" : "", f.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", f.metalnessMap ? "#define USE_METALNESSMAP" : "", f.alphaMap ? "#define USE_ALPHAMAP" : "", f.vertexColors ? "#define USE_COLOR" : "", f.gradientMap ?
            "#define USE_GRADIENTMAP" : "", f.flatShading ? "#define FLAT_SHADED" : "", f.doubleSided ? "#define DOUBLE_SIDED" : "", f.flipSided ? "#define FLIP_SIDED" : "", f.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", f.shadowMapEnabled ? "#define " + n : "", f.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", f.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", f.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", f.logarithmicDepthBuffer && (g.isWebGL2 || b.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", f.envMap &&
            (g.isWebGL2 || b.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", 0 !== f.toneMapping ? "#define TONE_MAPPING" : "", 0 !== f.toneMapping ? S.tonemapping_pars_fragment : "", 0 !== f.toneMapping ? ug("toneMapping", f.toneMapping) : "", f.dithering ? "#define DITHERING" : "", f.outputEncoding || f.mapEncoding || f.envMapEncoding || f.emissiveMapEncoding ? S.encodings_pars_fragment : "", f.mapEncoding ? Wd("mapTexelToLinear", f.mapEncoding) : "", f.envMapEncoding ? Wd("envMapTexelToLinear",
                f.envMapEncoding) : "", f.emissiveMapEncoding ? Wd("emissiveMapTexelToLinear", f.emissiveMapEncoding) : "", f.outputEncoding ? tg("linearToOutputTexel", f.outputEncoding) : "", f.depthPacking ? "#define DEPTH_PACKING " + d.depthPacking : "", "\n"
        ].filter(vc).join("\n"));
        m = Xd(m);
        m = Ve(m, f);
        m = We(m, f);
        q = Xd(q);
        q = Ve(q, f);
        q = We(q, f);
        m = Xe(m);
        q = Xe(q);
        g.isWebGL2 && !d.isRawShaderMaterial && (g = !1, n = /^\s*#version\s+300\s+es\s*\n/, d.isShaderMaterial && null !== m.match(n) && null !== q.match(n) && (g = !0, m = m.replace(n, ""), q = q.replace(n, "")), k = "#version 300 es\n\n#define attribute in\n#define varying out\n#define texture2D texture\n" +
            k, b = ["#version 300 es\n\n#define varying in", g ? "" : "out highp vec4 pc_fragColor;", g ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad"].join("\n") +
            "\n" + b);
        q = b + q;
        m = Te(h, h.VERTEX_SHADER, k + m);
        q = Te(h, h.FRAGMENT_SHADER, q);
        h.attachShader(w, m);
        h.attachShader(w, q);
        void 0 !== d.index0AttributeName ? h.bindAttribLocation(w, 0, d.index0AttributeName) : !0 === f.morphTargets && h.bindAttribLocation(w, 0, "position");
        h.linkProgram(w);
        f = h.getProgramInfoLog(w).trim();
        g = h.getShaderInfoLog(m).trim();
        n = h.getShaderInfoLog(q).trim();
        u = t = !0;
        if (!1 === h.getProgramParameter(w, h.LINK_STATUS)) t = !1, console.error("THREE.WebGLProgram: shader error: ", h.getError(), "gl.VALIDATE_STATUS",
            h.getProgramParameter(w, h.VALIDATE_STATUS), "gl.getProgramInfoLog", f, g, n);
        else if ("" !== f) console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", f);
        else if ("" === g || "" === n) u = !1;
        u && (this.diagnostics = {
            runnable: t,
            material: d,
            programLog: f,
            vertexShader: {
                log: g,
                prefix: k
            },
            fragmentShader: {
                log: n,
                prefix: b
            }
        });
        h.deleteShader(m);
        h.deleteShader(q);
        var B;
        this.getUniforms = function() {
            void 0 === B && (B = new Za(h, w, a));
            return B
        };
        var E;
        this.getAttributes = function() {
            if (void 0 === E) {
                for (var a = {}, b = h.getProgramParameter(w, h.ACTIVE_ATTRIBUTES),
                        c = 0; c < b; c++) {
                    var d = h.getActiveAttrib(w, c).name;
                    a[d] = h.getAttribLocation(w, d)
                }
                E = a
            }
            return E
        };
        this.destroy = function() {
            h.deleteProgram(w);
            this.program = void 0
        };
        Object.defineProperties(this, {
            uniforms: {
                get: function() {
                    console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms().");
                    return this.getUniforms()
                }
            },
            attributes: {
                get: function() {
                    console.warn("THREE.WebGLProgram: .attributes is now .getAttributes().");
                    return this.getAttributes()
                }
            }
        });
        this.name = e.name;
        this.id = yg++;
        this.code = c;
        this.usedTimes = 1;
        this.program =
            w;
        this.vertexShader = m;
        this.fragmentShader = q;
        return this
    }

    function zg(a, b, c) {
        function d(a, b) {
            if (a) a.isTexture ? c = a.encoding : a.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), c = a.texture.encoding);
            else var c = 3E3;
            3E3 === c && b && (c = 3007);
            return c
        }
        var e = [],
            f = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "phong",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow",
                SpriteMaterial: "sprite"
            },
            g = "precision supportsVertexTextures map mapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap objectSpaceNormalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering".split(" ");
        this.getParameters = function(b, e, g, q, n, t, u) {
            var h = f[b.type];
            if (u.isSkinnedMesh) {
                var k = u.skeleton.bones;
                if (c.floatVertexTextures) k = 1024;
                else {
                    var m = Math.min(Math.floor((c.maxVertexUniforms - 20) / 4), k.length);
                    m < k.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + k.length + " bones. This GPU supports " + m + "."), k = 0) : k = m
                }
            } else k = 0;
            m = c.precision;
            null !== b.precision && (m = c.getMaxPrecision(b.precision), m !== b.precision && console.warn("THREE.WebGLProgram.getParameters:", b.precision, "not supported, using", m, "instead."));
            var l = a.getRenderTarget();
            return {
                shaderID: h,
                precision: m,
                supportsVertexTextures: c.vertexTextures,
                outputEncoding: d(l ? l.texture : null, a.gammaOutput),
                map: !!b.map,
                mapEncoding: d(b.map, a.gammaInput),
                envMap: !!b.envMap,
                envMapMode: b.envMap && b.envMap.mapping,
                envMapEncoding: d(b.envMap, a.gammaInput),
                envMapCubeUV: !!b.envMap && (306 === b.envMap.mapping || 307 === b.envMap.mapping),
                lightMap: !!b.lightMap,
                aoMap: !!b.aoMap,
                emissiveMap: !!b.emissiveMap,
                emissiveMapEncoding: d(b.emissiveMap, a.gammaInput),
                bumpMap: !!b.bumpMap,
                normalMap: !!b.normalMap,
                objectSpaceNormalMap: 1 === b.normalMapType,
                displacementMap: !!b.displacementMap,
                roughnessMap: !!b.roughnessMap,
                metalnessMap: !!b.metalnessMap,
                specularMap: !!b.specularMap,
                alphaMap: !!b.alphaMap,
                gradientMap: !!b.gradientMap,
                combine: b.combine,
                vertexColors: b.vertexColors,
                fog: !!q,
                useFog: b.fog,
                fogExp: q && q.isFogExp2,
                flatShading: b.flatShading,
                sizeAttenuation: b.sizeAttenuation,
                logarithmicDepthBuffer: c.logarithmicDepthBuffer,
                skinning: b.skinning && 0 < k,
                maxBones: k,
                useVertexTexture: c.floatVertexTextures,
                morphTargets: b.morphTargets,
                morphNormals: b.morphNormals,
                maxMorphTargets: a.maxMorphTargets,
                maxMorphNormals: a.maxMorphNormals,
                numDirLights: e.directional.length,
                numPointLights: e.point.length,
                numSpotLights: e.spot.length,
                numRectAreaLights: e.rectArea.length,
                numHemiLights: e.hemi.length,
                numClippingPlanes: n,
                numClipIntersection: t,
                dithering: b.dithering,
                shadowMapEnabled: a.shadowMap.enabled && u.receiveShadow && 0 < g.length,
                shadowMapType: a.shadowMap.type,
                toneMapping: a.toneMapping,
                physicallyCorrectLights: a.physicallyCorrectLights,
                premultipliedAlpha: b.premultipliedAlpha,
                alphaTest: b.alphaTest,
                doubleSided: 2 === b.side,
                flipSided: 1 === b.side,
                depthPacking: void 0 !== b.depthPacking ? b.depthPacking : !1
            }
        };
        this.getProgramCode = function(b, c) {
            var d = [];
            c.shaderID ? d.push(c.shaderID) : (d.push(b.fragmentShader), d.push(b.vertexShader));
            if (void 0 !== b.defines)
                for (var e in b.defines) d.push(e), d.push(b.defines[e]);
            for (e = 0; e < g.length; e++) d.push(c[g[e]]);
            d.push(b.onBeforeCompile.toString());
            d.push(a.gammaOutput);
            return d.join()
        };
        this.acquireProgram = function(d, f, g, q) {
            for (var h, k = 0, m = e.length; k <
                m; k++) {
                var r = e[k];
                if (r.code === q) {
                    h = r;
                    ++h.usedTimes;
                    break
                }
            }
            void 0 === h && (h = new xg(a, b, q, d, f, g, c), e.push(h));
            return h
        };
        this.releaseProgram = function(a) {
            if (0 === --a.usedTimes) {
                var b = e.indexOf(a);
                e[b] = e[e.length - 1];
                e.pop();
                a.destroy()
            }
        };
        this.programs = e
    }

    function Ag() {
        var a = new WeakMap;
        return {
            get: function(b) {
                var c = a.get(b);
                void 0 === c && (c = {}, a.set(b, c));
                return c
            },
            remove: function(b) {
                a.delete(b)
            },
            update: function(b, c, d) {
                a.get(b)[c] = d
            },
            dispose: function() {
                a = new WeakMap
            }
        }
    }

    function Bg(a, b) {
        return a.renderOrder !==
            b.renderOrder ? a.renderOrder - b.renderOrder : a.program && b.program && a.program !== b.program ? a.program.id - b.program.id : a.material.id !== b.material.id ? a.material.id - b.material.id : a.z !== b.z ? a.z - b.z : a.id - b.id
    }

    function Cg(a, b) {
        return a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z !== b.z ? b.z - a.z : a.id - b.id
    }

    function Dg() {
        var a = [],
            b = 0,
            c = [],
            d = [];
        return {
            opaque: c,
            transparent: d,
            init: function() {
                b = 0;
                c.length = 0;
                d.length = 0
            },
            push: function(e, f, g, h, k) {
                var m = a[b];
                void 0 === m ? (m = {
                    id: e.id,
                    object: e,
                    geometry: f,
                    material: g,
                    program: g.program,
                    renderOrder: e.renderOrder,
                    z: h,
                    group: k
                }, a[b] = m) : (m.id = e.id, m.object = e, m.geometry = f, m.material = g, m.program = g.program, m.renderOrder = e.renderOrder, m.z = h, m.group = k);
                (!0 === g.transparent ? d : c).push(m);
                b++
            },
            sort: function() {
                1 < c.length && c.sort(Bg);
                1 < d.length && d.sort(Cg)
            }
        }
    }

    function Eg() {
        var a = {};
        return {
            get: function(b, c) {
                b = b.id + "," + c.id;
                c = a[b];
                void 0 === c && (c = new Dg, a[b] = c);
                return c
            },
            dispose: function() {
                a = {}
            }
        }
    }

    function Fg() {
        var a = {};
        return {
            get: function(b) {
                if (void 0 !== a[b.id]) return a[b.id];
                switch (b.type) {
                    case "DirectionalLight":
                        var c = {
                            direction: new p,
                            color: new G,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new z
                        };
                        break;
                    case "SpotLight":
                        c = {
                            position: new p,
                            direction: new p,
                            color: new G,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new z
                        };
                        break;
                    case "PointLight":
                        c = {
                            position: new p,
                            color: new G,
                            distance: 0,
                            decay: 0,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new z,
                            shadowCameraNear: 1,
                            shadowCameraFar: 1E3
                        };
                        break;
                    case "HemisphereLight":
                        c = {
                            direction: new p,
                            skyColor: new G,
                            groundColor: new G
                        };
                        break;
                    case "RectAreaLight":
                        c = {
                            color: new G,
                            position: new p,
                            halfWidth: new p,
                            halfHeight: new p
                        }
                }
                return a[b.id] = c
            }
        }
    }

    function Gg() {
        var a = new Fg,
            b = {
                id: Hg++,
                hash: {
                    stateID: -1,
                    directionalLength: -1,
                    pointLength: -1,
                    spotLength: -1,
                    rectAreaLength: -1,
                    hemiLength: -1,
                    shadowsLength: -1
                },
                ambient: [0, 0, 0],
                directional: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotShadowMap: [],
                spotShadowMatrix: [],
                rectArea: [],
                point: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: []
            },
            c = new p,
            d = new I,
            e = new I;
        return {
            setup: function(f,
                g, h) {
                var k = 0,
                    m = 0,
                    q = 0,
                    n = 0,
                    t = 0,
                    u = 0,
                    r = 0,
                    l = 0;
                h = h.matrixWorldInverse;
                for (var y = 0, p = f.length; y < p; y++) {
                    var w = f[y],
                        B = w.color,
                        E = w.intensity,
                        P = w.distance,
                        N = w.shadow && w.shadow.map ? w.shadow.map.texture : null;
                    if (w.isAmbientLight) k += B.r * E, m += B.g * E, q += B.b * E;
                    else if (w.isDirectionalLight) {
                        var O = a.get(w);
                        O.color.copy(w.color).multiplyScalar(w.intensity);
                        O.direction.setFromMatrixPosition(w.matrixWorld);
                        c.setFromMatrixPosition(w.target.matrixWorld);
                        O.direction.sub(c);
                        O.direction.transformDirection(h);
                        if (O.shadow = w.castShadow) B =
                            w.shadow, O.shadowBias = B.bias, O.shadowRadius = B.radius, O.shadowMapSize = B.mapSize;
                        b.directionalShadowMap[n] = N;
                        b.directionalShadowMatrix[n] = w.shadow.matrix;
                        b.directional[n] = O;
                        n++
                    } else if (w.isSpotLight) {
                        O = a.get(w);
                        O.position.setFromMatrixPosition(w.matrixWorld);
                        O.position.applyMatrix4(h);
                        O.color.copy(B).multiplyScalar(E);
                        O.distance = P;
                        O.direction.setFromMatrixPosition(w.matrixWorld);
                        c.setFromMatrixPosition(w.target.matrixWorld);
                        O.direction.sub(c);
                        O.direction.transformDirection(h);
                        O.coneCos = Math.cos(w.angle);
                        O.penumbraCos = Math.cos(w.angle * (1 - w.penumbra));
                        O.decay = 0 === w.distance ? 0 : w.decay;
                        if (O.shadow = w.castShadow) B = w.shadow, O.shadowBias = B.bias, O.shadowRadius = B.radius, O.shadowMapSize = B.mapSize;
                        b.spotShadowMap[u] = N;
                        b.spotShadowMatrix[u] = w.shadow.matrix;
                        b.spot[u] = O;
                        u++
                    } else if (w.isRectAreaLight) O = a.get(w), O.color.copy(B).multiplyScalar(E), O.position.setFromMatrixPosition(w.matrixWorld), O.position.applyMatrix4(h), e.identity(), d.copy(w.matrixWorld), d.premultiply(h), e.extractRotation(d), O.halfWidth.set(.5 * w.width,
                        0, 0), O.halfHeight.set(0, .5 * w.height, 0), O.halfWidth.applyMatrix4(e), O.halfHeight.applyMatrix4(e), b.rectArea[r] = O, r++;
                    else if (w.isPointLight) {
                        O = a.get(w);
                        O.position.setFromMatrixPosition(w.matrixWorld);
                        O.position.applyMatrix4(h);
                        O.color.copy(w.color).multiplyScalar(w.intensity);
                        O.distance = w.distance;
                        O.decay = 0 === w.distance ? 0 : w.decay;
                        if (O.shadow = w.castShadow) B = w.shadow, O.shadowBias = B.bias, O.shadowRadius = B.radius, O.shadowMapSize = B.mapSize, O.shadowCameraNear = B.camera.near, O.shadowCameraFar = B.camera.far;
                        b.pointShadowMap[t] = N;
                        b.pointShadowMatrix[t] = w.shadow.matrix;
                        b.point[t] = O;
                        t++
                    } else w.isHemisphereLight && (O = a.get(w), O.direction.setFromMatrixPosition(w.matrixWorld), O.direction.transformDirection(h), O.direction.normalize(), O.skyColor.copy(w.color).multiplyScalar(E), O.groundColor.copy(w.groundColor).multiplyScalar(E), b.hemi[l] = O, l++)
                }
                b.ambient[0] = k;
                b.ambient[1] = m;
                b.ambient[2] = q;
                b.directional.length = n;
                b.spot.length = u;
                b.rectArea.length = r;
                b.point.length = t;
                b.hemi.length = l;
                b.hash.stateID = b.id;
                b.hash.directionalLength =
                    n;
                b.hash.pointLength = t;
                b.hash.spotLength = u;
                b.hash.rectAreaLength = r;
                b.hash.hemiLength = l;
                b.hash.shadowsLength = g.length
            },
            state: b
        }
    }

    function Ye() {
        var a = new Gg,
            b = [],
            c = [];
        return {
            init: function() {
                b.length = 0;
                c.length = 0
            },
            state: {
                lightsArray: b,
                shadowsArray: c,
                lights: a
            },
            setupLights: function(d) {
                a.setup(b, c, d)
            },
            pushLight: function(a) {
                b.push(a)
            },
            pushShadow: function(a) {
                c.push(a)
            }
        }
    }

    function Ig() {
        var a = {};
        return {
            get: function(b, c) {
                if (void 0 === a[b.id]) {
                    var d = new Ye;
                    a[b.id] = {};
                    a[b.id][c.id] = d
                } else void 0 === a[b.id][c.id] ?
                    (d = new Ye, a[b.id][c.id] = d) : d = a[b.id][c.id];
                return d
            },
            dispose: function() {
                a = {}
            }
        }
    }

    function $a(a) {
        J.call(this);
        this.type = "MeshDepthMaterial";
        this.depthPacking = 3200;
        this.morphTargets = this.skinning = !1;
        this.displacementMap = this.alphaMap = this.map = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.wireframe = !1;
        this.wireframeLinewidth = 1;
        this.lights = this.fog = !1;
        this.setValues(a)
    }

    function ab(a) {
        J.call(this);
        this.type = "MeshDistanceMaterial";
        this.referencePosition = new p;
        this.nearDistance = 1;
        this.farDistance =
            1E3;
        this.morphTargets = this.skinning = !1;
        this.displacementMap = this.alphaMap = this.map = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.lights = this.fog = !1;
        this.setValues(a)
    }

    function Ze(a, b, c) {
        function d(b, c, d, e, f, g) {
            var h = b.geometry;
            var k = n;
            var m = b.customDepthMaterial;
            d && (k = t, m = b.customDistanceMaterial);
            m ? k = m : (m = !1, c.morphTargets && (h && h.isBufferGeometry ? m = h.morphAttributes && h.morphAttributes.position && 0 < h.morphAttributes.position.length : h && h.isGeometry && (m = h.morphTargets && 0 < h.morphTargets.length)),
                b.isSkinnedMesh && !1 === c.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", b), b = b.isSkinnedMesh && c.skinning, h = 0, m && (h |= 1), b && (h |= 2), k = k[h]);
            a.localClippingEnabled && !0 === c.clipShadows && 0 !== c.clippingPlanes.length && (h = k.uuid, m = c.uuid, b = u[h], void 0 === b && (b = {}, u[h] = b), h = b[m], void 0 === h && (h = k.clone(), b[m] = h), k = h);
            k.visible = c.visible;
            k.wireframe = c.wireframe;
            k.side = null != c.shadowSide ? c.shadowSide : r[c.side];
            k.clipShadows = c.clipShadows;
            k.clippingPlanes = c.clippingPlanes;
            k.clipIntersection = c.clipIntersection;
            k.wireframeLinewidth = c.wireframeLinewidth;
            k.linewidth = c.linewidth;
            d && k.isMeshDistanceMaterial && (k.referencePosition.copy(e), k.nearDistance = f, k.farDistance = g);
            return k
        }

        function e(c, g, h, k) {
            if (!1 !== c.visible) {
                if (c.layers.test(g.layers) && (c.isMesh || c.isLine || c.isPoints) && c.castShadow && (!c.frustumCulled || f.intersectsObject(c))) {
                    c.modelViewMatrix.multiplyMatrices(h.matrixWorldInverse, c.matrixWorld);
                    var m = b.update(c),
                        n = c.material;
                    if (Array.isArray(n))
                        for (var t = m.groups,
                                u = 0, r = t.length; u < r; u++) {
                            var l = t[u],
                                P = n[l.materialIndex];
                            P && P.visible && (P = d(c, P, k, q, h.near, h.far), a.renderBufferDirect(h, null, m, P, c, l))
                        } else n.visible && (P = d(c, n, k, q, h.near, h.far), a.renderBufferDirect(h, null, m, P, c, null))
                }
                c = c.children;
                m = 0;
                for (n = c.length; m < n; m++) e(c[m], g, h, k)
            }
        }
        var f = new md,
            g = new I,
            h = new z,
            k = new z(c, c),
            m = new p,
            q = new p,
            n = Array(4),
            t = Array(4),
            u = {},
            r = {
                0: 1,
                1: 0,
                2: 2
            },
            l = [new p(1, 0, 0), new p(-1, 0, 0), new p(0, 0, 1), new p(0, 0, -1), new p(0, 1, 0), new p(0, -1, 0)],
            y = [new p(0, 1, 0), new p(0, 1, 0), new p(0, 1, 0),
                new p(0, 1, 0), new p(0, 0, 1), new p(0, 0, -1)
            ],
            x = [new V, new V, new V, new V, new V, new V];
        for (c = 0; 4 !== c; ++c) {
            var w = 0 !== (c & 1),
                B = 0 !== (c & 2),
                E = new $a({
                    depthPacking: 3201,
                    morphTargets: w,
                    skinning: B
                });
            n[c] = E;
            w = new ab({
                morphTargets: w,
                skinning: B
            });
            t[c] = w
        }
        var P = this;
        this.enabled = !1;
        this.autoUpdate = !0;
        this.needsUpdate = !1;
        this.type = 1;
        this.render = function(b, c, d) {
            if (!1 !== P.enabled && (!1 !== P.autoUpdate || !1 !== P.needsUpdate) && 0 !== b.length) {
                var n = a.state;
                n.disable(a.context.BLEND);
                n.buffers.color.setClear(1, 1, 1, 1);
                n.buffers.depth.setTest(!0);
                n.setScissorTest(!1);
                for (var t, u = 0, r = b.length; u < r; u++) {
                    var v = b[u];
                    t = v.shadow;
                    var p = v && v.isPointLight;
                    if (void 0 === t) console.warn("THREE.WebGLShadowMap:", v, "has no shadow.");
                    else {
                        var w = t.camera;
                        h.copy(t.mapSize);
                        h.min(k);
                        if (p) {
                            var N = h.x,
                                E = h.y;
                            x[0].set(2 * N, E, N, E);
                            x[1].set(0, E, N, E);
                            x[2].set(3 * N, E, N, E);
                            x[3].set(N, E, N, E);
                            x[4].set(3 * N, 0, N, E);
                            x[5].set(N, 0, N, E);
                            h.x *= 4;
                            h.y *= 2
                        }
                        null === t.map && (t.map = new fb(h.x, h.y, {
                            minFilter: 1003,
                            magFilter: 1003,
                            format: 1023
                        }), t.map.texture.name = v.name + ".shadowMap", w.updateProjectionMatrix());
                        t.isSpotLightShadow && t.update(v);
                        N = t.map;
                        E = t.matrix;
                        q.setFromMatrixPosition(v.matrixWorld);
                        w.position.copy(q);
                        p ? (t = 6, E.makeTranslation(-q.x, -q.y, -q.z)) : (t = 1, m.setFromMatrixPosition(v.target.matrixWorld), w.lookAt(m), w.updateMatrixWorld(), E.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), E.multiply(w.projectionMatrix), E.multiply(w.matrixWorldInverse));
                        a.setRenderTarget(N);
                        a.clear();
                        for (v = 0; v < t; v++) p && (m.copy(w.position), m.add(l[v]), w.up.copy(y[v]), w.lookAt(m), w.updateMatrixWorld(), n.viewport(x[v])), g.multiplyMatrices(w.projectionMatrix,
                            w.matrixWorldInverse), f.setFromMatrix(g), e(c, d, w, p)
                    }
                }
                P.needsUpdate = !1
            }
        }
    }

    function Jg(a, b, c, d) {
        function e(b, c, d) {
            var e = new Uint8Array(4),
                f = a.createTexture();
            a.bindTexture(b, f);
            a.texParameteri(b, a.TEXTURE_MIN_FILTER, a.NEAREST);
            a.texParameteri(b, a.TEXTURE_MAG_FILTER, a.NEAREST);
            for (b = 0; b < d; b++) a.texImage2D(c + b, 0, a.RGBA, 1, 1, 0, a.RGBA, a.UNSIGNED_BYTE, e);
            return f
        }

        function f(c, e) {
            x[c] = 1;
            0 === w[c] && (a.enableVertexAttribArray(c), w[c] = 1);
            B[c] !== e && ((d.isWebGL2 ? a : b.get("ANGLE_instanced_arrays"))[d.isWebGL2 ? "vertexAttribDivisor" :
                "vertexAttribDivisorANGLE"](c, e), B[c] = e)
        }

        function g(b) {
            !0 !== E[b] && (a.enable(b), E[b] = !0)
        }

        function h(b) {
            !1 !== E[b] && (a.disable(b), E[b] = !1)
        }

        function k(b, d, e, f, k, m, n, q) {
            0 !== b ? g(a.BLEND) : h(a.BLEND);
            if (5 !== b) {
                if (b !== O || q !== C) switch (b) {
                    case 2:
                        q ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ONE, a.ONE, a.ONE, a.ONE)) : (a.blendEquation(a.FUNC_ADD), a.blendFunc(a.SRC_ALPHA, a.ONE));
                        break;
                    case 3:
                        q ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ZERO, a.ZERO, a.ONE_MINUS_SRC_COLOR,
                            a.ONE_MINUS_SRC_ALPHA)) : (a.blendEquation(a.FUNC_ADD), a.blendFunc(a.ZERO, a.ONE_MINUS_SRC_COLOR));
                        break;
                    case 4:
                        q ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ZERO, a.SRC_COLOR, a.ZERO, a.SRC_ALPHA)) : (a.blendEquation(a.FUNC_ADD), a.blendFunc(a.ZERO, a.SRC_COLOR));
                        break;
                    default:
                        q ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ONE, a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE_MINUS_SRC_ALPHA)) : (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.SRC_ALPHA,
                            a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE_MINUS_SRC_ALPHA))
                }
                D = A = Ud = Td = Sd = z = null
            } else {
                k = k || d;
                m = m || e;
                n = n || f;
                if (d !== z || k !== Ud) a.blendEquationSeparate(c.convert(d), c.convert(k)), z = d, Ud = k;
                if (e !== Sd || f !== Td || m !== A || n !== D) a.blendFuncSeparate(c.convert(e), c.convert(f), c.convert(m), c.convert(n)), Sd = e, Td = f, A = m, D = n
            }
            O = b;
            C = q
        }

        function m(b) {
            G !== b && (b ? a.frontFace(a.CW) : a.frontFace(a.CCW), G = b)
        }

        function q(b) {
            0 !== b ? (g(a.CULL_FACE), b !== K && (1 === b ? a.cullFace(a.BACK) : 2 === b ? a.cullFace(a.FRONT) : a.cullFace(a.FRONT_AND_BACK))) : h(a.CULL_FACE);
            K = b
        }

        function n(b, c, d) {
            if (b) {
                if (g(a.POLYGON_OFFSET_FILL), R !== c || I !== d) a.polygonOffset(c, d), R = c, I = d
            } else h(a.POLYGON_OFFSET_FILL)
        }

        function t(b) {
            void 0 === b && (b = a.TEXTURE0 + J - 1);
            Q !== b && (a.activeTexture(b), Q = b)
        }
        var u = new function() {
                var b = !1,
                    c = new V,
                    d = null,
                    e = new V(0, 0, 0, 0);
                return {
                    setMask: function(c) {
                        d === c || b || (a.colorMask(c, c, c, c), d = c)
                    },
                    setLocked: function(a) {
                        b = a
                    },
                    setClear: function(b, d, f, g, h) {
                        !0 === h && (b *= g, d *= g, f *= g);
                        c.set(b, d, f, g);
                        !1 === e.equals(c) && (a.clearColor(b, d, f, g), e.copy(c))
                    },
                    reset: function() {
                        b = !1;
                        d = null;
                        e.set(-1, 0, 0, 0)
                    }
                }
            },
            r = new function() {
                var b = !1,
                    c = null,
                    d = null,
                    e = null;
                return {
                    setTest: function(b) {
                        b ? g(a.DEPTH_TEST) : h(a.DEPTH_TEST)
                    },
                    setMask: function(d) {
                        c === d || b || (a.depthMask(d), c = d)
                    },
                    setFunc: function(b) {
                        if (d !== b) {
                            if (b) switch (b) {
                                case 0:
                                    a.depthFunc(a.NEVER);
                                    break;
                                case 1:
                                    a.depthFunc(a.ALWAYS);
                                    break;
                                case 2:
                                    a.depthFunc(a.LESS);
                                    break;
                                case 3:
                                    a.depthFunc(a.LEQUAL);
                                    break;
                                case 4:
                                    a.depthFunc(a.EQUAL);
                                    break;
                                case 5:
                                    a.depthFunc(a.GEQUAL);
                                    break;
                                case 6:
                                    a.depthFunc(a.GREATER);
                                    break;
                                case 7:
                                    a.depthFunc(a.NOTEQUAL);
                                    break;
                                default:
                                    a.depthFunc(a.LEQUAL)
                            } else a.depthFunc(a.LEQUAL);
                            d = b
                        }
                    },
                    setLocked: function(a) {
                        b = a
                    },
                    setClear: function(b) {
                        e !== b && (a.clearDepth(b), e = b)
                    },
                    reset: function() {
                        b = !1;
                        e = d = c = null
                    }
                }
            },
            l = new function() {
                var b = !1,
                    c = null,
                    d = null,
                    e = null,
                    f = null,
                    k = null,
                    m = null,
                    n = null,
                    q = null;
                return {
                    setTest: function(b) {
                        b ? g(a.STENCIL_TEST) : h(a.STENCIL_TEST)
                    },
                    setMask: function(d) {
                        c === d || b || (a.stencilMask(d), c = d)
                    },
                    setFunc: function(b, c, g) {
                        if (d !== b || e !== c || f !== g) a.stencilFunc(b, c, g), d = b, e = c, f = g
                    },
                    setOp: function(b, c, d) {
                        if (k !== b || m !==
                            c || n !== d) a.stencilOp(b, c, d), k = b, m = c, n = d
                    },
                    setLocked: function(a) {
                        b = a
                    },
                    setClear: function(b) {
                        q !== b && (a.clearStencil(b), q = b)
                    },
                    reset: function() {
                        b = !1;
                        q = n = m = k = f = e = d = c = null
                    }
                }
            },
            p = a.getParameter(a.MAX_VERTEX_ATTRIBS),
            x = new Uint8Array(p),
            w = new Uint8Array(p),
            B = new Uint8Array(p),
            E = {},
            P = null,
            N = null,
            O = null,
            z = null,
            Sd = null,
            Td = null,
            Ud = null,
            A = null,
            D = null,
            C = !1,
            G = null,
            K = null,
            L = null,
            R = null,
            I = null,
            J = a.getParameter(a.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
            H = !1;
        p = 0;
        p = a.getParameter(a.VERSION); - 1 !== p.indexOf("WebGL") ? (p = parseFloat(/^WebGL ([0-9])/.exec(p)[1]),
            H = 1 <= p) : -1 !== p.indexOf("OpenGL ES") && (p = parseFloat(/^OpenGL ES ([0-9])/.exec(p)[1]), H = 2 <= p);
        var Q = null,
            S = {},
            Y = new V,
            W = new V,
            M = {};
        M[a.TEXTURE_2D] = e(a.TEXTURE_2D, a.TEXTURE_2D, 1);
        M[a.TEXTURE_CUBE_MAP] = e(a.TEXTURE_CUBE_MAP, a.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
        u.setClear(0, 0, 0, 1);
        r.setClear(1);
        l.setClear(0);
        g(a.DEPTH_TEST);
        r.setFunc(3);
        m(!1);
        q(1);
        g(a.CULL_FACE);
        g(a.BLEND);
        k(1);
        return {
            buffers: {
                color: u,
                depth: r,
                stencil: l
            },
            initAttributes: function() {
                for (var a = 0, b = x.length; a < b; a++) x[a] = 0
            },
            enableAttribute: function(a) {
                f(a,
                    0)
            },
            enableAttributeAndDivisor: f,
            disableUnusedAttributes: function() {
                for (var b = 0, c = w.length; b !== c; ++b) w[b] !== x[b] && (a.disableVertexAttribArray(b), w[b] = 0)
            },
            enable: g,
            disable: h,
            getCompressedTextureFormats: function() {
                if (null === P && (P = [], b.get("WEBGL_compressed_texture_pvrtc") || b.get("WEBGL_compressed_texture_s3tc") || b.get("WEBGL_compressed_texture_etc1") || b.get("WEBGL_compressed_texture_astc")))
                    for (var c = a.getParameter(a.COMPRESSED_TEXTURE_FORMATS), d = 0; d < c.length; d++) P.push(c[d]);
                return P
            },
            useProgram: function(b) {
                return N !==
                    b ? (a.useProgram(b), N = b, !0) : !1
            },
            setBlending: k,
            setMaterial: function(b, c) {
                2 === b.side ? h(a.CULL_FACE) : g(a.CULL_FACE);
                var d = 1 === b.side;
                c && (d = !d);
                m(d);
                1 === b.blending && !1 === b.transparent ? k(0) : k(b.blending, b.blendEquation, b.blendSrc, b.blendDst, b.blendEquationAlpha, b.blendSrcAlpha, b.blendDstAlpha, b.premultipliedAlpha);
                r.setFunc(b.depthFunc);
                r.setTest(b.depthTest);
                r.setMask(b.depthWrite);
                u.setMask(b.colorWrite);
                n(b.polygonOffset, b.polygonOffsetFactor, b.polygonOffsetUnits)
            },
            setFlipSided: m,
            setCullFace: q,
            setLineWidth: function(b) {
                b !==
                    L && (H && a.lineWidth(b), L = b)
            },
            setPolygonOffset: n,
            setScissorTest: function(b) {
                b ? g(a.SCISSOR_TEST) : h(a.SCISSOR_TEST)
            },
            activeTexture: t,
            bindTexture: function(b, c) {
                null === Q && t();
                var d = S[Q];
                void 0 === d && (d = {
                    type: void 0,
                    texture: void 0
                }, S[Q] = d);
                if (d.type !== b || d.texture !== c) a.bindTexture(b, c || M[b]), d.type = b, d.texture = c
            },
            compressedTexImage2D: function() {
                try {
                    a.compressedTexImage2D.apply(a, arguments)
                } catch (U) {
                    console.error("THREE.WebGLState:", U)
                }
            },
            texImage2D: function() {
                try {
                    a.texImage2D.apply(a, arguments)
                } catch (U) {
                    console.error("THREE.WebGLState:",
                        U)
                }
            },
            scissor: function(b) {
                !1 === Y.equals(b) && (a.scissor(b.x, b.y, b.z, b.w), Y.copy(b))
            },
            viewport: function(b) {
                !1 === W.equals(b) && (a.viewport(b.x, b.y, b.z, b.w), W.copy(b))
            },
            reset: function() {
                for (var b = 0; b < w.length; b++) 1 === w[b] && (a.disableVertexAttribArray(b), w[b] = 0);
                E = {};
                Q = P = null;
                S = {};
                K = G = O = N = null;
                u.reset();
                r.reset();
                l.reset()
            }
        }
    }

    function Kg(a, b, c, d, e, f, g) {
        function h(a, b) {
            if (a.width > b || a.height > b) {
                if ("data" in a) {
                    console.warn("THREE.WebGLRenderer: image in DataTexture is too big (" + a.width + "x" + a.height + ").");
                    return
                }
                b /= Math.max(a.width, a.height);
                var c = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                c.width = Math.floor(a.width * b);
                c.height = Math.floor(a.height * b);
                c.getContext("2d").drawImage(a, 0, 0, a.width, a.height, 0, 0, c.width, c.height);
                console.warn("THREE.WebGLRenderer: image is too big (" + a.width + "x" + a.height + "). Resized to " + c.width + "x" + c.height);
                return c
            }
            return a
        }

        function k(a) {
            return H.isPowerOfTwo(a.width) && H.isPowerOfTwo(a.height)
        }

        function m(a, b) {
            return a.generateMipmaps && b && 1003 !==
                a.minFilter && 1006 !== a.minFilter
        }

        function q(b, c, e, f) {
            a.generateMipmap(b);
            d.get(c).__maxMipLevel = Math.log(Math.max(e, f)) * Math.LOG2E
        }

        function n(b, c) {
            if (!e.isWebGL2) return b;
            if (b === a.RGB) {
                if (c === a.FLOAT) return a.RGB32F;
                if (c === a.HALF_FLOAT) return a.RGB16F;
                if (c === a.UNSIGNED_BYTE) return a.RGB8
            }
            if (b === a.RGBA) {
                if (c === a.FLOAT) return a.RGBA32F;
                if (c === a.HALF_FLOAT) return a.RGBA16F;
                if (c === a.UNSIGNED_BYTE) return a.RGBA8
            }
            return b
        }

        function t(b) {
            return 1003 === b || 1004 === b || 1005 === b ? a.NEAREST : a.LINEAR
        }

        function u(b) {
            b =
                b.target;
            b.removeEventListener("dispose", u);
            a: {
                var c = d.get(b);
                if (b.image && c.__image__webglTextureCube) a.deleteTexture(c.__image__webglTextureCube);
                else {
                    if (void 0 === c.__webglInit) break a;
                    a.deleteTexture(c.__webglTexture)
                }
                d.remove(b)
            }
            b.isVideoTexture && delete B[b.id];
            g.memory.textures--
        }

        function r(b) {
            b = b.target;
            b.removeEventListener("dispose", r);
            var c = d.get(b),
                e = d.get(b.texture);
            if (b) {
                void 0 !== e.__webglTexture && a.deleteTexture(e.__webglTexture);
                b.depthTexture && b.depthTexture.dispose();
                if (b.isWebGLRenderTargetCube)
                    for (e =
                        0; 6 > e; e++) a.deleteFramebuffer(c.__webglFramebuffer[e]), c.__webglDepthbuffer && a.deleteRenderbuffer(c.__webglDepthbuffer[e]);
                else a.deleteFramebuffer(c.__webglFramebuffer), c.__webglDepthbuffer && a.deleteRenderbuffer(c.__webglDepthbuffer);
                d.remove(b.texture);
                d.remove(b)
            }
            g.memory.textures--
        }

        function l(b, t) {
            var r = d.get(b);
            if (b.isVideoTexture) {
                var l = b.id,
                    v = g.render.frame;
                B[l] !== v && (B[l] = v, b.update())
            }
            if (0 < b.version && r.__version !== b.version)
                if (l = b.image, void 0 === l) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                else if (!1 === l.complete) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
                void 0 === r.__webglInit && (r.__webglInit = !0, b.addEventListener("dispose", u), r.__webglTexture = a.createTexture(), g.memory.textures++);
                c.activeTexture(a.TEXTURE0 + t);
                c.bindTexture(a.TEXTURE_2D, r.__webglTexture);
                a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, b.flipY);
                a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, b.premultiplyAlpha);
                a.pixelStorei(a.UNPACK_ALIGNMENT, b.unpackAlignment);
                t = h(b.image, e.maxTextureSize);
                (e.isWebGL2 ? 0 : 1001 !== b.wrapS || 1001 !== b.wrapT || 1003 !== b.minFilter && 1006 !== b.minFilter) && !1 === k(t) && (t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof ImageBitmap) && (void 0 === E && (E = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), E.width = H.floorPowerOfTwo(t.width), E.height = H.floorPowerOfTwo(t.height), E.getContext("2d").drawImage(t, 0, 0, E.width, E.height), console.warn("THREE.WebGLRenderer: image is not power of two (" + t.width + "x" + t.height + "). Resized to " + E.width +
                    "x" + E.height), t = E);
                l = k(t);
                v = f.convert(b.format);
                var w = f.convert(b.type),
                    y = n(v, w);
                p(a.TEXTURE_2D, b, l);
                var P = b.mipmaps;
                if (b.isDepthTexture) {
                    y = a.DEPTH_COMPONENT;
                    if (1015 === b.type) {
                        if (!e.isWebGL2) throw Error("Float Depth Texture only supported in WebGL2.0");
                        y = a.DEPTH_COMPONENT32F
                    } else e.isWebGL2 && (y = a.DEPTH_COMPONENT16);
                    1026 === b.format && y === a.DEPTH_COMPONENT && 1012 !== b.type && 1014 !== b.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), b.type =
                        1012, w = f.convert(b.type));
                    1027 === b.format && (y = a.DEPTH_STENCIL, 1020 !== b.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), b.type = 1020, w = f.convert(b.type)));
                    c.texImage2D(a.TEXTURE_2D, 0, y, t.width, t.height, 0, v, w, null)
                } else if (b.isDataTexture)
                    if (0 < P.length && l) {
                        for (var N = 0, x = P.length; N < x; N++) {
                            var z = P[N];
                            c.texImage2D(a.TEXTURE_2D, N, y, z.width, z.height, 0, v, w, z.data)
                        }
                        b.generateMipmaps = !1;
                        r.__maxMipLevel = P.length - 1
                    } else c.texImage2D(a.TEXTURE_2D, 0, y, t.width,
                        t.height, 0, v, w, t.data), r.__maxMipLevel = 0;
                else if (b.isCompressedTexture) {
                    N = 0;
                    for (x = P.length; N < x; N++) z = P[N], 1023 !== b.format && 1022 !== b.format ? -1 < c.getCompressedTextureFormats().indexOf(v) ? c.compressedTexImage2D(a.TEXTURE_2D, N, y, z.width, z.height, 0, z.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : c.texImage2D(a.TEXTURE_2D, N, y, z.width, z.height, 0, v, w, z.data);
                    r.__maxMipLevel = P.length - 1
                } else if (0 < P.length && l) {
                    N = 0;
                    for (x = P.length; N < x; N++) z =
                        P[N], c.texImage2D(a.TEXTURE_2D, N, y, v, w, z);
                    b.generateMipmaps = !1;
                    r.__maxMipLevel = P.length - 1
                } else c.texImage2D(a.TEXTURE_2D, 0, y, v, w, t), r.__maxMipLevel = 0;
                m(b, l) && q(a.TEXTURE_2D, b, t.width, t.height);
                r.__version = b.version;
                if (b.onUpdate) b.onUpdate(b);
                return
            }
            c.activeTexture(a.TEXTURE0 + t);
            c.bindTexture(a.TEXTURE_2D, r.__webglTexture)
        }

        function p(c, g, h) {
            h ? (a.texParameteri(c, a.TEXTURE_WRAP_S, f.convert(g.wrapS)), a.texParameteri(c, a.TEXTURE_WRAP_T, f.convert(g.wrapT)), a.texParameteri(c, a.TEXTURE_MAG_FILTER, f.convert(g.magFilter)),
                a.texParameteri(c, a.TEXTURE_MIN_FILTER, f.convert(g.minFilter))) : (a.texParameteri(c, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE), a.texParameteri(c, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE), 1001 === g.wrapS && 1001 === g.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), a.texParameteri(c, a.TEXTURE_MAG_FILTER, t(g.magFilter)), a.texParameteri(c, a.TEXTURE_MIN_FILTER, t(g.minFilter)), 1003 !== g.minFilter && 1006 !== g.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));
            !(h = b.get("EXT_texture_filter_anisotropic")) || 1015 === g.type && null === b.get("OES_texture_float_linear") || 1016 === g.type && null === (e.isWebGL2 || b.get("OES_texture_half_float_linear")) || !(1 < g.anisotropy || d.get(g).__currentAnisotropy) || (a.texParameterf(c, h.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(g.anisotropy, e.getMaxAnisotropy())), d.get(g).__currentAnisotropy = g.anisotropy)
        }

        function x(b, e, g, h) {
            var k = f.convert(e.texture.format),
                m = f.convert(e.texture.type),
                q = n(k, m);
            c.texImage2D(h, 0, q, e.width, e.height, 0, k, m, null);
            a.bindFramebuffer(a.FRAMEBUFFER, b);
            a.framebufferTexture2D(a.FRAMEBUFFER, g, h, d.get(e.texture).__webglTexture, 0);
            a.bindFramebuffer(a.FRAMEBUFFER, null)
        }

        function w(b, c) {
            a.bindRenderbuffer(a.RENDERBUFFER, b);
            c.depthBuffer && !c.stencilBuffer ? (a.renderbufferStorage(a.RENDERBUFFER, a.DEPTH_COMPONENT16, c.width, c.height), a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_ATTACHMENT, a.RENDERBUFFER, b)) : c.depthBuffer && c.stencilBuffer ? (a.renderbufferStorage(a.RENDERBUFFER, a.DEPTH_STENCIL, c.width, c.height), a.framebufferRenderbuffer(a.FRAMEBUFFER,
                a.DEPTH_STENCIL_ATTACHMENT, a.RENDERBUFFER, b)) : a.renderbufferStorage(a.RENDERBUFFER, a.RGBA4, c.width, c.height);
            a.bindRenderbuffer(a.RENDERBUFFER, null)
        }
        var B = {},
            E;
        this.setTexture2D = l;
        this.setTextureCube = function(b, t) {
            var r = d.get(b);
            if (6 === b.image.length)
                if (0 < b.version && r.__version !== b.version) {
                    r.__image__webglTextureCube || (b.addEventListener("dispose", u), r.__image__webglTextureCube = a.createTexture(), g.memory.textures++);
                    c.activeTexture(a.TEXTURE0 + t);
                    c.bindTexture(a.TEXTURE_CUBE_MAP, r.__image__webglTextureCube);
                    a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, b.flipY);
                    t = b && b.isCompressedTexture;
                    for (var l = b.image[0] && b.image[0].isDataTexture, v = [], w = 0; 6 > w; w++) v[w] = t || l ? l ? b.image[w].image : b.image[w] : h(b.image[w], e.maxCubemapSize);
                    var y = v[0],
                        E = k(y),
                        P = f.convert(b.format),
                        x = f.convert(b.type),
                        N = n(P, x);
                    p(a.TEXTURE_CUBE_MAP, b, E);
                    for (w = 0; 6 > w; w++)
                        if (t)
                            for (var B, z = v[w].mipmaps, A = 0, D = z.length; A < D; A++) B = z[A], 1023 !== b.format && 1022 !== b.format ? -1 < c.getCompressedTextureFormats().indexOf(P) ? c.compressedTexImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X +
                                w, A, N, B.width, B.height, 0, B.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : c.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + w, A, N, B.width, B.height, 0, P, x, B.data);
                        else l ? c.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + w, 0, N, v[w].width, v[w].height, 0, P, x, v[w].data) : c.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + w, 0, N, P, x, v[w]);
                    r.__maxMipLevel = t ? z.length - 1 : 0;
                    m(b, E) && q(a.TEXTURE_CUBE_MAP, b, y.width, y.height);
                    r.__version = b.version;
                    if (b.onUpdate) b.onUpdate(b)
                } else c.activeTexture(a.TEXTURE0 +
                    t), c.bindTexture(a.TEXTURE_CUBE_MAP, r.__image__webglTextureCube)
        };
        this.setTextureCubeDynamic = function(b, e) {
            c.activeTexture(a.TEXTURE0 + e);
            c.bindTexture(a.TEXTURE_CUBE_MAP, d.get(b).__webglTexture)
        };
        this.setupRenderTarget = function(b) {
            var e = d.get(b),
                f = d.get(b.texture);
            b.addEventListener("dispose", r);
            f.__webglTexture = a.createTexture();
            g.memory.textures++;
            var h = !0 === b.isWebGLRenderTargetCube,
                n = k(b);
            if (h) {
                e.__webglFramebuffer = [];
                for (var t = 0; 6 > t; t++) e.__webglFramebuffer[t] = a.createFramebuffer()
            } else e.__webglFramebuffer =
                a.createFramebuffer();
            if (h) {
                c.bindTexture(a.TEXTURE_CUBE_MAP, f.__webglTexture);
                p(a.TEXTURE_CUBE_MAP, b.texture, n);
                for (t = 0; 6 > t; t++) x(e.__webglFramebuffer[t], b, a.COLOR_ATTACHMENT0, a.TEXTURE_CUBE_MAP_POSITIVE_X + t);
                m(b.texture, n) && q(a.TEXTURE_CUBE_MAP, b.texture, b.width, b.height);
                c.bindTexture(a.TEXTURE_CUBE_MAP, null)
            } else c.bindTexture(a.TEXTURE_2D, f.__webglTexture), p(a.TEXTURE_2D, b.texture, n), x(e.__webglFramebuffer, b, a.COLOR_ATTACHMENT0, a.TEXTURE_2D), m(b.texture, n) && q(a.TEXTURE_2D, b.texture, b.width, b.height),
                c.bindTexture(a.TEXTURE_2D, null);
            if (b.depthBuffer) {
                e = d.get(b);
                f = !0 === b.isWebGLRenderTargetCube;
                if (b.depthTexture) {
                    if (f) throw Error("target.depthTexture not supported in Cube render targets");
                    if (b && b.isWebGLRenderTargetCube) throw Error("Depth Texture with cube render targets is not supported");
                    a.bindFramebuffer(a.FRAMEBUFFER, e.__webglFramebuffer);
                    if (!b.depthTexture || !b.depthTexture.isDepthTexture) throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    d.get(b.depthTexture).__webglTexture &&
                        b.depthTexture.image.width === b.width && b.depthTexture.image.height === b.height || (b.depthTexture.image.width = b.width, b.depthTexture.image.height = b.height, b.depthTexture.needsUpdate = !0);
                    l(b.depthTexture, 0);
                    e = d.get(b.depthTexture).__webglTexture;
                    if (1026 === b.depthTexture.format) a.framebufferTexture2D(a.FRAMEBUFFER, a.DEPTH_ATTACHMENT, a.TEXTURE_2D, e, 0);
                    else if (1027 === b.depthTexture.format) a.framebufferTexture2D(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.TEXTURE_2D, e, 0);
                    else throw Error("Unknown depthTexture format");
                } else if (f)
                    for (e.__webglDepthbuffer = [], f = 0; 6 > f; f++) a.bindFramebuffer(a.FRAMEBUFFER, e.__webglFramebuffer[f]), e.__webglDepthbuffer[f] = a.createRenderbuffer(), w(e.__webglDepthbuffer[f], b);
                else a.bindFramebuffer(a.FRAMEBUFFER, e.__webglFramebuffer), e.__webglDepthbuffer = a.createRenderbuffer(), w(e.__webglDepthbuffer, b);
                a.bindFramebuffer(a.FRAMEBUFFER, null)
            }
        };
        this.updateRenderTargetMipmap = function(b) {
            var e = b.texture,
                f = k(b);
            if (m(e, f)) {
                f = b.isWebGLRenderTargetCube ? a.TEXTURE_CUBE_MAP : a.TEXTURE_2D;
                var g = d.get(e).__webglTexture;
                c.bindTexture(f, g);
                q(f, e, b.width, b.height);
                c.bindTexture(f, null)
            }
        }
    }

    function $e(a, b, c) {
        return {
            convert: function(d) {
                if (1E3 === d) return a.REPEAT;
                if (1001 === d) return a.CLAMP_TO_EDGE;
                if (1002 === d) return a.MIRRORED_REPEAT;
                if (1003 === d) return a.NEAREST;
                if (1004 === d) return a.NEAREST_MIPMAP_NEAREST;
                if (1005 === d) return a.NEAREST_MIPMAP_LINEAR;
                if (1006 === d) return a.LINEAR;
                if (1007 === d) return a.LINEAR_MIPMAP_NEAREST;
                if (1008 === d) return a.LINEAR_MIPMAP_LINEAR;
                if (1009 === d) return a.UNSIGNED_BYTE;
                if (1017 === d) return a.UNSIGNED_SHORT_4_4_4_4;
                if (1018 === d) return a.UNSIGNED_SHORT_5_5_5_1;
                if (1019 === d) return a.UNSIGNED_SHORT_5_6_5;
                if (1010 === d) return a.BYTE;
                if (1011 === d) return a.SHORT;
                if (1012 === d) return a.UNSIGNED_SHORT;
                if (1013 === d) return a.INT;
                if (1014 === d) return a.UNSIGNED_INT;
                if (1015 === d) return a.FLOAT;
                if (1016 === d) {
                    if (c.isWebGL2) return a.HALF_FLOAT;
                    var e = b.get("OES_texture_half_float");
                    if (null !== e) return e.HALF_FLOAT_OES
                }
                if (1021 === d) return a.ALPHA;
                if (1022 === d) return a.RGB;
                if (1023 === d) return a.RGBA;
                if (1024 === d) return a.LUMINANCE;
                if (1025 ===
                    d) return a.LUMINANCE_ALPHA;
                if (1026 === d) return a.DEPTH_COMPONENT;
                if (1027 === d) return a.DEPTH_STENCIL;
                if (100 === d) return a.FUNC_ADD;
                if (101 === d) return a.FUNC_SUBTRACT;
                if (102 === d) return a.FUNC_REVERSE_SUBTRACT;
                if (200 === d) return a.ZERO;
                if (201 === d) return a.ONE;
                if (202 === d) return a.SRC_COLOR;
                if (203 === d) return a.ONE_MINUS_SRC_COLOR;
                if (204 === d) return a.SRC_ALPHA;
                if (205 === d) return a.ONE_MINUS_SRC_ALPHA;
                if (206 === d) return a.DST_ALPHA;
                if (207 === d) return a.ONE_MINUS_DST_ALPHA;
                if (208 === d) return a.DST_COLOR;
                if (209 ===
                    d) return a.ONE_MINUS_DST_COLOR;
                if (210 === d) return a.SRC_ALPHA_SATURATE;
                if (33776 === d || 33777 === d || 33778 === d || 33779 === d)
                    if (e = b.get("WEBGL_compressed_texture_s3tc"), null !== e) {
                        if (33776 === d) return e.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if (33777 === d) return e.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if (33778 === d) return e.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if (33779 === d) return e.COMPRESSED_RGBA_S3TC_DXT5_EXT
                    }
                if (35840 === d || 35841 === d || 35842 === d || 35843 === d)
                    if (e = b.get("WEBGL_compressed_texture_pvrtc"), null !== e) {
                        if (35840 === d) return e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (35841 === d) return e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (35842 === d) return e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (35843 === d) return e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                if (36196 === d && (e = b.get("WEBGL_compressed_texture_etc1"), null !== e)) return e.COMPRESSED_RGB_ETC1_WEBGL;
                if (37808 === d || 37809 === d || 37810 === d || 37811 === d || 37812 === d || 37813 === d || 37814 === d || 37815 === d || 37816 === d || 37817 === d || 37818 === d || 37819 === d || 37820 === d || 37821 === d)
                    if (e = b.get("WEBGL_compressed_texture_astc"), null !== e) return d;
                if (103 === d || 104 ===
                    d) {
                    if (c.isWebGL2) {
                        if (103 === d) return a.MIN;
                        if (104 === d) return a.MAX
                    }
                    e = b.get("EXT_blend_minmax");
                    if (null !== e) {
                        if (103 === d) return e.MIN_EXT;
                        if (104 === d) return e.MAX_EXT
                    }
                }
                if (1020 === d) {
                    if (c.isWebGL2) return a.UNSIGNED_INT_24_8;
                    e = b.get("WEBGL_depth_texture");
                    if (null !== e) return e.UNSIGNED_INT_24_8_WEBGL
                }
                return 0
            }
        }
    }

    function Kb() {
        D.call(this);
        this.type = "Group"
    }

    function Z(a, b, c, d) {
        Na.call(this);
        this.type = "PerspectiveCamera";
        this.fov = void 0 !== a ? a : 50;
        this.zoom = 1;
        this.near = void 0 !== c ? c : .1;
        this.far = void 0 !== d ? d : 2E3;
        this.focus = 10;
        this.aspect = void 0 !== b ? b : 1;
        this.view = null;
        this.filmGauge = 35;
        this.filmOffset = 0;
        this.updateProjectionMatrix()
    }

    function yc(a) {
        Z.call(this);
        this.cameras = a || []
    }

    function af(a) {
        function b() {
            return null !== e && !0 === e.isPresenting
        }

        function c() {
            if (b()) {
                var c = e.getEyeParameters("left"),
                    f = c.renderWidth;
                c = c.renderHeight;
                x = a.getPixelRatio();
                y = a.getSize();
                a.setDrawingBufferSize(2 * f, c, 1);
                B.start()
            } else d.enabled && (a.setDrawingBufferSize(y.width, y.height, x), B.stop())
        }
        var d = this,
            e = null,
            f = null,
            g = null,
            h = [],
            k = new I,
            m = new I;
        "undefined" !== typeof window && "VRFrameData" in window && (f = new window.VRFrameData, window.addEventListener("vrdisplaypresentchange", c, !1));
        var q = new I,
            n = new fa,
            t = new p,
            u = new Z;
        u.bounds = new V(0, 0, .5, 1);
        u.layers.enable(1);
        var r = new Z;
        r.bounds = new V(.5, 0, .5, 1);
        r.layers.enable(2);
        var l = new yc([u, r]);
        l.layers.enable(1);
        l.layers.enable(2);
        var y, x, w = [];
        this.enabled = !1;
        this.userHeight = 1.6;
        this.getController = function(a) {
            var b = h[a];
            void 0 === b && (b = new Kb, b.matrixAutoUpdate = !1, b.visible = !1, h[a] =
                b);
            return b
        };
        this.getDevice = function() {
            return e
        };
        this.setDevice = function(a) {
            void 0 !== a && (e = a);
            B.setContext(a)
        };
        this.setPoseTarget = function(a) {
            void 0 !== a && (g = a)
        };
        this.getCamera = function(a) {
            if (null === e) return a.position.set(0, d.userHeight, 0), a;
            e.depthNear = a.near;
            e.depthFar = a.far;
            e.getFrameData(f);
            var b = e.stageParameters;
            b ? k.fromArray(b.sittingToStandingTransform) : k.makeTranslation(0, d.userHeight, 0);
            b = f.pose;
            var c = null !== g ? g : a;
            c.matrix.copy(k);
            c.matrix.decompose(c.position, c.quaternion, c.scale);
            null !==
                b.orientation && (n.fromArray(b.orientation), c.quaternion.multiply(n));
            null !== b.position && (n.setFromRotationMatrix(k), t.fromArray(b.position), t.applyQuaternion(n), c.position.add(t));
            c.updateMatrixWorld();
            if (!1 === e.isPresenting) return a;
            u.near = a.near;
            r.near = a.near;
            u.far = a.far;
            r.far = a.far;
            l.matrixWorld.copy(a.matrixWorld);
            l.matrixWorldInverse.copy(a.matrixWorldInverse);
            u.matrixWorldInverse.fromArray(f.leftViewMatrix);
            r.matrixWorldInverse.fromArray(f.rightViewMatrix);
            m.getInverse(k);
            u.matrixWorldInverse.multiply(m);
            r.matrixWorldInverse.multiply(m);
            a = c.parent;
            null !== a && (q.getInverse(a.matrixWorld), u.matrixWorldInverse.multiply(q), r.matrixWorldInverse.multiply(q));
            u.matrixWorld.getInverse(u.matrixWorldInverse);
            r.matrixWorld.getInverse(r.matrixWorldInverse);
            u.projectionMatrix.fromArray(f.leftProjectionMatrix);
            r.projectionMatrix.fromArray(f.rightProjectionMatrix);
            l.projectionMatrix.copy(u.projectionMatrix);
            a = e.getLayers();
            a.length && (a = a[0], null !== a.leftBounds && 4 === a.leftBounds.length && u.bounds.fromArray(a.leftBounds),
                null !== a.rightBounds && 4 === a.rightBounds.length && r.bounds.fromArray(a.rightBounds));
            a: for (a = 0; a < h.length; a++) {
                b = h[a];
                b: {
                    c = a;
                    for (var v = navigator.getGamepads && navigator.getGamepads(), p = 0, y = 0, x = v.length; p < x; p++) {
                        var E = v[p];
                        if (E && ("Daydream Controller" === E.id || "Gear VR Controller" === E.id || "Oculus Go Controller" === E.id || "OpenVR Gamepad" === E.id || E.id.startsWith("Oculus Touch") || E.id.startsWith("Spatial Controller"))) {
                            if (y === c) {
                                c = E;
                                break b
                            }
                            y++
                        }
                    }
                    c = void 0
                }
                if (void 0 !== c && void 0 !== c.pose) {
                    if (null === c.pose) break a;
                    v = c.pose;
                    !1 === v.hasPosition && b.position.set(.2, -.6, -.05);
                    null !== v.position && b.position.fromArray(v.position);
                    null !== v.orientation && b.quaternion.fromArray(v.orientation);
                    b.matrix.compose(b.position, b.quaternion, b.scale);
                    b.matrix.premultiply(k);
                    b.matrix.decompose(b.position, b.quaternion, b.scale);
                    b.matrixWorldNeedsUpdate = !0;
                    b.visible = !0;
                    v = "Daydream Controller" === c.id ? 0 : 1;
                    w[a] !== c.buttons[v].pressed && (w[a] = c.buttons[v].pressed, !0 === w[a] ? b.dispatchEvent({
                        type: "selectstart"
                    }) : (b.dispatchEvent({
                            type: "selectend"
                        }),
                        b.dispatchEvent({
                            type: "select"
                        })))
                } else b.visible = !1
            }
            return l
        };
        this.getStandingMatrix = function() {
            return k
        };
        this.isPresenting = b;
        var B = new Qd;
        this.setAnimationLoop = function(a) {
            B.setAnimationLoop(a)
        };
        this.submitFrame = function() {
            b() && e.submitFrame()
        };
        this.dispose = function() {
            "undefined" !== typeof window && window.removeEventListener("vrdisplaypresentchange", c)
        }
    }

    function Lg(a) {
        function b() {
            return null !== h && null !== k
        }

        function c(a) {
            var b = q[n.indexOf(a.inputSource)];
            b && b.dispatchEvent({
                type: a.type
            })
        }

        function d() {
            a.setFramebuffer(null);
            p.stop()
        }

        function e(a, b) {
            null === b ? a.matrixWorld.copy(a.matrix) : a.matrixWorld.multiplyMatrices(b.matrixWorld, a.matrix);
            a.matrixWorldInverse.getInverse(a.matrixWorld)
        }
        var f = a.context,
            g = null,
            h = null,
            k = null,
            m = null,
            q = [],
            n = [],
            t = new Z;
        t.layers.enable(1);
        t.viewport = new V;
        var u = new Z;
        u.layers.enable(2);
        u.viewport = new V;
        var r = new yc([t, u]);
        r.layers.enable(1);
        r.layers.enable(2);
        this.enabled = !1;
        this.getController = function(a) {
            var b = q[a];
            void 0 === b && (b = new Kb, b.matrixAutoUpdate = !1, b.visible = !1, q[a] = b);
            return b
        };
        this.getDevice = function() {
            return g
        };
        this.setDevice = function(a) {
            void 0 !== a && (g = a);
            a instanceof XRDevice && f.setCompatibleXRDevice(a)
        };
        this.setSession = function(b, e) {
            h = b;
            null !== h && (h.addEventListener("select", c), h.addEventListener("selectstart", c), h.addEventListener("selectend", c), h.addEventListener("end", d), h.baseLayer = new XRWebGLLayer(h, f), h.requestFrameOfReference(e.frameOfReferenceType).then(function(b) {
                    k = b;
                    a.setFramebuffer(h.baseLayer.framebuffer);
                    p.setContext(h);
                    p.start()
                }), n = h.getInputSources(),
                h.addEventListener("inputsourceschange", function() {
                    n = h.getInputSources();
                    console.log(n)
                }))
        };
        this.getCamera = function(a) {
            if (b()) {
                var c = a.parent,
                    d = r.cameras;
                e(r, c);
                for (var f = 0; f < d.length; f++) e(d[f], c);
                a.matrixWorld.copy(r.matrixWorld);
                a = a.children;
                f = 0;
                for (c = a.length; f < c; f++) a[f].updateMatrixWorld(!0);
                return r
            }
            return a
        };
        this.isPresenting = b;
        var l = null,
            p = new Qd;
        p.setAnimationLoop(function(a, b) {
            m = b.getDevicePose(k);
            if (null !== m)
                for (var c = h.baseLayer, d = b.views, e = 0; e < d.length; e++) {
                    var f = d[e],
                        g = c.getViewport(f),
                        t = m.getViewMatrix(f),
                        u = r.cameras[e];
                    u.matrix.fromArray(t).getInverse(u.matrix);
                    u.projectionMatrix.fromArray(f.projectionMatrix);
                    u.viewport.set(g.x, g.y, g.width, g.height);
                    0 === e && (r.matrix.copy(u.matrix), r.projectionMatrix.copy(u.projectionMatrix))
                }
            for (e = 0; e < q.length; e++) {
                c = q[e];
                if (d = n[e])
                    if (d = b.getInputPose(d, k), null !== d) {
                        c.matrix.elements = d.pointerMatrix;
                        c.matrix.decompose(c.position, c.rotation, c.scale);
                        c.visible = !0;
                        continue
                    }
                c.visible = !1
            }
            l && l(a)
        });
        this.setAnimationLoop = function(a) {
            l = a
        };
        this.dispose =
            function() {};
        this.getStandingMatrix = function() {
            console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed.");
            return new THREE.Matrix4
        };
        this.submitFrame = function() {}
    }

    function Zd(a) {
        var b;

        function c() {
            ha = new Pf(F);
            ua = new Nf(F, ha, a);
            ua.isWebGL2 || (ha.get("WEBGL_depth_texture"), ha.get("OES_texture_float"), ha.get("OES_texture_half_float"), ha.get("OES_texture_half_float_linear"), ha.get("OES_standard_derivatives"), ha.get("OES_element_index_uint"), ha.get("ANGLE_instanced_arrays"));
            ha.get("OES_texture_float_linear");
            da = new $e(F, ha, ua);
            ba = new Jg(F, ha, da, ua);
            ba.scissor(wc.copy(fa).multiplyScalar(U));
            ba.viewport(T.copy(od).multiplyScalar(U));
            ca = new Sf(F);
            Ba = new Ag;
            ia = new Kg(F, ha, ba, Ba, ua, da, ca);
            pa = new Ff(F);
            ra = new Qf(F, pa, ca);
            ma = new Vf(ra, ca);
            va = new Uf(F);
            la = new zg(C, ha, ua);
            sa = new Eg;
            na = new Ig;
            ka = new Lf(C, ba, ma, N);
            xa = new Mf(F, ha, ca, ua);
            ya = new Rf(F, ha, ca, ua);
            ca.programs = la.programs;
            C.context = F;
            C.capabilities = ua;
            C.extensions = ha;
            C.properties = Ba;
            C.renderLists = sa;
            C.state = ba;
            C.info = ca
        }

        function d(a) {
            a.preventDefault();
            console.log("THREE.WebGLRenderer: Context Lost.");
            G = !0
        }

        function e() {
            console.log("THREE.WebGLRenderer: Context Restored.");
            G = !1;
            c()
        }

        function f(a) {
            a = a.target;
            a.removeEventListener("dispose", f);
            g(a);
            Ba.remove(a)
        }

        function g(a) {
            var b = Ba.get(a).program;
            a.program = void 0;
            void 0 !== b && la.releaseProgram(b)
        }

        function h(a, b) {
            a.render(function(a) {
                C.renderBufferImmediate(a, b)
            })
        }

        function k(a, b, c) {
            if (!1 !== a.visible) {
                if (a.layers.test(b.layers))
                    if (a.isLight) D.pushLight(a), a.castShadow && D.pushShadow(a);
                    else if (a.isSprite) {
                    if (!a.frustumCulled ||
                        oa.intersectsSprite(a)) {
                        c && bb.setFromMatrixPosition(a.matrixWorld).applyMatrix4(xc);
                        var d = ma.update(a),
                            e = a.material;
                        A.push(a, d, e, bb.z, null)
                    }
                } else if (a.isImmediateRenderObject) c && bb.setFromMatrixPosition(a.matrixWorld).applyMatrix4(xc), A.push(a, null, a.material, bb.z, null);
                else if (a.isMesh || a.isLine || a.isPoints)
                    if (a.isSkinnedMesh && a.skeleton.update(), !a.frustumCulled || oa.intersectsObject(a))
                        if (c && bb.setFromMatrixPosition(a.matrixWorld).applyMatrix4(xc), d = ma.update(a), e = a.material, Array.isArray(e))
                            for (var f =
                                    d.groups, g = 0, h = f.length; g < h; g++) {
                                var m = f[g],
                                    n = e[m.materialIndex];
                                n && n.visible && A.push(a, d, n, bb.z, m)
                            } else e.visible && A.push(a, d, e, bb.z, null);
                a = a.children;
                g = 0;
                for (h = a.length; g < h; g++) k(a[g], b, c)
            }
        }

        function m(a, b, c, d) {
            for (var e = 0, f = a.length; e < f; e++) {
                var g = a[e],
                    h = g.object,
                    k = g.geometry,
                    m = void 0 === d ? g.material : d;
                g = g.group;
                if (c.isArrayCamera) {
                    W = c;
                    for (var n = c.cameras, t = 0, u = n.length; t < u; t++) {
                        var l = n[t];
                        if (h.layers.test(l.layers)) {
                            if ("viewport" in l) ba.viewport(T.copy(l.viewport));
                            else {
                                var r = l.bounds;
                                ba.viewport(T.set(r.x *
                                    Z, r.y * M, r.z * Z, r.w * M).multiplyScalar(U))
                            }
                            q(h, b, l, k, m, g)
                        }
                    }
                } else W = null, q(h, b, c, k, m, g)
            }
        }

        function q(a, c, d, e, f, g) {
            a.onBeforeRender(C, c, d, e, f, g);
            D = na.get(c, W || d);
            a.modelViewMatrix.multiplyMatrices(d.matrixWorldInverse, a.matrixWorld);
            a.normalMatrix.getNormalMatrix(a.modelViewMatrix);
            if (a.isImmediateRenderObject) {
                ba.setMaterial(f);
                var k = t(d, c.fog, f, a);
                S = b = null;
                nd = !1;
                h(a, k)
            } else C.renderBufferDirect(d, c.fog, e, f, a, g);
            a.onAfterRender(C, c, d, e, f, g);
            D = na.get(c, W || d)
        }

        function n(a, b, c) {
            var d = Ba.get(a),
                e = D.state.lights,
                h = d.lightsHash,
                k = e.state.hash;
            c = la.getParameters(a, e.state, D.state.shadowsArray, b, aa.numPlanes, aa.numIntersection, c);
            var m = la.getProgramCode(a, c),
                n = d.program,
                q = !0;
            if (void 0 === n) a.addEventListener("dispose", f);
            else if (n.code !== m) g(a);
            else {
                if (h.stateID !== k.stateID || h.directionalLength !== k.directionalLength || h.pointLength !== k.pointLength || h.spotLength !== k.spotLength || h.rectAreaLength !== k.rectAreaLength || h.hemiLength !== k.hemiLength || h.shadowsLength !== k.shadowsLength) h.stateID = k.stateID, h.directionalLength =
                    k.directionalLength, h.pointLength = k.pointLength, h.spotLength = k.spotLength, h.rectAreaLength = k.rectAreaLength, h.hemiLength = k.hemiLength, h.shadowsLength = k.shadowsLength;
                else if (void 0 !== c.shaderID) return;
                q = !1
            }
            q && (c.shaderID ? (m = nb[c.shaderID], d.shader = {
                name: a.type,
                uniforms: Aa.clone(m.uniforms),
                vertexShader: m.vertexShader,
                fragmentShader: m.fragmentShader
            }) : d.shader = {
                name: a.type,
                uniforms: a.uniforms,
                vertexShader: a.vertexShader,
                fragmentShader: a.fragmentShader
            }, a.onBeforeCompile(d.shader, C), m = la.getProgramCode(a,
                c), n = la.acquireProgram(a, d.shader, c, m), d.program = n, a.program = n);
            c = n.getAttributes();
            if (a.morphTargets)
                for (m = a.numSupportedMorphTargets = 0; m < C.maxMorphTargets; m++) 0 <= c["morphTarget" + m] && a.numSupportedMorphTargets++;
            if (a.morphNormals)
                for (m = a.numSupportedMorphNormals = 0; m < C.maxMorphNormals; m++) 0 <= c["morphNormal" + m] && a.numSupportedMorphNormals++;
            c = d.shader.uniforms;
            if (!a.isShaderMaterial && !a.isRawShaderMaterial || !0 === a.clipping) d.numClippingPlanes = aa.numPlanes, d.numIntersection = aa.numIntersection, c.clippingPlanes =
                aa.uniform;
            d.fog = b;
            void 0 === h && (d.lightsHash = h = {});
            h.stateID = k.stateID;
            h.directionalLength = k.directionalLength;
            h.pointLength = k.pointLength;
            h.spotLength = k.spotLength;
            h.rectAreaLength = k.rectAreaLength;
            h.hemiLength = k.hemiLength;
            h.shadowsLength = k.shadowsLength;
            a.lights && (c.ambientLightColor.value = e.state.ambient, c.directionalLights.value = e.state.directional, c.spotLights.value = e.state.spot, c.rectAreaLights.value = e.state.rectArea, c.pointLights.value = e.state.point, c.hemisphereLights.value = e.state.hemi, c.directionalShadowMap.value =
                e.state.directionalShadowMap, c.directionalShadowMatrix.value = e.state.directionalShadowMatrix, c.spotShadowMap.value = e.state.spotShadowMap, c.spotShadowMatrix.value = e.state.spotShadowMatrix, c.pointShadowMap.value = e.state.pointShadowMap, c.pointShadowMatrix.value = e.state.pointShadowMatrix);
            a = d.program.getUniforms();
            a = Za.seqWithValue(a.seq, c);
            d.uniformsList = a
        }

        function t(a, b, c, d) {
            X = 0;
            var e = Ba.get(c),
                f = e.lightsHash,
                g = D.state.lights.state.hash;
            pd && (Yd || a !== Y) && aa.setState(c.clippingPlanes, c.clipIntersection,
                c.clipShadows, a, e, a === Y && c.id === J);
            !1 === c.needsUpdate && (void 0 === e.program ? c.needsUpdate = !0 : c.fog && e.fog !== b ? c.needsUpdate = !0 : !c.lights || f.stateID === g.stateID && f.directionalLength === g.directionalLength && f.pointLength === g.pointLength && f.spotLength === g.spotLength && f.rectAreaLength === g.rectAreaLength && f.hemiLength === g.hemiLength && f.shadowsLength === g.shadowsLength ? void 0 === e.numClippingPlanes || e.numClippingPlanes === aa.numPlanes && e.numIntersection === aa.numIntersection || (c.needsUpdate = !0) : c.needsUpdate = !0);
            c.needsUpdate && (n(c, b, d), c.needsUpdate = !1);
            var h = !1,
                k = !1,
                m = !1;
            f = e.program;
            g = f.getUniforms();
            var q = e.shader.uniforms;
            ba.useProgram(f.program) && (m = k = h = !0);
            c.id !== J && (J = c.id, k = !0);
            if (h || a !== Y) {
                g.setValue(F, "projectionMatrix", a.projectionMatrix);
                ua.logarithmicDepthBuffer && g.setValue(F, "logDepthBufFC", 2 / (Math.log(a.far + 1) / Math.LN2));
                Y !== (W || a) && (Y = W || a, m = k = !0);
                if (c.isShaderMaterial || c.isMeshPhongMaterial || c.isMeshStandardMaterial || c.envMap) h = g.map.cameraPosition, void 0 !== h && h.setValue(F, bb.setFromMatrixPosition(a.matrixWorld));
                (c.isMeshPhongMaterial || c.isMeshLambertMaterial || c.isMeshBasicMaterial || c.isMeshStandardMaterial || c.isShaderMaterial || c.skinning) && g.setValue(F, "viewMatrix", a.matrixWorldInverse)
            }
            if (c.skinning && (g.setOptional(F, d, "bindMatrix"), g.setOptional(F, d, "bindMatrixInverse"), a = d.skeleton))
                if (h = a.bones, ua.floatVertexTextures) {
                    if (void 0 === a.boneTexture) {
                        h = Math.sqrt(4 * h.length);
                        h = H.ceilPowerOfTwo(h);
                        h = Math.max(h, 4);
                        var t = new Float32Array(h * h * 4);
                        t.set(a.boneMatrices);
                        var v = new gb(t, h, h, 1023, 1015);
                        v.needsUpdate = !0;
                        a.boneMatrices = t;
                        a.boneTexture = v;
                        a.boneTextureSize = h
                    }
                    g.setValue(F, "boneTexture", a.boneTexture);
                    g.setValue(F, "boneTextureSize", a.boneTextureSize)
                } else g.setOptional(F, a, "boneMatrices");
            k && (g.setValue(F, "toneMappingExposure", C.toneMappingExposure), g.setValue(F, "toneMappingWhitePoint", C.toneMappingWhitePoint), c.lights && (k = m, q.ambientLightColor.needsUpdate = k, q.directionalLights.needsUpdate = k, q.pointLights.needsUpdate = k, q.spotLights.needsUpdate = k, q.rectAreaLights.needsUpdate = k, q.hemisphereLights.needsUpdate =
                k), b && c.fog && (q.fogColor.value = b.color, b.isFog ? (q.fogNear.value = b.near, q.fogFar.value = b.far) : b.isFogExp2 && (q.fogDensity.value = b.density)), c.isMeshBasicMaterial ? u(q, c) : c.isMeshLambertMaterial ? (u(q, c), c.emissiveMap && (q.emissiveMap.value = c.emissiveMap)) : c.isMeshPhongMaterial ? (u(q, c), c.isMeshToonMaterial ? (r(q, c), c.gradientMap && (q.gradientMap.value = c.gradientMap)) : r(q, c)) : c.isMeshStandardMaterial ? (u(q, c), c.isMeshPhysicalMaterial ? (l(q, c), q.reflectivity.value = c.reflectivity, q.clearCoat.value = c.clearCoat,
                q.clearCoatRoughness.value = c.clearCoatRoughness) : l(q, c)) : c.isMeshDepthMaterial ? (u(q, c), c.displacementMap && (q.displacementMap.value = c.displacementMap, q.displacementScale.value = c.displacementScale, q.displacementBias.value = c.displacementBias)) : c.isMeshDistanceMaterial ? (u(q, c), c.displacementMap && (q.displacementMap.value = c.displacementMap, q.displacementScale.value = c.displacementScale, q.displacementBias.value = c.displacementBias), q.referencePosition.value.copy(c.referencePosition), q.nearDistance.value = c.nearDistance,
                q.farDistance.value = c.farDistance) : c.isMeshNormalMaterial ? (u(q, c), c.bumpMap && (q.bumpMap.value = c.bumpMap, q.bumpScale.value = c.bumpScale, 1 === c.side && (q.bumpScale.value *= -1)), c.normalMap && (q.normalMap.value = c.normalMap, q.normalScale.value.copy(c.normalScale), 1 === c.side && q.normalScale.value.negate()), c.displacementMap && (q.displacementMap.value = c.displacementMap, q.displacementScale.value = c.displacementScale, q.displacementBias.value = c.displacementBias)) : c.isLineBasicMaterial ? (q.diffuse.value = c.color, q.opacity.value =
                c.opacity, c.isLineDashedMaterial && (q.dashSize.value = c.dashSize, q.totalSize.value = c.dashSize + c.gapSize, q.scale.value = c.scale)) : c.isPointsMaterial ? (q.diffuse.value = c.color, q.opacity.value = c.opacity, q.size.value = c.size * U, q.scale.value = .5 * M, q.map.value = c.map, null !== c.map && (!0 === c.map.matrixAutoUpdate && c.map.updateMatrix(), q.uvTransform.value.copy(c.map.matrix))) : c.isSpriteMaterial ? (q.diffuse.value = c.color, q.opacity.value = c.opacity, q.rotation.value = c.rotation, q.map.value = c.map, null !== c.map && (!0 === c.map.matrixAutoUpdate &&
                c.map.updateMatrix(), q.uvTransform.value.copy(c.map.matrix))) : c.isShadowMaterial && (q.color.value = c.color, q.opacity.value = c.opacity), void 0 !== q.ltc_1 && (q.ltc_1.value = K.LTC_1), void 0 !== q.ltc_2 && (q.ltc_2.value = K.LTC_2), Za.upload(F, e.uniformsList, q, C));
            c.isShaderMaterial && !0 === c.uniformsNeedUpdate && (Za.upload(F, e.uniformsList, q, C), c.uniformsNeedUpdate = !1);
            c.isSpriteMaterial && g.setValue(F, "center", d.center);
            g.setValue(F, "modelViewMatrix", d.modelViewMatrix);
            g.setValue(F, "normalMatrix", d.normalMatrix);
            g.setValue(F,
                "modelMatrix", d.matrixWorld);
            return f
        }

        function u(a, b) {
            a.opacity.value = b.opacity;
            b.color && (a.diffuse.value = b.color);
            b.emissive && a.emissive.value.copy(b.emissive).multiplyScalar(b.emissiveIntensity);
            b.map && (a.map.value = b.map);
            b.alphaMap && (a.alphaMap.value = b.alphaMap);
            b.specularMap && (a.specularMap.value = b.specularMap);
            b.envMap && (a.envMap.value = b.envMap, a.flipEnvMap.value = b.envMap && b.envMap.isCubeTexture ? -1 : 1, a.reflectivity.value = b.reflectivity, a.refractionRatio.value = b.refractionRatio, a.maxMipLevel.value =
                Ba.get(b.envMap).__maxMipLevel);
            b.lightMap && (a.lightMap.value = b.lightMap, a.lightMapIntensity.value = b.lightMapIntensity);
            b.aoMap && (a.aoMap.value = b.aoMap, a.aoMapIntensity.value = b.aoMapIntensity);
            if (b.map) var c = b.map;
            else b.specularMap ? c = b.specularMap : b.displacementMap ? c = b.displacementMap : b.normalMap ? c = b.normalMap : b.bumpMap ? c = b.bumpMap : b.roughnessMap ? c = b.roughnessMap : b.metalnessMap ? c = b.metalnessMap : b.alphaMap ? c = b.alphaMap : b.emissiveMap && (c = b.emissiveMap);
            void 0 !== c && (c.isWebGLRenderTarget && (c = c.texture), !0 === c.matrixAutoUpdate && c.updateMatrix(), a.uvTransform.value.copy(c.matrix))
        }

        function r(a, b) {
            a.specular.value = b.specular;
            a.shininess.value = Math.max(b.shininess, 1E-4);
            b.emissiveMap && (a.emissiveMap.value = b.emissiveMap);
            b.bumpMap && (a.bumpMap.value = b.bumpMap, a.bumpScale.value = b.bumpScale, 1 === b.side && (a.bumpScale.value *= -1));
            b.normalMap && (a.normalMap.value = b.normalMap, a.normalScale.value.copy(b.normalScale), 1 === b.side && a.normalScale.value.negate());
            b.displacementMap && (a.displacementMap.value = b.displacementMap,
                a.displacementScale.value = b.displacementScale, a.displacementBias.value = b.displacementBias)
        }

        function l(a, b) {
            a.roughness.value = b.roughness;
            a.metalness.value = b.metalness;
            b.roughnessMap && (a.roughnessMap.value = b.roughnessMap);
            b.metalnessMap && (a.metalnessMap.value = b.metalnessMap);
            b.emissiveMap && (a.emissiveMap.value = b.emissiveMap);
            b.bumpMap && (a.bumpMap.value = b.bumpMap, a.bumpScale.value = b.bumpScale, 1 === b.side && (a.bumpScale.value *= -1));
            b.normalMap && (a.normalMap.value = b.normalMap, a.normalScale.value.copy(b.normalScale),
                1 === b.side && a.normalScale.value.negate());
            b.displacementMap && (a.displacementMap.value = b.displacementMap, a.displacementScale.value = b.displacementScale, a.displacementBias.value = b.displacementBias);
            b.envMap && (a.envMapIntensity.value = b.envMapIntensity)
        }
        console.log("THREE.WebGLRenderer", "95");
        a = a || {};
        var y = void 0 !== a.canvas ? a.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
            x = void 0 !== a.context ? a.context : null,
            w = void 0 !== a.alpha ? a.alpha : !1,
            B = void 0 !== a.depth ? a.depth : !0,
            E = void 0 !==
            a.stencil ? a.stencil : !0,
            P = void 0 !== a.antialias ? a.antialias : !1,
            N = void 0 !== a.premultipliedAlpha ? a.premultipliedAlpha : !0,
            O = void 0 !== a.preserveDrawingBuffer ? a.preserveDrawingBuffer : !1,
            z = void 0 !== a.powerPreference ? a.powerPreference : "default",
            A = null,
            D = null;
        this.domElement = y;
        this.context = null;
        this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0;
        this.clippingPlanes = [];
        this.localClippingEnabled = !1;
        this.gammaFactor = 2;
        this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1;
        this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1;
        this.maxMorphTargets = 8;
        this.maxMorphNormals = 4;
        var C = this,
            G = !1,
            L = null,
            R = null,
            Q = null,
            J = -1;
        var S = b = null;
        var nd = !1;
        var Y = null,
            W = null,
            T = new V,
            wc = new V,
            ea = null,
            X = 0,
            Z = y.width,
            M = y.height,
            U = 1,
            od = new V(0, 0, Z, M),
            fa = new V(0, 0, Z, M),
            qa = !1,
            oa = new md,
            aa = new Of,
            pd = !1,
            Yd = !1,
            xc = new I,
            bb = new p;
        try {
            w = {
                alpha: w,
                depth: B,
                stencil: E,
                antialias: P,
                premultipliedAlpha: N,
                preserveDrawingBuffer: O,
                powerPreference: z
            };
            y.addEventListener("webglcontextlost", d, !1);
            y.addEventListener("webglcontextrestored", e, !1);
            var F = x || y.getContext("webgl", w) || y.getContext("experimental-webgl", w);
            if (null === F) {
                if (null !== y.getContext("webgl")) throw Error("Error creating WebGL context with your selected attributes.");
                throw Error("Error creating WebGL context.");
            }
            void 0 === F.getShaderPrecisionFormat && (F.getShaderPrecisionFormat = function() {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            })
        } catch (Mg) {
            console.error("THREE.WebGLRenderer: " + Mg.message)
        }
        var ha, ua, ba, ca, Ba, ia, pa, ra, ma, la, sa,
            na, ka, va, xa, ya, da;
        c();
        var ja = "xr" in navigator ? new Lg(C) : new af(C);
        this.vr = ja;
        var za = new Ze(C, ma, ua.maxTextureSize);
        this.shadowMap = za;
        this.getContext = function() {
            return F
        };
        this.getContextAttributes = function() {
            return F.getContextAttributes()
        };
        this.forceContextLoss = function() {
            var a = ha.get("WEBGL_lose_context");
            a && a.loseContext()
        };
        this.forceContextRestore = function() {
            var a = ha.get("WEBGL_lose_context");
            a && a.restoreContext()
        };
        this.getPixelRatio = function() {
            return U
        };
        this.setPixelRatio = function(a) {
            void 0 !==
                a && (U = a, this.setSize(Z, M, !1))
        };
        this.getSize = function() {
            return {
                width: Z,
                height: M
            }
        };
        this.setSize = function(a, b, c) {
            ja.isPresenting() ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (Z = a, M = b, y.width = a * U, y.height = b * U, !1 !== c && (y.style.width = a + "px", y.style.height = b + "px"), this.setViewport(0, 0, a, b))
        };
        this.getDrawingBufferSize = function() {
            return {
                width: Z * U,
                height: M * U
            }
        };
        this.setDrawingBufferSize = function(a, b, c) {
            Z = a;
            M = b;
            U = c;
            y.width = a * c;
            y.height = b * c;
            this.setViewport(0, 0, a, b)
        };
        this.getCurrentViewport = function() {
            return T
        };
        this.setViewport = function(a, b, c, d) {
            od.set(a, M - b - d, c, d);
            ba.viewport(T.copy(od).multiplyScalar(U))
        };
        this.setScissor = function(a, b, c, d) {
            fa.set(a, M - b - d, c, d);
            ba.scissor(wc.copy(fa).multiplyScalar(U))
        };
        this.setScissorTest = function(a) {
            ba.setScissorTest(qa = a)
        };
        this.getClearColor = function() {
            return ka.getClearColor()
        };
        this.setClearColor = function() {
            ka.setClearColor.apply(ka, arguments)
        };
        this.getClearAlpha = function() {
            return ka.getClearAlpha()
        };
        this.setClearAlpha = function() {
            ka.setClearAlpha.apply(ka,
                arguments)
        };
        this.clear = function(a, b, c) {
            var d = 0;
            if (void 0 === a || a) d |= F.COLOR_BUFFER_BIT;
            if (void 0 === b || b) d |= F.DEPTH_BUFFER_BIT;
            if (void 0 === c || c) d |= F.STENCIL_BUFFER_BIT;
            F.clear(d)
        };
        this.clearColor = function() {
            this.clear(!0, !1, !1)
        };
        this.clearDepth = function() {
            this.clear(!1, !0, !1)
        };
        this.clearStencil = function() {
            this.clear(!1, !1, !0)
        };
        this.clearTarget = function(a, b, c, d) {
            this.setRenderTarget(a);
            this.clear(b, c, d)
        };
        this.dispose = function() {
            y.removeEventListener("webglcontextlost", d, !1);
            y.removeEventListener("webglcontextrestored",
                e, !1);
            sa.dispose();
            na.dispose();
            Ba.dispose();
            ma.dispose();
            ja.dispose();
            ta.stop()
        };
        this.renderBufferImmediate = function(a, b) {
            ba.initAttributes();
            var c = Ba.get(a);
            a.hasPositions && !c.position && (c.position = F.createBuffer());
            a.hasNormals && !c.normal && (c.normal = F.createBuffer());
            a.hasUvs && !c.uv && (c.uv = F.createBuffer());
            a.hasColors && !c.color && (c.color = F.createBuffer());
            b = b.getAttributes();
            a.hasPositions && (F.bindBuffer(F.ARRAY_BUFFER, c.position), F.bufferData(F.ARRAY_BUFFER, a.positionArray, F.DYNAMIC_DRAW), ba.enableAttribute(b.position),
                F.vertexAttribPointer(b.position, 3, F.FLOAT, !1, 0, 0));
            a.hasNormals && (F.bindBuffer(F.ARRAY_BUFFER, c.normal), F.bufferData(F.ARRAY_BUFFER, a.normalArray, F.DYNAMIC_DRAW), ba.enableAttribute(b.normal), F.vertexAttribPointer(b.normal, 3, F.FLOAT, !1, 0, 0));
            a.hasUvs && (F.bindBuffer(F.ARRAY_BUFFER, c.uv), F.bufferData(F.ARRAY_BUFFER, a.uvArray, F.DYNAMIC_DRAW), ba.enableAttribute(b.uv), F.vertexAttribPointer(b.uv, 2, F.FLOAT, !1, 0, 0));
            a.hasColors && (F.bindBuffer(F.ARRAY_BUFFER, c.color), F.bufferData(F.ARRAY_BUFFER, a.colorArray,
                F.DYNAMIC_DRAW), ba.enableAttribute(b.color), F.vertexAttribPointer(b.color, 3, F.FLOAT, !1, 0, 0));
            ba.disableUnusedAttributes();
            F.drawArrays(F.TRIANGLES, 0, a.count);
            a.count = 0
        };
        this.renderBufferDirect = function(a, c, d, e, f, g) {
            var h = f.isMesh && 0 > f.normalMatrix.determinant();
            ba.setMaterial(e, h);
            var k = t(a, c, e, f),
                m = !1;
            if (b !== d.id || S !== k.id || nd !== (!0 === e.wireframe)) b = d.id, S = k.id, nd = !0 === e.wireframe, m = !0;
            f.morphTargetInfluences && (va.update(f, d, e, k), m = !0);
            h = d.index;
            var q = d.attributes.position;
            c = 1;
            !0 === e.wireframe &&
                (h = ra.getWireframeAttribute(d), c = 2);
            a = xa;
            if (null !== h) {
                var n = pa.get(h);
                a = ya;
                a.setIndex(n)
            }
            if (m) {
                if (d && d.isInstancedBufferGeometry & !ua.isWebGL2 && null === ha.get("ANGLE_instanced_arrays")) console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                else {
                    ba.initAttributes();
                    m = d.attributes;
                    k = k.getAttributes();
                    var u = e.defaultAttributeValues;
                    for (N in k) {
                        var l = k[N];
                        if (0 <= l) {
                            var r = m[N];
                            if (void 0 !== r) {
                                var v = r.normalized,
                                    p = r.itemSize,
                                    w = pa.get(r);
                                if (void 0 !== w) {
                                    var y = w.buffer,
                                        E = w.type;
                                    w = w.bytesPerElement;
                                    if (r.isInterleavedBufferAttribute) {
                                        var x = r.data,
                                            B = x.stride;
                                        r = r.offset;
                                        x && x.isInstancedInterleavedBuffer ? (ba.enableAttributeAndDivisor(l, x.meshPerAttribute), void 0 === d.maxInstancedCount && (d.maxInstancedCount = x.meshPerAttribute * x.count)) : ba.enableAttribute(l);
                                        F.bindBuffer(F.ARRAY_BUFFER, y);
                                        F.vertexAttribPointer(l, p, E, v, B * w, r * w)
                                    } else r.isInstancedBufferAttribute ? (ba.enableAttributeAndDivisor(l, r.meshPerAttribute), void 0 ===
                                        d.maxInstancedCount && (d.maxInstancedCount = r.meshPerAttribute * r.count)) : ba.enableAttribute(l), F.bindBuffer(F.ARRAY_BUFFER, y), F.vertexAttribPointer(l, p, E, v, 0, 0)
                                }
                            } else if (void 0 !== u && (v = u[N], void 0 !== v)) switch (v.length) {
                                case 2:
                                    F.vertexAttrib2fv(l, v);
                                    break;
                                case 3:
                                    F.vertexAttrib3fv(l, v);
                                    break;
                                case 4:
                                    F.vertexAttrib4fv(l, v);
                                    break;
                                default:
                                    F.vertexAttrib1fv(l, v)
                            }
                        }
                    }
                    ba.disableUnusedAttributes()
                }
                null !== h && F.bindBuffer(F.ELEMENT_ARRAY_BUFFER, n.buffer)
            }
            n = Infinity;
            null !== h ? n = h.count : void 0 !== q && (n = q.count);
            h = d.drawRange.start *
                c;
            q = null !== g ? g.start * c : 0;
            var N = Math.max(h, q);
            g = Math.max(0, Math.min(n, h + d.drawRange.count * c, q + (null !== g ? g.count * c : Infinity)) - 1 - N + 1);
            if (0 !== g) {
                if (f.isMesh)
                    if (!0 === e.wireframe) ba.setLineWidth(e.wireframeLinewidth * (null === R ? U : 1)), a.setMode(F.LINES);
                    else switch (f.drawMode) {
                        case 0:
                            a.setMode(F.TRIANGLES);
                            break;
                        case 1:
                            a.setMode(F.TRIANGLE_STRIP);
                            break;
                        case 2:
                            a.setMode(F.TRIANGLE_FAN)
                    } else f.isLine ? (e = e.linewidth, void 0 === e && (e = 1), ba.setLineWidth(e * (null === R ? U : 1)), f.isLineSegments ? a.setMode(F.LINES) : f.isLineLoop ?
                        a.setMode(F.LINE_LOOP) : a.setMode(F.LINE_STRIP)) : f.isPoints ? a.setMode(F.POINTS) : f.isSprite && a.setMode(F.TRIANGLES);
                d && d.isInstancedBufferGeometry ? 0 < d.maxInstancedCount && a.renderInstances(d, N, g) : a.render(N, g)
            }
        };
        this.compile = function(a, b) {
            D = na.get(a, b);
            D.init();
            a.traverse(function(a) {
                a.isLight && (D.pushLight(a), a.castShadow && D.pushShadow(a))
            });
            D.setupLights(b);
            a.traverse(function(b) {
                if (b.material)
                    if (Array.isArray(b.material))
                        for (var c = 0; c < b.material.length; c++) n(b.material[c], a.fog, b);
                    else n(b.material,
                        a.fog, b)
            })
        };
        var wa = null,
            ta = new Qd;
        ta.setAnimationLoop(function(a) {
            ja.isPresenting() || wa && wa(a)
        });
        "undefined" !== typeof window && ta.setContext(window);
        this.setAnimationLoop = function(a) {
            wa = a;
            ja.setAnimationLoop(a);
            ta.start()
        };
        this.render = function(a, c, d, e) {
            if (!c || !c.isCamera) console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            else if (!G) {
                S = b = null;
                nd = !1;
                J = -1;
                Y = null;
                !0 === a.autoUpdate && a.updateMatrixWorld();
                null === c.parent && c.updateMatrixWorld();
                ja.enabled && (c = ja.getCamera(c));
                D = na.get(a, c);
                D.init();
                a.onBeforeRender(C, a, c, d);
                xc.multiplyMatrices(c.projectionMatrix, c.matrixWorldInverse);
                oa.setFromMatrix(xc);
                Yd = this.localClippingEnabled;
                pd = aa.init(this.clippingPlanes, Yd, c);
                A = sa.get(a, c);
                A.init();
                k(a, c, C.sortObjects);
                !0 === C.sortObjects && A.sort();
                pd && aa.beginShadows();
                za.render(D.state.shadowsArray, a, c);
                D.setupLights(c);
                pd && aa.endShadows();
                this.info.autoReset && this.info.reset();
                void 0 === d && (d = null);
                this.setRenderTarget(d);
                ka.render(A, a, c, e);
                e = A.opaque;
                var f = A.transparent;
                if (a.overrideMaterial) {
                    var g =
                        a.overrideMaterial;
                    e.length && m(e, a, c, g);
                    f.length && m(f, a, c, g)
                } else e.length && m(e, a, c), f.length && m(f, a, c);
                d && ia.updateRenderTargetMipmap(d);
                ba.buffers.depth.setTest(!0);
                ba.buffers.depth.setMask(!0);
                ba.buffers.color.setMask(!0);
                ba.setPolygonOffset(!1);
                a.onAfterRender(C, a, c);
                ja.enabled && ja.submitFrame();
                D = A = null
            }
        };
        this.allocTextureUnit = function() {
            var a = X;
            a >= ua.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + a + " texture units while this GPU supports only " + ua.maxTextures);
            X += 1;
            return a
        };
        this.setTexture2D = function() {
            var a = !1;
            return function(b, c) {
                b && b.isWebGLRenderTarget && (a || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), a = !0), b = b.texture);
                ia.setTexture2D(b, c)
            }
        }();
        this.setTexture = function() {
            var a = !1;
            return function(b, c) {
                a || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), a = !0);
                ia.setTexture2D(b, c)
            }
        }();
        this.setTextureCube = function() {
            var a = !1;
            return function(b, c) {
                b &&
                    b.isWebGLRenderTargetCube && (a || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), a = !0), b = b.texture);
                b && b.isCubeTexture || Array.isArray(b.image) && 6 === b.image.length ? ia.setTextureCube(b, c) : ia.setTextureCubeDynamic(b, c)
            }
        }();
        this.setFramebuffer = function(a) {
            L = a
        };
        this.getRenderTarget = function() {
            return R
        };
        this.setRenderTarget = function(a) {
            (R = a) && void 0 === Ba.get(a).__webglFramebuffer && ia.setupRenderTarget(a);
            var b = L,
                c = !1;
            a ? (b =
                Ba.get(a).__webglFramebuffer, a.isWebGLRenderTargetCube && (b = b[a.activeCubeFace], c = !0), T.copy(a.viewport), wc.copy(a.scissor), ea = a.scissorTest) : (T.copy(od).multiplyScalar(U), wc.copy(fa).multiplyScalar(U), ea = qa);
            Q !== b && (F.bindFramebuffer(F.FRAMEBUFFER, b), Q = b);
            ba.viewport(T);
            ba.scissor(wc);
            ba.setScissorTest(ea);
            c && (c = Ba.get(a.texture), F.framebufferTexture2D(F.FRAMEBUFFER, F.COLOR_ATTACHMENT0, F.TEXTURE_CUBE_MAP_POSITIVE_X + a.activeCubeFace, c.__webglTexture, a.activeMipMapLevel))
        };
        this.readRenderTargetPixels =
            function(a, b, c, d, e, f) {
                if (a && a.isWebGLRenderTarget) {
                    var g = Ba.get(a).__webglFramebuffer;
                    if (g) {
                        var h = !1;
                        g !== Q && (F.bindFramebuffer(F.FRAMEBUFFER, g), h = !0);
                        try {
                            var k = a.texture,
                                m = k.format,
                                q = k.type;
                            1023 !== m && da.convert(m) !== F.getParameter(F.IMPLEMENTATION_COLOR_READ_FORMAT) ? console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") : 1009 === q || da.convert(q) === F.getParameter(F.IMPLEMENTATION_COLOR_READ_TYPE) || 1015 === q && (ua.isWebGL2 || ha.get("OES_texture_float") ||
                                ha.get("WEBGL_color_buffer_float")) || 1016 === q && (ua.isWebGL2 ? ha.get("EXT_color_buffer_float") : ha.get("EXT_color_buffer_half_float")) ? F.checkFramebufferStatus(F.FRAMEBUFFER) === F.FRAMEBUFFER_COMPLETE ? 0 <= b && b <= a.width - d && 0 <= c && c <= a.height - e && F.readPixels(b, c, d, e, da.convert(m), da.convert(q), f) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") : console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.")
                        } finally {
                            h &&
                                F.bindFramebuffer(F.FRAMEBUFFER, Q)
                        }
                    }
                } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
            };
        this.copyFramebufferToTexture = function(a, b, c) {
            var d = b.image.width,
                e = b.image.height,
                f = da.convert(b.format);
            this.setTexture2D(b, 0);
            F.copyTexImage2D(F.TEXTURE_2D, c || 0, f, a.x, a.y, d, e, 0)
        };
        this.copyTextureToTexture = function(a, b, c, d) {
            var e = b.image.width,
                f = b.image.height,
                g = da.convert(c.format),
                h = da.convert(c.type);
            this.setTexture2D(c, 0);
            b.isDataTexture ? F.texSubImage2D(F.TEXTURE_2D,
                d || 0, a.x, a.y, e, f, g, h, b.image.data) : F.texSubImage2D(F.TEXTURE_2D, d || 0, a.x, a.y, g, h, b.image)
        }
    }

    function Lb(a, b) {
        this.name = "";
        this.color = new G(a);
        this.density = void 0 !== b ? b : 2.5E-4
    }

    function Mb(a, b, c) {
        this.name = "";
        this.color = new G(a);
        this.near = void 0 !== b ? b : 1;
        this.far = void 0 !== c ? c : 1E3
    }

    function qd() {
        D.call(this);
        this.type = "Scene";
        this.overrideMaterial = this.fog = this.background = null;
        this.autoUpdate = !0
    }

    function ob(a, b) {
        this.array = a;
        this.stride = b;
        this.count = void 0 !== a ? a.length / b : 0;
        this.dynamic = !1;
        this.updateRange = {
            offset: 0,
            count: -1
        };
        this.version = 0
    }

    function zc(a, b, c, d) {
        this.data = a;
        this.itemSize = b;
        this.offset = c;
        this.normalized = !0 === d
    }

    function cb(a) {
        J.call(this);
        this.type = "SpriteMaterial";
        this.color = new G(16777215);
        this.map = null;
        this.rotation = 0;
        this.lights = !1;
        this.transparent = !0;
        this.setValues(a)
    }

    function Ac(a) {
        D.call(this);
        this.type = "Sprite";
        if (void 0 === Nb) {
            Nb = new C;
            var b = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]);
            b = new ob(b, 5);
            Nb.setIndex([0, 1, 2, 0, 2, 3]);
            Nb.addAttribute("position",
                new zc(b, 3, 0, !1));
            Nb.addAttribute("uv", new zc(b, 2, 3, !1))
        }
        this.geometry = Nb;
        this.material = void 0 !== a ? a : new cb;
        this.center = new z(.5, .5)
    }

    function Bc() {
        D.call(this);
        this.type = "LOD";
        Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            }
        })
    }

    function Cc(a, b) {
        a = a || [];
        this.bones = a.slice(0);
        this.boneMatrices = new Float32Array(16 * this.bones.length);
        if (void 0 === b) this.calculateInverses();
        else if (this.bones.length === b.length) this.boneInverses = b.slice(0);
        else
            for (console.warn("THREE.Skeleton boneInverses is the wrong length."),
                this.boneInverses = [], a = 0, b = this.bones.length; a < b; a++) this.boneInverses.push(new I)
    }

    function rd() {
        D.call(this);
        this.type = "Bone"
    }

    function sd(a, b) {
        la.call(this, a, b);
        this.type = "SkinnedMesh";
        this.bindMode = "attached";
        this.bindMatrix = new I;
        this.bindMatrixInverse = new I;
        a = this.initBones();
        a = new Cc(a);
        this.bind(a, this.matrixWorld);
        this.normalizeSkinWeights()
    }

    function Y(a) {
        J.call(this);
        this.type = "LineBasicMaterial";
        this.color = new G(16777215);
        this.linewidth = 1;
        this.linejoin = this.linecap = "round";
        this.lights = !1;
        this.setValues(a)
    }

    function sa(a, b, c) {
        1 === c && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.");
        D.call(this);
        this.type = "Line";
        this.geometry = void 0 !== a ? a : new C;
        this.material = void 0 !== b ? b : new Y({
            color: 16777215 * Math.random()
        })
    }

    function W(a, b) {
        sa.call(this, a, b);
        this.type = "LineSegments"
    }

    function td(a, b) {
        sa.call(this, a, b);
        this.type = "LineLoop"
    }

    function Ea(a) {
        J.call(this);
        this.type = "PointsMaterial";
        this.color = new G(16777215);
        this.map = null;
        this.size =
            1;
        this.sizeAttenuation = !0;
        this.lights = this.morphTargets = !1;
        this.setValues(a)
    }

    function Ob(a, b) {
        D.call(this);
        this.type = "Points";
        this.geometry = void 0 !== a ? a : new C;
        this.material = void 0 !== b ? b : new Ea({
            color: 16777215 * Math.random()
        })
    }

    function $d(a, b, c, d, e, f, g, h, k) {
        T.call(this, a, b, c, d, e, f, g, h, k);
        this.generateMipmaps = !1
    }

    function Pb(a, b, c, d, e, f, g, h, k, m, q, n) {
        T.call(this, null, f, g, h, k, m, d, e, q, n);
        this.image = {
            width: b,
            height: c
        };
        this.mipmaps = a;
        this.generateMipmaps = this.flipY = !1
    }

    function Dc(a, b, c, d, e, f, g, h, k) {
        T.call(this,
            a, b, c, d, e, f, g, h, k);
        this.needsUpdate = !0
    }

    function Ec(a, b, c, d, e, f, g, h, k, m) {
        m = void 0 !== m ? m : 1026;
        if (1026 !== m && 1027 !== m) throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === c && 1026 === m && (c = 1012);
        void 0 === c && 1027 === m && (c = 1020);
        T.call(this, null, d, e, f, g, h, m, c, k);
        this.image = {
            width: a,
            height: b
        };
        this.magFilter = void 0 !== g ? g : 1003;
        this.minFilter = void 0 !== h ? h : 1003;
        this.generateMipmaps = this.flipY = !1
    }

    function Qb(a) {
        C.call(this);
        this.type = "WireframeGeometry";
        var b = [],
            c, d, e, f = [0, 0],
            g = {},
            h = ["a", "b", "c"];
        if (a && a.isGeometry) {
            var k = a.faces;
            var m = 0;
            for (d = k.length; m < d; m++) {
                var q = k[m];
                for (c = 0; 3 > c; c++) {
                    var n = q[h[c]];
                    var t = q[h[(c + 1) % 3]];
                    f[0] = Math.min(n, t);
                    f[1] = Math.max(n, t);
                    n = f[0] + "," + f[1];
                    void 0 === g[n] && (g[n] = {
                        index1: f[0],
                        index2: f[1]
                    })
                }
            }
            for (n in g) m = g[n], h = a.vertices[m.index1], b.push(h.x, h.y, h.z), h = a.vertices[m.index2], b.push(h.x, h.y, h.z)
        } else if (a && a.isBufferGeometry)
            if (h = new p, null !== a.index) {
                k = a.attributes.position;
                q = a.index;
                var u = a.groups;
                0 === u.length && (u = [{
                    start: 0,
                    count: q.count,
                    materialIndex: 0
                }]);
                a = 0;
                for (e = u.length; a < e; ++a)
                    for (m = u[a], c = m.start, d = m.count, m = c, d = c + d; m < d; m += 3)
                        for (c = 0; 3 > c; c++) n = q.getX(m + c), t = q.getX(m + (c + 1) % 3), f[0] = Math.min(n, t), f[1] = Math.max(n, t), n = f[0] + "," + f[1], void 0 === g[n] && (g[n] = {
                            index1: f[0],
                            index2: f[1]
                        });
                for (n in g) m = g[n], h.fromBufferAttribute(k, m.index1), b.push(h.x, h.y, h.z), h.fromBufferAttribute(k, m.index2), b.push(h.x, h.y, h.z)
            } else
                for (k = a.attributes.position, m = 0, d = k.count / 3; m < d; m++)
                    for (c = 0; 3 > c; c++) g = 3 * m + c, h.fromBufferAttribute(k, g), b.push(h.x,
                        h.y, h.z), g = 3 * m + (c + 1) % 3, h.fromBufferAttribute(k, g), b.push(h.x, h.y, h.z);
        this.addAttribute("position", new A(b, 3))
    }

    function Fc(a, b, c) {
        R.call(this);
        this.type = "ParametricGeometry";
        this.parameters = {
            func: a,
            slices: b,
            stacks: c
        };
        this.fromBufferGeometry(new Rb(a, b, c));
        this.mergeVertices()
    }

    function Rb(a, b, c) {
        C.call(this);
        this.type = "ParametricBufferGeometry";
        this.parameters = {
            func: a,
            slices: b,
            stacks: c
        };
        var d = [],
            e = [],
            f = [],
            g = [],
            h = new p,
            k = new p,
            m = new p,
            q = new p,
            n = new p,
            t, u;
        3 > a.length && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
        var r = b + 1;
        for (t = 0; t <= c; t++) {
            var l = t / c;
            for (u = 0; u <= b; u++) {
                var y = u / b;
                a(y, l, k);
                e.push(k.x, k.y, k.z);
                0 <= y - 1E-5 ? (a(y - 1E-5, l, m), q.subVectors(k, m)) : (a(y + 1E-5, l, m), q.subVectors(m, k));
                0 <= l - 1E-5 ? (a(y, l - 1E-5, m), n.subVectors(k, m)) : (a(y, l + 1E-5, m), n.subVectors(m, k));
                h.crossVectors(q, n).normalize();
                f.push(h.x, h.y, h.z);
                g.push(y, l)
            }
        }
        for (t = 0; t < c; t++)
            for (u = 0; u < b; u++) a = t * r + u + 1, h = (t + 1) * r + u + 1, k = (t + 1) * r + u, d.push(t * r + u, a, k), d.push(a, h, k);
        this.setIndex(d);
        this.addAttribute("position", new A(e, 3));
        this.addAttribute("normal",
            new A(f, 3));
        this.addAttribute("uv", new A(g, 2))
    }

    function Gc(a, b, c, d) {
        R.call(this);
        this.type = "PolyhedronGeometry";
        this.parameters = {
            vertices: a,
            indices: b,
            radius: c,
            detail: d
        };
        this.fromBufferGeometry(new na(a, b, c, d));
        this.mergeVertices()
    }

    function na(a, b, c, d) {
        function e(a) {
            h.push(a.x, a.y, a.z)
        }

        function f(b, c) {
            b *= 3;
            c.x = a[b + 0];
            c.y = a[b + 1];
            c.z = a[b + 2]
        }

        function g(a, b, c, d) {
            0 > d && 1 === a.x && (k[b] = a.x - 1);
            0 === c.x && 0 === c.z && (k[b] = d / 2 / Math.PI + .5)
        }
        C.call(this);
        this.type = "PolyhedronBufferGeometry";
        this.parameters = {
            vertices: a,
            indices: b,
            radius: c,
            detail: d
        };
        c = c || 1;
        d = d || 0;
        var h = [],
            k = [];
        (function(a) {
            for (var c = new p, d = new p, g = new p, h = 0; h < b.length; h += 3) {
                f(b[h + 0], c);
                f(b[h + 1], d);
                f(b[h + 2], g);
                var k, m, l = c,
                    x = d,
                    w = g,
                    B = Math.pow(2, a),
                    E = [];
                for (m = 0; m <= B; m++) {
                    E[m] = [];
                    var P = l.clone().lerp(w, m / B),
                        N = x.clone().lerp(w, m / B),
                        O = B - m;
                    for (k = 0; k <= O; k++) E[m][k] = 0 === k && m === B ? P : P.clone().lerp(N, k / O)
                }
                for (m = 0; m < B; m++)
                    for (k = 0; k < 2 * (B - m) - 1; k++) l = Math.floor(k / 2), 0 === k % 2 ? (e(E[m][l + 1]), e(E[m + 1][l]), e(E[m][l])) : (e(E[m][l + 1]), e(E[m + 1][l + 1]), e(E[m + 1][l]))
            }
        })(d);
        (function(a) {
            for (var b =
                    new p, c = 0; c < h.length; c += 3) b.x = h[c + 0], b.y = h[c + 1], b.z = h[c + 2], b.normalize().multiplyScalar(a), h[c + 0] = b.x, h[c + 1] = b.y, h[c + 2] = b.z
        })(c);
        (function() {
            for (var a = new p, b = 0; b < h.length; b += 3) a.x = h[b + 0], a.y = h[b + 1], a.z = h[b + 2], k.push(Math.atan2(a.z, -a.x) / 2 / Math.PI + .5, 1 - (Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + .5));
            a = new p;
            b = new p;
            for (var c = new p, d = new p, e = new z, f = new z, l = new z, y = 0, x = 0; y < h.length; y += 9, x += 6) {
                a.set(h[y + 0], h[y + 1], h[y + 2]);
                b.set(h[y + 3], h[y + 4], h[y + 5]);
                c.set(h[y + 6], h[y + 7], h[y + 8]);
                e.set(k[x + 0],
                    k[x + 1]);
                f.set(k[x + 2], k[x + 3]);
                l.set(k[x + 4], k[x + 5]);
                d.copy(a).add(b).add(c).divideScalar(3);
                var w = Math.atan2(d.z, -d.x);
                g(e, x + 0, a, w);
                g(f, x + 2, b, w);
                g(l, x + 4, c, w)
            }
            for (a = 0; a < k.length; a += 6) b = k[a + 0], c = k[a + 2], d = k[a + 4], e = Math.min(b, c, d), .9 < Math.max(b, c, d) && .1 > e && (.2 > b && (k[a + 0] += 1), .2 > c && (k[a + 2] += 1), .2 > d && (k[a + 4] += 1))
        })();
        this.addAttribute("position", new A(h, 3));
        this.addAttribute("normal", new A(h.slice(), 3));
        this.addAttribute("uv", new A(k, 2));
        0 === d ? this.computeVertexNormals() : this.normalizeNormals()
    }

    function Hc(a,
        b) {
        R.call(this);
        this.type = "TetrahedronGeometry";
        this.parameters = {
            radius: a,
            detail: b
        };
        this.fromBufferGeometry(new Sb(a, b));
        this.mergeVertices()
    }

    function Sb(a, b) {
        na.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], a, b);
        this.type = "TetrahedronBufferGeometry";
        this.parameters = {
            radius: a,
            detail: b
        }
    }

    function Ic(a, b) {
        R.call(this);
        this.type = "OctahedronGeometry";
        this.parameters = {
            radius: a,
            detail: b
        };
        this.fromBufferGeometry(new pb(a, b));
        this.mergeVertices()
    }

    function pb(a, b) {
        na.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], a, b);
        this.type = "OctahedronBufferGeometry";
        this.parameters = {
            radius: a,
            detail: b
        }
    }

    function Jc(a, b) {
        R.call(this);
        this.type = "IcosahedronGeometry";
        this.parameters = {
            radius: a,
            detail: b
        };
        this.fromBufferGeometry(new Tb(a, b));
        this.mergeVertices()
    }

    function Tb(a, b) {
        var c = (1 + Math.sqrt(5)) / 2;
        na.call(this, [-1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, 0, 0, -1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, c, 0, -1, c, 0, 1, -c, 0, -1, -c, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5,
            11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1
        ], a, b);
        this.type = "IcosahedronBufferGeometry";
        this.parameters = {
            radius: a,
            detail: b
        }
    }

    function Kc(a, b) {
        R.call(this);
        this.type = "DodecahedronGeometry";
        this.parameters = {
            radius: a,
            detail: b
        };
        this.fromBufferGeometry(new Ub(a, b));
        this.mergeVertices()
    }

    function Ub(a, b) {
        var c = (1 + Math.sqrt(5)) / 2,
            d = 1 / c;
        na.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, -d, -c, 0, -d, c, 0, d, -c, 0, d, c,
            0, -c, 0, -d, c, 0, -d, -c, 0, d, c, 0, d
        ], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], a, b);
        this.type = "DodecahedronBufferGeometry";
        this.parameters = {
            radius: a,
            detail: b
        }
    }

    function Lc(a, b, c, d, e, f) {
        R.call(this);
        this.type = "TubeGeometry";
        this.parameters = {
            path: a,
            tubularSegments: b,
            radius: c,
            radialSegments: d,
            closed: e
        };
        void 0 !== f && console.warn("THREE.TubeGeometry: taper has been removed.");
        a = new Vb(a, b, c, d, e);
        this.tangents = a.tangents;
        this.normals = a.normals;
        this.binormals = a.binormals;
        this.fromBufferGeometry(a);
        this.mergeVertices()
    }

    function Vb(a, b, c, d, e) {
        function f(e) {
            q = a.getPointAt(e / b, q);
            var f = g.normals[e];
            e = g.binormals[e];
            for (t = 0; t <= d; t++) {
                var m = t / d * Math.PI * 2,
                    n = Math.sin(m);
                m = -Math.cos(m);
                k.x = m * f.x + n * e.x;
                k.y = m * f.y + n * e.y;
                k.z = m * f.z + n * e.z;
                k.normalize();
                r.push(k.x, k.y, k.z);
                h.x = q.x + c * k.x;
                h.y = q.y + c * k.y;
                h.z =
                    q.z + c * k.z;
                l.push(h.x, h.y, h.z)
            }
        }
        C.call(this);
        this.type = "TubeBufferGeometry";
        this.parameters = {
            path: a,
            tubularSegments: b,
            radius: c,
            radialSegments: d,
            closed: e
        };
        b = b || 64;
        c = c || 1;
        d = d || 8;
        e = e || !1;
        var g = a.computeFrenetFrames(b, e);
        this.tangents = g.tangents;
        this.normals = g.normals;
        this.binormals = g.binormals;
        var h = new p,
            k = new p,
            m = new z,
            q = new p,
            n, t, l = [],
            r = [],
            v = [],
            y = [];
        for (n = 0; n < b; n++) f(n);
        f(!1 === e ? b : 0);
        for (n = 0; n <= b; n++)
            for (t = 0; t <= d; t++) m.x = n / b, m.y = t / d, v.push(m.x, m.y);
        (function() {
            for (t = 1; t <= b; t++)
                for (n = 1; n <= d; n++) {
                    var a =
                        (d + 1) * t + (n - 1),
                        c = (d + 1) * t + n,
                        e = (d + 1) * (t - 1) + n;
                    y.push((d + 1) * (t - 1) + (n - 1), a, e);
                    y.push(a, c, e)
                }
        })();
        this.setIndex(y);
        this.addAttribute("position", new A(l, 3));
        this.addAttribute("normal", new A(r, 3));
        this.addAttribute("uv", new A(v, 2))
    }

    function Mc(a, b, c, d, e, f, g) {
        R.call(this);
        this.type = "TorusKnotGeometry";
        this.parameters = {
            radius: a,
            tube: b,
            tubularSegments: c,
            radialSegments: d,
            p: e,
            q: f
        };
        void 0 !== g && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.");
        this.fromBufferGeometry(new Wb(a,
            b, c, d, e, f));
        this.mergeVertices()
    }

    function Wb(a, b, c, d, e, f) {
        function g(a, b, c, d, e) {
            var f = Math.sin(a);
            b = c / b * a;
            c = Math.cos(b);
            e.x = d * (2 + c) * .5 * Math.cos(a);
            e.y = d * (2 + c) * f * .5;
            e.z = d * Math.sin(b) * .5
        }
        C.call(this);
        this.type = "TorusKnotBufferGeometry";
        this.parameters = {
            radius: a,
            tube: b,
            tubularSegments: c,
            radialSegments: d,
            p: e,
            q: f
        };
        a = a || 1;
        b = b || .4;
        c = Math.floor(c) || 64;
        d = Math.floor(d) || 8;
        e = e || 2;
        f = f || 3;
        var h = [],
            k = [],
            m = [],
            q = [],
            n, t = new p,
            l = new p,
            r = new p,
            v = new p,
            y = new p,
            x = new p,
            w = new p;
        for (n = 0; n <= c; ++n) {
            var B = n / c * e * Math.PI * 2;
            g(B, e, f, a, r);
            g(B + .01, e, f, a, v);
            x.subVectors(v, r);
            w.addVectors(v, r);
            y.crossVectors(x, w);
            w.crossVectors(y, x);
            y.normalize();
            w.normalize();
            for (B = 0; B <= d; ++B) {
                var E = B / d * Math.PI * 2,
                    P = -b * Math.cos(E);
                E = b * Math.sin(E);
                t.x = r.x + (P * w.x + E * y.x);
                t.y = r.y + (P * w.y + E * y.y);
                t.z = r.z + (P * w.z + E * y.z);
                k.push(t.x, t.y, t.z);
                l.subVectors(t, r).normalize();
                m.push(l.x, l.y, l.z);
                q.push(n / c);
                q.push(B / d)
            }
        }
        for (B = 1; B <= c; B++)
            for (n = 1; n <= d; n++) a = (d + 1) * B + (n - 1), b = (d + 1) * B + n, e = (d + 1) * (B - 1) + n, h.push((d + 1) * (B - 1) + (n - 1), a, e), h.push(a, b, e);
        this.setIndex(h);
        this.addAttribute("position", new A(k, 3));
        this.addAttribute("normal", new A(m, 3));
        this.addAttribute("uv", new A(q, 2))
    }

    function Nc(a, b, c, d, e) {
        R.call(this);
        this.type = "TorusGeometry";
        this.parameters = {
            radius: a,
            tube: b,
            radialSegments: c,
            tubularSegments: d,
            arc: e
        };
        this.fromBufferGeometry(new Xb(a, b, c, d, e));
        this.mergeVertices()
    }

    function Xb(a, b, c, d, e) {
        C.call(this);
        this.type = "TorusBufferGeometry";
        this.parameters = {
            radius: a,
            tube: b,
            radialSegments: c,
            tubularSegments: d,
            arc: e
        };
        a = a || 1;
        b = b || .4;
        c = Math.floor(c) || 8;
        d = Math.floor(d) ||
            6;
        e = e || 2 * Math.PI;
        var f = [],
            g = [],
            h = [],
            k = [],
            m = new p,
            q = new p,
            n = new p,
            t, l;
        for (t = 0; t <= c; t++)
            for (l = 0; l <= d; l++) {
                var r = l / d * e,
                    v = t / c * Math.PI * 2;
                q.x = (a + b * Math.cos(v)) * Math.cos(r);
                q.y = (a + b * Math.cos(v)) * Math.sin(r);
                q.z = b * Math.sin(v);
                g.push(q.x, q.y, q.z);
                m.x = a * Math.cos(r);
                m.y = a * Math.sin(r);
                n.subVectors(q, m).normalize();
                h.push(n.x, n.y, n.z);
                k.push(l / d);
                k.push(t / c)
            }
        for (t = 1; t <= c; t++)
            for (l = 1; l <= d; l++) a = (d + 1) * (t - 1) + l - 1, b = (d + 1) * (t - 1) + l, e = (d + 1) * t + l, f.push((d + 1) * t + l - 1, a, e), f.push(a, b, e);
        this.setIndex(f);
        this.addAttribute("position",
            new A(g, 3));
        this.addAttribute("normal", new A(h, 3));
        this.addAttribute("uv", new A(k, 2))
    }

    function bf(a, b, c, d, e) {
        for (var f, g = 0, h = b, k = c - d; h < c; h += d) g += (a[k] - a[h]) * (a[h + 1] + a[k + 1]), k = h;
        if (e === 0 < g)
            for (e = b; e < c; e += d) f = cf(e, a[e], a[e + 1], f);
        else
            for (e = c - d; e >= b; e -= d) f = cf(e, a[e], a[e + 1], f);
        f && qb(f, f.next) && (Oc(f), f = f.next);
        return f
    }

    function Pc(a, b) {
        if (!a) return a;
        b || (b = a);
        do {
            var c = !1;
            if (a.steiner || !qb(a, a.next) && 0 !== ma(a.prev, a, a.next)) a = a.next;
            else {
                Oc(a);
                a = b = a.prev;
                if (a === a.next) break;
                c = !0
            }
        } while (c || a !== b);
        return b
    }

    function Qc(a, b, c, d, e, f, g) {
        if (a) {
            if (!g && f) {
                var h = a,
                    k = h;
                do null === k.z && (k.z = ae(k.x, k.y, d, e, f)), k.prevZ = k.prev, k = k.nextZ = k.next; while (k !== h);
                k.prevZ.nextZ = null;
                k.prevZ = null;
                h = k;
                var m, q, n, t, l = 1;
                do {
                    k = h;
                    var r = h = null;
                    for (q = 0; k;) {
                        q++;
                        var v = k;
                        for (m = n = 0; m < l && (n++, v = v.nextZ, v); m++);
                        for (t = l; 0 < n || 0 < t && v;) 0 !== n && (0 === t || !v || k.z <= v.z) ? (m = k, k = k.nextZ, n--) : (m = v, v = v.nextZ, t--), r ? r.nextZ = m : h = m, m.prevZ = r, r = m;
                        k = v
                    }
                    r.nextZ = null;
                    l *= 2
                } while (1 < q)
            }
            for (h = a; a.prev !== a.next;) {
                k = a.prev;
                v = a.next;
                if (f) a: {
                    r = a;
                    t = d;
                    var p = e,
                        x = f;
                    q = r.prev;
                    n = r;
                    l = r.next;
                    if (0 <= ma(q, n, l)) r = !1;
                    else {
                        var w = q.x > n.x ? q.x > l.x ? q.x : l.x : n.x > l.x ? n.x : l.x,
                            B = q.y > n.y ? q.y > l.y ? q.y : l.y : n.y > l.y ? n.y : l.y;
                        m = ae(q.x < n.x ? q.x < l.x ? q.x : l.x : n.x < l.x ? n.x : l.x, q.y < n.y ? q.y < l.y ? q.y : l.y : n.y < l.y ? n.y : l.y, t, p, x);
                        t = ae(w, B, t, p, x);
                        for (p = r.nextZ; p && p.z <= t;) {
                            if (p !== r.prev && p !== r.next && ud(q.x, q.y, n.x, n.y, l.x, l.y, p.x, p.y) && 0 <= ma(p.prev, p, p.next)) {
                                r = !1;
                                break a
                            }
                            p = p.nextZ
                        }
                        for (p = r.prevZ; p && p.z >= m;) {
                            if (p !== r.prev && p !== r.next && ud(q.x, q.y, n.x, n.y, l.x, l.y, p.x, p.y) && 0 <= ma(p.prev, p, p.next)) {
                                r = !1;
                                break a
                            }
                            p =
                                p.prevZ
                        }
                        r = !0
                    }
                } else a: if (r = a, q = r.prev, n = r, l = r.next, 0 <= ma(q, n, l)) r = !1;
                    else {
                        for (m = r.next.next; m !== r.prev;) {
                            if (ud(q.x, q.y, n.x, n.y, l.x, l.y, m.x, m.y) && 0 <= ma(m.prev, m, m.next)) {
                                r = !1;
                                break a
                            }
                            m = m.next
                        }
                        r = !0
                    }
                if (r) b.push(k.i / c), b.push(a.i / c), b.push(v.i / c), Oc(a), h = a = v.next;
                else if (a = v, a === h) {
                    if (!g) Qc(Pc(a), b, c, d, e, f, 1);
                    else if (1 === g) {
                        g = b;
                        h = c;
                        k = a;
                        do v = k.prev, r = k.next.next, !qb(v, r) && df(v, k, k.next, r) && Rc(v, r) && Rc(r, v) && (g.push(v.i / h), g.push(k.i / h), g.push(r.i / h), Oc(k), Oc(k.next), k = a = r), k = k.next; while (k !== a);
                        a = k;
                        Qc(a,
                            b, c, d, e, f, 2)
                    } else if (2 === g) a: {
                        g = a;
                        do {
                            for (h = g.next.next; h !== g.prev;) {
                                if (k = g.i !== h.i) {
                                    k = g;
                                    v = h;
                                    if (r = k.next.i !== v.i && k.prev.i !== v.i) {
                                        b: {
                                            r = k;
                                            do {
                                                if (r.i !== k.i && r.next.i !== k.i && r.i !== v.i && r.next.i !== v.i && df(r, r.next, k, v)) {
                                                    r = !0;
                                                    break b
                                                }
                                                r = r.next
                                            } while (r !== k);
                                            r = !1
                                        }
                                        r = !r
                                    }
                                    if (r = r && Rc(k, v) && Rc(v, k)) {
                                        r = k;
                                        q = !1;
                                        n = (k.x + v.x) / 2;
                                        v = (k.y + v.y) / 2;
                                        do r.y > v !== r.next.y > v && r.next.y !== r.y && n < (r.next.x - r.x) * (v - r.y) / (r.next.y - r.y) + r.x && (q = !q), r = r.next; while (r !== k);
                                        r = q
                                    }
                                    k = r
                                }
                                if (k) {
                                    a = ef(g, h);
                                    g = Pc(g, g.next);
                                    a = Pc(a, a.next);
                                    Qc(g, b, c, d, e,
                                        f);
                                    Qc(a, b, c, d, e, f);
                                    break a
                                }
                                h = h.next
                            }
                            g = g.next
                        } while (g !== a)
                    }
                    break
                }
            }
        }
    }

    function Ng(a, b) {
        return a.x - b.x
    }

    function Og(a, b) {
        var c = b,
            d = a.x,
            e = a.y,
            f = -Infinity;
        do {
            if (e <= c.y && e >= c.next.y && c.next.y !== c.y) {
                var g = c.x + (e - c.y) * (c.next.x - c.x) / (c.next.y - c.y);
                if (g <= d && g > f) {
                    f = g;
                    if (g === d) {
                        if (e === c.y) return c;
                        if (e === c.next.y) return c.next
                    }
                    var h = c.x < c.next.x ? c : c.next
                }
            }
            c = c.next
        } while (c !== b);
        if (!h) return null;
        if (d === f) return h.prev;
        b = h;
        g = h.x;
        var k = h.y,
            m = Infinity;
        for (c = h.next; c !== b;) {
            if (d >= c.x && c.x >= g && d !== c.x && ud(e < k ? d : f, e,
                    g, k, e < k ? f : d, e, c.x, c.y)) {
                var q = Math.abs(e - c.y) / (d - c.x);
                (q < m || q === m && c.x > h.x) && Rc(c, a) && (h = c, m = q)
            }
            c = c.next
        }
        return h
    }

    function ae(a, b, c, d, e) {
        a = 32767 * (a - c) * e;
        b = 32767 * (b - d) * e;
        a = (a | a << 8) & 16711935;
        a = (a | a << 4) & 252645135;
        a = (a | a << 2) & 858993459;
        b = (b | b << 8) & 16711935;
        b = (b | b << 4) & 252645135;
        b = (b | b << 2) & 858993459;
        return (a | a << 1) & 1431655765 | ((b | b << 1) & 1431655765) << 1
    }

    function Pg(a) {
        var b = a,
            c = a;
        do b.x < c.x && (c = b), b = b.next; while (b !== a);
        return c
    }

    function ud(a, b, c, d, e, f, g, h) {
        return 0 <= (e - g) * (b - h) - (a - g) * (f - h) && 0 <= (a - g) * (d - h) - (c -
            g) * (b - h) && 0 <= (c - g) * (f - h) - (e - g) * (d - h)
    }

    function ma(a, b, c) {
        return (b.y - a.y) * (c.x - b.x) - (b.x - a.x) * (c.y - b.y)
    }

    function qb(a, b) {
        return a.x === b.x && a.y === b.y
    }

    function df(a, b, c, d) {
        return qb(a, b) && qb(c, d) || qb(a, d) && qb(c, b) ? !0 : 0 < ma(a, b, c) !== 0 < ma(a, b, d) && 0 < ma(c, d, a) !== 0 < ma(c, d, b)
    }

    function Rc(a, b) {
        return 0 > ma(a.prev, a, a.next) ? 0 <= ma(a, b, a.next) && 0 <= ma(a, a.prev, b) : 0 > ma(a, b, a.prev) || 0 > ma(a, a.next, b)
    }

    function ef(a, b) {
        var c = new be(a.i, a.x, a.y),
            d = new be(b.i, b.x, b.y),
            e = a.next,
            f = b.prev;
        a.next = b;
        b.prev = a;
        c.next = e;
        e.prev =
            c;
        d.next = c;
        c.prev = d;
        f.next = d;
        d.prev = f;
        return d
    }

    function cf(a, b, c, d) {
        a = new be(a, b, c);
        d ? (a.next = d.next, a.prev = d, d.next.prev = a, d.next = a) : (a.prev = a, a.next = a);
        return a
    }

    function Oc(a) {
        a.next.prev = a.prev;
        a.prev.next = a.next;
        a.prevZ && (a.prevZ.nextZ = a.nextZ);
        a.nextZ && (a.nextZ.prevZ = a.prevZ)
    }

    function be(a, b, c) {
        this.i = a;
        this.x = b;
        this.y = c;
        this.nextZ = this.prevZ = this.z = this.next = this.prev = null;
        this.steiner = !1
    }

    function ff(a) {
        var b = a.length;
        2 < b && a[b - 1].equals(a[0]) && a.pop()
    }

    function gf(a, b) {
        for (var c = 0; c < b.length; c++) a.push(b[c].x),
            a.push(b[c].y)
    }

    function rb(a, b) {
        R.call(this);
        this.type = "ExtrudeGeometry";
        this.parameters = {
            shapes: a,
            options: b
        };
        this.fromBufferGeometry(new Oa(a, b));
        this.mergeVertices()
    }

    function Oa(a, b) {
        function c(a) {
            function c(a, b, c) {
                b || console.error("THREE.ExtrudeGeometry: vec does not exist");
                return b.clone().multiplyScalar(c).add(a)
            }

            function g(a, b, c) {
                var d = a.x - b.x;
                var e = a.y - b.y;
                var f = c.x - a.x;
                var g = c.y - a.y,
                    h = d * d + e * e;
                if (Math.abs(d * g - e * f) > Number.EPSILON) {
                    var k = Math.sqrt(h),
                        m = Math.sqrt(f * f + g * g);
                    h = b.x - e / k;
                    b = b.y + d / k;
                    g = ((c.x - g / m - h) * g - (c.y + f / m - b) * f) / (d * g - e * f);
                    f = h + d * g - a.x;
                    d = b + e * g - a.y;
                    e = f * f + d * d;
                    if (2 >= e) return new z(f, d);
                    e = Math.sqrt(e / 2)
                } else a = !1, d > Number.EPSILON ? f > Number.EPSILON && (a = !0) : d < -Number.EPSILON ? f < -Number.EPSILON && (a = !0) : Math.sign(e) === Math.sign(g) && (a = !0), a ? (f = -e, e = Math.sqrt(h)) : (f = d, d = e, e = Math.sqrt(h / 2));
                return new z(f / e, d / e)
            }

            function h(a, b) {
                for (M = a.length; 0 <= --M;) {
                    var c = M;
                    var f = M - 1;
                    0 > f && (f = a.length - 1);
                    var g, h = w + 2 * O;
                    for (g = 0; g < h; g++) {
                        var k = Z * g,
                            m = Z * (g + 1),
                            q = b + f + k,
                            n = b + f + m;
                        m = b + c + m;
                        r(b + c + k);
                        r(q);
                        r(m);
                        r(q);
                        r(n);
                        r(m);
                        k = e.length / 3;
                        k = D.generateSideWallUV(d, e, k - 6, k - 3, k - 2, k - 1);
                        v(k[0]);
                        v(k[1]);
                        v(k[3]);
                        v(k[1]);
                        v(k[2]);
                        v(k[3])
                    }
                }
            }

            function k(a, b, c) {
                y.push(a);
                y.push(b);
                y.push(c)
            }

            function l(a, b, c) {
                r(a);
                r(b);
                r(c);
                a = e.length / 3;
                a = D.generateTopUV(d, e, a - 3, a - 2, a - 1);
                v(a[0]);
                v(a[1]);
                v(a[2])
            }

            function r(a) {
                e.push(y[3 * a]);
                e.push(y[3 * a + 1]);
                e.push(y[3 * a + 2])
            }

            function v(a) {
                f.push(a.x);
                f.push(a.y)
            }
            var y = [],
                x = void 0 !== b.curveSegments ? b.curveSegments : 12,
                w = void 0 !== b.steps ? b.steps : 1,
                B = void 0 !== b.depth ? b.depth : 100,
                E = void 0 !== b.bevelEnabled ?
                b.bevelEnabled : !0,
                P = void 0 !== b.bevelThickness ? b.bevelThickness : 6,
                N = void 0 !== b.bevelSize ? b.bevelSize : P - 2,
                O = void 0 !== b.bevelSegments ? b.bevelSegments : 3,
                A = b.extrudePath,
                D = void 0 !== b.UVGenerator ? b.UVGenerator : Qg;
            void 0 !== b.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), B = b.amount);
            var C = !1;
            if (A) {
                var G = A.getSpacedPoints(w);
                C = !0;
                E = !1;
                var K = A.computeFrenetFrames(w, !1);
                var L = new p;
                var R = new p;
                var Q = new p
            }
            E || (N = P = O = 0);
            var I;
            x = a.extractPoints(x);
            a = x.shape;
            var J = x.holes;
            if (!Va.isClockWise(a)) {
                a = a.reverse();
                var H = 0;
                for (I = J.length; H < I; H++) {
                    var S = J[H];
                    Va.isClockWise(S) && (J[H] = S.reverse())
                }
            }
            var Y = Va.triangulateShape(a, J),
                W = a;
            H = 0;
            for (I = J.length; H < I; H++) S = J[H], a = a.concat(S);
            var T, Z = a.length,
                V, ea = Y.length;
            x = [];
            var M = 0;
            var U = W.length;
            var X = U - 1;
            for (T = M + 1; M < U; M++, X++, T++) X === U && (X = 0), T === U && (T = 0), x[M] = g(W[M], W[X], W[T]);
            A = [];
            var fa = x.concat();
            H = 0;
            for (I = J.length; H < I; H++) {
                S = J[H];
                var ca = [];
                M = 0;
                U = S.length;
                X = U - 1;
                for (T = M + 1; M < U; M++, X++, T++) X === U && (X = 0), T === U && (T = 0), ca[M] = g(S[M], S[X],
                    S[T]);
                A.push(ca);
                fa = fa.concat(ca)
            }
            for (X = 0; X < O; X++) {
                U = X / O;
                var da = P * Math.cos(U * Math.PI / 2);
                T = N * Math.sin(U * Math.PI / 2);
                M = 0;
                for (U = W.length; M < U; M++) {
                    var aa = c(W[M], x[M], T);
                    k(aa.x, aa.y, -da)
                }
                H = 0;
                for (I = J.length; H < I; H++)
                    for (S = J[H], ca = A[H], M = 0, U = S.length; M < U; M++) aa = c(S[M], ca[M], T), k(aa.x, aa.y, -da)
            }
            T = N;
            for (M = 0; M < Z; M++) aa = E ? c(a[M], fa[M], T) : a[M], C ? (R.copy(K.normals[0]).multiplyScalar(aa.x), L.copy(K.binormals[0]).multiplyScalar(aa.y), Q.copy(G[0]).add(R).add(L), k(Q.x, Q.y, Q.z)) : k(aa.x, aa.y, 0);
            for (U = 1; U <= w; U++)
                for (M =
                    0; M < Z; M++) aa = E ? c(a[M], fa[M], T) : a[M], C ? (R.copy(K.normals[U]).multiplyScalar(aa.x), L.copy(K.binormals[U]).multiplyScalar(aa.y), Q.copy(G[U]).add(R).add(L), k(Q.x, Q.y, Q.z)) : k(aa.x, aa.y, B / w * U);
            for (X = O - 1; 0 <= X; X--) {
                U = X / O;
                da = P * Math.cos(U * Math.PI / 2);
                T = N * Math.sin(U * Math.PI / 2);
                M = 0;
                for (U = W.length; M < U; M++) aa = c(W[M], x[M], T), k(aa.x, aa.y, B + da);
                H = 0;
                for (I = J.length; H < I; H++)
                    for (S = J[H], ca = A[H], M = 0, U = S.length; M < U; M++) aa = c(S[M], ca[M], T), C ? k(aa.x, aa.y + G[w - 1].y, G[w - 1].x + da) : k(aa.x, aa.y, B + da)
            }(function() {
                var a = e.length / 3;
                if (E) {
                    var b =
                        0 * Z;
                    for (M = 0; M < ea; M++) V = Y[M], l(V[2] + b, V[1] + b, V[0] + b);
                    b = Z * (w + 2 * O);
                    for (M = 0; M < ea; M++) V = Y[M], l(V[0] + b, V[1] + b, V[2] + b)
                } else {
                    for (M = 0; M < ea; M++) V = Y[M], l(V[2], V[1], V[0]);
                    for (M = 0; M < ea; M++) V = Y[M], l(V[0] + Z * w, V[1] + Z * w, V[2] + Z * w)
                }
                d.addGroup(a, e.length / 3 - a, 0)
            })();
            (function() {
                var a = e.length / 3,
                    b = 0;
                h(W, b);
                b += W.length;
                H = 0;
                for (I = J.length; H < I; H++) S = J[H], h(S, b), b += S.length;
                d.addGroup(a, e.length / 3 - a, 1)
            })()
        }
        C.call(this);
        this.type = "ExtrudeBufferGeometry";
        this.parameters = {
            shapes: a,
            options: b
        };
        a = Array.isArray(a) ? a : [a];
        for (var d =
                this, e = [], f = [], g = 0, h = a.length; g < h; g++) c(a[g]);
        this.addAttribute("position", new A(e, 3));
        this.addAttribute("uv", new A(f, 2));
        this.computeVertexNormals()
    }

    function hf(a, b, c) {
        c.shapes = [];
        if (Array.isArray(a))
            for (var d = 0, e = a.length; d < e; d++) c.shapes.push(a[d].uuid);
        else c.shapes.push(a.uuid);
        void 0 !== b.extrudePath && (c.options.extrudePath = b.extrudePath.toJSON());
        return c
    }

    function Sc(a, b) {
        R.call(this);
        this.type = "TextGeometry";
        this.parameters = {
            text: a,
            parameters: b
        };
        this.fromBufferGeometry(new Yb(a, b));
        this.mergeVertices()
    }

    function Yb(a, b) {
        b = b || {};
        var c = b.font;
        if (!c || !c.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new R;
        a = c.generateShapes(a, b.size);
        b.depth = void 0 !== b.height ? b.height : 50;
        void 0 === b.bevelThickness && (b.bevelThickness = 10);
        void 0 === b.bevelSize && (b.bevelSize = 8);
        void 0 === b.bevelEnabled && (b.bevelEnabled = !1);
        Oa.call(this, a, b);
        this.type = "TextBufferGeometry"
    }

    function Tc(a, b, c, d, e, f, g) {
        R.call(this);
        this.type = "SphereGeometry";
        this.parameters = {
            radius: a,
            widthSegments: b,
            heightSegments: c,
            phiStart: d,
            phiLength: e,
            thetaStart: f,
            thetaLength: g
        };
        this.fromBufferGeometry(new sb(a, b, c, d, e, f, g));
        this.mergeVertices()
    }

    function sb(a, b, c, d, e, f, g) {
        C.call(this);
        this.type = "SphereBufferGeometry";
        this.parameters = {
            radius: a,
            widthSegments: b,
            heightSegments: c,
            phiStart: d,
            phiLength: e,
            thetaStart: f,
            thetaLength: g
        };
        a = a || 1;
        b = Math.max(3, Math.floor(b) || 8);
        c = Math.max(2, Math.floor(c) || 6);
        d = void 0 !== d ? d : 0;
        e = void 0 !== e ? e : 2 * Math.PI;
        f = void 0 !== f ? f : 0;
        g = void 0 !== g ? g : Math.PI;
        var h = f + g,
            k, m, q = 0,
            n = [],
            l = new p,
            u = new p,
            r = [],
            v = [],
            y = [],
            x = [];
        for (m = 0; m <= c; m++) {
            var w = [],
                B = m / c;
            for (k = 0; k <= b; k++) {
                var E = k / b;
                l.x = -a * Math.cos(d + E * e) * Math.sin(f + B * g);
                l.y = a * Math.cos(f + B * g);
                l.z = a * Math.sin(d + E * e) * Math.sin(f + B * g);
                v.push(l.x, l.y, l.z);
                u.set(l.x, l.y, l.z).normalize();
                y.push(u.x, u.y, u.z);
                x.push(E, 1 - B);
                w.push(q++)
            }
            n.push(w)
        }
        for (m = 0; m < c; m++)
            for (k = 0; k < b; k++) a = n[m][k + 1], d = n[m][k], e = n[m + 1][k], g = n[m + 1][k + 1], (0 !== m || 0 < f) && r.push(a, d, g), (m !== c - 1 || h < Math.PI) && r.push(d, e, g);
        this.setIndex(r);
        this.addAttribute("position", new A(v, 3));
        this.addAttribute("normal",
            new A(y, 3));
        this.addAttribute("uv", new A(x, 2))
    }

    function Uc(a, b, c, d, e, f) {
        R.call(this);
        this.type = "RingGeometry";
        this.parameters = {
            innerRadius: a,
            outerRadius: b,
            thetaSegments: c,
            phiSegments: d,
            thetaStart: e,
            thetaLength: f
        };
        this.fromBufferGeometry(new Zb(a, b, c, d, e, f));
        this.mergeVertices()
    }

    function Zb(a, b, c, d, e, f) {
        C.call(this);
        this.type = "RingBufferGeometry";
        this.parameters = {
            innerRadius: a,
            outerRadius: b,
            thetaSegments: c,
            phiSegments: d,
            thetaStart: e,
            thetaLength: f
        };
        a = a || .5;
        b = b || 1;
        e = void 0 !== e ? e : 0;
        f = void 0 !== f ? f : 2 * Math.PI;
        c = void 0 !== c ? Math.max(3, c) : 8;
        d = void 0 !== d ? Math.max(1, d) : 1;
        var g = [],
            h = [],
            k = [],
            m = [],
            q = a,
            n = (b - a) / d,
            l = new p,
            u = new z,
            r, v;
        for (r = 0; r <= d; r++) {
            for (v = 0; v <= c; v++) a = e + v / c * f, l.x = q * Math.cos(a), l.y = q * Math.sin(a), h.push(l.x, l.y, l.z), k.push(0, 0, 1), u.x = (l.x / b + 1) / 2, u.y = (l.y / b + 1) / 2, m.push(u.x, u.y);
            q += n
        }
        for (r = 0; r < d; r++)
            for (b = r * (c + 1), v = 0; v < c; v++) a = v + b, e = a + c + 1, f = a + c + 2, q = a + 1, g.push(a, e, q), g.push(e, f, q);
        this.setIndex(g);
        this.addAttribute("position", new A(h, 3));
        this.addAttribute("normal", new A(k, 3));
        this.addAttribute("uv",
            new A(m, 2))
    }

    function Vc(a, b, c, d) {
        R.call(this);
        this.type = "LatheGeometry";
        this.parameters = {
            points: a,
            segments: b,
            phiStart: c,
            phiLength: d
        };
        this.fromBufferGeometry(new $b(a, b, c, d));
        this.mergeVertices()
    }

    function $b(a, b, c, d) {
        C.call(this);
        this.type = "LatheBufferGeometry";
        this.parameters = {
            points: a,
            segments: b,
            phiStart: c,
            phiLength: d
        };
        b = Math.floor(b) || 12;
        c = c || 0;
        d = d || 2 * Math.PI;
        d = H.clamp(d, 0, 2 * Math.PI);
        var e = [],
            f = [],
            g = [],
            h = 1 / b,
            k = new p,
            m = new z,
            q;
        for (q = 0; q <= b; q++) {
            var n = c + q * h * d;
            var l = Math.sin(n),
                u = Math.cos(n);
            for (n =
                0; n <= a.length - 1; n++) k.x = a[n].x * l, k.y = a[n].y, k.z = a[n].x * u, f.push(k.x, k.y, k.z), m.x = q / b, m.y = n / (a.length - 1), g.push(m.x, m.y)
        }
        for (q = 0; q < b; q++)
            for (n = 0; n < a.length - 1; n++) c = n + q * a.length, h = c + a.length, k = c + a.length + 1, m = c + 1, e.push(c, h, m), e.push(h, k, m);
        this.setIndex(e);
        this.addAttribute("position", new A(f, 3));
        this.addAttribute("uv", new A(g, 2));
        this.computeVertexNormals();
        if (d === 2 * Math.PI)
            for (d = this.attributes.normal.array, e = new p, f = new p, g = new p, c = b * a.length * 3, n = q = 0; q < a.length; q++, n += 3) e.x = d[n + 0], e.y = d[n + 1], e.z =
                d[n + 2], f.x = d[c + n + 0], f.y = d[c + n + 1], f.z = d[c + n + 2], g.addVectors(e, f).normalize(), d[n + 0] = d[c + n + 0] = g.x, d[n + 1] = d[c + n + 1] = g.y, d[n + 2] = d[c + n + 2] = g.z
    }

    function tb(a, b) {
        R.call(this);
        this.type = "ShapeGeometry";
        "object" === typeof b && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), b = b.curveSegments);
        this.parameters = {
            shapes: a,
            curveSegments: b
        };
        this.fromBufferGeometry(new ub(a, b));
        this.mergeVertices()
    }

    function ub(a, b) {
        function c(a) {
            var c, h = e.length / 3;
            a = a.extractPoints(b);
            var m = a.shape,
                q = a.holes;
            if (!1 === Va.isClockWise(m))
                for (m = m.reverse(), a = 0, c = q.length; a < c; a++) {
                    var l = q[a];
                    !0 === Va.isClockWise(l) && (q[a] = l.reverse())
                }
            var p = Va.triangulateShape(m, q);
            a = 0;
            for (c = q.length; a < c; a++) l = q[a], m = m.concat(l);
            a = 0;
            for (c = m.length; a < c; a++) l = m[a], e.push(l.x, l.y, 0), f.push(0, 0, 1), g.push(l.x, l.y);
            a = 0;
            for (c = p.length; a < c; a++) m = p[a], d.push(m[0] + h, m[1] + h, m[2] + h), k += 3
        }
        C.call(this);
        this.type = "ShapeBufferGeometry";
        this.parameters = {
            shapes: a,
            curveSegments: b
        };
        b = b || 12;
        var d = [],
            e = [],
            f = [],
            g = [],
            h = 0,
            k = 0;
        if (!1 === Array.isArray(a)) c(a);
        else
            for (var m = 0; m < a.length; m++) c(a[m]), this.addGroup(h, k, m), h += k, k = 0;
        this.setIndex(d);
        this.addAttribute("position", new A(e, 3));
        this.addAttribute("normal", new A(f, 3));
        this.addAttribute("uv", new A(g, 2))
    }

    function jf(a, b) {
        b.shapes = [];
        if (Array.isArray(a))
            for (var c = 0, d = a.length; c < d; c++) b.shapes.push(a[c].uuid);
        else b.shapes.push(a.uuid);
        return b
    }

    function ac(a, b) {
        C.call(this);
        this.type = "EdgesGeometry";
        this.parameters = {
            thresholdAngle: b
        };
        var c = [];
        b = Math.cos(H.DEG2RAD * (void 0 !== b ? b : 1));
        var d = [0, 0],
            e = {},
            f = ["a", "b", "c"];
        if (a.isBufferGeometry) {
            var g = new R;
            g.fromBufferGeometry(a)
        } else g = a.clone();
        g.mergeVertices();
        g.computeFaceNormals();
        a = g.vertices;
        g = g.faces;
        for (var h = 0, k = g.length; h < k; h++)
            for (var m = g[h], q = 0; 3 > q; q++) {
                var n = m[f[q]];
                var l = m[f[(q + 1) % 3]];
                d[0] = Math.min(n, l);
                d[1] = Math.max(n, l);
                n = d[0] + "," + d[1];
                void 0 === e[n] ? e[n] = {
                    index1: d[0],
                    index2: d[1],
                    face1: h,
                    face2: void 0
                } : e[n].face2 = h
            }
        for (n in e)
            if (d = e[n], void 0 === d.face2 || g[d.face1].normal.dot(g[d.face2].normal) <= b) f = a[d.index1], c.push(f.x, f.y, f.z), f = a[d.index2],
                c.push(f.x, f.y, f.z);
        this.addAttribute("position", new A(c, 3))
    }

    function vb(a, b, c, d, e, f, g, h) {
        R.call(this);
        this.type = "CylinderGeometry";
        this.parameters = {
            radiusTop: a,
            radiusBottom: b,
            height: c,
            radialSegments: d,
            heightSegments: e,
            openEnded: f,
            thetaStart: g,
            thetaLength: h
        };
        this.fromBufferGeometry(new Wa(a, b, c, d, e, f, g, h));
        this.mergeVertices()
    }

    function Wa(a, b, c, d, e, f, g, h) {
        function k(c) {
            var e, f = new z,
                k = new p,
                t = 0,
                v = !0 === c ? a : b,
                w = !0 === c ? 1 : -1;
            var A = r;
            for (e = 1; e <= d; e++) n.push(0, y * w, 0), l.push(0, w, 0), u.push(.5, .5), r++;
            var C =
                r;
            for (e = 0; e <= d; e++) {
                var D = e / d * h + g,
                    H = Math.cos(D);
                D = Math.sin(D);
                k.x = v * D;
                k.y = y * w;
                k.z = v * H;
                n.push(k.x, k.y, k.z);
                l.push(0, w, 0);
                f.x = .5 * H + .5;
                f.y = .5 * D * w + .5;
                u.push(f.x, f.y);
                r++
            }
            for (e = 0; e < d; e++) f = A + e, k = C + e, !0 === c ? q.push(k, k + 1, f) : q.push(k + 1, k, f), t += 3;
            m.addGroup(x, t, !0 === c ? 1 : 2);
            x += t
        }
        C.call(this);
        this.type = "CylinderBufferGeometry";
        this.parameters = {
            radiusTop: a,
            radiusBottom: b,
            height: c,
            radialSegments: d,
            heightSegments: e,
            openEnded: f,
            thetaStart: g,
            thetaLength: h
        };
        var m = this;
        a = void 0 !== a ? a : 1;
        b = void 0 !== b ? b : 1;
        c = c || 1;
        d = Math.floor(d) ||
            8;
        e = Math.floor(e) || 1;
        f = void 0 !== f ? f : !1;
        g = void 0 !== g ? g : 0;
        h = void 0 !== h ? h : 2 * Math.PI;
        var q = [],
            n = [],
            l = [],
            u = [],
            r = 0,
            v = [],
            y = c / 2,
            x = 0;
        (function() {
            var f, k, t = new p,
                P = new p,
                N = 0,
                z = (b - a) / c;
            for (k = 0; k <= e; k++) {
                var A = [],
                    D = k / e,
                    C = D * (b - a) + a;
                for (f = 0; f <= d; f++) {
                    var H = f / d,
                        G = H * h + g,
                        K = Math.sin(G);
                    G = Math.cos(G);
                    P.x = C * K;
                    P.y = -D * c + y;
                    P.z = C * G;
                    n.push(P.x, P.y, P.z);
                    t.set(K, z, G).normalize();
                    l.push(t.x, t.y, t.z);
                    u.push(H, 1 - D);
                    A.push(r++)
                }
                v.push(A)
            }
            for (f = 0; f < d; f++)
                for (k = 0; k < e; k++) t = v[k + 1][f], P = v[k + 1][f + 1], z = v[k][f + 1], q.push(v[k][f], t, z),
                    q.push(t, P, z), N += 6;
            m.addGroup(x, N, 0);
            x += N
        })();
        !1 === f && (0 < a && k(!0), 0 < b && k(!1));
        this.setIndex(q);
        this.addAttribute("position", new A(n, 3));
        this.addAttribute("normal", new A(l, 3));
        this.addAttribute("uv", new A(u, 2))
    }

    function Wc(a, b, c, d, e, f, g) {
        vb.call(this, 0, a, b, c, d, e, f, g);
        this.type = "ConeGeometry";
        this.parameters = {
            radius: a,
            height: b,
            radialSegments: c,
            heightSegments: d,
            openEnded: e,
            thetaStart: f,
            thetaLength: g
        }
    }

    function Xc(a, b, c, d, e, f, g) {
        Wa.call(this, 0, a, b, c, d, e, f, g);
        this.type = "ConeBufferGeometry";
        this.parameters = {
            radius: a,
            height: b,
            radialSegments: c,
            heightSegments: d,
            openEnded: e,
            thetaStart: f,
            thetaLength: g
        }
    }

    function Yc(a, b, c, d) {
        R.call(this);
        this.type = "CircleGeometry";
        this.parameters = {
            radius: a,
            segments: b,
            thetaStart: c,
            thetaLength: d
        };
        this.fromBufferGeometry(new bc(a, b, c, d));
        this.mergeVertices()
    }

    function bc(a, b, c, d) {
        C.call(this);
        this.type = "CircleBufferGeometry";
        this.parameters = {
            radius: a,
            segments: b,
            thetaStart: c,
            thetaLength: d
        };
        a = a || 1;
        b = void 0 !== b ? Math.max(3, b) : 8;
        c = void 0 !== c ? c : 0;
        d = void 0 !== d ? d : 2 * Math.PI;
        var e = [],
            f = [],
            g = [],
            h = [],
            k, m = new p,
            q = new z;
        f.push(0, 0, 0);
        g.push(0, 0, 1);
        h.push(.5, .5);
        var n = 0;
        for (k = 3; n <= b; n++, k += 3) {
            var l = c + n / b * d;
            m.x = a * Math.cos(l);
            m.y = a * Math.sin(l);
            f.push(m.x, m.y, m.z);
            g.push(0, 0, 1);
            q.x = (f[k] / a + 1) / 2;
            q.y = (f[k + 1] / a + 1) / 2;
            h.push(q.x, q.y)
        }
        for (k = 1; k <= b; k++) e.push(k, k + 1, 0);
        this.setIndex(e);
        this.addAttribute("position", new A(f, 3));
        this.addAttribute("normal", new A(g, 3));
        this.addAttribute("uv", new A(h, 2))
    }

    function wb(a) {
        J.call(this);
        this.type = "ShadowMaterial";
        this.color = new G(0);
        this.transparent = !0;
        this.setValues(a)
    }

    function cc(a) {
        ta.call(this, a);
        this.type = "RawShaderMaterial"
    }

    function Pa(a) {
        J.call(this);
        this.defines = {
            STANDARD: ""
        };
        this.type = "MeshStandardMaterial";
        this.color = new G(16777215);
        this.metalness = this.roughness = .5;
        this.lightMap = this.map = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new G(0);
        this.emissiveIntensity = 1;
        this.bumpMap = this.emissiveMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = 0;
        this.normalScale = new z(1, 1);
        this.displacementMap = null;
        this.displacementScale =
            1;
        this.displacementBias = 0;
        this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null;
        this.envMapIntensity = 1;
        this.refractionRatio = .98;
        this.wireframe = !1;
        this.wireframeLinewidth = 1;
        this.wireframeLinejoin = this.wireframeLinecap = "round";
        this.morphNormals = this.morphTargets = this.skinning = !1;
        this.setValues(a)
    }

    function xb(a) {
        Pa.call(this);
        this.defines = {
            PHYSICAL: ""
        };
        this.type = "MeshPhysicalMaterial";
        this.reflectivity = .5;
        this.clearCoatRoughness = this.clearCoat = 0;
        this.setValues(a)
    }

    function Fa(a) {
        J.call(this);
        this.type = "MeshPhongMaterial";
        this.color = new G(16777215);
        this.specular = new G(1118481);
        this.shininess = 30;
        this.lightMap = this.map = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new G(0);
        this.emissiveIntensity = 1;
        this.bumpMap = this.emissiveMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = 0;
        this.normalScale = new z(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.envMap = this.alphaMap = this.specularMap = null;
        this.combine = 0;
        this.reflectivity = 1;
        this.refractionRatio = .98;
        this.wireframe = !1;
        this.wireframeLinewidth = 1;
        this.wireframeLinejoin = this.wireframeLinecap = "round";
        this.morphNormals = this.morphTargets = this.skinning = !1;
        this.setValues(a)
    }

    function yb(a) {
        Fa.call(this);
        this.defines = {
            TOON: ""
        };
        this.type = "MeshToonMaterial";
        this.gradientMap = null;
        this.setValues(a)
    }

    function zb(a) {
        J.call(this);
        this.type = "MeshNormalMaterial";
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = 0;
        this.normalScale = new z(1, 1);
        this.displacementMap =
            null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.wireframe = !1;
        this.wireframeLinewidth = 1;
        this.morphNormals = this.morphTargets = this.skinning = this.lights = this.fog = !1;
        this.setValues(a)
    }

    function Ab(a) {
        J.call(this);
        this.type = "MeshLambertMaterial";
        this.color = new G(16777215);
        this.lightMap = this.map = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new G(0);
        this.emissiveIntensity = 1;
        this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null;
        this.combine = 0;
        this.reflectivity =
            1;
        this.refractionRatio = .98;
        this.wireframe = !1;
        this.wireframeLinewidth = 1;
        this.wireframeLinejoin = this.wireframeLinecap = "round";
        this.morphNormals = this.morphTargets = this.skinning = !1;
        this.setValues(a)
    }

    function Bb(a) {
        Y.call(this);
        this.type = "LineDashedMaterial";
        this.scale = 1;
        this.dashSize = 3;
        this.gapSize = 1;
        this.setValues(a)
    }

    function ce(a, b, c) {
        var d = this,
            e = !1,
            f = 0,
            g = 0,
            h = void 0;
        this.onStart = void 0;
        this.onLoad = a;
        this.onProgress = b;
        this.onError = c;
        this.itemStart = function(a) {
            g++;
            if (!1 === e && void 0 !== d.onStart) d.onStart(a,
                f, g);
            e = !0
        };
        this.itemEnd = function(a) {
            f++;
            if (void 0 !== d.onProgress) d.onProgress(a, f, g);
            if (f === g && (e = !1, void 0 !== d.onLoad)) d.onLoad()
        };
        this.itemError = function(a) {
            if (void 0 !== d.onError) d.onError(a)
        };
        this.resolveURL = function(a) {
            return h ? h(a) : a
        };
        this.setURLModifier = function(a) {
            h = a;
            return this
        }
    }

    function Ga(a) {
        this.manager = void 0 !== a ? a : ka
    }

    function kf(a) {
        this.manager = void 0 !== a ? a : ka;
        this._parser = null
    }

    function de(a) {
        this.manager = void 0 !== a ? a : ka;
        this._parser = null
    }

    function Zc(a) {
        this.manager = void 0 !== a ? a : ka
    }

    function ee(a) {
        this.manager = void 0 !== a ? a : ka
    }

    function vd(a) {
        this.manager = void 0 !== a ? a : ka
    }

    function L() {
        this.type = "Curve";
        this.arcLengthDivisions = 200
    }

    function za(a, b, c, d, e, f, g, h) {
        L.call(this);
        this.type = "EllipseCurve";
        this.aX = a || 0;
        this.aY = b || 0;
        this.xRadius = c || 1;
        this.yRadius = d || 1;
        this.aStartAngle = e || 0;
        this.aEndAngle = f || 2 * Math.PI;
        this.aClockwise = g || !1;
        this.aRotation = h || 0
    }

    function dc(a, b, c, d, e, f) {
        za.call(this, a, b, c, c, d, e, f);
        this.type = "ArcCurve"
    }

    function fe() {
        var a = 0,
            b = 0,
            c = 0,
            d = 0;
        return {
            initCatmullRom: function(e,
                f, g, h, k) {
                e = k * (g - e);
                h = k * (h - f);
                a = f;
                b = e;
                c = -3 * f + 3 * g - 2 * e - h;
                d = 2 * f - 2 * g + e + h
            },
            initNonuniformCatmullRom: function(e, f, g, h, k, m, q) {
                e = ((f - e) / k - (g - e) / (k + m) + (g - f) / m) * m;
                h = ((g - f) / m - (h - f) / (m + q) + (h - g) / q) * m;
                a = f;
                b = e;
                c = -3 * f + 3 * g - 2 * e - h;
                d = 2 * f - 2 * g + e + h
            },
            calc: function(e) {
                var f = e * e;
                return a + b * e + c * f + d * f * e
            }
        }
    }

    function ca(a, b, c, d) {
        L.call(this);
        this.type = "CatmullRomCurve3";
        this.points = a || [];
        this.closed = b || !1;
        this.curveType = c || "centripetal";
        this.tension = d || .5
    }

    function lf(a, b, c, d, e) {
        b = .5 * (d - b);
        e = .5 * (e - c);
        var f = a * a;
        return (2 * c - 2 * d + b + e) *
            a * f + (-3 * c + 3 * d - 2 * b - e) * f + b * a + c
    }

    function $c(a, b, c, d) {
        var e = 1 - a;
        return e * e * b + 2 * (1 - a) * a * c + a * a * d
    }

    function ad(a, b, c, d, e) {
        var f = 1 - a,
            g = 1 - a;
        return f * f * f * b + 3 * g * g * a * c + 3 * (1 - a) * a * a * d + a * a * a * e
    }

    function Ha(a, b, c, d) {
        L.call(this);
        this.type = "CubicBezierCurve";
        this.v0 = a || new z;
        this.v1 = b || new z;
        this.v2 = c || new z;
        this.v3 = d || new z
    }

    function Qa(a, b, c, d) {
        L.call(this);
        this.type = "CubicBezierCurve3";
        this.v0 = a || new p;
        this.v1 = b || new p;
        this.v2 = c || new p;
        this.v3 = d || new p
    }

    function va(a, b) {
        L.call(this);
        this.type = "LineCurve";
        this.v1 = a ||
            new z;
        this.v2 = b || new z
    }

    function Ia(a, b) {
        L.call(this);
        this.type = "LineCurve3";
        this.v1 = a || new p;
        this.v2 = b || new p
    }

    function Ja(a, b, c) {
        L.call(this);
        this.type = "QuadraticBezierCurve";
        this.v0 = a || new z;
        this.v1 = b || new z;
        this.v2 = c || new z
    }

    function Ra(a, b, c) {
        L.call(this);
        this.type = "QuadraticBezierCurve3";
        this.v0 = a || new p;
        this.v1 = b || new p;
        this.v2 = c || new p
    }

    function Ka(a) {
        L.call(this);
        this.type = "SplineCurve";
        this.points = a || []
    }

    function Xa() {
        L.call(this);
        this.type = "CurvePath";
        this.curves = [];
        this.autoClose = !1
    }

    function La(a) {
        Xa.call(this);
        this.type = "Path";
        this.currentPoint = new z;
        a && this.setFromPoints(a)
    }

    function db(a) {
        La.call(this, a);
        this.uuid = H.generateUUID();
        this.type = "Shape";
        this.holes = []
    }

    function X(a, b) {
        D.call(this);
        this.type = "Light";
        this.color = new G(a);
        this.intensity = void 0 !== b ? b : 1;
        this.receiveShadow = void 0
    }

    function wd(a, b, c) {
        X.call(this, a, c);
        this.type = "HemisphereLight";
        this.castShadow = void 0;
        this.position.copy(D.DefaultUp);
        this.updateMatrix();
        this.groundColor = new G(b)
    }

    function Cb(a) {
        this.camera = a;
        this.bias = 0;
        this.radius = 1;
        this.mapSize =
            new z(512, 512);
        this.map = null;
        this.matrix = new I
    }

    function xd() {
        Cb.call(this, new Z(50, 1, .5, 500))
    }

    function yd(a, b, c, d, e, f) {
        X.call(this, a, b);
        this.type = "SpotLight";
        this.position.copy(D.DefaultUp);
        this.updateMatrix();
        this.target = new D;
        Object.defineProperty(this, "power", {
            get: function() {
                return this.intensity * Math.PI
            },
            set: function(a) {
                this.intensity = a / Math.PI
            }
        });
        this.distance = void 0 !== c ? c : 0;
        this.angle = void 0 !== d ? d : Math.PI / 3;
        this.penumbra = void 0 !== e ? e : 0;
        this.decay = void 0 !== f ? f : 1;
        this.shadow = new xd
    }

    function zd(a,
        b, c, d) {
        X.call(this, a, b);
        this.type = "PointLight";
        Object.defineProperty(this, "power", {
            get: function() {
                return 4 * this.intensity * Math.PI
            },
            set: function(a) {
                this.intensity = a / (4 * Math.PI)
            }
        });
        this.distance = void 0 !== c ? c : 0;
        this.decay = void 0 !== d ? d : 1;
        this.shadow = new Cb(new Z(90, 1, .5, 500))
    }

    function Ad() {
        Cb.call(this, new Hb(-5, 5, 5, -5, .5, 500))
    }

    function Bd(a, b) {
        X.call(this, a, b);
        this.type = "DirectionalLight";
        this.position.copy(D.DefaultUp);
        this.updateMatrix();
        this.target = new D;
        this.shadow = new Ad
    }

    function Cd(a, b) {
        X.call(this,
            a, b);
        this.type = "AmbientLight";
        this.castShadow = void 0
    }

    function Dd(a, b, c, d) {
        X.call(this, a, b);
        this.type = "RectAreaLight";
        this.width = void 0 !== c ? c : 10;
        this.height = void 0 !== d ? d : 10
    }

    function wa(a, b, c, d) {
        this.parameterPositions = a;
        this._cachedIndex = 0;
        this.resultBuffer = void 0 !== d ? d : new b.constructor(c);
        this.sampleValues = b;
        this.valueSize = c
    }

    function Ed(a, b, c, d) {
        wa.call(this, a, b, c, d);
        this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0
    }

    function bd(a, b, c, d) {
        wa.call(this, a, b, c, d)
    }

    function Fd(a, b,
        c, d) {
        wa.call(this, a, b, c, d)
    }

    function oa(a, b, c, d) {
        if (void 0 === a) throw Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === b || 0 === b.length) throw Error("THREE.KeyframeTrack: no keyframes in track named " + a);
        this.name = a;
        this.times = ia.convertArray(b, this.TimeBufferType);
        this.values = ia.convertArray(c, this.ValueBufferType);
        this.setInterpolation(d || this.DefaultInterpolation)
    }

    function Gd(a, b, c) {
        oa.call(this, a, b, c)
    }

    function Hd(a, b, c, d) {
        oa.call(this, a, b, c, d)
    }

    function ec(a, b, c, d) {
        oa.call(this, a,
            b, c, d)
    }

    function Id(a, b, c, d) {
        wa.call(this, a, b, c, d)
    }

    function cd(a, b, c, d) {
        oa.call(this, a, b, c, d)
    }

    function Jd(a, b, c, d) {
        oa.call(this, a, b, c, d)
    }

    function fc(a, b, c, d) {
        oa.call(this, a, b, c, d)
    }

    function Ca(a, b, c) {
        this.name = a;
        this.tracks = c;
        this.duration = void 0 !== b ? b : -1;
        this.uuid = H.generateUUID();
        0 > this.duration && this.resetDuration()
    }

    function Rg(a) {
        switch (a.toLowerCase()) {
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
                return ec;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
                return fc;
            case "color":
                return Hd;
            case "quaternion":
                return cd;
            case "bool":
            case "boolean":
                return Gd;
            case "string":
                return Jd
        }
        throw Error("THREE.KeyframeTrack: Unsupported typeName: " + a);
    }

    function Sg(a) {
        if (void 0 === a.type) throw Error("THREE.KeyframeTrack: track type undefined, can not parse");
        var b = Rg(a.type);
        if (void 0 === a.times) {
            var c = [],
                d = [];
            ia.flattenJSON(a.keys, c, d, "value");
            a.times = c;
            a.values = d
        }
        return void 0 !== b.parse ? b.parse(a) : new b(a.name, a.times, a.values, a.interpolation)
    }

    function Kd(a) {
        this.manager = void 0 !==
            a ? a : ka;
        this.textures = {}
    }

    function ge(a) {
        this.manager = void 0 !== a ? a : ka
    }

    function gc() {}

    function he(a) {
        "boolean" === typeof a && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), a = void 0);
        this.manager = void 0 !== a ? a : ka;
        this.withCredentials = !1
    }

    function mf(a) {
        this.manager = void 0 !== a ? a : ka;
        this.texturePath = ""
    }

    function ie(a) {
        "undefined" === typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
        "undefined" === typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
        this.manager = void 0 !== a ? a : ka;
        this.options = void 0
    }

    function je() {
        this.type = "ShapePath";
        this.color = new G;
        this.subPaths = [];
        this.currentPath = null
    }

    function ke(a) {
        this.type = "Font";
        this.data = a
    }

    function nf(a) {
        this.manager = void 0 !== a ? a : ka
    }

    function le(a) {
        this.manager = void 0 !== a ? a : ka
    }

    function of() {
        this.type = "StereoCamera";
        this.aspect = 1;
        this.eyeSep = .064;
        this.cameraL = new Z;
        this.cameraL.layers.enable(1);
        this.cameraL.matrixAutoUpdate = !1;
        this.cameraR = new Z;
        this.cameraR.layers.enable(2);
        this.cameraR.matrixAutoUpdate = !1
    }

    function dd(a, b, c) {
        D.call(this);
        this.type = "CubeCamera";
        var d = new Z(90, 1, a, b);
        d.up.set(0, -1, 0);
        d.lookAt(new p(1, 0, 0));
        this.add(d);
        var e = new Z(90, 1, a, b);
        e.up.set(0, -1, 0);
        e.lookAt(new p(-1, 0, 0));
        this.add(e);
        var f = new Z(90, 1, a, b);
        f.up.set(0, 0, 1);
        f.lookAt(new p(0, 1, 0));
        this.add(f);
        var g = new Z(90, 1, a, b);
        g.up.set(0, 0, -1);
        g.lookAt(new p(0, -1, 0));
        this.add(g);
        var h = new Z(90, 1, a, b);
        h.up.set(0, -1, 0);
        h.lookAt(new p(0, 0, 1));
        this.add(h);
        var k = new Z(90, 1, a, b);
        k.up.set(0, -1, 0);
        k.lookAt(new p(0, 0, -1));
        this.add(k);
        this.renderTarget = new Gb(c, c, {
            format: 1022,
            magFilter: 1006,
            minFilter: 1006
        });
        this.renderTarget.texture.name = "CubeCamera";
        this.update = function(a, b) {
            null === this.parent && this.updateMatrixWorld();
            var c = this.renderTarget,
                m = c.texture.generateMipmaps;
            c.texture.generateMipmaps = !1;
            c.activeCubeFace = 0;
            a.render(b, d, c);
            c.activeCubeFace = 1;
            a.render(b, e, c);
            c.activeCubeFace = 2;
            a.render(b, f, c);
            c.activeCubeFace = 3;
            a.render(b, g, c);
            c.activeCubeFace = 4;
            a.render(b, h, c);
            c.texture.generateMipmaps = m;
            c.activeCubeFace = 5;
            a.render(b,
                k, c);
            a.setRenderTarget(null)
        };
        this.clear = function(a, b, c, d) {
            for (var e = this.renderTarget, f = 0; 6 > f; f++) e.activeCubeFace = f, a.setRenderTarget(e), a.clear(b, c, d);
            a.setRenderTarget(null)
        }
    }

    function me() {
        D.call(this);
        this.type = "AudioListener";
        this.context = ne.getContext();
        this.gain = this.context.createGain();
        this.gain.connect(this.context.destination);
        this.filter = null
    }

    function hc(a) {
        D.call(this);
        this.type = "Audio";
        this.context = a.context;
        this.gain = this.context.createGain();
        this.gain.connect(a.getInput());
        this.autoplay = !1;
        this.buffer = null;
        this.loop = !1;
        this.offset = this.startTime = 0;
        this.playbackRate = 1;
        this.isPlaying = !1;
        this.hasPlaybackControl = !0;
        this.sourceType = "empty";
        this.filters = []
    }

    function oe(a) {
        hc.call(this, a);
        this.panner = this.context.createPanner();
        this.panner.connect(this.gain)
    }

    function pe(a, b) {
        this.analyser = a.context.createAnalyser();
        this.analyser.fftSize = void 0 !== b ? b : 2048;
        this.data = new Uint8Array(this.analyser.frequencyBinCount);
        a.getOutput().connect(this.analyser)
    }

    function qe(a, b, c) {
        this.binding = a;
        this.valueSize =
            c;
        a = Float64Array;
        switch (b) {
            case "quaternion":
                b = this._slerp;
                break;
            case "string":
            case "bool":
                a = Array;
                b = this._select;
                break;
            default:
                b = this._lerp
        }
        this.buffer = new a(4 * c);
        this._mixBufferRegion = b;
        this.referenceCount = this.useCount = this.cumulativeWeight = 0
    }

    function pf(a, b, c) {
        c = c || pa.parseTrackName(b);
        this._targetGroup = a;
        this._bindings = a.subscribe_(b, c)
    }

    function pa(a, b, c) {
        this.path = b;
        this.parsedPath = c || pa.parseTrackName(b);
        this.node = pa.findNode(a, this.parsedPath.nodeName) || a;
        this.rootNode = a
    }

    function qf() {
        this.uuid =
            H.generateUUID();
        this._objects = Array.prototype.slice.call(arguments);
        this.nCachedObjects_ = 0;
        var a = {};
        this._indicesByUUID = a;
        for (var b = 0, c = arguments.length; b !== c; ++b) a[arguments[b].uuid] = b;
        this._paths = [];
        this._parsedPaths = [];
        this._bindings = [];
        this._bindingsIndicesByPath = {};
        var d = this;
        this.stats = {
            objects: {get total() {
                    return d._objects.length
                },
                get inUse() {
                    return this.total - d.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return d._bindings.length
            }
        }
    }

    function rf(a, b, c) {
        this._mixer = a;
        this._clip = b;
        this._localRoot =
            c || null;
        a = b.tracks;
        b = a.length;
        c = Array(b);
        for (var d = {
                endingStart: 2400,
                endingEnd: 2400
            }, e = 0; e !== b; ++e) {
            var f = a[e].createInterpolant(null);
            c[e] = f;
            f.settings = d
        }
        this._interpolantSettings = d;
        this._interpolants = c;
        this._propertyBindings = Array(b);
        this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null;
        this.loop = 2201;
        this._loopCount = -1;
        this._startTime = null;
        this.time = 0;
        this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1;
        this.repetitions = Infinity;
        this.paused = !1;
        this.enabled = !0;
        this.clampWhenFinished = !1;
        this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0
    }

    function re(a) {
        this._root = a;
        this._initMemoryManager();
        this.time = this._accuIndex = 0;
        this.timeScale = 1
    }

    function Ld(a, b) {
        "string" === typeof a && (console.warn("THREE.Uniform: Type parameter is no longer needed."), a = b);
        this.value = a
    }

    function se() {
        C.call(this);
        this.type = "InstancedBufferGeometry";
        this.maxInstancedCount = void 0
    }

    function te(a, b, c) {
        ob.call(this, a, b);
        this.meshPerAttribute = c || 1
    }

    function ue(a, b, c) {
        Q.call(this,
            a, b);
        this.meshPerAttribute = c || 1
    }

    function sf(a, b, c, d) {
        this.ray = new mb(a, b);
        this.near = c || 0;
        this.far = d || Infinity;
        this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        };
        Object.defineProperties(this.params, {
            PointCloud: {
                get: function() {
                    console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points.");
                    return this.Points
                }
            }
        })
    }

    function tf(a, b) {
        return a.distance - b.distance
    }

    function ve(a, b, c, d) {
        if (!1 !== a.visible && (a.raycast(b, c), !0 === d)) {
            a = a.children;
            d = 0;
            for (var e = a.length; d < e; d++) ve(a[d],
                b, c, !0)
        }
    }

    function uf(a) {
        this.autoStart = void 0 !== a ? a : !0;
        this.elapsedTime = this.oldTime = this.startTime = 0;
        this.running = !1
    }

    function vf(a, b, c) {
        this.radius = void 0 !== a ? a : 1;
        this.phi = void 0 !== b ? b : 0;
        this.theta = void 0 !== c ? c : 0;
        return this
    }

    function wf(a, b, c) {
        this.radius = void 0 !== a ? a : 1;
        this.theta = void 0 !== b ? b : 0;
        this.y = void 0 !== c ? c : 0;
        return this
    }

    function we(a, b) {
        this.min = void 0 !== a ? a : new z(Infinity, Infinity);
        this.max = void 0 !== b ? b : new z(-Infinity, -Infinity)
    }

    function xe(a, b) {
        this.start = void 0 !== a ? a : new p;
        this.end =
            void 0 !== b ? b : new p
    }

    function ed(a) {
        D.call(this);
        this.material = a;
        this.render = function() {}
    }

    function fd(a, b, c, d) {
        this.object = a;
        this.size = void 0 !== b ? b : 1;
        a = void 0 !== c ? c : 16711680;
        d = void 0 !== d ? d : 1;
        b = 0;
        (c = this.object.geometry) && c.isGeometry ? b = 3 * c.faces.length : c && c.isBufferGeometry && (b = c.attributes.normal.count);
        c = new C;
        b = new A(6 * b, 3);
        c.addAttribute("position", b);
        W.call(this, c, new Y({
            color: a,
            linewidth: d
        }));
        this.matrixAutoUpdate = !1;
        this.update()
    }

    function ic(a, b) {
        D.call(this);
        this.light = a;
        this.light.updateMatrixWorld();
        this.matrix = a.matrixWorld;
        this.matrixAutoUpdate = !1;
        this.color = b;
        a = new C;
        b = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
        for (var c = 0, d = 1; 32 > c; c++, d++) {
            var e = c / 32 * Math.PI * 2,
                f = d / 32 * Math.PI * 2;
            b.push(Math.cos(e), Math.sin(e), 1, Math.cos(f), Math.sin(f), 1)
        }
        a.addAttribute("position", new A(b, 3));
        b = new Y({
            fog: !1
        });
        this.cone = new W(a, b);
        this.add(this.cone);
        this.update()
    }

    function xf(a) {
        var b = [];
        a && a.isBone && b.push(a);
        for (var c = 0; c < a.children.length; c++) b.push.apply(b, xf(a.children[c]));
        return b
    }

    function jc(a) {
        for (var b = xf(a), c = new C, d = [], e = [], f = new G(0, 0, 1), g = new G(0, 1, 0), h = 0; h < b.length; h++) {
            var k = b[h];
            k.parent && k.parent.isBone && (d.push(0, 0, 0), d.push(0, 0, 0), e.push(f.r, f.g, f.b), e.push(g.r, g.g, g.b))
        }
        c.addAttribute("position", new A(d, 3));
        c.addAttribute("color", new A(e, 3));
        d = new Y({
            vertexColors: 2,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        });
        W.call(this, c, d);
        this.root = a;
        this.bones = b;
        this.matrix = a.matrixWorld;
        this.matrixAutoUpdate = !1
    }

    function kc(a, b, c) {
        this.light = a;
        this.light.updateMatrixWorld();
        this.color = c;
        a = new sb(b, 4, 2);
        b = new da({
            wireframe: !0,
            fog: !1
        });
        la.call(this, a, b);
        this.matrix = this.light.matrixWorld;
        this.matrixAutoUpdate = !1;
        this.update()
    }

    function lc(a, b) {
        D.call(this);
        this.light = a;
        this.light.updateMatrixWorld();
        this.matrix = a.matrixWorld;
        this.matrixAutoUpdate = !1;
        this.color = b;
        a = new Y({
            fog: !1
        });
        b = new C;
        b.addAttribute("position", new Q(new Float32Array(15), 3));
        this.line = new sa(b, a);
        this.add(this.line);
        this.update()
    }

    function mc(a, b, c) {
        D.call(this);
        this.light = a;
        this.light.updateMatrixWorld();
        this.matrix = a.matrixWorld;
        this.matrixAutoUpdate = !1;
        this.color = c;
        a = new pb(b);
        a.rotateY(.5 * Math.PI);
        this.material = new da({
            wireframe: !0,
            fog: !1
        });
        void 0 === this.color && (this.material.vertexColors = 2);
        b = a.getAttribute("position");
        b = new Float32Array(3 * b.count);
        a.addAttribute("color", new Q(b, 3));
        this.add(new la(a, this.material));
        this.update()
    }

    function gd(a, b, c, d) {
        a = a || 10;
        b = b || 10;
        c = new G(void 0 !== c ? c : 4473924);
        d = new G(void 0 !== d ? d : 8947848);
        var e = b / 2,
            f = a / b,
            g = a / 2;
        a = [];
        for (var h = [], k = 0, m = 0, q = -g; k <= b; k++, q += f) {
            a.push(-g,
                0, q, g, 0, q);
            a.push(q, 0, -g, q, 0, g);
            var n = k === e ? c : d;
            n.toArray(h, m);
            m += 3;
            n.toArray(h, m);
            m += 3;
            n.toArray(h, m);
            m += 3;
            n.toArray(h, m);
            m += 3
        }
        b = new C;
        b.addAttribute("position", new A(a, 3));
        b.addAttribute("color", new A(h, 3));
        c = new Y({
            vertexColors: 2
        });
        W.call(this, b, c)
    }

    function Md(a, b, c, d, e, f) {
        a = a || 10;
        b = b || 16;
        c = c || 8;
        d = d || 64;
        e = new G(void 0 !== e ? e : 4473924);
        f = new G(void 0 !== f ? f : 8947848);
        var g = [],
            h = [],
            k;
        for (k = 0; k <= b; k++) {
            var m = k / b * 2 * Math.PI;
            var q = Math.sin(m) * a;
            m = Math.cos(m) * a;
            g.push(0, 0, 0);
            g.push(q, 0, m);
            var n = k & 1 ? e : f;
            h.push(n.r,
                n.g, n.b);
            h.push(n.r, n.g, n.b)
        }
        for (k = 0; k <= c; k++) {
            n = k & 1 ? e : f;
            var l = a - a / c * k;
            for (b = 0; b < d; b++) m = b / d * 2 * Math.PI, q = Math.sin(m) * l, m = Math.cos(m) * l, g.push(q, 0, m), h.push(n.r, n.g, n.b), m = (b + 1) / d * 2 * Math.PI, q = Math.sin(m) * l, m = Math.cos(m) * l, g.push(q, 0, m), h.push(n.r, n.g, n.b)
        }
        a = new C;
        a.addAttribute("position", new A(g, 3));
        a.addAttribute("color", new A(h, 3));
        g = new Y({
            vertexColors: 2
        });
        W.call(this, a, g)
    }

    function hd(a, b, c, d) {
        this.object = a;
        this.size = void 0 !== b ? b : 1;
        a = void 0 !== c ? c : 16776960;
        d = void 0 !== d ? d : 1;
        b = 0;
        (c = this.object.geometry) &&
        c.isGeometry ? b = c.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
        c = new C;
        b = new A(6 * b, 3);
        c.addAttribute("position", b);
        W.call(this, c, new Y({
            color: a,
            linewidth: d
        }));
        this.matrixAutoUpdate = !1;
        this.update()
    }

    function nc(a, b, c) {
        D.call(this);
        this.light = a;
        this.light.updateMatrixWorld();
        this.matrix = a.matrixWorld;
        this.matrixAutoUpdate = !1;
        this.color = c;
        void 0 === b && (b = 1);
        a = new C;
        a.addAttribute("position", new A([-b, b, 0, b, b, 0, b, -b, 0, -b, -b, 0, -b, b, 0], 3));
        b = new Y({
            fog: !1
        });
        this.lightPlane = new sa(a, b);
        this.add(this.lightPlane);
        a = new C;
        a.addAttribute("position", new A([0, 0, 0, 0, 0, 1], 3));
        this.targetLine = new sa(a, b);
        this.add(this.targetLine);
        this.update()
    }

    function id(a) {
        function b(a, b, d) {
            c(a, d);
            c(b, d)
        }

        function c(a, b) {
            f.push(0, 0, 0);
            g.push(b.r, b.g, b.b);
            void 0 === h[a] && (h[a] = []);
            h[a].push(f.length / 3 - 1)
        }
        var d = new C,
            e = new Y({
                color: 16777215,
                vertexColors: 1
            }),
            f = [],
            g = [],
            h = {},
            k = new G(16755200),
            m = new G(16711680),
            q = new G(43775),
            n = new G(16777215),
            l = new G(3355443);
        b("n1", "n2", k);
        b("n2", "n4", k);
        b("n4", "n3", k);
        b("n3", "n1", k);
        b("f1", "f2", k);
        b("f2", "f4", k);
        b("f4", "f3", k);
        b("f3", "f1", k);
        b("n1", "f1", k);
        b("n2", "f2", k);
        b("n3", "f3", k);
        b("n4", "f4", k);
        b("p", "n1", m);
        b("p", "n2", m);
        b("p", "n3", m);
        b("p", "n4", m);
        b("u1", "u2", q);
        b("u2", "u3", q);
        b("u3", "u1", q);
        b("c", "t", n);
        b("p", "c", l);
        b("cn1", "cn2", l);
        b("cn3", "cn4", l);
        b("cf1", "cf2", l);
        b("cf3", "cf4", l);
        d.addAttribute("position", new A(f, 3));
        d.addAttribute("color", new A(g, 3));
        W.call(this, d, e);
        this.camera = a;
        this.camera.updateProjectionMatrix &&
            this.camera.updateProjectionMatrix();
        this.matrix = a.matrixWorld;
        this.matrixAutoUpdate = !1;
        this.pointMap = h;
        this.update()
    }

    function Db(a, b) {
        this.object = a;
        void 0 === b && (b = 16776960);
        a = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
        var c = new Float32Array(24),
            d = new C;
        d.setIndex(new Q(a, 1));
        d.addAttribute("position", new Q(c, 3));
        W.call(this, d, new Y({
            color: b
        }));
        this.matrixAutoUpdate = !1;
        this.update()
    }

    function jd(a, b) {
        this.type = "Box3Helper";
        this.box = a;
        a = void 0 !== b ? b : 16776960;
        b = new Uint16Array([0,
            1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7
        ]);
        var c = new C;
        c.setIndex(new Q(b, 1));
        c.addAttribute("position", new A([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3));
        W.call(this, c, new Y({
            color: a
        }));
        this.geometry.computeBoundingSphere()
    }

    function kd(a, b, c) {
        this.type = "PlaneHelper";
        this.plane = a;
        this.size = void 0 === b ? 1 : b;
        a = void 0 !== c ? c : 16776960;
        b = new C;
        b.addAttribute("position", new A([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3));
        b.computeBoundingSphere();
        sa.call(this,
            b, new Y({
                color: a
            }));
        b = new C;
        b.addAttribute("position", new A([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3));
        b.computeBoundingSphere();
        this.add(new la(b, new da({
            color: a,
            opacity: .2,
            transparent: !0,
            depthWrite: !1
        })))
    }

    function Eb(a, b, c, d, e, f) {
        D.call(this);
        void 0 === d && (d = 16776960);
        void 0 === c && (c = 1);
        void 0 === e && (e = .2 * c);
        void 0 === f && (f = .2 * e);
        void 0 === Nd && (Nd = new C, Nd.addAttribute("position", new A([0, 0, 0, 0, 1, 0], 3)), ye = new Wa(0, .5, 1, 5, 1), ye.translate(0, -.5, 0));
        this.position.copy(b);
        this.line = new sa(Nd, new Y({
            color: d
        }));
        this.line.matrixAutoUpdate = !1;
        this.add(this.line);
        this.cone = new la(ye, new da({
            color: d
        }));
        this.cone.matrixAutoUpdate = !1;
        this.add(this.cone);
        this.setDirection(a);
        this.setLength(c, e, f)
    }

    function ld(a) {
        a = a || 1;
        var b = [0, 0, 0, a, 0, 0, 0, 0, 0, 0, a, 0, 0, 0, 0, 0, 0, a];
        a = new C;
        a.addAttribute("position", new A(b, 3));
        a.addAttribute("color", new A([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
        b = new Y({
            vertexColors: 2
        });
        W.call(this, a, b)
    }

    function yf(a) {
        console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");
        ca.call(this, a);
        this.type = "catmullrom";
        this.closed = !0
    }

    function zf(a) {
        console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");
        ca.call(this, a);
        this.type = "catmullrom"
    }

    function ze(a) {
        console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.");
        ca.call(this, a);
        this.type = "catmullrom"
    }
    void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52));
    void 0 === Number.isInteger && (Number.isInteger = function(a) {
        return "number" === typeof a && isFinite(a) && Math.floor(a) ===
            a
    });
    void 0 === Math.sign && (Math.sign = function(a) {
        return 0 > a ? -1 : 0 < a ? 1 : +a
    });
    !1 === "name" in Function.prototype && Object.defineProperty(Function.prototype, "name", {
        get: function() {
            return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
        }
    });
    void 0 === Object.assign && function() {
        Object.assign = function(a) {
            if (void 0 === a || null === a) throw new TypeError("Cannot convert undefined or null to object");
            for (var b = Object(a), c = 1; c < arguments.length; c++) {
                var d = arguments[c];
                if (void 0 !== d && null !== d)
                    for (var e in d) Object.prototype.hasOwnProperty.call(d,
                        e) && (b[e] = d[e])
            }
            return b
        }
    }();
    Object.assign(ya.prototype, {
        addEventListener: function(a, b) {
            void 0 === this._listeners && (this._listeners = {});
            var c = this._listeners;
            void 0 === c[a] && (c[a] = []); - 1 === c[a].indexOf(b) && c[a].push(b)
        },
        hasEventListener: function(a, b) {
            if (void 0 === this._listeners) return !1;
            var c = this._listeners;
            return void 0 !== c[a] && -1 !== c[a].indexOf(b)
        },
        removeEventListener: function(a, b) {
            void 0 !== this._listeners && (a = this._listeners[a], void 0 !== a && (b = a.indexOf(b), -1 !== b && a.splice(b, 1)))
        },
        dispatchEvent: function(a) {
            if (void 0 !==
                this._listeners) {
                var b = this._listeners[a.type];
                if (void 0 !== b) {
                    a.target = this;
                    b = b.slice(0);
                    for (var c = 0, d = b.length; c < d; c++) b[c].call(this, a)
                }
            }
        }
    });
    var H = {
        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI,
        generateUUID: function() {
            for (var a = [], b = 0; 256 > b; b++) a[b] = (16 > b ? "0" : "") + b.toString(16);
            return function() {
                var b = 4294967295 * Math.random() | 0,
                    d = 4294967295 * Math.random() | 0,
                    e = 4294967295 * Math.random() | 0,
                    f = 4294967295 * Math.random() | 0;
                return (a[b & 255] + a[b >> 8 & 255] + a[b >> 16 & 255] + a[b >> 24 & 255] + "-" + a[d & 255] + a[d >> 8 & 255] + "-" + a[d >>
                    16 & 15 | 64] + a[d >> 24 & 255] + "-" + a[e & 63 | 128] + a[e >> 8 & 255] + "-" + a[e >> 16 & 255] + a[e >> 24 & 255] + a[f & 255] + a[f >> 8 & 255] + a[f >> 16 & 255] + a[f >> 24 & 255]).toUpperCase()
            }
        }(),
        clamp: function(a, b, c) {
            return Math.max(b, Math.min(c, a))
        },
        euclideanModulo: function(a, b) {
            return (a % b + b) % b
        },
        mapLinear: function(a, b, c, d, e) {
            return d + (a - b) * (e - d) / (c - b)
        },
        lerp: function(a, b, c) {
            return (1 - c) * a + c * b
        },
        smoothstep: function(a, b, c) {
            if (a <= b) return 0;
            if (a >= c) return 1;
            a = (a - b) / (c - b);
            return a * a * (3 - 2 * a)
        },
        smootherstep: function(a, b, c) {
            if (a <= b) return 0;
            if (a >= c) return 1;
            a = (a - b) / (c - b);
            return a * a * a * (a * (6 * a - 15) + 10)
        },
        randInt: function(a, b) {
            return a + Math.floor(Math.random() * (b - a + 1))
        },
        randFloat: function(a, b) {
            return a + Math.random() * (b - a)
        },
        randFloatSpread: function(a) {
            return a * (.5 - Math.random())
        },
        degToRad: function(a) {
            return a * H.DEG2RAD
        },
        radToDeg: function(a) {
            return a * H.RAD2DEG
        },
        isPowerOfTwo: function(a) {
            return 0 === (a & a - 1) && 0 !== a
        },
        ceilPowerOfTwo: function(a) {
            return Math.pow(2, Math.ceil(Math.log(a) / Math.LN2))
        },
        floorPowerOfTwo: function(a) {
            return Math.pow(2, Math.floor(Math.log(a) /
                Math.LN2))
        }
    };
    Object.defineProperties(z.prototype, {
        width: {
            get: function() {
                return this.x
            },
            set: function(a) {
                this.x = a
            }
        },
        height: {
            get: function() {
                return this.y
            },
            set: function(a) {
                this.y = a
            }
        }
    });
    Object.assign(z.prototype, {
        isVector2: !0,
        set: function(a, b) {
            this.x = a;
            this.y = b;
            return this
        },
        setScalar: function(a) {
            this.y = this.x = a;
            return this
        },
        setX: function(a) {
            this.x = a;
            return this
        },
        setY: function(a) {
            this.y = a;
            return this
        },
        setComponent: function(a, b) {
            switch (a) {
                case 0:
                    this.x = b;
                    break;
                case 1:
                    this.y = b;
                    break;
                default:
                    throw Error("index is out of range: " +
                        a);
            }
            return this
        },
        getComponent: function(a) {
            switch (a) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw Error("index is out of range: " + a);
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y)
        },
        copy: function(a) {
            this.x = a.x;
            this.y = a.y;
            return this
        },
        add: function(a, b) {
            if (void 0 !== b) return console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
            this.x += a.x;
            this.y += a.y;
            return this
        },
        addScalar: function(a) {
            this.x += a;
            this.y += a;
            return this
        },
        addVectors: function(a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            return this
        },
        addScaledVector: function(a, b) {
            this.x += a.x * b;
            this.y += a.y * b;
            return this
        },
        sub: function(a, b) {
            if (void 0 !== b) return console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
            this.x -= a.x;
            this.y -= a.y;
            return this
        },
        subScalar: function(a) {
            this.x -= a;
            this.y -= a;
            return this
        },
        subVectors: function(a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            return this
        },
        multiply: function(a) {
            this.x *= a.x;
            this.y *=
                a.y;
            return this
        },
        multiplyScalar: function(a) {
            this.x *= a;
            this.y *= a;
            return this
        },
        divide: function(a) {
            this.x /= a.x;
            this.y /= a.y;
            return this
        },
        divideScalar: function(a) {
            return this.multiplyScalar(1 / a)
        },
        applyMatrix3: function(a) {
            var b = this.x,
                c = this.y;
            a = a.elements;
            this.x = a[0] * b + a[3] * c + a[6];
            this.y = a[1] * b + a[4] * c + a[7];
            return this
        },
        min: function(a) {
            this.x = Math.min(this.x, a.x);
            this.y = Math.min(this.y, a.y);
            return this
        },
        max: function(a) {
            this.x = Math.max(this.x, a.x);
            this.y = Math.max(this.y, a.y);
            return this
        },
        clamp: function(a,
            b) {
            this.x = Math.max(a.x, Math.min(b.x, this.x));
            this.y = Math.max(a.y, Math.min(b.y, this.y));
            return this
        },
        clampScalar: function() {
            var a = new z,
                b = new z;
            return function(c, d) {
                a.set(c, c);
                b.set(d, d);
                return this.clamp(a, b)
            }
        }(),
        clampLength: function(a, b) {
            var c = this.length();
            return this.divideScalar(c || 1).multiplyScalar(Math.max(a, Math.min(b, c)))
        },
        floor: function() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            return this
        },
        ceil: function() {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            return this
        },
        round: function() {
            this.x =
                Math.round(this.x);
            this.y = Math.round(this.y);
            return this
        },
        roundToZero: function() {
            this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
            this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
            return this
        },
        negate: function() {
            this.x = -this.x;
            this.y = -this.y;
            return this
        },
        dot: function(a) {
            return this.x * a.x + this.y * a.y
        },
        cross: function(a) {
            return this.x * a.y - this.y * a.x
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        manhattanLength: function() {
            return Math.abs(this.x) +
                Math.abs(this.y)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        angle: function() {
            var a = Math.atan2(this.y, this.x);
            0 > a && (a += 2 * Math.PI);
            return a
        },
        distanceTo: function(a) {
            return Math.sqrt(this.distanceToSquared(a))
        },
        distanceToSquared: function(a) {
            var b = this.x - a.x;
            a = this.y - a.y;
            return b * b + a * a
        },
        manhattanDistanceTo: function(a) {
            return Math.abs(this.x - a.x) + Math.abs(this.y - a.y)
        },
        setLength: function(a) {
            return this.normalize().multiplyScalar(a)
        },
        lerp: function(a, b) {
            this.x += (a.x - this.x) * b;
            this.y +=
                (a.y - this.y) * b;
            return this
        },
        lerpVectors: function(a, b, c) {
            return this.subVectors(b, a).multiplyScalar(c).add(a)
        },
        equals: function(a) {
            return a.x === this.x && a.y === this.y
        },
        fromArray: function(a, b) {
            void 0 === b && (b = 0);
            this.x = a[b];
            this.y = a[b + 1];
            return this
        },
        toArray: function(a, b) {
            void 0 === a && (a = []);
            void 0 === b && (b = 0);
            a[b] = this.x;
            a[b + 1] = this.y;
            return a
        },
        fromBufferAttribute: function(a, b, c) {
            void 0 !== c && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
            this.x = a.getX(b);
            this.y = a.getY(b);
            return this
        },
        rotateAround: function(a, b) {
            var c = Math.cos(b);
            b = Math.sin(b);
            var d = this.x - a.x,
                e = this.y - a.y;
            this.x = d * c - e * b + a.x;
            this.y = d * b + e * c + a.y;
            return this
        }
    });
    Object.assign(I.prototype, {
        isMatrix4: !0,
        set: function(a, b, c, d, e, f, g, h, k, m, q, n, l, u, r, p) {
            var t = this.elements;
            t[0] = a;
            t[4] = b;
            t[8] = c;
            t[12] = d;
            t[1] = e;
            t[5] = f;
            t[9] = g;
            t[13] = h;
            t[2] = k;
            t[6] = m;
            t[10] = q;
            t[14] = n;
            t[3] = l;
            t[7] = u;
            t[11] = r;
            t[15] = p;
            return this
        },
        identity: function() {
            this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            return this
        },
        clone: function() {
            return (new I).fromArray(this.elements)
        },
        copy: function(a) {
            var b = this.elements;
            a = a.elements;
            b[0] = a[0];
            b[1] = a[1];
            b[2] = a[2];
            b[3] = a[3];
            b[4] = a[4];
            b[5] = a[5];
            b[6] = a[6];
            b[7] = a[7];
            b[8] = a[8];
            b[9] = a[9];
            b[10] = a[10];
            b[11] = a[11];
            b[12] = a[12];
            b[13] = a[13];
            b[14] = a[14];
            b[15] = a[15];
            return this
        },
        copyPosition: function(a) {
            var b = this.elements;
            a = a.elements;
            b[12] = a[12];
            b[13] = a[13];
            b[14] = a[14];
            return this
        },
        extractBasis: function(a, b, c) {
            a.setFromMatrixColumn(this, 0);
            b.setFromMatrixColumn(this, 1);
            c.setFromMatrixColumn(this, 2);
            return this
        },
        makeBasis: function(a, b, c) {
            this.set(a.x,
                b.x, c.x, 0, a.y, b.y, c.y, 0, a.z, b.z, c.z, 0, 0, 0, 0, 1);
            return this
        },
        extractRotation: function() {
            var a = new p;
            return function(b) {
                var c = this.elements,
                    d = b.elements,
                    e = 1 / a.setFromMatrixColumn(b, 0).length(),
                    f = 1 / a.setFromMatrixColumn(b, 1).length();
                b = 1 / a.setFromMatrixColumn(b, 2).length();
                c[0] = d[0] * e;
                c[1] = d[1] * e;
                c[2] = d[2] * e;
                c[3] = 0;
                c[4] = d[4] * f;
                c[5] = d[5] * f;
                c[6] = d[6] * f;
                c[7] = 0;
                c[8] = d[8] * b;
                c[9] = d[9] * b;
                c[10] = d[10] * b;
                c[11] = 0;
                c[12] = 0;
                c[13] = 0;
                c[14] = 0;
                c[15] = 1;
                return this
            }
        }(),
        makeRotationFromEuler: function(a) {
            a && a.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var b = this.elements,
                c = a.x,
                d = a.y,
                e = a.z,
                f = Math.cos(c);
            c = Math.sin(c);
            var g = Math.cos(d);
            d = Math.sin(d);
            var h = Math.cos(e);
            e = Math.sin(e);
            if ("XYZ" === a.order) {
                a = f * h;
                var k = f * e,
                    m = c * h,
                    q = c * e;
                b[0] = g * h;
                b[4] = -g * e;
                b[8] = d;
                b[1] = k + m * d;
                b[5] = a - q * d;
                b[9] = -c * g;
                b[2] = q - a * d;
                b[6] = m + k * d;
                b[10] = f * g
            } else "YXZ" === a.order ? (a = g * h, k = g * e, m = d * h, q = d * e, b[0] = a + q * c, b[4] = m * c - k, b[8] = f * d, b[1] = f * e, b[5] = f * h, b[9] = -c, b[2] = k * c - m, b[6] = q + a * c, b[10] = f * g) : "ZXY" === a.order ? (a = g * h, k = g * e, m = d * h, q = d * e, b[0] = a - q * c, b[4] = -f * e, b[8] = m + k * c, b[1] = k + m * c, b[5] = f * h, b[9] =
                q - a * c, b[2] = -f * d, b[6] = c, b[10] = f * g) : "ZYX" === a.order ? (a = f * h, k = f * e, m = c * h, q = c * e, b[0] = g * h, b[4] = m * d - k, b[8] = a * d + q, b[1] = g * e, b[5] = q * d + a, b[9] = k * d - m, b[2] = -d, b[6] = c * g, b[10] = f * g) : "YZX" === a.order ? (a = f * g, k = f * d, m = c * g, q = c * d, b[0] = g * h, b[4] = q - a * e, b[8] = m * e + k, b[1] = e, b[5] = f * h, b[9] = -c * h, b[2] = -d * h, b[6] = k * e + m, b[10] = a - q * e) : "XZY" === a.order && (a = f * g, k = f * d, m = c * g, q = c * d, b[0] = g * h, b[4] = -e, b[8] = d * h, b[1] = a * e + q, b[5] = f * h, b[9] = k * e - m, b[2] = m * e - k, b[6] = c * h, b[10] = q * e + a);
            b[3] = 0;
            b[7] = 0;
            b[11] = 0;
            b[12] = 0;
            b[13] = 0;
            b[14] = 0;
            b[15] = 1;
            return this
        },
        makeRotationFromQuaternion: function() {
            var a =
                new p(0, 0, 0),
                b = new p(1, 1, 1);
            return function(c) {
                return this.compose(a, c, b)
            }
        }(),
        lookAt: function() {
            var a = new p,
                b = new p,
                c = new p;
            return function(d, e, f) {
                var g = this.elements;
                c.subVectors(d, e);
                0 === c.lengthSq() && (c.z = 1);
                c.normalize();
                a.crossVectors(f, c);
                0 === a.lengthSq() && (1 === Math.abs(f.z) ? c.x += 1E-4 : c.z += 1E-4, c.normalize(), a.crossVectors(f, c));
                a.normalize();
                b.crossVectors(c, a);
                g[0] = a.x;
                g[4] = b.x;
                g[8] = c.x;
                g[1] = a.y;
                g[5] = b.y;
                g[9] = c.y;
                g[2] = a.z;
                g[6] = b.z;
                g[10] = c.z;
                return this
            }
        }(),
        multiply: function(a, b) {
            return void 0 !==
                b ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(a, b)) : this.multiplyMatrices(this, a)
        },
        premultiply: function(a) {
            return this.multiplyMatrices(a, this)
        },
        multiplyMatrices: function(a, b) {
            var c = a.elements,
                d = b.elements;
            b = this.elements;
            a = c[0];
            var e = c[4],
                f = c[8],
                g = c[12],
                h = c[1],
                k = c[5],
                m = c[9],
                q = c[13],
                n = c[2],
                l = c[6],
                u = c[10],
                r = c[14],
                p = c[3],
                y = c[7],
                x = c[11];
            c = c[15];
            var w = d[0],
                B = d[4],
                E = d[8],
                P = d[12],
                N = d[1],
                z = d[5],
                A = d[9],
                D = d[13],
                C = d[2],
                H = d[6],
                G = d[10],
                K = d[14],
                L = d[3],
                I = d[7],
                J = d[11];
            d = d[15];
            b[0] = a * w + e * N + f * C + g * L;
            b[4] = a * B + e * z + f * H + g * I;
            b[8] = a * E + e * A + f * G + g * J;
            b[12] = a * P + e * D + f * K + g * d;
            b[1] = h * w + k * N + m * C + q * L;
            b[5] = h * B + k * z + m * H + q * I;
            b[9] = h * E + k * A + m * G + q * J;
            b[13] = h * P + k * D + m * K + q * d;
            b[2] = n * w + l * N + u * C + r * L;
            b[6] = n * B + l * z + u * H + r * I;
            b[10] = n * E + l * A + u * G + r * J;
            b[14] = n * P + l * D + u * K + r * d;
            b[3] = p * w + y * N + x * C + c * L;
            b[7] = p * B + y * z + x * H + c * I;
            b[11] = p * E + y * A + x * G + c * J;
            b[15] = p * P + y * D + x * K + c * d;
            return this
        },
        multiplyScalar: function(a) {
            var b = this.elements;
            b[0] *= a;
            b[4] *= a;
            b[8] *= a;
            b[12] *= a;
            b[1] *= a;
            b[5] *=
                a;
            b[9] *= a;
            b[13] *= a;
            b[2] *= a;
            b[6] *= a;
            b[10] *= a;
            b[14] *= a;
            b[3] *= a;
            b[7] *= a;
            b[11] *= a;
            b[15] *= a;
            return this
        },
        applyToBufferAttribute: function() {
            var a = new p;
            return function(b) {
                for (var c = 0, d = b.count; c < d; c++) a.x = b.getX(c), a.y = b.getY(c), a.z = b.getZ(c), a.applyMatrix4(this), b.setXYZ(c, a.x, a.y, a.z);
                return b
            }
        }(),
        determinant: function() {
            var a = this.elements,
                b = a[0],
                c = a[4],
                d = a[8],
                e = a[12],
                f = a[1],
                g = a[5],
                h = a[9],
                k = a[13],
                m = a[2],
                q = a[6],
                n = a[10],
                l = a[14];
            return a[3] * (+e * h * q - d * k * q - e * g * n + c * k * n + d * g * l - c * h * l) + a[7] * (+b * h * l - b * k * n + e * f * n -
                d * f * l + d * k * m - e * h * m) + a[11] * (+b * k * q - b * g * l - e * f * q + c * f * l + e * g * m - c * k * m) + a[15] * (-d * g * m - b * h * q + b * g * n + d * f * q - c * f * n + c * h * m)
        },
        transpose: function() {
            var a = this.elements;
            var b = a[1];
            a[1] = a[4];
            a[4] = b;
            b = a[2];
            a[2] = a[8];
            a[8] = b;
            b = a[6];
            a[6] = a[9];
            a[9] = b;
            b = a[3];
            a[3] = a[12];
            a[12] = b;
            b = a[7];
            a[7] = a[13];
            a[13] = b;
            b = a[11];
            a[11] = a[14];
            a[14] = b;
            return this
        },
        setPosition: function(a) {
            var b = this.elements;
            b[12] = a.x;
            b[13] = a.y;
            b[14] = a.z;
            return this
        },
        getInverse: function(a, b) {
            var c = this.elements,
                d = a.elements;
            a = d[0];
            var e = d[1],
                f = d[2],
                g = d[3],
                h = d[4],
                k = d[5],
                m = d[6],
                q = d[7],
                n = d[8],
                l = d[9],
                u = d[10],
                r = d[11],
                p = d[12],
                y = d[13],
                x = d[14];
            d = d[15];
            var w = l * x * q - y * u * q + y * m * r - k * x * r - l * m * d + k * u * d,
                B = p * u * q - n * x * q - p * m * r + h * x * r + n * m * d - h * u * d,
                E = n * y * q - p * l * q + p * k * r - h * y * r - n * k * d + h * l * d,
                z = p * l * m - n * y * m - p * k * u + h * y * u + n * k * x - h * l * x,
                N = a * w + e * B + f * E + g * z;
            if (0 === N) {
                if (!0 === b) throw Error("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0");
                console.warn("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0");
                return this.identity()
            }
            b = 1 / N;
            c[0] = w * b;
            c[1] = (y * u * g - l * x * g - y * f *
                r + e * x * r + l * f * d - e * u * d) * b;
            c[2] = (k * x * g - y * m * g + y * f * q - e * x * q - k * f * d + e * m * d) * b;
            c[3] = (l * m * g - k * u * g - l * f * q + e * u * q + k * f * r - e * m * r) * b;
            c[4] = B * b;
            c[5] = (n * x * g - p * u * g + p * f * r - a * x * r - n * f * d + a * u * d) * b;
            c[6] = (p * m * g - h * x * g - p * f * q + a * x * q + h * f * d - a * m * d) * b;
            c[7] = (h * u * g - n * m * g + n * f * q - a * u * q - h * f * r + a * m * r) * b;
            c[8] = E * b;
            c[9] = (p * l * g - n * y * g - p * e * r + a * y * r + n * e * d - a * l * d) * b;
            c[10] = (h * y * g - p * k * g + p * e * q - a * y * q - h * e * d + a * k * d) * b;
            c[11] = (n * k * g - h * l * g - n * e * q + a * l * q + h * e * r - a * k * r) * b;
            c[12] = z * b;
            c[13] = (n * y * f - p * l * f + p * e * u - a * y * u - n * e * x + a * l * x) * b;
            c[14] = (p * k * f - h * y * f - p * e * m + a * y * m + h * e * x - a * k * x) *
                b;
            c[15] = (h * l * f - n * k * f + n * e * m - a * l * m - h * e * u + a * k * u) * b;
            return this
        },
        scale: function(a) {
            var b = this.elements,
                c = a.x,
                d = a.y;
            a = a.z;
            b[0] *= c;
            b[4] *= d;
            b[8] *= a;
            b[1] *= c;
            b[5] *= d;
            b[9] *= a;
            b[2] *= c;
            b[6] *= d;
            b[10] *= a;
            b[3] *= c;
            b[7] *= d;
            b[11] *= a;
            return this
        },
        getMaxScaleOnAxis: function() {
            var a = this.elements;
            return Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], a[4] * a[4] + a[5] * a[5] + a[6] * a[6], a[8] * a[8] + a[9] * a[9] + a[10] * a[10]))
        },
        makeTranslation: function(a, b, c) {
            this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1);
            return this
        },
        makeRotationX: function(a) {
            var b =
                Math.cos(a);
            a = Math.sin(a);
            this.set(1, 0, 0, 0, 0, b, -a, 0, 0, a, b, 0, 0, 0, 0, 1);
            return this
        },
        makeRotationY: function(a) {
            var b = Math.cos(a);
            a = Math.sin(a);
            this.set(b, 0, a, 0, 0, 1, 0, 0, -a, 0, b, 0, 0, 0, 0, 1);
            return this
        },
        makeRotationZ: function(a) {
            var b = Math.cos(a);
            a = Math.sin(a);
            this.set(b, -a, 0, 0, a, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            return this
        },
        makeRotationAxis: function(a, b) {
            var c = Math.cos(b);
            b = Math.sin(b);
            var d = 1 - c,
                e = a.x,
                f = a.y;
            a = a.z;
            var g = d * e,
                h = d * f;
            this.set(g * e + c, g * f - b * a, g * a + b * f, 0, g * f + b * a, h * f + c, h * a - b * e, 0, g * a - b * f, h * a + b * e, d * a * a + c, 0, 0,
                0, 0, 1);
            return this
        },
        makeScale: function(a, b, c) {
            this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1);
            return this
        },
        makeShear: function(a, b, c) {
            this.set(1, b, c, 0, a, 1, c, 0, a, b, 1, 0, 0, 0, 0, 1);
            return this
        },
        compose: function(a, b, c) {
            var d = this.elements,
                e = b._x,
                f = b._y,
                g = b._z,
                h = b._w,
                k = e + e,
                m = f + f,
                q = g + g;
            b = e * k;
            var l = e * m;
            e *= q;
            var t = f * m;
            f *= q;
            g *= q;
            k *= h;
            m *= h;
            h *= q;
            q = c.x;
            var u = c.y;
            c = c.z;
            d[0] = (1 - (t + g)) * q;
            d[1] = (l + h) * q;
            d[2] = (e - m) * q;
            d[3] = 0;
            d[4] = (l - h) * u;
            d[5] = (1 - (b + g)) * u;
            d[6] = (f + k) * u;
            d[7] = 0;
            d[8] = (e + m) * c;
            d[9] = (f - k) * c;
            d[10] = (1 - (b + t)) * c;
            d[11] = 0;
            d[12] = a.x;
            d[13] = a.y;
            d[14] = a.z;
            d[15] = 1;
            return this
        },
        decompose: function() {
            var a = new p,
                b = new I;
            return function(c, d, e) {
                var f = this.elements,
                    g = a.set(f[0], f[1], f[2]).length(),
                    h = a.set(f[4], f[5], f[6]).length(),
                    k = a.set(f[8], f[9], f[10]).length();
                0 > this.determinant() && (g = -g);
                c.x = f[12];
                c.y = f[13];
                c.z = f[14];
                b.copy(this);
                c = 1 / g;
                f = 1 / h;
                var m = 1 / k;
                b.elements[0] *= c;
                b.elements[1] *= c;
                b.elements[2] *= c;
                b.elements[4] *= f;
                b.elements[5] *= f;
                b.elements[6] *= f;
                b.elements[8] *= m;
                b.elements[9] *= m;
                b.elements[10] *= m;
                d.setFromRotationMatrix(b);
                e.x = g;
                e.y = h;
                e.z = k;
                return this
            }
        }(),
        makePerspective: function(a, b, c, d, e, f) {
            void 0 === f && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
            var g = this.elements;
            g[0] = 2 * e / (b - a);
            g[4] = 0;
            g[8] = (b + a) / (b - a);
            g[12] = 0;
            g[1] = 0;
            g[5] = 2 * e / (c - d);
            g[9] = (c + d) / (c - d);
            g[13] = 0;
            g[2] = 0;
            g[6] = 0;
            g[10] = -(f + e) / (f - e);
            g[14] = -2 * f * e / (f - e);
            g[3] = 0;
            g[7] = 0;
            g[11] = -1;
            g[15] = 0;
            return this
        },
        makeOrthographic: function(a, b, c, d, e, f) {
            var g = this.elements,
                h = 1 / (b - a),
                k = 1 / (c - d),
                m = 1 / (f - e);
            g[0] =
                2 * h;
            g[4] = 0;
            g[8] = 0;
            g[12] = -((b + a) * h);
            g[1] = 0;
            g[5] = 2 * k;
            g[9] = 0;
            g[13] = -((c + d) * k);
            g[2] = 0;
            g[6] = 0;
            g[10] = -2 * m;
            g[14] = -((f + e) * m);
            g[3] = 0;
            g[7] = 0;
            g[11] = 0;
            g[15] = 1;
            return this
        },
        equals: function(a) {
            var b = this.elements;
            a = a.elements;
            for (var c = 0; 16 > c; c++)
                if (b[c] !== a[c]) return !1;
            return !0
        },
        fromArray: function(a, b) {
            void 0 === b && (b = 0);
            for (var c = 0; 16 > c; c++) this.elements[c] = a[c + b];
            return this
        },
        toArray: function(a, b) {
            void 0 === a && (a = []);
            void 0 === b && (b = 0);
            var c = this.elements;
            a[b] = c[0];
            a[b + 1] = c[1];
            a[b + 2] = c[2];
            a[b + 3] = c[3];
            a[b + 4] = c[4];
            a[b + 5] = c[5];
            a[b + 6] = c[6];
            a[b + 7] = c[7];
            a[b + 8] = c[8];
            a[b + 9] = c[9];
            a[b + 10] = c[10];
            a[b + 11] = c[11];
            a[b + 12] = c[12];
            a[b + 13] = c[13];
            a[b + 14] = c[14];
            a[b + 15] = c[15];
            return a
        }
    });
    Object.assign(fa, {
        slerp: function(a, b, c, d) {
            return c.copy(a).slerp(b, d)
        },
        slerpFlat: function(a, b, c, d, e, f, g) {
            var h = c[d + 0],
                k = c[d + 1],
                m = c[d + 2];
            c = c[d + 3];
            d = e[f + 0];
            var q = e[f + 1],
                l = e[f + 2];
            e = e[f + 3];
            if (c !== e || h !== d || k !== q || m !== l) {
                f = 1 - g;
                var t = h * d + k * q + m * l + c * e,
                    u = 0 <= t ? 1 : -1,
                    r = 1 - t * t;
                r > Number.EPSILON && (r = Math.sqrt(r), t = Math.atan2(r, t * u), f = Math.sin(f * t) / r, g = Math.sin(g *
                    t) / r);
                u *= g;
                h = h * f + d * u;
                k = k * f + q * u;
                m = m * f + l * u;
                c = c * f + e * u;
                f === 1 - g && (g = 1 / Math.sqrt(h * h + k * k + m * m + c * c), h *= g, k *= g, m *= g, c *= g)
            }
            a[b] = h;
            a[b + 1] = k;
            a[b + 2] = m;
            a[b + 3] = c
        }
    });
    Object.defineProperties(fa.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(a) {
                this._x = a;
                this.onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(a) {
                this._y = a;
                this.onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(a) {
                this._z = a;
                this.onChangeCallback()
            }
        },
        w: {
            get: function() {
                return this._w
            },
            set: function(a) {
                this._w =
                    a;
                this.onChangeCallback()
            }
        }
    });
    Object.assign(fa.prototype, {
        set: function(a, b, c, d) {
            this._x = a;
            this._y = b;
            this._z = c;
            this._w = d;
            this.onChangeCallback();
            return this
        },
        clone: function() {
            return new this.constructor(this._x, this._y, this._z, this._w)
        },
        copy: function(a) {
            this._x = a.x;
            this._y = a.y;
            this._z = a.z;
            this._w = a.w;
            this.onChangeCallback();
            return this
        },
        setFromEuler: function(a, b) {
            if (!a || !a.isEuler) throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            var c =
                a._x,
                d = a._y,
                e = a._z;
            a = a.order;
            var f = Math.cos,
                g = Math.sin,
                h = f(c / 2),
                k = f(d / 2);
            f = f(e / 2);
            c = g(c / 2);
            d = g(d / 2);
            e = g(e / 2);
            "XYZ" === a ? (this._x = c * k * f + h * d * e, this._y = h * d * f - c * k * e, this._z = h * k * e + c * d * f, this._w = h * k * f - c * d * e) : "YXZ" === a ? (this._x = c * k * f + h * d * e, this._y = h * d * f - c * k * e, this._z = h * k * e - c * d * f, this._w = h * k * f + c * d * e) : "ZXY" === a ? (this._x = c * k * f - h * d * e, this._y = h * d * f + c * k * e, this._z = h * k * e + c * d * f, this._w = h * k * f - c * d * e) : "ZYX" === a ? (this._x = c * k * f - h * d * e, this._y = h * d * f + c * k * e, this._z = h * k * e - c * d * f, this._w = h * k * f + c * d * e) : "YZX" === a ? (this._x = c * k * f +
                h * d * e, this._y = h * d * f + c * k * e, this._z = h * k * e - c * d * f, this._w = h * k * f - c * d * e) : "XZY" === a && (this._x = c * k * f - h * d * e, this._y = h * d * f - c * k * e, this._z = h * k * e + c * d * f, this._w = h * k * f + c * d * e);
            if (!1 !== b) this.onChangeCallback();
            return this
        },
        setFromAxisAngle: function(a, b) {
            b /= 2;
            var c = Math.sin(b);
            this._x = a.x * c;
            this._y = a.y * c;
            this._z = a.z * c;
            this._w = Math.cos(b);
            this.onChangeCallback();
            return this
        },
        setFromRotationMatrix: function(a) {
            var b = a.elements,
                c = b[0];
            a = b[4];
            var d = b[8],
                e = b[1],
                f = b[5],
                g = b[9],
                h = b[2],
                k = b[6];
            b = b[10];
            var m = c + f + b;
            0 < m ? (c = .5 /
                Math.sqrt(m + 1), this._w = .25 / c, this._x = (k - g) * c, this._y = (d - h) * c, this._z = (e - a) * c) : c > f && c > b ? (c = 2 * Math.sqrt(1 + c - f - b), this._w = (k - g) / c, this._x = .25 * c, this._y = (a + e) / c, this._z = (d + h) / c) : f > b ? (c = 2 * Math.sqrt(1 + f - c - b), this._w = (d - h) / c, this._x = (a + e) / c, this._y = .25 * c, this._z = (g + k) / c) : (c = 2 * Math.sqrt(1 + b - c - f), this._w = (e - a) / c, this._x = (d + h) / c, this._y = (g + k) / c, this._z = .25 * c);
            this.onChangeCallback();
            return this
        },
        setFromUnitVectors: function() {
            var a = new p,
                b;
            return function(c, d) {
                void 0 === a && (a = new p);
                b = c.dot(d) + 1;
                1E-6 > b ? (b = 0,
                    Math.abs(c.x) > Math.abs(c.z) ? a.set(-c.y, c.x, 0) : a.set(0, -c.z, c.y)) : a.crossVectors(c, d);
                this._x = a.x;
                this._y = a.y;
                this._z = a.z;
                this._w = b;
                return this.normalize()
            }
        }(),
        angleTo: function(a) {
            return 2 * Math.acos(Math.abs(H.clamp(this.dot(a), -1, 1)))
        },
        rotateTowards: function(a, b) {
            var c = this.angleTo(a);
            if (0 === c) return this;
            this.slerp(a, Math.min(1, b / c));
            return this
        },
        inverse: function() {
            return this.conjugate()
        },
        conjugate: function() {
            this._x *= -1;
            this._y *= -1;
            this._z *= -1;
            this.onChangeCallback();
            return this
        },
        dot: function(a) {
            return this._x *
                a._x + this._y * a._y + this._z * a._z + this._w * a._w
        },
        lengthSq: function() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        },
        length: function() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        },
        normalize: function() {
            var a = this.length();
            0 === a ? (this._z = this._y = this._x = 0, this._w = 1) : (a = 1 / a, this._x *= a, this._y *= a, this._z *= a, this._w *= a);
            this.onChangeCallback();
            return this
        },
        multiply: function(a, b) {
            return void 0 !== b ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),
                this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a)
        },
        premultiply: function(a) {
            return this.multiplyQuaternions(a, this)
        },
        multiplyQuaternions: function(a, b) {
            var c = a._x,
                d = a._y,
                e = a._z;
            a = a._w;
            var f = b._x,
                g = b._y,
                h = b._z;
            b = b._w;
            this._x = c * b + a * f + d * h - e * g;
            this._y = d * b + a * g + e * f - c * h;
            this._z = e * b + a * h + c * g - d * f;
            this._w = a * b - c * f - d * g - e * h;
            this.onChangeCallback();
            return this
        },
        slerp: function(a, b) {
            if (0 === b) return this;
            if (1 === b) return this.copy(a);
            var c = this._x,
                d = this._y,
                e = this._z,
                f = this._w,
                g = f * a._w + c * a._x + d * a._y + e * a._z;
            0 > g ? (this._w = -a._w, this._x = -a._x, this._y = -a._y, this._z = -a._z, g = -g) : this.copy(a);
            if (1 <= g) return this._w = f, this._x = c, this._y = d, this._z = e, this;
            a = 1 - g * g;
            if (a <= Number.EPSILON) return g = 1 - b, this._w = g * f + b * this._w, this._x = g * c + b * this._x, this._y = g * d + b * this._y, this._z = g * e + b * this._z, this.normalize();
            a = Math.sqrt(a);
            var h = Math.atan2(a, g);
            g = Math.sin((1 - b) * h) / a;
            b = Math.sin(b * h) / a;
            this._w = f * g + this._w * b;
            this._x = c * g + this._x * b;
            this._y = d * g + this._y * b;
            this._z = e * g + this._z * b;
            this.onChangeCallback();
            return this
        },
        equals: function(a) {
            return a._x ===
                this._x && a._y === this._y && a._z === this._z && a._w === this._w
        },
        fromArray: function(a, b) {
            void 0 === b && (b = 0);
            this._x = a[b];
            this._y = a[b + 1];
            this._z = a[b + 2];
            this._w = a[b + 3];
            this.onChangeCallback();
            return this
        },
        toArray: function(a, b) {
            void 0 === a && (a = []);
            void 0 === b && (b = 0);
            a[b] = this._x;
            a[b + 1] = this._y;
            a[b + 2] = this._z;
            a[b + 3] = this._w;
            return a
        },
        onChange: function(a) {
            this.onChangeCallback = a;
            return this
        },
        onChangeCallback: function() {}
    });
    Object.assign(p.prototype, {
        isVector3: !0,
        set: function(a, b, c) {
            this.x = a;
            this.y = b;
            this.z = c;
            return this
        },
        setScalar: function(a) {
            this.z = this.y = this.x = a;
            return this
        },
        setX: function(a) {
            this.x = a;
            return this
        },
        setY: function(a) {
            this.y = a;
            return this
        },
        setZ: function(a) {
            this.z = a;
            return this
        },
        setComponent: function(a, b) {
            switch (a) {
                case 0:
                    this.x = b;
                    break;
                case 1:
                    this.y = b;
                    break;
                case 2:
                    this.z = b;
                    break;
                default:
                    throw Error("index is out of range: " + a);
            }
            return this
        },
        getComponent: function(a) {
            switch (a) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw Error("index is out of range: " + a);
            }
        },
        clone: function() {
            return new this.constructor(this.x,
                this.y, this.z)
        },
        copy: function(a) {
            this.x = a.x;
            this.y = a.y;
            this.z = a.z;
            return this
        },
        add: function(a, b) {
            if (void 0 !== b) return console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
            this.x += a.x;
            this.y += a.y;
            this.z += a.z;
            return this
        },
        addScalar: function(a) {
            this.x += a;
            this.y += a;
            this.z += a;
            return this
        },
        addVectors: function(a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            this.z = a.z + b.z;
            return this
        },
        addScaledVector: function(a, b) {
            this.x += a.x * b;
            this.y += a.y * b;
            this.z +=
                a.z * b;
            return this
        },
        sub: function(a, b) {
            if (void 0 !== b) return console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
            this.x -= a.x;
            this.y -= a.y;
            this.z -= a.z;
            return this
        },
        subScalar: function(a) {
            this.x -= a;
            this.y -= a;
            this.z -= a;
            return this
        },
        subVectors: function(a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            this.z = a.z - b.z;
            return this
        },
        multiply: function(a, b) {
            if (void 0 !== b) return console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),
                this.multiplyVectors(a, b);
            this.x *= a.x;
            this.y *= a.y;
            this.z *= a.z;
            return this
        },
        multiplyScalar: function(a) {
            this.x *= a;
            this.y *= a;
            this.z *= a;
            return this
        },
        multiplyVectors: function(a, b) {
            this.x = a.x * b.x;
            this.y = a.y * b.y;
            this.z = a.z * b.z;
            return this
        },
        applyEuler: function() {
            var a = new fa;
            return function(b) {
                b && b.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
                return this.applyQuaternion(a.setFromEuler(b))
            }
        }(),
        applyAxisAngle: function() {
            var a = new fa;
            return function(b,
                c) {
                return this.applyQuaternion(a.setFromAxisAngle(b, c))
            }
        }(),
        applyMatrix3: function(a) {
            var b = this.x,
                c = this.y,
                d = this.z;
            a = a.elements;
            this.x = a[0] * b + a[3] * c + a[6] * d;
            this.y = a[1] * b + a[4] * c + a[7] * d;
            this.z = a[2] * b + a[5] * c + a[8] * d;
            return this
        },
        applyMatrix4: function(a) {
            var b = this.x,
                c = this.y,
                d = this.z;
            a = a.elements;
            var e = 1 / (a[3] * b + a[7] * c + a[11] * d + a[15]);
            this.x = (a[0] * b + a[4] * c + a[8] * d + a[12]) * e;
            this.y = (a[1] * b + a[5] * c + a[9] * d + a[13]) * e;
            this.z = (a[2] * b + a[6] * c + a[10] * d + a[14]) * e;
            return this
        },
        applyQuaternion: function(a) {
            var b = this.x,
                c = this.y,
                d = this.z,
                e = a.x,
                f = a.y,
                g = a.z;
            a = a.w;
            var h = a * b + f * d - g * c,
                k = a * c + g * b - e * d,
                m = a * d + e * c - f * b;
            b = -e * b - f * c - g * d;
            this.x = h * a + b * -e + k * -g - m * -f;
            this.y = k * a + b * -f + m * -e - h * -g;
            this.z = m * a + b * -g + h * -f - k * -e;
            return this
        },
        project: function() {
            var a = new I;
            return function(b) {
                a.multiplyMatrices(b.projectionMatrix, a.getInverse(b.matrixWorld));
                return this.applyMatrix4(a)
            }
        }(),
        unproject: function() {
            var a = new I;
            return function(b) {
                a.multiplyMatrices(b.matrixWorld, a.getInverse(b.projectionMatrix));
                return this.applyMatrix4(a)
            }
        }(),
        transformDirection: function(a) {
            var b =
                this.x,
                c = this.y,
                d = this.z;
            a = a.elements;
            this.x = a[0] * b + a[4] * c + a[8] * d;
            this.y = a[1] * b + a[5] * c + a[9] * d;
            this.z = a[2] * b + a[6] * c + a[10] * d;
            return this.normalize()
        },
        divide: function(a) {
            this.x /= a.x;
            this.y /= a.y;
            this.z /= a.z;
            return this
        },
        divideScalar: function(a) {
            return this.multiplyScalar(1 / a)
        },
        min: function(a) {
            this.x = Math.min(this.x, a.x);
            this.y = Math.min(this.y, a.y);
            this.z = Math.min(this.z, a.z);
            return this
        },
        max: function(a) {
            this.x = Math.max(this.x, a.x);
            this.y = Math.max(this.y, a.y);
            this.z = Math.max(this.z, a.z);
            return this
        },
        clamp: function(a,
            b) {
            this.x = Math.max(a.x, Math.min(b.x, this.x));
            this.y = Math.max(a.y, Math.min(b.y, this.y));
            this.z = Math.max(a.z, Math.min(b.z, this.z));
            return this
        },
        clampScalar: function() {
            var a = new p,
                b = new p;
            return function(c, d) {
                a.set(c, c, c);
                b.set(d, d, d);
                return this.clamp(a, b)
            }
        }(),
        clampLength: function(a, b) {
            var c = this.length();
            return this.divideScalar(c || 1).multiplyScalar(Math.max(a, Math.min(b, c)))
        },
        floor: function() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            this.z = Math.floor(this.z);
            return this
        },
        ceil: function() {
            this.x =
                Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            this.z = Math.ceil(this.z);
            return this
        },
        round: function() {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            this.z = Math.round(this.z);
            return this
        },
        roundToZero: function() {
            this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
            this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
            this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
            return this
        },
        negate: function() {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            return this
        },
        dot: function(a) {
            return this.x * a.x + this.y *
                a.y + this.z * a.z
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(a) {
            return this.normalize().multiplyScalar(a)
        },
        lerp: function(a, b) {
            this.x += (a.x - this.x) * b;
            this.y += (a.y - this.y) * b;
            this.z += (a.z - this.z) * b;
            return this
        },
        lerpVectors: function(a,
            b, c) {
            return this.subVectors(b, a).multiplyScalar(c).add(a)
        },
        cross: function(a, b) {
            return void 0 !== b ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(a, b)) : this.crossVectors(this, a)
        },
        crossVectors: function(a, b) {
            var c = a.x,
                d = a.y;
            a = a.z;
            var e = b.x,
                f = b.y;
            b = b.z;
            this.x = d * b - a * f;
            this.y = a * e - c * b;
            this.z = c * f - d * e;
            return this
        },
        projectOnVector: function(a) {
            var b = a.dot(this) / a.lengthSq();
            return this.copy(a).multiplyScalar(b)
        },
        projectOnPlane: function() {
            var a =
                new p;
            return function(b) {
                a.copy(this).projectOnVector(b);
                return this.sub(a)
            }
        }(),
        reflect: function() {
            var a = new p;
            return function(b) {
                return this.sub(a.copy(b).multiplyScalar(2 * this.dot(b)))
            }
        }(),
        angleTo: function(a) {
            a = this.dot(a) / Math.sqrt(this.lengthSq() * a.lengthSq());
            return Math.acos(H.clamp(a, -1, 1))
        },
        distanceTo: function(a) {
            return Math.sqrt(this.distanceToSquared(a))
        },
        distanceToSquared: function(a) {
            var b = this.x - a.x,
                c = this.y - a.y;
            a = this.z - a.z;
            return b * b + c * c + a * a
        },
        manhattanDistanceTo: function(a) {
            return Math.abs(this.x -
                a.x) + Math.abs(this.y - a.y) + Math.abs(this.z - a.z)
        },
        setFromSpherical: function(a) {
            var b = Math.sin(a.phi) * a.radius;
            this.x = b * Math.sin(a.theta);
            this.y = Math.cos(a.phi) * a.radius;
            this.z = b * Math.cos(a.theta);
            return this
        },
        setFromCylindrical: function(a) {
            this.x = a.radius * Math.sin(a.theta);
            this.y = a.y;
            this.z = a.radius * Math.cos(a.theta);
            return this
        },
        setFromMatrixPosition: function(a) {
            a = a.elements;
            this.x = a[12];
            this.y = a[13];
            this.z = a[14];
            return this
        },
        setFromMatrixScale: function(a) {
            var b = this.setFromMatrixColumn(a, 0).length(),
                c = this.setFromMatrixColumn(a, 1).length();
            a = this.setFromMatrixColumn(a, 2).length();
            this.x = b;
            this.y = c;
            this.z = a;
            return this
        },
        setFromMatrixColumn: function(a, b) {
            return this.fromArray(a.elements, 4 * b)
        },
        equals: function(a) {
            return a.x === this.x && a.y === this.y && a.z === this.z
        },
        fromArray: function(a, b) {
            void 0 === b && (b = 0);
            this.x = a[b];
            this.y = a[b + 1];
            this.z = a[b + 2];
            return this
        },
        toArray: function(a, b) {
            void 0 === a && (a = []);
            void 0 === b && (b = 0);
            a[b] = this.x;
            a[b + 1] = this.y;
            a[b + 2] = this.z;
            return a
        },
        fromBufferAttribute: function(a, b, c) {
            void 0 !==
                c && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
            this.x = a.getX(b);
            this.y = a.getY(b);
            this.z = a.getZ(b);
            return this
        }
    });
    Object.assign(ra.prototype, {
        isMatrix3: !0,
        set: function(a, b, c, d, e, f, g, h, k) {
            var m = this.elements;
            m[0] = a;
            m[1] = d;
            m[2] = g;
            m[3] = b;
            m[4] = e;
            m[5] = h;
            m[6] = c;
            m[7] = f;
            m[8] = k;
            return this
        },
        identity: function() {
            this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
            return this
        },
        clone: function() {
            return (new this.constructor).fromArray(this.elements)
        },
        copy: function(a) {
            var b = this.elements;
            a = a.elements;
            b[0] = a[0];
            b[1] = a[1];
            b[2] = a[2];
            b[3] = a[3];
            b[4] = a[4];
            b[5] = a[5];
            b[6] = a[6];
            b[7] = a[7];
            b[8] = a[8];
            return this
        },
        setFromMatrix4: function(a) {
            a = a.elements;
            this.set(a[0], a[4], a[8], a[1], a[5], a[9], a[2], a[6], a[10]);
            return this
        },
        applyToBufferAttribute: function() {
            var a = new p;
            return function(b) {
                for (var c = 0, d = b.count; c < d; c++) a.x = b.getX(c), a.y = b.getY(c), a.z = b.getZ(c), a.applyMatrix3(this), b.setXYZ(c, a.x, a.y, a.z);
                return b
            }
        }(),
        multiply: function(a) {
            return this.multiplyMatrices(this, a)
        },
        premultiply: function(a) {
            return this.multiplyMatrices(a,
                this)
        },
        multiplyMatrices: function(a, b) {
            var c = a.elements,
                d = b.elements;
            b = this.elements;
            a = c[0];
            var e = c[3],
                f = c[6],
                g = c[1],
                h = c[4],
                k = c[7],
                m = c[2],
                q = c[5];
            c = c[8];
            var l = d[0],
                t = d[3],
                u = d[6],
                r = d[1],
                p = d[4],
                y = d[7],
                x = d[2],
                w = d[5];
            d = d[8];
            b[0] = a * l + e * r + f * x;
            b[3] = a * t + e * p + f * w;
            b[6] = a * u + e * y + f * d;
            b[1] = g * l + h * r + k * x;
            b[4] = g * t + h * p + k * w;
            b[7] = g * u + h * y + k * d;
            b[2] = m * l + q * r + c * x;
            b[5] = m * t + q * p + c * w;
            b[8] = m * u + q * y + c * d;
            return this
        },
        multiplyScalar: function(a) {
            var b = this.elements;
            b[0] *= a;
            b[3] *= a;
            b[6] *= a;
            b[1] *= a;
            b[4] *= a;
            b[7] *= a;
            b[2] *= a;
            b[5] *= a;
            b[8] *=
                a;
            return this
        },
        determinant: function() {
            var a = this.elements,
                b = a[0],
                c = a[1],
                d = a[2],
                e = a[3],
                f = a[4],
                g = a[5],
                h = a[6],
                k = a[7];
            a = a[8];
            return b * f * a - b * g * k - c * e * a + c * g * h + d * e * k - d * f * h
        },
        getInverse: function(a, b) {
            a && a.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
            var c = a.elements;
            a = this.elements;
            var d = c[0],
                e = c[1],
                f = c[2],
                g = c[3],
                h = c[4],
                k = c[5],
                m = c[6],
                q = c[7];
            c = c[8];
            var l = c * h - k * q,
                t = k * m - c * g,
                u = q * g - h * m,
                r = d * l + e * t + f * u;
            if (0 === r) {
                if (!0 === b) throw Error("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0");
                console.warn("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0");
                return this.identity()
            }
            b = 1 / r;
            a[0] = l * b;
            a[1] = (f * q - c * e) * b;
            a[2] = (k * e - f * h) * b;
            a[3] = t * b;
            a[4] = (c * d - f * m) * b;
            a[5] = (f * g - k * d) * b;
            a[6] = u * b;
            a[7] = (e * m - q * d) * b;
            a[8] = (h * d - e * g) * b;
            return this
        },
        transpose: function() {
            var a = this.elements;
            var b = a[1];
            a[1] = a[3];
            a[3] = b;
            b = a[2];
            a[2] = a[6];
            a[6] = b;
            b = a[5];
            a[5] = a[7];
            a[7] = b;
            return this
        },
        getNormalMatrix: function(a) {
            return this.setFromMatrix4(a).getInverse(this).transpose()
        },
        transposeIntoArray: function(a) {
            var b =
                this.elements;
            a[0] = b[0];
            a[1] = b[3];
            a[2] = b[6];
            a[3] = b[1];
            a[4] = b[4];
            a[5] = b[7];
            a[6] = b[2];
            a[7] = b[5];
            a[8] = b[8];
            return this
        },
        setUvTransform: function(a, b, c, d, e, f, g) {
            var h = Math.cos(e);
            e = Math.sin(e);
            this.set(c * h, c * e, -c * (h * f + e * g) + f + a, -d * e, d * h, -d * (-e * f + h * g) + g + b, 0, 0, 1)
        },
        scale: function(a, b) {
            var c = this.elements;
            c[0] *= a;
            c[3] *= a;
            c[6] *= a;
            c[1] *= b;
            c[4] *= b;
            c[7] *= b;
            return this
        },
        rotate: function(a) {
            var b = Math.cos(a);
            a = Math.sin(a);
            var c = this.elements,
                d = c[0],
                e = c[3],
                f = c[6],
                g = c[1],
                h = c[4],
                k = c[7];
            c[0] = b * d + a * g;
            c[3] = b * e + a * h;
            c[6] =
                b * f + a * k;
            c[1] = -a * d + b * g;
            c[4] = -a * e + b * h;
            c[7] = -a * f + b * k;
            return this
        },
        translate: function(a, b) {
            var c = this.elements;
            c[0] += a * c[2];
            c[3] += a * c[5];
            c[6] += a * c[8];
            c[1] += b * c[2];
            c[4] += b * c[5];
            c[7] += b * c[8];
            return this
        },
        equals: function(a) {
            var b = this.elements;
            a = a.elements;
            for (var c = 0; 9 > c; c++)
                if (b[c] !== a[c]) return !1;
            return !0
        },
        fromArray: function(a, b) {
            void 0 === b && (b = 0);
            for (var c = 0; 9 > c; c++) this.elements[c] = a[c + b];
            return this
        },
        toArray: function(a, b) {
            void 0 === a && (a = []);
            void 0 === b && (b = 0);
            var c = this.elements;
            a[b] = c[0];
            a[b + 1] = c[1];
            a[b + 2] = c[2];
            a[b + 3] = c[3];
            a[b + 4] = c[4];
            a[b + 5] = c[5];
            a[b + 6] = c[6];
            a[b + 7] = c[7];
            a[b + 8] = c[8];
            return a
        }
    });
    var eb = {
            getDataURL: function(a) {
                if (a instanceof HTMLCanvasElement) var b = a;
                else {
                    "undefined" !== typeof OffscreenCanvas ? b = new OffscreenCanvas(a.width, a.height) : (b = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), b.width = a.width, b.height = a.height);
                    var c = b.getContext("2d");
                    a instanceof ImageData ? c.putImageData(a, 0, 0) : c.drawImage(a, 0, 0, a.width, a.height)
                }
                return 2048 < b.width || 2048 < b.height ? b.toDataURL("image/jpeg",
                    .6) : b.toDataURL("image/png")
            }
        },
        Ef = 0;
    T.DEFAULT_IMAGE = void 0;
    T.DEFAULT_MAPPING = 300;
    T.prototype = Object.assign(Object.create(ya.prototype), {
        constructor: T,
        isTexture: !0,
        updateMatrix: function() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            this.name = a.name;
            this.image = a.image;
            this.mipmaps = a.mipmaps.slice(0);
            this.mapping = a.mapping;
            this.wrapS = a.wrapS;
            this.wrapT =
                a.wrapT;
            this.magFilter = a.magFilter;
            this.minFilter = a.minFilter;
            this.anisotropy = a.anisotropy;
            this.format = a.format;
            this.type = a.type;
            this.offset.copy(a.offset);
            this.repeat.copy(a.repeat);
            this.center.copy(a.center);
            this.rotation = a.rotation;
            this.matrixAutoUpdate = a.matrixAutoUpdate;
            this.matrix.copy(a.matrix);
            this.generateMipmaps = a.generateMipmaps;
            this.premultiplyAlpha = a.premultiplyAlpha;
            this.flipY = a.flipY;
            this.unpackAlignment = a.unpackAlignment;
            this.encoding = a.encoding;
            return this
        },
        toJSON: function(a) {
            var b =
                void 0 === a || "string" === typeof a;
            if (!b && void 0 !== a.textures[this.uuid]) return a.textures[this.uuid];
            var c = {
                metadata: {
                    version: 4.5,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY
            };
            if (void 0 !==
                this.image) {
                var d = this.image;
                void 0 === d.uuid && (d.uuid = H.generateUUID());
                if (!b && void 0 === a.images[d.uuid]) {
                    if (Array.isArray(d)) {
                        var e = [];
                        for (var f = 0, g = d.length; f < g; f++) e.push(eb.getDataURL(d[f]))
                    } else e = eb.getDataURL(d);
                    a.images[d.uuid] = {
                        uuid: d.uuid,
                        url: e
                    }
                }
                c.image = d.uuid
            }
            b || (a.textures[this.uuid] = c);
            return c
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        },
        transformUv: function(a) {
            if (300 === this.mapping) {
                a.applyMatrix3(this.matrix);
                if (0 > a.x || 1 < a.x) switch (this.wrapS) {
                    case 1E3:
                        a.x -= Math.floor(a.x);
                        break;
                    case 1001:
                        a.x = 0 > a.x ? 0 : 1;
                        break;
                    case 1002:
                        a.x = 1 === Math.abs(Math.floor(a.x) % 2) ? Math.ceil(a.x) - a.x : a.x - Math.floor(a.x)
                }
                if (0 > a.y || 1 < a.y) switch (this.wrapT) {
                    case 1E3:
                        a.y -= Math.floor(a.y);
                        break;
                    case 1001:
                        a.y = 0 > a.y ? 0 : 1;
                        break;
                    case 1002:
                        a.y = 1 === Math.abs(Math.floor(a.y) % 2) ? Math.ceil(a.y) - a.y : a.y - Math.floor(a.y)
                }
                this.flipY && (a.y = 1 - a.y)
            }
        }
    });
    Object.defineProperty(T.prototype, "needsUpdate", {
        set: function(a) {
            !0 === a && this.version++
        }
    });
    Object.assign(V.prototype, {
        isVector4: !0,
        set: function(a, b, c, d) {
            this.x = a;
            this.y =
                b;
            this.z = c;
            this.w = d;
            return this
        },
        setScalar: function(a) {
            this.w = this.z = this.y = this.x = a;
            return this
        },
        setX: function(a) {
            this.x = a;
            return this
        },
        setY: function(a) {
            this.y = a;
            return this
        },
        setZ: function(a) {
            this.z = a;
            return this
        },
        setW: function(a) {
            this.w = a;
            return this
        },
        setComponent: function(a, b) {
            switch (a) {
                case 0:
                    this.x = b;
                    break;
                case 1:
                    this.y = b;
                    break;
                case 2:
                    this.z = b;
                    break;
                case 3:
                    this.w = b;
                    break;
                default:
                    throw Error("index is out of range: " + a);
            }
            return this
        },
        getComponent: function(a) {
            switch (a) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw Error("index is out of range: " + a);
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y, this.z, this.w)
        },
        copy: function(a) {
            this.x = a.x;
            this.y = a.y;
            this.z = a.z;
            this.w = void 0 !== a.w ? a.w : 1;
            return this
        },
        add: function(a, b) {
            if (void 0 !== b) return console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
            this.x += a.x;
            this.y += a.y;
            this.z += a.z;
            this.w += a.w;
            return this
        },
        addScalar: function(a) {
            this.x +=
                a;
            this.y += a;
            this.z += a;
            this.w += a;
            return this
        },
        addVectors: function(a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            this.z = a.z + b.z;
            this.w = a.w + b.w;
            return this
        },
        addScaledVector: function(a, b) {
            this.x += a.x * b;
            this.y += a.y * b;
            this.z += a.z * b;
            this.w += a.w * b;
            return this
        },
        sub: function(a, b) {
            if (void 0 !== b) return console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
            this.x -= a.x;
            this.y -= a.y;
            this.z -= a.z;
            this.w -= a.w;
            return this
        },
        subScalar: function(a) {
            this.x -= a;
            this.y -=
                a;
            this.z -= a;
            this.w -= a;
            return this
        },
        subVectors: function(a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            this.z = a.z - b.z;
            this.w = a.w - b.w;
            return this
        },
        multiplyScalar: function(a) {
            this.x *= a;
            this.y *= a;
            this.z *= a;
            this.w *= a;
            return this
        },
        applyMatrix4: function(a) {
            var b = this.x,
                c = this.y,
                d = this.z,
                e = this.w;
            a = a.elements;
            this.x = a[0] * b + a[4] * c + a[8] * d + a[12] * e;
            this.y = a[1] * b + a[5] * c + a[9] * d + a[13] * e;
            this.z = a[2] * b + a[6] * c + a[10] * d + a[14] * e;
            this.w = a[3] * b + a[7] * c + a[11] * d + a[15] * e;
            return this
        },
        divideScalar: function(a) {
            return this.multiplyScalar(1 /
                a)
        },
        setAxisAngleFromQuaternion: function(a) {
            this.w = 2 * Math.acos(a.w);
            var b = Math.sqrt(1 - a.w * a.w);
            1E-4 > b ? (this.x = 1, this.z = this.y = 0) : (this.x = a.x / b, this.y = a.y / b, this.z = a.z / b);
            return this
        },
        setAxisAngleFromRotationMatrix: function(a) {
            a = a.elements;
            var b = a[0];
            var c = a[4];
            var d = a[8],
                e = a[1],
                f = a[5],
                g = a[9];
            var h = a[2];
            var k = a[6];
            var m = a[10];
            if (.01 > Math.abs(c - e) && .01 > Math.abs(d - h) && .01 > Math.abs(g - k)) {
                if (.1 > Math.abs(c + e) && .1 > Math.abs(d + h) && .1 > Math.abs(g + k) && .1 > Math.abs(b + f + m - 3)) return this.set(1, 0, 0, 0), this;
                a = Math.PI;
                b = (b + 1) / 2;
                f = (f + 1) / 2;
                m = (m + 1) / 2;
                c = (c + e) / 4;
                d = (d + h) / 4;
                g = (g + k) / 4;
                b > f && b > m ? .01 > b ? (k = 0, c = h = .707106781) : (k = Math.sqrt(b), h = c / k, c = d / k) : f > m ? .01 > f ? (k = .707106781, h = 0, c = .707106781) : (h = Math.sqrt(f), k = c / h, c = g / h) : .01 > m ? (h = k = .707106781, c = 0) : (c = Math.sqrt(m), k = d / c, h = g / c);
                this.set(k, h, c, a);
                return this
            }
            a = Math.sqrt((k - g) * (k - g) + (d - h) * (d - h) + (e - c) * (e - c));.001 > Math.abs(a) && (a = 1);
            this.x = (k - g) / a;
            this.y = (d - h) / a;
            this.z = (e - c) / a;
            this.w = Math.acos((b + f + m - 1) / 2);
            return this
        },
        min: function(a) {
            this.x = Math.min(this.x, a.x);
            this.y = Math.min(this.y,
                a.y);
            this.z = Math.min(this.z, a.z);
            this.w = Math.min(this.w, a.w);
            return this
        },
        max: function(a) {
            this.x = Math.max(this.x, a.x);
            this.y = Math.max(this.y, a.y);
            this.z = Math.max(this.z, a.z);
            this.w = Math.max(this.w, a.w);
            return this
        },
        clamp: function(a, b) {
            this.x = Math.max(a.x, Math.min(b.x, this.x));
            this.y = Math.max(a.y, Math.min(b.y, this.y));
            this.z = Math.max(a.z, Math.min(b.z, this.z));
            this.w = Math.max(a.w, Math.min(b.w, this.w));
            return this
        },
        clampScalar: function() {
            var a, b;
            return function(c, d) {
                void 0 === a && (a = new V, b = new V);
                a.set(c,
                    c, c, c);
                b.set(d, d, d, d);
                return this.clamp(a, b)
            }
        }(),
        clampLength: function(a, b) {
            var c = this.length();
            return this.divideScalar(c || 1).multiplyScalar(Math.max(a, Math.min(b, c)))
        },
        floor: function() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            this.z = Math.floor(this.z);
            this.w = Math.floor(this.w);
            return this
        },
        ceil: function() {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            this.z = Math.ceil(this.z);
            this.w = Math.ceil(this.w);
            return this
        },
        round: function() {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            this.z = Math.round(this.z);
            this.w = Math.round(this.w);
            return this
        },
        roundToZero: function() {
            this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
            this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
            this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
            this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w);
            return this
        },
        negate: function() {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            this.w = -this.w;
            return this
        },
        dot: function(a) {
            return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w
        },
        lengthSq: function() {
            return this.x *
                this.x + this.y * this.y + this.z * this.z + this.w * this.w
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(a) {
            return this.normalize().multiplyScalar(a)
        },
        lerp: function(a, b) {
            this.x += (a.x - this.x) * b;
            this.y += (a.y - this.y) * b;
            this.z += (a.z - this.z) * b;
            this.w += (a.w - this.w) * b;
            return this
        },
        lerpVectors: function(a,
            b, c) {
            return this.subVectors(b, a).multiplyScalar(c).add(a)
        },
        equals: function(a) {
            return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w
        },
        fromArray: function(a, b) {
            void 0 === b && (b = 0);
            this.x = a[b];
            this.y = a[b + 1];
            this.z = a[b + 2];
            this.w = a[b + 3];
            return this
        },
        toArray: function(a, b) {
            void 0 === a && (a = []);
            void 0 === b && (b = 0);
            a[b] = this.x;
            a[b + 1] = this.y;
            a[b + 2] = this.z;
            a[b + 3] = this.w;
            return a
        },
        fromBufferAttribute: function(a, b, c) {
            void 0 !== c && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
            this.x = a.getX(b);
            this.y = a.getY(b);
            this.z = a.getZ(b);
            this.w = a.getW(b);
            return this
        }
    });
    fb.prototype = Object.assign(Object.create(ya.prototype), {
        constructor: fb,
        isWebGLRenderTarget: !0,
        setSize: function(a, b) {
            if (this.width !== a || this.height !== b) this.width = a, this.height = b, this.dispose();
            this.viewport.set(0, 0, a, b);
            this.scissor.set(0, 0, a, b)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            this.width = a.width;
            this.height = a.height;
            this.viewport.copy(a.viewport);
            this.texture = a.texture.clone();
            this.depthBuffer = a.depthBuffer;
            this.stencilBuffer = a.stencilBuffer;
            this.depthTexture = a.depthTexture;
            return this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    });
    Gb.prototype = Object.create(fb.prototype);
    Gb.prototype.constructor = Gb;
    Gb.prototype.isWebGLRenderTargetCube = !0;
    gb.prototype = Object.create(T.prototype);
    gb.prototype.constructor = gb;
    gb.prototype.isDataTexture = !0;
    Object.assign(Sa.prototype, {
        isBox3: !0,
        set: function(a, b) {
            this.min.copy(a);
            this.max.copy(b);
            return this
        },
        setFromArray: function(a) {
            for (var b =
                    Infinity, c = Infinity, d = Infinity, e = -Infinity, f = -Infinity, g = -Infinity, h = 0, k = a.length; h < k; h += 3) {
                var m = a[h],
                    q = a[h + 1],
                    l = a[h + 2];
                m < b && (b = m);
                q < c && (c = q);
                l < d && (d = l);
                m > e && (e = m);
                q > f && (f = q);
                l > g && (g = l)
            }
            this.min.set(b, c, d);
            this.max.set(e, f, g);
            return this
        },
        setFromBufferAttribute: function(a) {
            for (var b = Infinity, c = Infinity, d = Infinity, e = -Infinity, f = -Infinity, g = -Infinity, h = 0, k = a.count; h < k; h++) {
                var m = a.getX(h),
                    l = a.getY(h),
                    n = a.getZ(h);
                m < b && (b = m);
                l < c && (c = l);
                n < d && (d = n);
                m > e && (e = m);
                l > f && (f = l);
                n > g && (g = n)
            }
            this.min.set(b, c, d);
            this.max.set(e, f, g);
            return this
        },
        setFromPoints: function(a) {
            this.makeEmpty();
            for (var b = 0, c = a.length; b < c; b++) this.expandByPoint(a[b]);
            return this
        },
        setFromCenterAndSize: function() {
            var a = new p;
            return function(b, c) {
                c = a.copy(c).multiplyScalar(.5);
                this.min.copy(b).sub(c);
                this.max.copy(b).add(c);
                return this
            }
        }(),
        setFromObject: function(a) {
            this.makeEmpty();
            return this.expandByObject(a)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            this.min.copy(a.min);
            this.max.copy(a.max);
            return this
        },
        makeEmpty: function() {
            this.min.x = this.min.y = this.min.z = Infinity;
            this.max.x = this.max.y = this.max.z = -Infinity;
            return this
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        },
        getCenter: function(a) {
            void 0 === a && (console.warn("THREE.Box3: .getCenter() target is now required"), a = new p);
            return this.isEmpty() ? a.set(0, 0, 0) : a.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function(a) {
            void 0 === a && (console.warn("THREE.Box3: .getSize() target is now required"),
                a = new p);
            return this.isEmpty() ? a.set(0, 0, 0) : a.subVectors(this.max, this.min)
        },
        expandByPoint: function(a) {
            this.min.min(a);
            this.max.max(a);
            return this
        },
        expandByVector: function(a) {
            this.min.sub(a);
            this.max.add(a);
            return this
        },
        expandByScalar: function(a) {
            this.min.addScalar(-a);
            this.max.addScalar(a);
            return this
        },
        expandByObject: function() {
            function a(a) {
                var f = a.geometry;
                if (void 0 !== f)
                    if (f.isGeometry)
                        for (f = f.vertices, c = 0, d = f.length; c < d; c++) e.copy(f[c]), e.applyMatrix4(a.matrixWorld), b.expandByPoint(e);
                    else if (f.isBufferGeometry &&
                    (f = f.attributes.position, void 0 !== f))
                    for (c = 0, d = f.count; c < d; c++) e.fromBufferAttribute(f, c).applyMatrix4(a.matrixWorld), b.expandByPoint(e)
            }
            var b, c, d, e = new p;
            return function(c) {
                b = this;
                c.updateMatrixWorld(!0);
                c.traverse(a);
                return this
            }
        }(),
        containsPoint: function(a) {
            return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y || a.z < this.min.z || a.z > this.max.z ? !1 : !0
        },
        containsBox: function(a) {
            return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z &&
                a.max.z <= this.max.z
        },
        getParameter: function(a, b) {
            void 0 === b && (console.warn("THREE.Box3: .getParameter() target is now required"), b = new p);
            return b.set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z - this.min.z) / (this.max.z - this.min.z))
        },
        intersectsBox: function(a) {
            return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max.z < this.min.z || a.min.z > this.max.z ? !1 : !0
        },
        intersectsSphere: function() {
            var a = new p;
            return function(b) {
                this.clampPoint(b.center,
                    a);
                return a.distanceToSquared(b.center) <= b.radius * b.radius
            }
        }(),
        intersectsPlane: function(a) {
            if (0 < a.normal.x) {
                var b = a.normal.x * this.min.x;
                var c = a.normal.x * this.max.x
            } else b = a.normal.x * this.max.x, c = a.normal.x * this.min.x;
            0 < a.normal.y ? (b += a.normal.y * this.min.y, c += a.normal.y * this.max.y) : (b += a.normal.y * this.max.y, c += a.normal.y * this.min.y);
            0 < a.normal.z ? (b += a.normal.z * this.min.z, c += a.normal.z * this.max.z) : (b += a.normal.z * this.max.z, c += a.normal.z * this.min.z);
            return b <= a.constant && c >= a.constant
        },
        intersectsTriangle: function() {
            function a(a) {
                var e;
                var f = 0;
                for (e = a.length - 3; f <= e; f += 3) {
                    h.fromArray(a, f);
                    var g = m.x * Math.abs(h.x) + m.y * Math.abs(h.y) + m.z * Math.abs(h.z),
                        k = b.dot(h),
                        l = c.dot(h),
                        q = d.dot(h);
                    if (Math.max(-Math.max(k, l, q), Math.min(k, l, q)) > g) return !1
                }
                return !0
            }
            var b = new p,
                c = new p,
                d = new p,
                e = new p,
                f = new p,
                g = new p,
                h = new p,
                k = new p,
                m = new p,
                l = new p;
            return function(h) {
                if (this.isEmpty()) return !1;
                this.getCenter(k);
                m.subVectors(this.max, k);
                b.subVectors(h.a, k);
                c.subVectors(h.b, k);
                d.subVectors(h.c, k);
                e.subVectors(c, b);
                f.subVectors(d, c);
                g.subVectors(b, d);
                h = [0, -e.z, e.y, 0, -f.z, f.y, 0, -g.z, g.y, e.z, 0, -e.x, f.z, 0, -f.x, g.z, 0, -g.x, -e.y, e.x, 0, -f.y, f.x, 0, -g.y, g.x, 0];
                if (!a(h)) return !1;
                h = [1, 0, 0, 0, 1, 0, 0, 0, 1];
                if (!a(h)) return !1;
                l.crossVectors(e, f);
                h = [l.x, l.y, l.z];
                return a(h)
            }
        }(),
        clampPoint: function(a, b) {
            void 0 === b && (console.warn("THREE.Box3: .clampPoint() target is now required"), b = new p);
            return b.copy(a).clamp(this.min, this.max)
        },
        distanceToPoint: function() {
            var a = new p;
            return function(b) {
                return a.copy(b).clamp(this.min, this.max).sub(b).length()
            }
        }(),
        getBoundingSphere: function() {
            var a =
                new p;
            return function(b) {
                void 0 === b && (console.warn("THREE.Box3: .getBoundingSphere() target is now required"), b = new Da);
                this.getCenter(b.center);
                b.radius = .5 * this.getSize(a).length();
                return b
            }
        }(),
        intersect: function(a) {
            this.min.max(a.min);
            this.max.min(a.max);
            this.isEmpty() && this.makeEmpty();
            return this
        },
        union: function(a) {
            this.min.min(a.min);
            this.max.max(a.max);
            return this
        },
        applyMatrix4: function(a) {
            if (this.isEmpty()) return this;
            a = a.elements;
            var b = a[0] * this.min.x,
                c = a[1] * this.min.x,
                d = a[2] * this.min.x,
                e =
                a[0] * this.max.x,
                f = a[1] * this.max.x,
                g = a[2] * this.max.x,
                h = a[4] * this.min.y,
                k = a[5] * this.min.y,
                m = a[6] * this.min.y,
                l = a[4] * this.max.y,
                n = a[5] * this.max.y,
                t = a[6] * this.max.y,
                u = a[8] * this.min.z,
                r = a[9] * this.min.z,
                p = a[10] * this.min.z,
                y = a[8] * this.max.z,
                x = a[9] * this.max.z,
                w = a[10] * this.max.z;
            this.min.x = Math.min(b, e) + Math.min(h, l) + Math.min(u, y) + a[12];
            this.min.y = Math.min(c, f) + Math.min(k, n) + Math.min(r, x) + a[13];
            this.min.z = Math.min(d, g) + Math.min(m, t) + Math.min(p, w) + a[14];
            this.max.x = Math.max(b, e) + Math.max(h, l) + Math.max(u, y) + a[12];
            this.max.y = Math.max(c, f) + Math.max(k, n) + Math.max(r, x) + a[13];
            this.max.z = Math.max(d, g) + Math.max(m, t) + Math.max(p, w) + a[14];
            return this
        },
        translate: function(a) {
            this.min.add(a);
            this.max.add(a);
            return this
        },
        equals: function(a) {
            return a.min.equals(this.min) && a.max.equals(this.max)
        }
    });
    Object.assign(Da.prototype, {
        set: function(a, b) {
            this.center.copy(a);
            this.radius = b;
            return this
        },
        setFromPoints: function() {
            var a = new Sa;
            return function(b, c) {
                var d = this.center;
                void 0 !== c ? d.copy(c) : a.setFromPoints(b).getCenter(d);
                for (var e =
                        c = 0, f = b.length; e < f; e++) c = Math.max(c, d.distanceToSquared(b[e]));
                this.radius = Math.sqrt(c);
                return this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            this.center.copy(a.center);
            this.radius = a.radius;
            return this
        },
        empty: function() {
            return 0 >= this.radius
        },
        containsPoint: function(a) {
            return a.distanceToSquared(this.center) <= this.radius * this.radius
        },
        distanceToPoint: function(a) {
            return a.distanceTo(this.center) - this.radius
        },
        intersectsSphere: function(a) {
            var b = this.radius + a.radius;
            return a.center.distanceToSquared(this.center) <= b * b
        },
        intersectsBox: function(a) {
            return a.intersectsSphere(this)
        },
        intersectsPlane: function(a) {
            return Math.abs(a.distanceToPoint(this.center)) <= this.radius
        },
        clampPoint: function(a, b) {
            var c = this.center.distanceToSquared(a);
            void 0 === b && (console.warn("THREE.Sphere: .clampPoint() target is now required"), b = new p);
            b.copy(a);
            c > this.radius * this.radius && (b.sub(this.center).normalize(), b.multiplyScalar(this.radius).add(this.center));
            return b
        },
        getBoundingBox: function(a) {
            void 0 ===
                a && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), a = new Sa);
            a.set(this.center, this.center);
            a.expandByScalar(this.radius);
            return a
        },
        applyMatrix4: function(a) {
            this.center.applyMatrix4(a);
            this.radius *= a.getMaxScaleOnAxis();
            return this
        },
        translate: function(a) {
            this.center.add(a);
            return this
        },
        equals: function(a) {
            return a.center.equals(this.center) && a.radius === this.radius
        }
    });
    Object.assign(Ma.prototype, {
        set: function(a, b) {
            this.normal.copy(a);
            this.constant = b;
            return this
        },
        setComponents: function(a,
            b, c, d) {
            this.normal.set(a, b, c);
            this.constant = d;
            return this
        },
        setFromNormalAndCoplanarPoint: function(a, b) {
            this.normal.copy(a);
            this.constant = -b.dot(this.normal);
            return this
        },
        setFromCoplanarPoints: function() {
            var a = new p,
                b = new p;
            return function(c, d, e) {
                d = a.subVectors(e, d).cross(b.subVectors(c, d)).normalize();
                this.setFromNormalAndCoplanarPoint(d, c);
                return this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            this.normal.copy(a.normal);
            this.constant = a.constant;
            return this
        },
        normalize: function() {
            var a =
                1 / this.normal.length();
            this.normal.multiplyScalar(a);
            this.constant *= a;
            return this
        },
        negate: function() {
            this.constant *= -1;
            this.normal.negate();
            return this
        },
        distanceToPoint: function(a) {
            return this.normal.dot(a) + this.constant
        },
        distanceToSphere: function(a) {
            return this.distanceToPoint(a.center) - a.radius
        },
        projectPoint: function(a, b) {
            void 0 === b && (console.warn("THREE.Plane: .projectPoint() target is now required"), b = new p);
            return b.copy(this.normal).multiplyScalar(-this.distanceToPoint(a)).add(a)
        },
        intersectLine: function() {
            var a =
                new p;
            return function(b, c) {
                void 0 === c && (console.warn("THREE.Plane: .intersectLine() target is now required"), c = new p);
                var d = b.delta(a),
                    e = this.normal.dot(d);
                if (0 === e) {
                    if (0 === this.distanceToPoint(b.start)) return c.copy(b.start)
                } else if (e = -(b.start.dot(this.normal) + this.constant) / e, !(0 > e || 1 < e)) return c.copy(d).multiplyScalar(e).add(b.start)
            }
        }(),
        intersectsLine: function(a) {
            var b = this.distanceToPoint(a.start);
            a = this.distanceToPoint(a.end);
            return 0 > b && 0 < a || 0 > a && 0 < b
        },
        intersectsBox: function(a) {
            return a.intersectsPlane(this)
        },
        intersectsSphere: function(a) {
            return a.intersectsPlane(this)
        },
        coplanarPoint: function(a) {
            void 0 === a && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), a = new p);
            return a.copy(this.normal).multiplyScalar(-this.constant)
        },
        applyMatrix4: function() {
            var a = new p,
                b = new ra;
            return function(c, d) {
                d = d || b.getNormalMatrix(c);
                c = this.coplanarPoint(a).applyMatrix4(c);
                d = this.normal.applyMatrix3(d).normalize();
                this.constant = -c.dot(d);
                return this
            }
        }(),
        translate: function(a) {
            this.constant -= a.dot(this.normal);
            return this
        },
        equals: function(a) {
            return a.normal.equals(this.normal) && a.constant === this.constant
        }
    });
    Object.assign(md.prototype, {
        set: function(a, b, c, d, e, f) {
            var g = this.planes;
            g[0].copy(a);
            g[1].copy(b);
            g[2].copy(c);
            g[3].copy(d);
            g[4].copy(e);
            g[5].copy(f);
            return this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            for (var b = this.planes, c = 0; 6 > c; c++) b[c].copy(a.planes[c]);
            return this
        },
        setFromMatrix: function(a) {
            var b = this.planes,
                c = a.elements;
            a = c[0];
            var d = c[1],
                e = c[2],
                f = c[3],
                g = c[4],
                h = c[5],
                k = c[6],
                m = c[7],
                l = c[8],
                n = c[9],
                t = c[10],
                p = c[11],
                r = c[12],
                v = c[13],
                y = c[14];
            c = c[15];
            b[0].setComponents(f - a, m - g, p - l, c - r).normalize();
            b[1].setComponents(f + a, m + g, p + l, c + r).normalize();
            b[2].setComponents(f + d, m + h, p + n, c + v).normalize();
            b[3].setComponents(f - d, m - h, p - n, c - v).normalize();
            b[4].setComponents(f - e, m - k, p - t, c - y).normalize();
            b[5].setComponents(f + e, m + k, p + t, c + y).normalize();
            return this
        },
        intersectsObject: function() {
            var a = new Da;
            return function(b) {
                var c = b.geometry;
                null === c.boundingSphere && c.computeBoundingSphere();
                a.copy(c.boundingSphere).applyMatrix4(b.matrixWorld);
                return this.intersectsSphere(a)
            }
        }(),
        intersectsSprite: function() {
            var a = new Da;
            return function(b) {
                a.center.set(0, 0, 0);
                a.radius = .7071067811865476;
                a.applyMatrix4(b.matrixWorld);
                return this.intersectsSphere(a)
            }
        }(),
        intersectsSphere: function(a) {
            var b = this.planes,
                c = a.center;
            a = -a.radius;
            for (var d = 0; 6 > d; d++)
                if (b[d].distanceToPoint(c) < a) return !1;
            return !0
        },
        intersectsBox: function() {
            var a = new p;
            return function(b) {
                for (var c = this.planes, d = 0; 6 > d; d++) {
                    var e = c[d];
                    a.x = 0 < e.normal.x ? b.max.x : b.min.x;
                    a.y = 0 < e.normal.y ? b.max.y : b.min.y;
                    a.z = 0 < e.normal.z ? b.max.z : b.min.z;
                    if (0 > e.distanceToPoint(a)) return !1
                }
                return !0
            }
        }(),
        containsPoint: function(a) {
            for (var b = this.planes, c = 0; 6 > c; c++)
                if (0 > b[c].distanceToPoint(a)) return !1;
            return !0
        }
    });
    var S = {
            alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",
            alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n",
            alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",
            aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n",
            aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
            begin_vertex: "\nvec3 transformed = vec3( position );\n",
            beginnormal_vertex: "\nvec3 objectNormal = vec3( normal );\n",
            bsdfs: "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",
            bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n",
            clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n",
            clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n",
            clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n",
            clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n",
            color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
            color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n",
            color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
            color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
            common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n",
            cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n",
            defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n",
            displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n",
            displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
            emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n",
            emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n",
            encodings_fragment: "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n",
            encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n",
            envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n",
            envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n",
            envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n",
            envmap_physical_pars_fragment: "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n",
            envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n",
            fog_vertex: "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif",
            fog_pars_vertex: "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n",
            fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n",
            fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n",
            gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n",
            lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
            lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
            lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n",
            lights_pars_begin: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n",
            lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
            lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n",
            lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n",
            lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",
            lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif\n",
            lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif\n",
            lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n",
            logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
            logdepthbuf_pars_fragment: "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n",
            logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif",
            logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n",
            map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n",
            map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n",
            map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n",
            map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n",
            metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n",
            metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
            morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
            morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
            morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n",
            normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n",
            normal_fragment_maps: "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
            normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif\n",
            packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
            premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n",
            project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n",
            dithering_fragment: "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n",
            dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n",
            roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n",
            roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
            shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n",
            shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n",
            shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n",
            shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n",
            skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
            skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n",
            skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n",
            skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
            specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
            specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
            tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n",
            tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",
            uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
            uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n",
            uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
            uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
            uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
            uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
            worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n",
            cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n",
            cube_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n",
            depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n",
            depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
            distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n",
            distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n",
            equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n",
            equirect_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
            linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
            linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n",
            meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
            meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n",
            meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
            meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
            meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
            meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
            meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
            meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
            normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n",
            normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n",
            points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
            points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}\n",
            shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n",
            shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
            sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
            sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tvec4 mvPosition;\n\tmvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n"
        },
        Aa = {
            merge: function(a) {
                for (var b = {}, c = 0; c < a.length; c++) {
                    var d = this.clone(a[c]),
                        e;
                    for (e in d) b[e] = d[e]
                }
                return b
            },
            clone: function(a) {
                var b = {},
                    c;
                for (c in a) {
                    b[c] = {};
                    for (var d in a[c]) {
                        var e = a[c][d];
                        e && (e.isColor || e.isMatrix3 || e.isMatrix4 || e.isVector2 || e.isVector3 || e.isVector4 || e.isTexture) ? b[c][d] = e.clone() : Array.isArray(e) ? b[c][d] = e.slice() : b[c][d] = e
                    }
                }
                return b
            }
        },
        Tg = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        };
    Object.assign(G.prototype, {
        isColor: !0,
        r: 1,
        g: 1,
        b: 1,
        set: function(a) {
            a && a.isColor ? this.copy(a) : "number" === typeof a ? this.setHex(a) : "string" === typeof a && this.setStyle(a);
            return this
        },
        setScalar: function(a) {
            this.b = this.g = this.r = a;
            return this
        },
        setHex: function(a) {
            a = Math.floor(a);
            this.r = (a >> 16 & 255) / 255;
            this.g = (a >> 8 & 255) / 255;
            this.b = (a & 255) / 255;
            return this
        },
        setRGB: function(a, b, c) {
            this.r = a;
            this.g = b;
            this.b = c;
            return this
        },
        setHSL: function() {
            function a(a, c, d) {
                0 > d && (d += 1);
                1 < d && --d;
                return d < 1 / 6 ? a + 6 * (c - a) * d : .5 > d ? c : d < 2 / 3 ? a + 6 * (c - a) * (2 / 3 - d) : a
            }
            return function(b,
                c, d) {
                b = H.euclideanModulo(b, 1);
                c = H.clamp(c, 0, 1);
                d = H.clamp(d, 0, 1);
                0 === c ? this.r = this.g = this.b = d : (c = .5 >= d ? d * (1 + c) : d + c - d * c, d = 2 * d - c, this.r = a(d, c, b + 1 / 3), this.g = a(d, c, b), this.b = a(d, c, b - 1 / 3));
                return this
            }
        }(),
        setStyle: function(a) {
            function b(b) {
                void 0 !== b && 1 > parseFloat(b) && console.warn("THREE.Color: Alpha component of " + a + " will be ignored.")
            }
            var c;
            if (c = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(a)) {
                var d = c[2];
                switch (c[1]) {
                    case "rgb":
                    case "rgba":
                        if (c = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) return this.r =
                            Math.min(255, parseInt(c[1], 10)) / 255, this.g = Math.min(255, parseInt(c[2], 10)) / 255, this.b = Math.min(255, parseInt(c[3], 10)) / 255, b(c[5]), this;
                        if (c = /^(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) return this.r = Math.min(100, parseInt(c[1], 10)) / 100, this.g = Math.min(100, parseInt(c[2], 10)) / 100, this.b = Math.min(100, parseInt(c[3], 10)) / 100, b(c[5]), this;
                        break;
                    case "hsl":
                    case "hsla":
                        if (c = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) {
                            d = parseFloat(c[1]) /
                                360;
                            var e = parseInt(c[2], 10) / 100,
                                f = parseInt(c[3], 10) / 100;
                            b(c[5]);
                            return this.setHSL(d, e, f)
                        }
                }
            } else if (c = /^#([A-Fa-f0-9]+)$/.exec(a)) {
                c = c[1];
                d = c.length;
                if (3 === d) return this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255, this.g = parseInt(c.charAt(1) + c.charAt(1), 16) / 255, this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255, this;
                if (6 === d) return this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255, this.g = parseInt(c.charAt(2) + c.charAt(3), 16) / 255, this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255, this
            }
            a && 0 < a.length && (c = Tg[a],
                void 0 !== c ? this.setHex(c) : console.warn("THREE.Color: Unknown color " + a));
            return this
        },
        clone: function() {
            return new this.constructor(this.r, this.g, this.b)
        },
        copy: function(a) {
            this.r = a.r;
            this.g = a.g;
            this.b = a.b;
            return this
        },
        copyGammaToLinear: function(a, b) {
            void 0 === b && (b = 2);
            this.r = Math.pow(a.r, b);
            this.g = Math.pow(a.g, b);
            this.b = Math.pow(a.b, b);
            return this
        },
        copyLinearToGamma: function(a, b) {
            void 0 === b && (b = 2);
            b = 0 < b ? 1 / b : 1;
            this.r = Math.pow(a.r, b);
            this.g = Math.pow(a.g, b);
            this.b = Math.pow(a.b, b);
            return this
        },
        convertGammaToLinear: function(a) {
            this.copyGammaToLinear(this,
                a);
            return this
        },
        convertLinearToGamma: function(a) {
            this.copyLinearToGamma(this, a);
            return this
        },
        copySRGBToLinear: function() {
            function a(a) {
                return .04045 > a ? .0773993808 * a : Math.pow(.9478672986 * a + .0521327014, 2.4)
            }
            return function(b) {
                this.r = a(b.r);
                this.g = a(b.g);
                this.b = a(b.b);
                return this
            }
        }(),
        copyLinearToSRGB: function() {
            function a(a) {
                return .0031308 > a ? 12.92 * a : 1.055 * Math.pow(a, .41666) - .055
            }
            return function(b) {
                this.r = a(b.r);
                this.g = a(b.g);
                this.b = a(b.b);
                return this
            }
        }(),
        convertSRGBToLinear: function() {
            this.copySRGBToLinear(this);
            return this
        },
        convertLinearToSRGB: function() {
            this.copyLinearToSRGB(this);
            return this
        },
        getHex: function() {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
        },
        getHexString: function() {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        },
        getHSL: function(a) {
            void 0 === a && (console.warn("THREE.Color: .getHSL() target is now required"), a = {
                h: 0,
                s: 0,
                l: 0
            });
            var b = this.r,
                c = this.g,
                d = this.b,
                e = Math.max(b, c, d),
                f = Math.min(b, c, d),
                g, h = (f + e) / 2;
            if (f === e) f = g = 0;
            else {
                var k = e - f;
                f = .5 >= h ? k / (e + f) : k / (2 - e - f);
                switch (e) {
                    case b:
                        g = (c -
                            d) / k + (c < d ? 6 : 0);
                        break;
                    case c:
                        g = (d - b) / k + 2;
                        break;
                    case d:
                        g = (b - c) / k + 4
                }
                g /= 6
            }
            a.h = g;
            a.s = f;
            a.l = h;
            return a
        },
        getStyle: function() {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        },
        offsetHSL: function() {
            var a = {};
            return function(b, c, d) {
                this.getHSL(a);
                a.h += b;
                a.s += c;
                a.l += d;
                this.setHSL(a.h, a.s, a.l);
                return this
            }
        }(),
        add: function(a) {
            this.r += a.r;
            this.g += a.g;
            this.b += a.b;
            return this
        },
        addColors: function(a, b) {
            this.r = a.r + b.r;
            this.g = a.g + b.g;
            this.b = a.b + b.b;
            return this
        },
        addScalar: function(a) {
            this.r += a;
            this.g +=
                a;
            this.b += a;
            return this
        },
        sub: function(a) {
            this.r = Math.max(0, this.r - a.r);
            this.g = Math.max(0, this.g - a.g);
            this.b = Math.max(0, this.b - a.b);
            return this
        },
        multiply: function(a) {
            this.r *= a.r;
            this.g *= a.g;
            this.b *= a.b;
            return this
        },
        multiplyScalar: function(a) {
            this.r *= a;
            this.g *= a;
            this.b *= a;
            return this
        },
        lerp: function(a, b) {
            this.r += (a.r - this.r) * b;
            this.g += (a.g - this.g) * b;
            this.b += (a.b - this.b) * b;
            return this
        },
        equals: function(a) {
            return a.r === this.r && a.g === this.g && a.b === this.b
        },
        fromArray: function(a, b) {
            void 0 === b && (b = 0);
            this.r =
                a[b];
            this.g = a[b + 1];
            this.b = a[b + 2];
            return this
        },
        toArray: function(a, b) {
            void 0 === a && (a = []);
            void 0 === b && (b = 0);
            a[b] = this.r;
            a[b + 1] = this.g;
            a[b + 2] = this.b;
            return a
        },
        toJSON: function() {
            return this.getHex()
        }
    });
    var K = {
            common: {
                diffuse: {
                    value: new G(15658734)
                },
                opacity: {
                    value: 1
                },
                map: {
                    value: null
                },
                uvTransform: {
                    value: new ra
                },
                alphaMap: {
                    value: null
                }
            },
            specularmap: {
                specularMap: {
                    value: null
                }
            },
            envmap: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                reflectivity: {
                    value: 1
                },
                refractionRatio: {
                    value: .98
                },
                maxMipLevel: {
                    value: 0
                }
            },
            aomap: {
                aoMap: {
                    value: null
                },
                aoMapIntensity: {
                    value: 1
                }
            },
            lightmap: {
                lightMap: {
                    value: null
                },
                lightMapIntensity: {
                    value: 1
                }
            },
            emissivemap: {
                emissiveMap: {
                    value: null
                }
            },
            bumpmap: {
                bumpMap: {
                    value: null
                },
                bumpScale: {
                    value: 1
                }
            },
            normalmap: {
                normalMap: {
                    value: null
                },
                normalScale: {
                    value: new z(1, 1)
                }
            },
            displacementmap: {
                displacementMap: {
                    value: null
                },
                displacementScale: {
                    value: 1
                },
                displacementBias: {
                    value: 0
                }
            },
            roughnessmap: {
                roughnessMap: {
                    value: null
                }
            },
            metalnessmap: {
                metalnessMap: {
                    value: null
                }
            },
            gradientmap: {
                gradientMap: {
                    value: null
                }
            },
            fog: {
                fogDensity: {
                    value: 2.5E-4
                },
                fogNear: {
                    value: 1
                },
                fogFar: {
                    value: 2E3
                },
                fogColor: {
                    value: new G(16777215)
                }
            },
            lights: {
                ambientLightColor: {
                    value: []
                },
                directionalLights: {
                    value: [],
                    properties: {
                        direction: {},
                        color: {},
                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                directionalShadowMap: {
                    value: []
                },
                directionalShadowMatrix: {
                    value: []
                },
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {},
                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                spotShadowMap: {
                    value: []
                },
                spotShadowMatrix: {
                    value: []
                },
                pointLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        decay: {},
                        distance: {},
                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        shadowCameraNear: {},
                        shadowCameraFar: {}
                    }
                },
                pointShadowMap: {
                    value: []
                },
                pointShadowMatrix: {
                    value: []
                },
                hemisphereLights: {
                    value: [],
                    properties: {
                        direction: {},
                        skyColor: {},
                        groundColor: {}
                    }
                },
                rectAreaLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        width: {},
                        height: {}
                    }
                }
            },
            points: {
                diffuse: {
                    value: new G(15658734)
                },
                opacity: {
                    value: 1
                },
                size: {
                    value: 1
                },
                scale: {
                    value: 1
                },
                map: {
                    value: null
                },
                uvTransform: {
                    value: new ra
                }
            },
            sprite: {
                diffuse: {
                    value: new G(15658734)
                },
                opacity: {
                    value: 1
                },
                center: {
                    value: new z(.5, .5)
                },
                rotation: {
                    value: 0
                },
                map: {
                    value: null
                },
                uvTransform: {
                    value: new ra
                }
            }
        },
        nb = {
            basic: {
                uniforms: Aa.merge([K.common, K.specularmap, K.envmap, K.aomap, K.lightmap, K.fog]),
                vertexShader: S.meshbasic_vert,
                fragmentShader: S.meshbasic_frag
            },
            lambert: {
                uniforms: Aa.merge([K.common, K.specularmap, K.envmap, K.aomap, K.lightmap, K.emissivemap, K.fog, K.lights, {
                    emissive: {
                        value: new G(0)
                    }
                }]),
                vertexShader: S.meshlambert_vert,
                fragmentShader: S.meshlambert_frag
            },
            phong: {
                uniforms: Aa.merge([K.common, K.specularmap, K.envmap, K.aomap, K.lightmap, K.emissivemap, K.bumpmap, K.normalmap, K.displacementmap, K.gradientmap, K.fog, K.lights, {
                    emissive: {
                        value: new G(0)
                    },
                    specular: {
                        value: new G(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: S.meshphong_vert,
                fragmentShader: S.meshphong_frag
            },
            standard: {
                uniforms: Aa.merge([K.common, K.envmap, K.aomap, K.lightmap, K.emissivemap, K.bumpmap, K.normalmap, K.displacementmap, K.roughnessmap, K.metalnessmap, K.fog, K.lights, {
                    emissive: {
                        value: new G(0)
                    },
                    roughness: {
                        value: .5
                    },
                    metalness: {
                        value: .5
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: S.meshphysical_vert,
                fragmentShader: S.meshphysical_frag
            },
            points: {
                uniforms: Aa.merge([K.points, K.fog]),
                vertexShader: S.points_vert,
                fragmentShader: S.points_frag
            },
            dashed: {
                uniforms: Aa.merge([K.common, K.fog, {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }]),
                vertexShader: S.linedashed_vert,
                fragmentShader: S.linedashed_frag
            },
            depth: {
                uniforms: Aa.merge([K.common, K.displacementmap]),
                vertexShader: S.depth_vert,
                fragmentShader: S.depth_frag
            },
            normal: {
                uniforms: Aa.merge([K.common,
                    K.bumpmap, K.normalmap, K.displacementmap, {
                        opacity: {
                            value: 1
                        }
                    }
                ]),
                vertexShader: S.normal_vert,
                fragmentShader: S.normal_frag
            },
            sprite: {
                uniforms: Aa.merge([K.sprite, K.fog]),
                vertexShader: S.sprite_vert,
                fragmentShader: S.sprite_frag
            },
            cube: {
                uniforms: {
                    tCube: {
                        value: null
                    },
                    tFlip: {
                        value: -1
                    },
                    opacity: {
                        value: 1
                    }
                },
                vertexShader: S.cube_vert,
                fragmentShader: S.cube_frag
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: S.equirect_vert,
                fragmentShader: S.equirect_frag
            },
            distanceRGBA: {
                uniforms: Aa.merge([K.common, K.displacementmap, {
                    referencePosition: {
                        value: new p
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1E3
                    }
                }]),
                vertexShader: S.distanceRGBA_vert,
                fragmentShader: S.distanceRGBA_frag
            },
            shadow: {
                uniforms: Aa.merge([K.lights, K.fog, {
                    color: {
                        value: new G(0)
                    },
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: S.shadow_vert,
                fragmentShader: S.shadow_frag
            }
        };
    nb.physical = {
        uniforms: Aa.merge([nb.standard.uniforms, {
            clearCoat: {
                value: 0
            },
            clearCoatRoughness: {
                value: 0
            }
        }]),
        vertexShader: S.meshphysical_vert,
        fragmentShader: S.meshphysical_frag
    };
    hb.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" ");
    hb.DefaultOrder = "XYZ";
    Object.defineProperties(hb.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(a) {
                this._x = a;
                this.onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(a) {
                this._y = a;
                this.onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(a) {
                this._z = a;
                this.onChangeCallback()
            }
        },
        order: {
            get: function() {
                return this._order
            },
            set: function(a) {
                this._order = a;
                this.onChangeCallback()
            }
        }
    });
    Object.assign(hb.prototype, {
        isEuler: !0,
        set: function(a, b, c, d) {
            this._x = a;
            this._y = b;
            this._z =
                c;
            this._order = d || this._order;
            this.onChangeCallback();
            return this
        },
        clone: function() {
            return new this.constructor(this._x, this._y, this._z, this._order)
        },
        copy: function(a) {
            this._x = a._x;
            this._y = a._y;
            this._z = a._z;
            this._order = a._order;
            this.onChangeCallback();
            return this
        },
        setFromRotationMatrix: function(a, b, c) {
            var d = H.clamp,
                e = a.elements;
            a = e[0];
            var f = e[4],
                g = e[8],
                h = e[1],
                k = e[5],
                m = e[9],
                l = e[2],
                n = e[6];
            e = e[10];
            b = b || this._order;
            "XYZ" === b ? (this._y = Math.asin(d(g, -1, 1)), .99999 > Math.abs(g) ? (this._x = Math.atan2(-m, e), this._z =
                    Math.atan2(-f, a)) : (this._x = Math.atan2(n, k), this._z = 0)) : "YXZ" === b ? (this._x = Math.asin(-d(m, -1, 1)), .99999 > Math.abs(m) ? (this._y = Math.atan2(g, e), this._z = Math.atan2(h, k)) : (this._y = Math.atan2(-l, a), this._z = 0)) : "ZXY" === b ? (this._x = Math.asin(d(n, -1, 1)), .99999 > Math.abs(n) ? (this._y = Math.atan2(-l, e), this._z = Math.atan2(-f, k)) : (this._y = 0, this._z = Math.atan2(h, a))) : "ZYX" === b ? (this._y = Math.asin(-d(l, -1, 1)), .99999 > Math.abs(l) ? (this._x = Math.atan2(n, e), this._z = Math.atan2(h, a)) : (this._x = 0, this._z = Math.atan2(-f, k))) : "YZX" ===
                b ? (this._z = Math.asin(d(h, -1, 1)), .99999 > Math.abs(h) ? (this._x = Math.atan2(-m, k), this._y = Math.atan2(-l, a)) : (this._x = 0, this._y = Math.atan2(g, e))) : "XZY" === b ? (this._z = Math.asin(-d(f, -1, 1)), .99999 > Math.abs(f) ? (this._x = Math.atan2(n, k), this._y = Math.atan2(g, a)) : (this._x = Math.atan2(-m, e), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + b);
            this._order = b;
            if (!1 !== c) this.onChangeCallback();
            return this
        },
        setFromQuaternion: function() {
            var a = new I;
            return function(b, c, d) {
                a.makeRotationFromQuaternion(b);
                return this.setFromRotationMatrix(a, c, d)
            }
        }(),
        setFromVector3: function(a, b) {
            return this.set(a.x, a.y, a.z, b || this._order)
        },
        reorder: function() {
            var a = new fa;
            return function(b) {
                a.setFromEuler(this);
                return this.setFromQuaternion(a, b)
            }
        }(),
        equals: function(a) {
            return a._x === this._x && a._y === this._y && a._z === this._z && a._order === this._order
        },
        fromArray: function(a) {
            this._x = a[0];
            this._y = a[1];
            this._z = a[2];
            void 0 !== a[3] && (this._order = a[3]);
            this.onChangeCallback();
            return this
        },
        toArray: function(a, b) {
            void 0 === a && (a = []);
            void 0 === b && (b = 0);
            a[b] = this._x;
            a[b + 1] = this._y;
            a[b + 2] = this._z;
            a[b + 3] = this._order;
            return a
        },
        toVector3: function(a) {
            return a ? a.set(this._x, this._y, this._z) : new p(this._x, this._y, this._z)
        },
        onChange: function(a) {
            this.onChangeCallback = a;
            return this
        },
        onChangeCallback: function() {}
    });
    Object.assign(Rd.prototype, {
        set: function(a) {
            this.mask = 1 << a | 0
        },
        enable: function(a) {
            this.mask = this.mask | 1 << a | 0
        },
        toggle: function(a) {
            this.mask ^= 1 << a | 0
        },
        disable: function(a) {
            this.mask &= ~(1 << a | 0)
        },
        test: function(a) {
            return 0 !== (this.mask &
                a.mask)
        }
    });
    var Gf = 0;
    D.DefaultUp = new p(0, 1, 0);
    D.DefaultMatrixAutoUpdate = !0;
    D.prototype = Object.assign(Object.create(ya.prototype), {
        constructor: D,
        isObject3D: !0,
        onBeforeRender: function() {},
        onAfterRender: function() {},
        applyMatrix: function(a) {
            this.matrix.multiplyMatrices(a, this.matrix);
            this.matrix.decompose(this.position, this.quaternion, this.scale)
        },
        applyQuaternion: function(a) {
            this.quaternion.premultiply(a);
            return this
        },
        setRotationFromAxisAngle: function(a, b) {
            this.quaternion.setFromAxisAngle(a, b)
        },
        setRotationFromEuler: function(a) {
            this.quaternion.setFromEuler(a, !0)
        },
        setRotationFromMatrix: function(a) {
            this.quaternion.setFromRotationMatrix(a)
        },
        setRotationFromQuaternion: function(a) {
            this.quaternion.copy(a)
        },
        rotateOnAxis: function() {
            var a = new fa;
            return function(b, c) {
                a.setFromAxisAngle(b, c);
                this.quaternion.multiply(a);
                return this
            }
        }(),
        rotateOnWorldAxis: function() {
            var a = new fa;
            return function(b, c) {
                a.setFromAxisAngle(b, c);
                this.quaternion.premultiply(a);
                return this
            }
        }(),
        rotateX: function() {
            var a = new p(1, 0, 0);
            return function(b) {
                return this.rotateOnAxis(a, b)
            }
        }(),
        rotateY: function() {
            var a =
                new p(0, 1, 0);
            return function(b) {
                return this.rotateOnAxis(a, b)
            }
        }(),
        rotateZ: function() {
            var a = new p(0, 0, 1);
            return function(b) {
                return this.rotateOnAxis(a, b)
            }
        }(),
        translateOnAxis: function() {
            var a = new p;
            return function(b, c) {
                a.copy(b).applyQuaternion(this.quaternion);
                this.position.add(a.multiplyScalar(c));
                return this
            }
        }(),
        translateX: function() {
            var a = new p(1, 0, 0);
            return function(b) {
                return this.translateOnAxis(a, b)
            }
        }(),
        translateY: function() {
            var a = new p(0, 1, 0);
            return function(b) {
                return this.translateOnAxis(a,
                    b)
            }
        }(),
        translateZ: function() {
            var a = new p(0, 0, 1);
            return function(b) {
                return this.translateOnAxis(a, b)
            }
        }(),
        localToWorld: function(a) {
            return a.applyMatrix4(this.matrixWorld)
        },
        worldToLocal: function() {
            var a = new I;
            return function(b) {
                return b.applyMatrix4(a.getInverse(this.matrixWorld))
            }
        }(),
        lookAt: function() {
            var a = new I,
                b = new p;
            return function(c, d, e) {
                c.isVector3 ? b.copy(c) : b.set(c, d, e);
                this.isCamera ? a.lookAt(this.position, b, this.up) : a.lookAt(b, this.position, this.up);
                this.quaternion.setFromRotationMatrix(a)
            }
        }(),
        add: function(a) {
            if (1 < arguments.length) {
                for (var b = 0; b < arguments.length; b++) this.add(arguments[b]);
                return this
            }
            if (a === this) return console.error("THREE.Object3D.add: object can't be added as a child of itself.", a), this;
            a && a.isObject3D ? (null !== a.parent && a.parent.remove(a), a.parent = this, a.dispatchEvent({
                type: "added"
            }), this.children.push(a)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", a);
            return this
        },
        remove: function(a) {
            if (1 < arguments.length) {
                for (var b = 0; b < arguments.length; b++) this.remove(arguments[b]);
                return this
            }
            b = this.children.indexOf(a); - 1 !== b && (a.parent = null, a.dispatchEvent({
                type: "removed"
            }), this.children.splice(b, 1));
            return this
        },
        getObjectById: function(a) {
            return this.getObjectByProperty("id", a)
        },
        getObjectByName: function(a) {
            return this.getObjectByProperty("name", a)
        },
        getObjectByProperty: function(a, b) {
            if (this[a] === b) return this;
            for (var c = 0, d = this.children.length; c < d; c++) {
                var e = this.children[c].getObjectByProperty(a, b);
                if (void 0 !== e) return e
            }
        },
        getWorldPosition: function(a) {
            void 0 === a && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"),
                a = new p);
            this.updateMatrixWorld(!0);
            return a.setFromMatrixPosition(this.matrixWorld)
        },
        getWorldQuaternion: function() {
            var a = new p,
                b = new p;
            return function(c) {
                void 0 === c && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), c = new fa);
                this.updateMatrixWorld(!0);
                this.matrixWorld.decompose(a, c, b);
                return c
            }
        }(),
        getWorldScale: function() {
            var a = new p,
                b = new fa;
            return function(c) {
                void 0 === c && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), c = new p);
                this.updateMatrixWorld(!0);
                this.matrixWorld.decompose(a, b, c);
                return c
            }
        }(),
        getWorldDirection: function() {
            var a = new fa;
            return function(b) {
                void 0 === b && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), b = new p);
                this.getWorldQuaternion(a);
                return b.set(0, 0, 1).applyQuaternion(a)
            }
        }(),
        raycast: function() {},
        traverse: function(a) {
            a(this);
            for (var b = this.children, c = 0, d = b.length; c < d; c++) b[c].traverse(a)
        },
        traverseVisible: function(a) {
            if (!1 !== this.visible) {
                a(this);
                for (var b = this.children, c = 0, d = b.length; c < d; c++) b[c].traverseVisible(a)
            }
        },
        traverseAncestors: function(a) {
            var b = this.parent;
            null !== b && (a(b), b.traverseAncestors(a))
        },
        updateMatrix: function() {
            this.matrix.compose(this.position, this.quaternion, this.scale);
            this.matrixWorldNeedsUpdate = !0
        },
        updateMatrixWorld: function(a) {
            this.matrixAutoUpdate && this.updateMatrix();
            if (this.matrixWorldNeedsUpdate || a) null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, a = !0;
            for (var b = this.children, c =
                    0, d = b.length; c < d; c++) b[c].updateMatrixWorld(a)
        },
        toJSON: function(a) {
            function b(b, c) {
                void 0 === b[c.uuid] && (b[c.uuid] = c.toJSON(a));
                return c.uuid
            }

            function c(a) {
                var b = [],
                    c;
                for (c in a) {
                    var d = a[c];
                    delete d.metadata;
                    b.push(d)
                }
                return b
            }
            var d = void 0 === a || "string" === typeof a,
                e = {};
            d && (a = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {}
            }, e.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            var f = {};
            f.uuid = this.uuid;
            f.type = this.type;
            "" !== this.name && (f.name = this.name);
            !0 === this.castShadow &&
                (f.castShadow = !0);
            !0 === this.receiveShadow && (f.receiveShadow = !0);
            !1 === this.visible && (f.visible = !1);
            !1 === this.frustumCulled && (f.frustumCulled = !1);
            0 !== this.renderOrder && (f.renderOrder = this.renderOrder);
            "{}" !== JSON.stringify(this.userData) && (f.userData = this.userData);
            f.layers = this.layers.mask;
            f.matrix = this.matrix.toArray();
            !1 === this.matrixAutoUpdate && (f.matrixAutoUpdate = !1);
            if (this.isMesh || this.isLine || this.isPoints) {
                f.geometry = b(a.geometries, this.geometry);
                var g = this.geometry.parameters;
                if (void 0 !==
                    g && void 0 !== g.shapes)
                    if (g = g.shapes, Array.isArray(g))
                        for (var h = 0, k = g.length; h < k; h++) b(a.shapes, g[h]);
                    else b(a.shapes, g)
            }
            if (void 0 !== this.material)
                if (Array.isArray(this.material)) {
                    g = [];
                    h = 0;
                    for (k = this.material.length; h < k; h++) g.push(b(a.materials, this.material[h]));
                    f.material = g
                } else f.material = b(a.materials, this.material);
            if (0 < this.children.length)
                for (f.children = [], h = 0; h < this.children.length; h++) f.children.push(this.children[h].toJSON(a).object);
            if (d) {
                d = c(a.geometries);
                h = c(a.materials);
                k = c(a.textures);
                var m = c(a.images);
                g = c(a.shapes);
                0 < d.length && (e.geometries = d);
                0 < h.length && (e.materials = h);
                0 < k.length && (e.textures = k);
                0 < m.length && (e.images = m);
                0 < g.length && (e.shapes = g)
            }
            e.object = f;
            return e
        },
        clone: function(a) {
            return (new this.constructor).copy(this, a)
        },
        copy: function(a, b) {
            void 0 === b && (b = !0);
            this.name = a.name;
            this.up.copy(a.up);
            this.position.copy(a.position);
            this.quaternion.copy(a.quaternion);
            this.scale.copy(a.scale);
            this.matrix.copy(a.matrix);
            this.matrixWorld.copy(a.matrixWorld);
            this.matrixAutoUpdate = a.matrixAutoUpdate;
            this.matrixWorldNeedsUpdate = a.matrixWorldNeedsUpdate;
            this.layers.mask = a.layers.mask;
            this.visible = a.visible;
            this.castShadow = a.castShadow;
            this.receiveShadow = a.receiveShadow;
            this.frustumCulled = a.frustumCulled;
            this.renderOrder = a.renderOrder;
            this.userData = JSON.parse(JSON.stringify(a.userData));
            if (!0 === b)
                for (b = 0; b < a.children.length; b++) this.add(a.children[b].clone());
            return this
        }
    });
    Na.prototype = Object.assign(Object.create(D.prototype), {
        constructor: Na,
        isCamera: !0,
        copy: function(a, b) {
            D.prototype.copy.call(this,
                a, b);
            this.matrixWorldInverse.copy(a.matrixWorldInverse);
            this.projectionMatrix.copy(a.projectionMatrix);
            return this
        },
        getWorldDirection: function() {
            var a = new fa;
            return function(b) {
                void 0 === b && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), b = new p);
                this.getWorldQuaternion(a);
                return b.set(0, 0, -1).applyQuaternion(a)
            }
        }(),
        updateMatrixWorld: function(a) {
            D.prototype.updateMatrixWorld.call(this, a);
            this.matrixWorldInverse.getInverse(this.matrixWorld)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    });
    Hb.prototype = Object.assign(Object.create(Na.prototype), {
        constructor: Hb,
        isOrthographicCamera: !0,
        copy: function(a, b) {
            Na.prototype.copy.call(this, a, b);
            this.left = a.left;
            this.right = a.right;
            this.top = a.top;
            this.bottom = a.bottom;
            this.near = a.near;
            this.far = a.far;
            this.zoom = a.zoom;
            this.view = null === a.view ? null : Object.assign({}, a.view);
            return this
        },
        setViewOffset: function(a, b, c, d, e, f) {
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            });
            this.view.enabled = !0;
            this.view.fullWidth =
                a;
            this.view.fullHeight = b;
            this.view.offsetX = c;
            this.view.offsetY = d;
            this.view.width = e;
            this.view.height = f;
            this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1);
            this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var a = (this.right - this.left) / (2 * this.zoom),
                b = (this.top - this.bottom) / (2 * this.zoom),
                c = (this.right + this.left) / 2,
                d = (this.top + this.bottom) / 2,
                e = c - a;
            c += a;
            a = d + b;
            b = d - b;
            if (null !== this.view && this.view.enabled) {
                c = this.zoom / (this.view.width / this.view.fullWidth);
                b = this.zoom / (this.view.height / this.view.fullHeight);
                var f = (this.right - this.left) / this.view.width;
                d = (this.top - this.bottom) / this.view.height;
                e += this.view.offsetX / c * f;
                c = e + this.view.width / c * f;
                a -= this.view.offsetY / b * d;
                b = a - this.view.height / b * d
            }
            this.projectionMatrix.makeOrthographic(e, c, a, b, this.near, this.far)
        },
        toJSON: function(a) {
            a = D.prototype.toJSON.call(this, a);
            a.object.zoom = this.zoom;
            a.object.left = this.left;
            a.object.right = this.right;
            a.object.top = this.top;
            a.object.bottom = this.bottom;
            a.object.near = this.near;
            a.object.far = this.far;
            null !== this.view && (a.object.view = Object.assign({}, this.view));
            return a
        }
    });
    Object.assign(Ta.prototype, {
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            this.a = a.a;
            this.b = a.b;
            this.c = a.c;
            this.normal.copy(a.normal);
            this.color.copy(a.color);
            this.materialIndex = a.materialIndex;
            for (var b = 0, c = a.vertexNormals.length; b < c; b++) this.vertexNormals[b] = a.vertexNormals[b].clone();
            b = 0;
            for (c = a.vertexColors.length; b < c; b++) this.vertexColors[b] = a.vertexColors[b].clone();
            return this
        }
    });
    var Hf = 0;
    R.prototype = Object.assign(Object.create(ya.prototype), {
        constructor: R,
        isGeometry: !0,
        applyMatrix: function(a) {
            for (var b = (new ra).getNormalMatrix(a), c = 0, d = this.vertices.length; c < d; c++) this.vertices[c].applyMatrix4(a);
            c = 0;
            for (d = this.faces.length; c < d; c++) {
                a = this.faces[c];
                a.normal.applyMatrix3(b).normalize();
                for (var e = 0, f = a.vertexNormals.length; e < f; e++) a.vertexNormals[e].applyMatrix3(b).normalize()
            }
            null !== this.boundingBox && this.computeBoundingBox();
            null !== this.boundingSphere && this.computeBoundingSphere();
            this.normalsNeedUpdate = this.verticesNeedUpdate = !0;
            return this
        },
        rotateX: function() {
            var a = new I;
            return function(b) {
                a.makeRotationX(b);
                this.applyMatrix(a);
                return this
            }
        }(),
        rotateY: function() {
            var a = new I;
            return function(b) {
                a.makeRotationY(b);
                this.applyMatrix(a);
                return this
            }
        }(),
        rotateZ: function() {
            var a = new I;
            return function(b) {
                a.makeRotationZ(b);
                this.applyMatrix(a);
                return this
            }
        }(),
        translate: function() {
            var a = new I;
            return function(b, c, d) {
                a.makeTranslation(b, c, d);
                this.applyMatrix(a);
                return this
            }
        }(),
        scale: function() {
            var a =
                new I;
            return function(b, c, d) {
                a.makeScale(b, c, d);
                this.applyMatrix(a);
                return this
            }
        }(),
        lookAt: function() {
            var a = new D;
            return function(b) {
                a.lookAt(b);
                a.updateMatrix();
                this.applyMatrix(a.matrix)
            }
        }(),
        fromBufferGeometry: function(a) {
            function b(a, b, d, e) {
                var f = void 0 !== g ? [l[a].clone(), l[b].clone(), l[d].clone()] : [],
                    q = void 0 !== h ? [c.colors[a].clone(), c.colors[b].clone(), c.colors[d].clone()] : [];
                e = new Ta(a, b, d, f, q, e);
                c.faces.push(e);
                void 0 !== k && c.faceVertexUvs[0].push([n[a].clone(), n[b].clone(), n[d].clone()]);
                void 0 !==
                    m && c.faceVertexUvs[1].push([t[a].clone(), t[b].clone(), t[d].clone()])
            }
            var c = this,
                d = null !== a.index ? a.index.array : void 0,
                e = a.attributes,
                f = e.position.array,
                g = void 0 !== e.normal ? e.normal.array : void 0,
                h = void 0 !== e.color ? e.color.array : void 0,
                k = void 0 !== e.uv ? e.uv.array : void 0,
                m = void 0 !== e.uv2 ? e.uv2.array : void 0;
            void 0 !== m && (this.faceVertexUvs[1] = []);
            for (var l = [], n = [], t = [], u = e = 0; e < f.length; e += 3, u += 2) c.vertices.push(new p(f[e], f[e + 1], f[e + 2])), void 0 !== g && l.push(new p(g[e], g[e + 1], g[e + 2])), void 0 !== h && c.colors.push(new G(h[e],
                h[e + 1], h[e + 2])), void 0 !== k && n.push(new z(k[u], k[u + 1])), void 0 !== m && t.push(new z(m[u], m[u + 1]));
            var r = a.groups;
            if (0 < r.length)
                for (e = 0; e < r.length; e++) {
                    f = r[e];
                    var v = f.start,
                        y = f.count;
                    u = v;
                    for (v += y; u < v; u += 3) void 0 !== d ? b(d[u], d[u + 1], d[u + 2], f.materialIndex) : b(u, u + 1, u + 2, f.materialIndex)
                } else if (void 0 !== d)
                    for (e = 0; e < d.length; e += 3) b(d[e], d[e + 1], d[e + 2]);
                else
                    for (e = 0; e < f.length / 3; e += 3) b(e, e + 1, e + 2);
            this.computeFaceNormals();
            null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());
            null !== a.boundingSphere &&
                (this.boundingSphere = a.boundingSphere.clone());
            return this
        },
        center: function() {
            var a = new p;
            return function() {
                this.computeBoundingBox();
                this.boundingBox.getCenter(a).negate();
                this.translate(a.x, a.y, a.z);
                return this
            }
        }(),
        normalize: function() {
            this.computeBoundingSphere();
            var a = this.boundingSphere.center,
                b = this.boundingSphere.radius;
            b = 0 === b ? 1 : 1 / b;
            var c = new I;
            c.set(b, 0, 0, -b * a.x, 0, b, 0, -b * a.y, 0, 0, b, -b * a.z, 0, 0, 0, 1);
            this.applyMatrix(c);
            return this
        },
        computeFaceNormals: function() {
            for (var a = new p, b = new p, c = 0, d =
                    this.faces.length; c < d; c++) {
                var e = this.faces[c],
                    f = this.vertices[e.a],
                    g = this.vertices[e.b];
                a.subVectors(this.vertices[e.c], g);
                b.subVectors(f, g);
                a.cross(b);
                a.normalize();
                e.normal.copy(a)
            }
        },
        computeVertexNormals: function(a) {
            void 0 === a && (a = !0);
            var b;
            var c = Array(this.vertices.length);
            var d = 0;
            for (b = this.vertices.length; d < b; d++) c[d] = new p;
            if (a) {
                var e = new p,
                    f = new p;
                a = 0;
                for (d = this.faces.length; a < d; a++) {
                    b = this.faces[a];
                    var g = this.vertices[b.a];
                    var h = this.vertices[b.b];
                    var k = this.vertices[b.c];
                    e.subVectors(k,
                        h);
                    f.subVectors(g, h);
                    e.cross(f);
                    c[b.a].add(e);
                    c[b.b].add(e);
                    c[b.c].add(e)
                }
            } else
                for (this.computeFaceNormals(), a = 0, d = this.faces.length; a < d; a++) b = this.faces[a], c[b.a].add(b.normal), c[b.b].add(b.normal), c[b.c].add(b.normal);
            d = 0;
            for (b = this.vertices.length; d < b; d++) c[d].normalize();
            a = 0;
            for (d = this.faces.length; a < d; a++) b = this.faces[a], g = b.vertexNormals, 3 === g.length ? (g[0].copy(c[b.a]), g[1].copy(c[b.b]), g[2].copy(c[b.c])) : (g[0] = c[b.a].clone(), g[1] = c[b.b].clone(), g[2] = c[b.c].clone());
            0 < this.faces.length && (this.normalsNeedUpdate = !0)
        },
        computeFlatVertexNormals: function() {
            var a;
            this.computeFaceNormals();
            var b = 0;
            for (a = this.faces.length; b < a; b++) {
                var c = this.faces[b];
                var d = c.vertexNormals;
                3 === d.length ? (d[0].copy(c.normal), d[1].copy(c.normal), d[2].copy(c.normal)) : (d[0] = c.normal.clone(), d[1] = c.normal.clone(), d[2] = c.normal.clone())
            }
            0 < this.faces.length && (this.normalsNeedUpdate = !0)
        },
        computeMorphNormals: function() {
            var a, b;
            var c = 0;
            for (b = this.faces.length; c < b; c++) {
                var d = this.faces[c];
                d.__originalFaceNormal ? d.__originalFaceNormal.copy(d.normal) :
                    d.__originalFaceNormal = d.normal.clone();
                d.__originalVertexNormals || (d.__originalVertexNormals = []);
                var e = 0;
                for (a = d.vertexNormals.length; e < a; e++) d.__originalVertexNormals[e] ? d.__originalVertexNormals[e].copy(d.vertexNormals[e]) : d.__originalVertexNormals[e] = d.vertexNormals[e].clone()
            }
            var f = new R;
            f.faces = this.faces;
            e = 0;
            for (a = this.morphTargets.length; e < a; e++) {
                if (!this.morphNormals[e]) {
                    this.morphNormals[e] = {};
                    this.morphNormals[e].faceNormals = [];
                    this.morphNormals[e].vertexNormals = [];
                    d = this.morphNormals[e].faceNormals;
                    var g = this.morphNormals[e].vertexNormals;
                    c = 0;
                    for (b = this.faces.length; c < b; c++) {
                        var h = new p;
                        var k = {
                            a: new p,
                            b: new p,
                            c: new p
                        };
                        d.push(h);
                        g.push(k)
                    }
                }
                g = this.morphNormals[e];
                f.vertices = this.morphTargets[e].vertices;
                f.computeFaceNormals();
                f.computeVertexNormals();
                c = 0;
                for (b = this.faces.length; c < b; c++) d = this.faces[c], h = g.faceNormals[c], k = g.vertexNormals[c], h.copy(d.normal), k.a.copy(d.vertexNormals[0]), k.b.copy(d.vertexNormals[1]), k.c.copy(d.vertexNormals[2])
            }
            c = 0;
            for (b = this.faces.length; c < b; c++) d = this.faces[c],
                d.normal = d.__originalFaceNormal, d.vertexNormals = d.__originalVertexNormals
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new Sa);
            this.boundingBox.setFromPoints(this.vertices)
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new Da);
            this.boundingSphere.setFromPoints(this.vertices)
        },
        merge: function(a, b, c) {
            if (a && a.isGeometry) {
                var d, e = this.vertices.length,
                    f = this.vertices,
                    g = a.vertices,
                    h = this.faces,
                    k = a.faces,
                    m = this.faceVertexUvs[0],
                    l = a.faceVertexUvs[0],
                    n = this.colors,
                    t = a.colors;
                void 0 === c && (c = 0);
                void 0 !== b && (d = (new ra).getNormalMatrix(b));
                a = 0;
                for (var p = g.length; a < p; a++) {
                    var r = g[a].clone();
                    void 0 !== b && r.applyMatrix4(b);
                    f.push(r)
                }
                a = 0;
                for (p = t.length; a < p; a++) n.push(t[a].clone());
                a = 0;
                for (p = k.length; a < p; a++) {
                    g = k[a];
                    var v = g.vertexNormals;
                    t = g.vertexColors;
                    n = new Ta(g.a + e, g.b + e, g.c + e);
                    n.normal.copy(g.normal);
                    void 0 !== d && n.normal.applyMatrix3(d).normalize();
                    b = 0;
                    for (f = v.length; b < f; b++) r = v[b].clone(), void 0 !== d && r.applyMatrix3(d).normalize(), n.vertexNormals.push(r);
                    n.color.copy(g.color);
                    b = 0;
                    for (f = t.length; b < f; b++) r = t[b], n.vertexColors.push(r.clone());
                    n.materialIndex = g.materialIndex + c;
                    h.push(n)
                }
                a = 0;
                for (p = l.length; a < p; a++)
                    if (c = l[a], d = [], void 0 !== c) {
                        b = 0;
                        for (f = c.length; b < f; b++) d.push(c[b].clone());
                        m.push(d)
                    }
            } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", a)
        },
        mergeMesh: function(a) {
            a && a.isMesh ? (a.matrixAutoUpdate && a.updateMatrix(), this.merge(a.geometry, a.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",
                a)
        },
        mergeVertices: function() {
            var a = {},
                b = [],
                c = [],
                d = Math.pow(10, 4),
                e;
            var f = 0;
            for (e = this.vertices.length; f < e; f++) {
                var g = this.vertices[f];
                g = Math.round(g.x * d) + "_" + Math.round(g.y * d) + "_" + Math.round(g.z * d);
                void 0 === a[g] ? (a[g] = f, b.push(this.vertices[f]), c[f] = b.length - 1) : c[f] = c[a[g]]
            }
            a = [];
            f = 0;
            for (e = this.faces.length; f < e; f++)
                for (d = this.faces[f], d.a = c[d.a], d.b = c[d.b], d.c = c[d.c], d = [d.a, d.b, d.c], g = 0; 3 > g; g++)
                    if (d[g] === d[(g + 1) % 3]) {
                        a.push(f);
                        break
                    }
            for (f = a.length - 1; 0 <= f; f--)
                for (d = a[f], this.faces.splice(d, 1), c = 0, e =
                    this.faceVertexUvs.length; c < e; c++) this.faceVertexUvs[c].splice(d, 1);
            f = this.vertices.length - b.length;
            this.vertices = b;
            return f
        },
        setFromPoints: function(a) {
            this.vertices = [];
            for (var b = 0, c = a.length; b < c; b++) {
                var d = a[b];
                this.vertices.push(new p(d.x, d.y, d.z || 0))
            }
            return this
        },
        sortFacesByMaterialIndex: function() {
            for (var a = this.faces, b = a.length, c = 0; c < b; c++) a[c]._id = c;
            a.sort(function(a, b) {
                return a.materialIndex - b.materialIndex
            });
            var d = this.faceVertexUvs[0],
                e = this.faceVertexUvs[1],
                f, g;
            d && d.length === b && (f = []);
            e &&
                e.length === b && (g = []);
            for (c = 0; c < b; c++) {
                var h = a[c]._id;
                f && f.push(d[h]);
                g && g.push(e[h])
            }
            f && (this.faceVertexUvs[0] = f);
            g && (this.faceVertexUvs[1] = g)
        },
        toJSON: function() {
            function a(a, b, c) {
                return c ? a | 1 << b : a & ~(1 << b)
            }

            function b(a) {
                var b = a.x.toString() + a.y.toString() + a.z.toString();
                if (void 0 !== m[b]) return m[b];
                m[b] = k.length / 3;
                k.push(a.x, a.y, a.z);
                return m[b]
            }

            function c(a) {
                var b = a.r.toString() + a.g.toString() + a.b.toString();
                if (void 0 !== n[b]) return n[b];
                n[b] = l.length;
                l.push(a.getHex());
                return n[b]
            }

            function d(a) {
                var b =
                    a.x.toString() + a.y.toString();
                if (void 0 !== p[b]) return p[b];
                p[b] = t.length / 2;
                t.push(a.x, a.y);
                return p[b]
            }
            var e = {
                metadata: {
                    version: 4.5,
                    type: "Geometry",
                    generator: "Geometry.toJSON"
                }
            };
            e.uuid = this.uuid;
            e.type = this.type;
            "" !== this.name && (e.name = this.name);
            if (void 0 !== this.parameters) {
                var f = this.parameters,
                    g;
                for (g in f) void 0 !== f[g] && (e[g] = f[g]);
                return e
            }
            f = [];
            for (g = 0; g < this.vertices.length; g++) {
                var h = this.vertices[g];
                f.push(h.x, h.y, h.z)
            }
            h = [];
            var k = [],
                m = {},
                l = [],
                n = {},
                t = [],
                p = {};
            for (g = 0; g < this.faces.length; g++) {
                var r =
                    this.faces[g],
                    v = void 0 !== this.faceVertexUvs[0][g],
                    y = 0 < r.normal.length(),
                    x = 0 < r.vertexNormals.length,
                    w = 1 !== r.color.r || 1 !== r.color.g || 1 !== r.color.b,
                    B = 0 < r.vertexColors.length,
                    E = 0;
                E = a(E, 0, 0);
                E = a(E, 1, !0);
                E = a(E, 2, !1);
                E = a(E, 3, v);
                E = a(E, 4, y);
                E = a(E, 5, x);
                E = a(E, 6, w);
                E = a(E, 7, B);
                h.push(E);
                h.push(r.a, r.b, r.c);
                h.push(r.materialIndex);
                v && (v = this.faceVertexUvs[0][g], h.push(d(v[0]), d(v[1]), d(v[2])));
                y && h.push(b(r.normal));
                x && (y = r.vertexNormals, h.push(b(y[0]), b(y[1]), b(y[2])));
                w && h.push(c(r.color));
                B && (r = r.vertexColors,
                    h.push(c(r[0]), c(r[1]), c(r[2])))
            }
            e.data = {};
            e.data.vertices = f;
            e.data.normals = k;
            0 < l.length && (e.data.colors = l);
            0 < t.length && (e.data.uvs = [t]);
            e.data.faces = h;
            return e
        },
        clone: function() {
            return (new R).copy(this)
        },
        copy: function(a) {
            var b, c, d;
            this.vertices = [];
            this.colors = [];
            this.faces = [];
            this.faceVertexUvs = [
                []
            ];
            this.morphTargets = [];
            this.morphNormals = [];
            this.skinWeights = [];
            this.skinIndices = [];
            this.lineDistances = [];
            this.boundingSphere = this.boundingBox = null;
            this.name = a.name;
            var e = a.vertices;
            var f = 0;
            for (b = e.length; f <
                b; f++) this.vertices.push(e[f].clone());
            e = a.colors;
            f = 0;
            for (b = e.length; f < b; f++) this.colors.push(e[f].clone());
            e = a.faces;
            f = 0;
            for (b = e.length; f < b; f++) this.faces.push(e[f].clone());
            f = 0;
            for (b = a.faceVertexUvs.length; f < b; f++) {
                var g = a.faceVertexUvs[f];
                void 0 === this.faceVertexUvs[f] && (this.faceVertexUvs[f] = []);
                e = 0;
                for (c = g.length; e < c; e++) {
                    var h = g[e],
                        k = [];
                    var m = 0;
                    for (d = h.length; m < d; m++) k.push(h[m].clone());
                    this.faceVertexUvs[f].push(k)
                }
            }
            m = a.morphTargets;
            f = 0;
            for (b = m.length; f < b; f++) {
                d = {};
                d.name = m[f].name;
                if (void 0 !==
                    m[f].vertices)
                    for (d.vertices = [], e = 0, c = m[f].vertices.length; e < c; e++) d.vertices.push(m[f].vertices[e].clone());
                if (void 0 !== m[f].normals)
                    for (d.normals = [], e = 0, c = m[f].normals.length; e < c; e++) d.normals.push(m[f].normals[e].clone());
                this.morphTargets.push(d)
            }
            m = a.morphNormals;
            f = 0;
            for (b = m.length; f < b; f++) {
                d = {};
                if (void 0 !== m[f].vertexNormals)
                    for (d.vertexNormals = [], e = 0, c = m[f].vertexNormals.length; e < c; e++) g = m[f].vertexNormals[e], h = {}, h.a = g.a.clone(), h.b = g.b.clone(), h.c = g.c.clone(), d.vertexNormals.push(h);
                if (void 0 !==
                    m[f].faceNormals)
                    for (d.faceNormals = [], e = 0, c = m[f].faceNormals.length; e < c; e++) d.faceNormals.push(m[f].faceNormals[e].clone());
                this.morphNormals.push(d)
            }
            e = a.skinWeights;
            f = 0;
            for (b = e.length; f < b; f++) this.skinWeights.push(e[f].clone());
            e = a.skinIndices;
            f = 0;
            for (b = e.length; f < b; f++) this.skinIndices.push(e[f].clone());
            e = a.lineDistances;
            f = 0;
            for (b = e.length; f < b; f++) this.lineDistances.push(e[f]);
            f = a.boundingBox;
            null !== f && (this.boundingBox = f.clone());
            f = a.boundingSphere;
            null !== f && (this.boundingSphere = f.clone());
            this.elementsNeedUpdate =
                a.elementsNeedUpdate;
            this.verticesNeedUpdate = a.verticesNeedUpdate;
            this.uvsNeedUpdate = a.uvsNeedUpdate;
            this.normalsNeedUpdate = a.normalsNeedUpdate;
            this.colorsNeedUpdate = a.colorsNeedUpdate;
            this.lineDistancesNeedUpdate = a.lineDistancesNeedUpdate;
            this.groupsNeedUpdate = a.groupsNeedUpdate;
            return this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    });
    Object.defineProperty(Q.prototype, "needsUpdate", {
        set: function(a) {
            !0 === a && this.version++
        }
    });
    Object.assign(Q.prototype, {
        isBufferAttribute: !0,
        onUploadCallback: function() {},
        setArray: function(a) {
            if (Array.isArray(a)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.count = void 0 !== a ? a.length / this.itemSize : 0;
            this.array = a;
            return this
        },
        setDynamic: function(a) {
            this.dynamic = a;
            return this
        },
        copy: function(a) {
            this.name = a.name;
            this.array = new a.array.constructor(a.array);
            this.itemSize = a.itemSize;
            this.count = a.count;
            this.normalized = a.normalized;
            this.dynamic = a.dynamic;
            return this
        },
        copyAt: function(a, b, c) {
            a *= this.itemSize;
            c *= b.itemSize;
            for (var d = 0, e = this.itemSize; d <
                e; d++) this.array[a + d] = b.array[c + d];
            return this
        },
        copyArray: function(a) {
            this.array.set(a);
            return this
        },
        copyColorsArray: function(a) {
            for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
                var f = a[d];
                void 0 === f && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", d), f = new G);
                b[c++] = f.r;
                b[c++] = f.g;
                b[c++] = f.b
            }
            return this
        },
        copyVector2sArray: function(a) {
            for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
                var f = a[d];
                void 0 === f && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
                    d), f = new z);
                b[c++] = f.x;
                b[c++] = f.y
            }
            return this
        },
        copyVector3sArray: function(a) {
            for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
                var f = a[d];
                void 0 === f && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", d), f = new p);
                b[c++] = f.x;
                b[c++] = f.y;
                b[c++] = f.z
            }
            return this
        },
        copyVector4sArray: function(a) {
            for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
                var f = a[d];
                void 0 === f && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", d), f = new V);
                b[c++] = f.x;
                b[c++] = f.y;
                b[c++] = f.z;
                b[c++] = f.w
            }
            return this
        },
        set: function(a, b) {
            void 0 === b && (b = 0);
            this.array.set(a, b);
            return this
        },
        getX: function(a) {
            return this.array[a * this.itemSize]
        },
        setX: function(a, b) {
            this.array[a * this.itemSize] = b;
            return this
        },
        getY: function(a) {
            return this.array[a * this.itemSize + 1]
        },
        setY: function(a, b) {
            this.array[a * this.itemSize + 1] = b;
            return this
        },
        getZ: function(a) {
            return this.array[a * this.itemSize + 2]
        },
        setZ: function(a, b) {
            this.array[a * this.itemSize + 2] = b;
            return this
        },
        getW: function(a) {
            return this.array[a * this.itemSize +
                3]
        },
        setW: function(a, b) {
            this.array[a * this.itemSize + 3] = b;
            return this
        },
        setXY: function(a, b, c) {
            a *= this.itemSize;
            this.array[a + 0] = b;
            this.array[a + 1] = c;
            return this
        },
        setXYZ: function(a, b, c, d) {
            a *= this.itemSize;
            this.array[a + 0] = b;
            this.array[a + 1] = c;
            this.array[a + 2] = d;
            return this
        },
        setXYZW: function(a, b, c, d, e) {
            a *= this.itemSize;
            this.array[a + 0] = b;
            this.array[a + 1] = c;
            this.array[a + 2] = d;
            this.array[a + 3] = e;
            return this
        },
        onUpload: function(a) {
            this.onUploadCallback = a;
            return this
        },
        clone: function() {
            return (new this.constructor(this.array,
                this.itemSize)).copy(this)
        }
    });
    oc.prototype = Object.create(Q.prototype);
    oc.prototype.constructor = oc;
    pc.prototype = Object.create(Q.prototype);
    pc.prototype.constructor = pc;
    qc.prototype = Object.create(Q.prototype);
    qc.prototype.constructor = qc;
    rc.prototype = Object.create(Q.prototype);
    rc.prototype.constructor = rc;
    ib.prototype = Object.create(Q.prototype);
    ib.prototype.constructor = ib;
    sc.prototype = Object.create(Q.prototype);
    sc.prototype.constructor = sc;
    jb.prototype = Object.create(Q.prototype);
    jb.prototype.constructor =
        jb;
    A.prototype = Object.create(Q.prototype);
    A.prototype.constructor = A;
    tc.prototype = Object.create(Q.prototype);
    tc.prototype.constructor = tc;
    Object.assign(Ee.prototype, {
        computeGroups: function(a) {
            var b = [],
                c = void 0;
            a = a.faces;
            for (var d = 0; d < a.length; d++) {
                var e = a[d];
                if (e.materialIndex !== c) {
                    c = e.materialIndex;
                    void 0 !== f && (f.count = 3 * d - f.start, b.push(f));
                    var f = {
                        start: 3 * d,
                        materialIndex: c
                    }
                }
            }
            void 0 !== f && (f.count = 3 * d - f.start, b.push(f));
            this.groups = b
        },
        fromGeometry: function(a) {
            var b = a.faces,
                c = a.vertices,
                d = a.faceVertexUvs,
                e = d[0] && 0 < d[0].length,
                f = d[1] && 0 < d[1].length,
                g = a.morphTargets,
                h = g.length;
            if (0 < h) {
                var k = [];
                for (var m = 0; m < h; m++) k[m] = [];
                this.morphTargets.position = k
            }
            var l = a.morphNormals,
                n = l.length;
            if (0 < n) {
                var t = [];
                for (m = 0; m < n; m++) t[m] = [];
                this.morphTargets.normal = t
            }
            var p = a.skinIndices,
                r = a.skinWeights,
                v = p.length === c.length,
                y = r.length === c.length;
            0 < c.length && 0 === b.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
            for (m = 0; m < b.length; m++) {
                var x = b[m];
                this.vertices.push(c[x.a], c[x.b], c[x.c]);
                var w = x.vertexNormals;
                3 === w.length ? this.normals.push(w[0], w[1], w[2]) : (w = x.normal, this.normals.push(w, w, w));
                w = x.vertexColors;
                3 === w.length ? this.colors.push(w[0], w[1], w[2]) : (w = x.color, this.colors.push(w, w, w));
                !0 === e && (w = d[0][m], void 0 !== w ? this.uvs.push(w[0], w[1], w[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", m), this.uvs.push(new z, new z, new z)));
                !0 === f && (w = d[1][m], void 0 !== w ? this.uvs2.push(w[0], w[1], w[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",
                    m), this.uvs2.push(new z, new z, new z)));
                for (w = 0; w < h; w++) {
                    var B = g[w].vertices;
                    k[w].push(B[x.a], B[x.b], B[x.c])
                }
                for (w = 0; w < n; w++) B = l[w].vertexNormals[m], t[w].push(B.a, B.b, B.c);
                v && this.skinIndices.push(p[x.a], p[x.b], p[x.c]);
                y && this.skinWeights.push(r[x.a], r[x.b], r[x.c])
            }
            this.computeGroups(a);
            this.verticesNeedUpdate = a.verticesNeedUpdate;
            this.normalsNeedUpdate = a.normalsNeedUpdate;
            this.colorsNeedUpdate = a.colorsNeedUpdate;
            this.uvsNeedUpdate = a.uvsNeedUpdate;
            this.groupsNeedUpdate = a.groupsNeedUpdate;
            return this
        }
    });
    var If = 1;
    C.prototype = Object.assign(Object.create(ya.prototype), {
        constructor: C,
        isBufferGeometry: !0,
        getIndex: function() {
            return this.index
        },
        setIndex: function(a) {
            Array.isArray(a) ? this.index = new(65535 < Fe(a) ? jb : ib)(a, 1) : this.index = a
        },
        addAttribute: function(a, b, c) {
            if (!(b && b.isBufferAttribute || b && b.isInterleavedBufferAttribute)) return console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(a, new Q(b, c));
            if ("index" === a) return console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),
                this.setIndex(b), this;
            this.attributes[a] = b;
            return this
        },
        getAttribute: function(a) {
            return this.attributes[a]
        },
        removeAttribute: function(a) {
            delete this.attributes[a];
            return this
        },
        addGroup: function(a, b, c) {
            this.groups.push({
                start: a,
                count: b,
                materialIndex: void 0 !== c ? c : 0
            })
        },
        clearGroups: function() {
            this.groups = []
        },
        setDrawRange: function(a, b) {
            this.drawRange.start = a;
            this.drawRange.count = b
        },
        applyMatrix: function(a) {
            var b = this.attributes.position;
            void 0 !== b && (a.applyToBufferAttribute(b), b.needsUpdate = !0);
            b = this.attributes.normal;
            void 0 !== b && ((new ra).getNormalMatrix(a).applyToBufferAttribute(b), b.needsUpdate = !0);
            null !== this.boundingBox && this.computeBoundingBox();
            null !== this.boundingSphere && this.computeBoundingSphere();
            return this
        },
        rotateX: function() {
            var a = new I;
            return function(b) {
                a.makeRotationX(b);
                this.applyMatrix(a);
                return this
            }
        }(),
        rotateY: function() {
            var a = new I;
            return function(b) {
                a.makeRotationY(b);
                this.applyMatrix(a);
                return this
            }
        }(),
        rotateZ: function() {
            var a = new I;
            return function(b) {
                a.makeRotationZ(b);
                this.applyMatrix(a);
                return this
            }
        }(),
        translate: function() {
            var a = new I;
            return function(b, c, d) {
                a.makeTranslation(b, c, d);
                this.applyMatrix(a);
                return this
            }
        }(),
        scale: function() {
            var a = new I;
            return function(b, c, d) {
                a.makeScale(b, c, d);
                this.applyMatrix(a);
                return this
            }
        }(),
        lookAt: function() {
            var a = new D;
            return function(b) {
                a.lookAt(b);
                a.updateMatrix();
                this.applyMatrix(a.matrix)
            }
        }(),
        center: function() {
            var a = new p;
            return function() {
                this.computeBoundingBox();
                this.boundingBox.getCenter(a).negate();
                this.translate(a.x, a.y, a.z);
                return this
            }
        }(),
        setFromObject: function(a) {
            var b = a.geometry;
            if (a.isPoints || a.isLine) {
                a = new A(3 * b.vertices.length, 3);
                var c = new A(3 * b.colors.length, 3);
                this.addAttribute("position", a.copyVector3sArray(b.vertices));
                this.addAttribute("color", c.copyColorsArray(b.colors));
                b.lineDistances && b.lineDistances.length === b.vertices.length && (a = new A(b.lineDistances.length, 1), this.addAttribute("lineDistance", a.copyArray(b.lineDistances)));
                null !== b.boundingSphere && (this.boundingSphere = b.boundingSphere.clone());
                null !== b.boundingBox &&
                    (this.boundingBox = b.boundingBox.clone())
            } else a.isMesh && b && b.isGeometry && this.fromGeometry(b);
            return this
        },
        setFromPoints: function(a) {
            for (var b = [], c = 0, d = a.length; c < d; c++) {
                var e = a[c];
                b.push(e.x, e.y, e.z || 0)
            }
            this.addAttribute("position", new A(b, 3));
            return this
        },
        updateFromObject: function(a) {
            var b = a.geometry;
            if (a.isMesh) {
                var c = b.__directGeometry;
                !0 === b.elementsNeedUpdate && (c = void 0, b.elementsNeedUpdate = !1);
                if (void 0 === c) return this.fromGeometry(b);
                c.verticesNeedUpdate = b.verticesNeedUpdate;
                c.normalsNeedUpdate =
                    b.normalsNeedUpdate;
                c.colorsNeedUpdate = b.colorsNeedUpdate;
                c.uvsNeedUpdate = b.uvsNeedUpdate;
                c.groupsNeedUpdate = b.groupsNeedUpdate;
                b.verticesNeedUpdate = !1;
                b.normalsNeedUpdate = !1;
                b.colorsNeedUpdate = !1;
                b.uvsNeedUpdate = !1;
                b.groupsNeedUpdate = !1;
                b = c
            }!0 === b.verticesNeedUpdate && (c = this.attributes.position, void 0 !== c && (c.copyVector3sArray(b.vertices), c.needsUpdate = !0), b.verticesNeedUpdate = !1);
            !0 === b.normalsNeedUpdate && (c = this.attributes.normal, void 0 !== c && (c.copyVector3sArray(b.normals), c.needsUpdate = !0), b.normalsNeedUpdate = !1);
            !0 === b.colorsNeedUpdate && (c = this.attributes.color, void 0 !== c && (c.copyColorsArray(b.colors), c.needsUpdate = !0), b.colorsNeedUpdate = !1);
            b.uvsNeedUpdate && (c = this.attributes.uv, void 0 !== c && (c.copyVector2sArray(b.uvs), c.needsUpdate = !0), b.uvsNeedUpdate = !1);
            b.lineDistancesNeedUpdate && (c = this.attributes.lineDistance, void 0 !== c && (c.copyArray(b.lineDistances), c.needsUpdate = !0), b.lineDistancesNeedUpdate = !1);
            b.groupsNeedUpdate && (b.computeGroups(a.geometry), this.groups = b.groups, b.groupsNeedUpdate = !1);
            return this
        },
        fromGeometry: function(a) {
            a.__directGeometry = (new Ee).fromGeometry(a);
            return this.fromDirectGeometry(a.__directGeometry)
        },
        fromDirectGeometry: function(a) {
            var b = new Float32Array(3 * a.vertices.length);
            this.addAttribute("position", (new Q(b, 3)).copyVector3sArray(a.vertices));
            0 < a.normals.length && (b = new Float32Array(3 * a.normals.length), this.addAttribute("normal", (new Q(b, 3)).copyVector3sArray(a.normals)));
            0 < a.colors.length && (b = new Float32Array(3 * a.colors.length), this.addAttribute("color", (new Q(b, 3)).copyColorsArray(a.colors)));
            0 < a.uvs.length && (b = new Float32Array(2 * a.uvs.length), this.addAttribute("uv", (new Q(b, 2)).copyVector2sArray(a.uvs)));
            0 < a.uvs2.length && (b = new Float32Array(2 * a.uvs2.length), this.addAttribute("uv2", (new Q(b, 2)).copyVector2sArray(a.uvs2)));
            this.groups = a.groups;
            for (var c in a.morphTargets) {
                b = [];
                for (var d = a.morphTargets[c], e = 0, f = d.length; e < f; e++) {
                    var g = d[e],
                        h = new A(3 * g.length, 3);
                    b.push(h.copyVector3sArray(g))
                }
                this.morphAttributes[c] = b
            }
            0 < a.skinIndices.length && (c = new A(4 * a.skinIndices.length, 4), this.addAttribute("skinIndex",
                c.copyVector4sArray(a.skinIndices)));
            0 < a.skinWeights.length && (c = new A(4 * a.skinWeights.length, 4), this.addAttribute("skinWeight", c.copyVector4sArray(a.skinWeights)));
            null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone());
            null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());
            return this
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new Sa);
            var a = this.attributes.position;
            void 0 !== a ? this.boundingBox.setFromBufferAttribute(a) : this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
        },
        computeBoundingSphere: function() {
            var a = new Sa,
                b = new p;
            return function() {
                null === this.boundingSphere && (this.boundingSphere = new Da);
                var c = this.attributes.position;
                if (c) {
                    var d = this.boundingSphere.center;
                    a.setFromBufferAttribute(c);
                    a.getCenter(d);
                    for (var e = 0,
                            f = 0, g = c.count; f < g; f++) b.x = c.getX(f), b.y = c.getY(f), b.z = c.getZ(f), e = Math.max(e, d.distanceToSquared(b));
                    this.boundingSphere.radius = Math.sqrt(e);
                    isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }
        }(),
        computeFaceNormals: function() {},
        computeVertexNormals: function() {
            var a = this.index,
                b = this.attributes,
                c = this.groups;
            if (b.position) {
                var d = b.position.array;
                if (void 0 === b.normal) this.addAttribute("normal",
                    new Q(new Float32Array(d.length), 3));
                else
                    for (var e = b.normal.array, f = 0, g = e.length; f < g; f++) e[f] = 0;
                e = b.normal.array;
                var h = new p,
                    k = new p,
                    m = new p,
                    l = new p,
                    n = new p;
                if (a) {
                    a = a.array;
                    0 === c.length && this.addGroup(0, a.length);
                    for (var t = 0, u = c.length; t < u; ++t) {
                        f = c[t];
                        g = f.start;
                        var r = f.count;
                        f = g;
                        for (g += r; f < g; f += 3) {
                            r = 3 * a[f + 0];
                            var v = 3 * a[f + 1];
                            var y = 3 * a[f + 2];
                            h.fromArray(d, r);
                            k.fromArray(d, v);
                            m.fromArray(d, y);
                            l.subVectors(m, k);
                            n.subVectors(h, k);
                            l.cross(n);
                            e[r] += l.x;
                            e[r + 1] += l.y;
                            e[r + 2] += l.z;
                            e[v] += l.x;
                            e[v + 1] += l.y;
                            e[v + 2] +=
                                l.z;
                            e[y] += l.x;
                            e[y + 1] += l.y;
                            e[y + 2] += l.z
                        }
                    }
                } else
                    for (f = 0, g = d.length; f < g; f += 9) h.fromArray(d, f), k.fromArray(d, f + 3), m.fromArray(d, f + 6), l.subVectors(m, k), n.subVectors(h, k), l.cross(n), e[f] = l.x, e[f + 1] = l.y, e[f + 2] = l.z, e[f + 3] = l.x, e[f + 4] = l.y, e[f + 5] = l.z, e[f + 6] = l.x, e[f + 7] = l.y, e[f + 8] = l.z;
                this.normalizeNormals();
                b.normal.needsUpdate = !0
            }
        },
        merge: function(a, b) {
            if (a && a.isBufferGeometry) {
                void 0 === b && (b = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                var c = this.attributes,
                    d;
                for (d in c)
                    if (void 0 !== a.attributes[d]) {
                        var e = c[d].array,
                            f = a.attributes[d],
                            g = f.array,
                            h = 0;
                        for (f = f.itemSize * b; h < g.length; h++, f++) e[f] = g[h]
                    }
                return this
            }
            console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", a)
        },
        normalizeNormals: function() {
            var a = new p;
            return function() {
                for (var b = this.attributes.normal, c = 0, d = b.count; c < d; c++) a.x = b.getX(c), a.y = b.getY(c), a.z = b.getZ(c), a.normalize(), b.setXYZ(c, a.x, a.y, a.z)
            }
        }(),
        toNonIndexed: function() {
            if (null ===
                this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
            var a = new C,
                b = this.index.array,
                c = this.attributes,
                d;
            for (d in c) {
                var e = c[d],
                    f = e.array,
                    g = e.itemSize,
                    h = new f.constructor(b.length * g),
                    k = 0;
                e = 0;
                for (var m = b.length; e < m; e++) {
                    var l = b[e] * g;
                    for (var n = 0; n < g; n++) h[k++] = f[l++]
                }
                a.addAttribute(d, new Q(h, g))
            }
            b = this.groups;
            e = 0;
            for (m = b.length; e < m; e++) c = b[e], a.addGroup(c.start, c.count, c.materialIndex);
            return a
        },
        toJSON: function() {
            var a = {
                metadata: {
                    version: 4.5,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            a.uuid = this.uuid;
            a.type = this.type;
            "" !== this.name && (a.name = this.name);
            0 < Object.keys(this.userData).length && (a.userData = this.userData);
            if (void 0 !== this.parameters) {
                var b = this.parameters;
                for (e in b) void 0 !== b[e] && (a[e] = b[e]);
                return a
            }
            a.data = {
                attributes: {}
            };
            var c = this.index;
            null !== c && (b = Array.prototype.slice.call(c.array), a.data.index = {
                type: c.array.constructor.name,
                array: b
            });
            c = this.attributes;
            for (e in c) {
                var d = c[e];
                b = Array.prototype.slice.call(d.array);
                a.data.attributes[e] = {
                    itemSize: d.itemSize,
                    type: d.array.constructor.name,
                    array: b,
                    normalized: d.normalized
                }
            }
            var e = this.groups;
            0 < e.length && (a.data.groups = JSON.parse(JSON.stringify(e)));
            e = this.boundingSphere;
            null !== e && (a.data.boundingSphere = {
                center: e.center.toArray(),
                radius: e.radius
            });
            return a
        },
        clone: function() {
            return (new C).copy(this)
        },
        copy: function(a) {
            var b;
            this.index = null;
            this.attributes = {};
            this.morphAttributes = {};
            this.groups = [];
            this.boundingSphere = this.boundingBox = null;
            this.name = a.name;
            var c = a.index;
            null !== c && this.setIndex(c.clone());
            c = a.attributes;
            for (g in c) this.addAttribute(g, c[g].clone());
            var d = a.morphAttributes;
            for (g in d) {
                var e = [],
                    f = d[g];
                c = 0;
                for (b = f.length; c < b; c++) e.push(f[c].clone());
                this.morphAttributes[g] = e
            }
            var g = a.groups;
            c = 0;
            for (b = g.length; c < b; c++) d = g[c], this.addGroup(d.start, d.count, d.materialIndex);
            g = a.boundingBox;
            null !== g && (this.boundingBox = g.clone());
            g = a.boundingSphere;
            null !== g && (this.boundingSphere = g.clone());
            this.drawRange.start = a.drawRange.start;
            this.drawRange.count = a.drawRange.count;
            this.userData = a.userData;
            return this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    });
    Ib.prototype = Object.create(R.prototype);
    Ib.prototype.constructor = Ib;
    kb.prototype = Object.create(C.prototype);
    kb.prototype.constructor = kb;
    uc.prototype = Object.create(R.prototype);
    uc.prototype.constructor = uc;
    lb.prototype = Object.create(C.prototype);
    lb.prototype.constructor = lb;
    var Kf = 0;
    J.prototype = Object.assign(Object.create(ya.prototype), {
        constructor: J,
        isMaterial: !0,
        onBeforeCompile: function() {},
        setValues: function(a) {
            if (void 0 !== a)
                for (var b in a) {
                    var c =
                        a[b];
                    if (void 0 === c) console.warn("THREE.Material: '" + b + "' parameter is undefined.");
                    else if ("shading" === b) console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === c ? !0 : !1;
                    else {
                        var d = this[b];
                        void 0 === d ? console.warn("THREE." + this.type + ": '" + b + "' is not a property of this material.") : d && d.isColor ? d.set(c) : d && d.isVector3 && c && c.isVector3 ? d.copy(c) : this[b] = "overdraw" === b ? Number(c) : c
                    }
                }
        },
        toJSON: function(a) {
            function b(a) {
                var b = [],
                    c;
                for (c in a) {
                    var d =
                        a[c];
                    delete d.metadata;
                    b.push(d)
                }
                return b
            }
            var c = void 0 === a || "string" === typeof a;
            c && (a = {
                textures: {},
                images: {}
            });
            var d = {
                metadata: {
                    version: 4.5,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };
            d.uuid = this.uuid;
            d.type = this.type;
            "" !== this.name && (d.name = this.name);
            this.color && this.color.isColor && (d.color = this.color.getHex());
            void 0 !== this.roughness && (d.roughness = this.roughness);
            void 0 !== this.metalness && (d.metalness = this.metalness);
            this.emissive && this.emissive.isColor && (d.emissive = this.emissive.getHex());
            1 !==
                this.emissiveIntensity && (d.emissiveIntensity = this.emissiveIntensity);
            this.specular && this.specular.isColor && (d.specular = this.specular.getHex());
            void 0 !== this.shininess && (d.shininess = this.shininess);
            void 0 !== this.clearCoat && (d.clearCoat = this.clearCoat);
            void 0 !== this.clearCoatRoughness && (d.clearCoatRoughness = this.clearCoatRoughness);
            this.map && this.map.isTexture && (d.map = this.map.toJSON(a).uuid);
            this.alphaMap && this.alphaMap.isTexture && (d.alphaMap = this.alphaMap.toJSON(a).uuid);
            this.lightMap && this.lightMap.isTexture &&
                (d.lightMap = this.lightMap.toJSON(a).uuid);
            this.aoMap && this.aoMap.isTexture && (d.aoMap = this.aoMap.toJSON(a).uuid, d.aoMapIntensity = this.aoMapIntensity);
            this.bumpMap && this.bumpMap.isTexture && (d.bumpMap = this.bumpMap.toJSON(a).uuid, d.bumpScale = this.bumpScale);
            this.normalMap && this.normalMap.isTexture && (d.normalMap = this.normalMap.toJSON(a).uuid, d.normalMapType = this.normalMapType, d.normalScale = this.normalScale.toArray());
            this.displacementMap && this.displacementMap.isTexture && (d.displacementMap = this.displacementMap.toJSON(a).uuid,
                d.displacementScale = this.displacementScale, d.displacementBias = this.displacementBias);
            this.roughnessMap && this.roughnessMap.isTexture && (d.roughnessMap = this.roughnessMap.toJSON(a).uuid);
            this.metalnessMap && this.metalnessMap.isTexture && (d.metalnessMap = this.metalnessMap.toJSON(a).uuid);
            this.emissiveMap && this.emissiveMap.isTexture && (d.emissiveMap = this.emissiveMap.toJSON(a).uuid);
            this.specularMap && this.specularMap.isTexture && (d.specularMap = this.specularMap.toJSON(a).uuid);
            this.envMap && this.envMap.isTexture &&
                (d.envMap = this.envMap.toJSON(a).uuid, d.reflectivity = this.reflectivity);
            this.gradientMap && this.gradientMap.isTexture && (d.gradientMap = this.gradientMap.toJSON(a).uuid);
            void 0 !== this.size && (d.size = this.size);
            void 0 !== this.sizeAttenuation && (d.sizeAttenuation = this.sizeAttenuation);
            1 !== this.blending && (d.blending = this.blending);
            !0 === this.flatShading && (d.flatShading = this.flatShading);
            0 !== this.side && (d.side = this.side);
            0 !== this.vertexColors && (d.vertexColors = this.vertexColors);
            1 > this.opacity && (d.opacity = this.opacity);
            !0 === this.transparent && (d.transparent = this.transparent);
            d.depthFunc = this.depthFunc;
            d.depthTest = this.depthTest;
            d.depthWrite = this.depthWrite;
            0 !== this.rotation && (d.rotation = this.rotation);
            1 !== this.linewidth && (d.linewidth = this.linewidth);
            void 0 !== this.dashSize && (d.dashSize = this.dashSize);
            void 0 !== this.gapSize && (d.gapSize = this.gapSize);
            void 0 !== this.scale && (d.scale = this.scale);
            !0 === this.dithering && (d.dithering = !0);
            0 < this.alphaTest && (d.alphaTest = this.alphaTest);
            !0 === this.premultipliedAlpha && (d.premultipliedAlpha =
                this.premultipliedAlpha);
            !0 === this.wireframe && (d.wireframe = this.wireframe);
            1 < this.wireframeLinewidth && (d.wireframeLinewidth = this.wireframeLinewidth);
            "round" !== this.wireframeLinecap && (d.wireframeLinecap = this.wireframeLinecap);
            "round" !== this.wireframeLinejoin && (d.wireframeLinejoin = this.wireframeLinejoin);
            !0 === this.morphTargets && (d.morphTargets = !0);
            !0 === this.skinning && (d.skinning = !0);
            !1 === this.visible && (d.visible = !1);
            "{}" !== JSON.stringify(this.userData) && (d.userData = this.userData);
            c && (c = b(a.textures),
                a = b(a.images), 0 < c.length && (d.textures = c), 0 < a.length && (d.images = a));
            return d
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            this.name = a.name;
            this.fog = a.fog;
            this.lights = a.lights;
            this.blending = a.blending;
            this.side = a.side;
            this.flatShading = a.flatShading;
            this.vertexColors = a.vertexColors;
            this.opacity = a.opacity;
            this.transparent = a.transparent;
            this.blendSrc = a.blendSrc;
            this.blendDst = a.blendDst;
            this.blendEquation = a.blendEquation;
            this.blendSrcAlpha = a.blendSrcAlpha;
            this.blendDstAlpha =
                a.blendDstAlpha;
            this.blendEquationAlpha = a.blendEquationAlpha;
            this.depthFunc = a.depthFunc;
            this.depthTest = a.depthTest;
            this.depthWrite = a.depthWrite;
            this.colorWrite = a.colorWrite;
            this.precision = a.precision;
            this.polygonOffset = a.polygonOffset;
            this.polygonOffsetFactor = a.polygonOffsetFactor;
            this.polygonOffsetUnits = a.polygonOffsetUnits;
            this.dithering = a.dithering;
            this.alphaTest = a.alphaTest;
            this.premultipliedAlpha = a.premultipliedAlpha;
            this.overdraw = a.overdraw;
            this.visible = a.visible;
            this.userData = JSON.parse(JSON.stringify(a.userData));
            this.clipShadows = a.clipShadows;
            this.clipIntersection = a.clipIntersection;
            var b = a.clippingPlanes,
                c = null;
            if (null !== b) {
                var d = b.length;
                c = Array(d);
                for (var e = 0; e !== d; ++e) c[e] = b[e].clone()
            }
            this.clippingPlanes = c;
            this.shadowSide = a.shadowSide;
            return this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    });
    da.prototype = Object.create(J.prototype);
    da.prototype.constructor = da;
    da.prototype.isMeshBasicMaterial = !0;
    da.prototype.copy = function(a) {
        J.prototype.copy.call(this, a);
        this.color.copy(a.color);
        this.map =
            a.map;
        this.lightMap = a.lightMap;
        this.lightMapIntensity = a.lightMapIntensity;
        this.aoMap = a.aoMap;
        this.aoMapIntensity = a.aoMapIntensity;
        this.specularMap = a.specularMap;
        this.alphaMap = a.alphaMap;
        this.envMap = a.envMap;
        this.combine = a.combine;
        this.reflectivity = a.reflectivity;
        this.refractionRatio = a.refractionRatio;
        this.wireframe = a.wireframe;
        this.wireframeLinewidth = a.wireframeLinewidth;
        this.wireframeLinecap = a.wireframeLinecap;
        this.wireframeLinejoin = a.wireframeLinejoin;
        this.skinning = a.skinning;
        this.morphTargets =
            a.morphTargets;
        return this
    };
    ta.prototype = Object.create(J.prototype);
    ta.prototype.constructor = ta;
    ta.prototype.isShaderMaterial = !0;
    ta.prototype.copy = function(a) {
        J.prototype.copy.call(this, a);
        this.fragmentShader = a.fragmentShader;
        this.vertexShader = a.vertexShader;
        this.uniforms = Aa.clone(a.uniforms);
        this.defines = Object.assign({}, a.defines);
        this.wireframe = a.wireframe;
        this.wireframeLinewidth = a.wireframeLinewidth;
        this.lights = a.lights;
        this.clipping = a.clipping;
        this.skinning = a.skinning;
        this.morphTargets = a.morphTargets;
        this.morphNormals = a.morphNormals;
        this.extensions = a.extensions;
        return this
    };
    ta.prototype.toJSON = function(a) {
        a = J.prototype.toJSON.call(this, a);
        a.uniforms = this.uniforms;
        a.vertexShader = this.vertexShader;
        a.fragmentShader = this.fragmentShader;
        return a
    };
    Object.assign(mb.prototype, {
        set: function(a, b) {
            this.origin.copy(a);
            this.direction.copy(b);
            return this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            this.origin.copy(a.origin);
            this.direction.copy(a.direction);
            return this
        },
        at: function(a,
            b) {
            void 0 === b && (console.warn("THREE.Ray: .at() target is now required"), b = new p);
            return b.copy(this.direction).multiplyScalar(a).add(this.origin)
        },
        lookAt: function(a) {
            this.direction.copy(a).sub(this.origin).normalize();
            return this
        },
        recast: function() {
            var a = new p;
            return function(b) {
                this.origin.copy(this.at(b, a));
                return this
            }
        }(),
        closestPointToPoint: function(a, b) {
            void 0 === b && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), b = new p);
            b.subVectors(a, this.origin);
            a = b.dot(this.direction);
            return 0 > a ? b.copy(this.origin) : b.copy(this.direction).multiplyScalar(a).add(this.origin)
        },
        distanceToPoint: function(a) {
            return Math.sqrt(this.distanceSqToPoint(a))
        },
        distanceSqToPoint: function() {
            var a = new p;
            return function(b) {
                var c = a.subVectors(b, this.origin).dot(this.direction);
                if (0 > c) return this.origin.distanceToSquared(b);
                a.copy(this.direction).multiplyScalar(c).add(this.origin);
                return a.distanceToSquared(b)
            }
        }(),
        distanceSqToSegment: function() {
            var a = new p,
                b = new p,
                c = new p;
            return function(d, e, f, g) {
                a.copy(d).add(e).multiplyScalar(.5);
                b.copy(e).sub(d).normalize();
                c.copy(this.origin).sub(a);
                var h = .5 * d.distanceTo(e),
                    k = -this.direction.dot(b),
                    m = c.dot(this.direction),
                    l = -c.dot(b),
                    n = c.lengthSq(),
                    t = Math.abs(1 - k * k);
                if (0 < t) {
                    d = k * l - m;
                    e = k * m - l;
                    var p = h * t;
                    0 <= d ? e >= -p ? e <= p ? (h = 1 / t, d *= h, e *= h, k = d * (d + k * e + 2 * m) + e * (k * d + e + 2 * l) + n) : (e = h, d = Math.max(0, -(k * e + m)), k = -d * d + e * (e + 2 * l) + n) : (e = -h, d = Math.max(0, -(k * e + m)), k = -d * d + e * (e + 2 * l) + n) : e <= -p ? (d = Math.max(0, -(-k * h + m)), e = 0 < d ? -h : Math.min(Math.max(-h, -l), h), k = -d * d + e * (e + 2 * l) + n) : e <= p ? (d = 0, e = Math.min(Math.max(-h, -l), h), k =
                        e * (e + 2 * l) + n) : (d = Math.max(0, -(k * h + m)), e = 0 < d ? h : Math.min(Math.max(-h, -l), h), k = -d * d + e * (e + 2 * l) + n)
                } else e = 0 < k ? -h : h, d = Math.max(0, -(k * e + m)), k = -d * d + e * (e + 2 * l) + n;
                f && f.copy(this.direction).multiplyScalar(d).add(this.origin);
                g && g.copy(b).multiplyScalar(e).add(a);
                return k
            }
        }(),
        intersectSphere: function() {
            var a = new p;
            return function(b, c) {
                a.subVectors(b.center, this.origin);
                var d = a.dot(this.direction),
                    e = a.dot(a) - d * d;
                b = b.radius * b.radius;
                if (e > b) return null;
                b = Math.sqrt(b - e);
                e = d - b;
                d += b;
                return 0 > e && 0 > d ? null : 0 > e ? this.at(d,
                    c) : this.at(e, c)
            }
        }(),
        intersectsSphere: function(a) {
            return this.distanceToPoint(a.center) <= a.radius
        },
        distanceToPlane: function(a) {
            var b = a.normal.dot(this.direction);
            if (0 === b) return 0 === a.distanceToPoint(this.origin) ? 0 : null;
            a = -(this.origin.dot(a.normal) + a.constant) / b;
            return 0 <= a ? a : null
        },
        intersectPlane: function(a, b) {
            a = this.distanceToPlane(a);
            return null === a ? null : this.at(a, b)
        },
        intersectsPlane: function(a) {
            var b = a.distanceToPoint(this.origin);
            return 0 === b || 0 > a.normal.dot(this.direction) * b ? !0 : !1
        },
        intersectBox: function(a,
            b) {
            var c = 1 / this.direction.x;
            var d = 1 / this.direction.y;
            var e = 1 / this.direction.z,
                f = this.origin;
            if (0 <= c) {
                var g = (a.min.x - f.x) * c;
                c *= a.max.x - f.x
            } else g = (a.max.x - f.x) * c, c *= a.min.x - f.x;
            if (0 <= d) {
                var h = (a.min.y - f.y) * d;
                d *= a.max.y - f.y
            } else h = (a.max.y - f.y) * d, d *= a.min.y - f.y;
            if (g > d || h > c) return null;
            if (h > g || g !== g) g = h;
            if (d < c || c !== c) c = d;
            0 <= e ? (h = (a.min.z - f.z) * e, a = (a.max.z - f.z) * e) : (h = (a.max.z - f.z) * e, a = (a.min.z - f.z) * e);
            if (g > a || h > c) return null;
            if (h > g || g !== g) g = h;
            if (a < c || c !== c) c = a;
            return 0 > c ? null : this.at(0 <= g ? g : c, b)
        },
        intersectsBox: function() {
            var a =
                new p;
            return function(b) {
                return null !== this.intersectBox(b, a)
            }
        }(),
        intersectTriangle: function() {
            var a = new p,
                b = new p,
                c = new p,
                d = new p;
            return function(e, f, g, h, k) {
                b.subVectors(f, e);
                c.subVectors(g, e);
                d.crossVectors(b, c);
                f = this.direction.dot(d);
                if (0 < f) {
                    if (h) return null;
                    h = 1
                } else if (0 > f) h = -1, f = -f;
                else return null;
                a.subVectors(this.origin, e);
                e = h * this.direction.dot(c.crossVectors(a, c));
                if (0 > e) return null;
                g = h * this.direction.dot(b.cross(a));
                if (0 > g || e + g > f) return null;
                e = -h * a.dot(d);
                return 0 > e ? null : this.at(e / f, k)
            }
        }(),
        applyMatrix4: function(a) {
            this.origin.applyMatrix4(a);
            this.direction.transformDirection(a);
            return this
        },
        equals: function(a) {
            return a.origin.equals(this.origin) && a.direction.equals(this.direction)
        }
    });
    Object.assign(ja, {
        getNormal: function() {
            var a = new p;
            return function(b, c, d, e) {
                void 0 === e && (console.warn("THREE.Triangle: .getNormal() target is now required"), e = new p);
                e.subVectors(d, c);
                a.subVectors(b, c);
                e.cross(a);
                b = e.lengthSq();
                return 0 < b ? e.multiplyScalar(1 / Math.sqrt(b)) : e.set(0, 0, 0)
            }
        }(),
        getBarycoord: function() {
            var a =
                new p,
                b = new p,
                c = new p;
            return function(d, e, f, g, h) {
                a.subVectors(g, e);
                b.subVectors(f, e);
                c.subVectors(d, e);
                d = a.dot(a);
                e = a.dot(b);
                f = a.dot(c);
                var k = b.dot(b);
                g = b.dot(c);
                var m = d * k - e * e;
                void 0 === h && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), h = new p);
                if (0 === m) return h.set(-2, -1, -1);
                m = 1 / m;
                k = (k * f - e * g) * m;
                d = (d * g - e * f) * m;
                return h.set(1 - k - d, d, k)
            }
        }(),
        containsPoint: function() {
            var a = new p;
            return function(b, c, d, e) {
                ja.getBarycoord(b, c, d, e, a);
                return 0 <= a.x && 0 <= a.y && 1 >= a.x + a.y
            }
        }()
    });
    Object.assign(ja.prototype, {
        set: function(a, b, c) {
            this.a.copy(a);
            this.b.copy(b);
            this.c.copy(c);
            return this
        },
        setFromPointsAndIndices: function(a, b, c, d) {
            this.a.copy(a[b]);
            this.b.copy(a[c]);
            this.c.copy(a[d]);
            return this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            this.a.copy(a.a);
            this.b.copy(a.b);
            this.c.copy(a.c);
            return this
        },
        getArea: function() {
            var a = new p,
                b = new p;
            return function() {
                a.subVectors(this.c, this.b);
                b.subVectors(this.a, this.b);
                return .5 * a.cross(b).length()
            }
        }(),
        getMidpoint: function(a) {
            void 0 ===
                a && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), a = new p);
            return a.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        },
        getNormal: function(a) {
            return ja.getNormal(this.a, this.b, this.c, a)
        },
        getPlane: function(a) {
            void 0 === a && (console.warn("THREE.Triangle: .getPlane() target is now required"), a = new p);
            return a.setFromCoplanarPoints(this.a, this.b, this.c)
        },
        getBarycoord: function(a, b) {
            return ja.getBarycoord(a, this.a, this.b, this.c, b)
        },
        containsPoint: function(a) {
            return ja.containsPoint(a,
                this.a, this.b, this.c)
        },
        intersectsBox: function(a) {
            return a.intersectsTriangle(this)
        },
        closestPointToPoint: function() {
            var a = new p,
                b = new p,
                c = new p,
                d = new p,
                e = new p,
                f = new p;
            return function(g, h) {
                void 0 === h && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), h = new p);
                var k = this.a,
                    m = this.b,
                    l = this.c;
                a.subVectors(m, k);
                b.subVectors(l, k);
                d.subVectors(g, k);
                var n = a.dot(d),
                    t = b.dot(d);
                if (0 >= n && 0 >= t) return h.copy(k);
                e.subVectors(g, m);
                var u = a.dot(e),
                    r = b.dot(e);
                if (0 <= u && r <= u) return h.copy(m);
                var v = n * r - u * t;
                if (0 >= v && 0 <= n && 0 >= u) return m = n / (n - u), h.copy(k).addScaledVector(a, m);
                f.subVectors(g, l);
                g = a.dot(f);
                var y = b.dot(f);
                if (0 <= y && g <= y) return h.copy(l);
                n = g * t - n * y;
                if (0 >= n && 0 <= t && 0 >= y) return v = t / (t - y), h.copy(k).addScaledVector(b, v);
                t = u * y - g * r;
                if (0 >= t && 0 <= r - u && 0 <= g - y) return c.subVectors(l, m), v = (r - u) / (r - u + (g - y)), h.copy(m).addScaledVector(c, v);
                l = 1 / (t + n + v);
                m = n * l;
                v *= l;
                return h.copy(k).addScaledVector(a, m).addScaledVector(b, v)
            }
        }(),
        equals: function(a) {
            return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c)
        }
    });
    la.prototype = Object.assign(Object.create(D.prototype), {
        constructor: la,
        isMesh: !0,
        setDrawMode: function(a) {
            this.drawMode = a
        },
        copy: function(a) {
            D.prototype.copy.call(this, a);
            this.drawMode = a.drawMode;
            void 0 !== a.morphTargetInfluences && (this.morphTargetInfluences = a.morphTargetInfluences.slice());
            void 0 !== a.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, a.morphTargetDictionary));
            return this
        },
        updateMorphTargets: function() {
            var a = this.geometry;
            if (a.isBufferGeometry) {
                a = a.morphAttributes;
                var b =
                    Object.keys(a);
                if (0 < b.length) {
                    var c = a[b[0]];
                    if (void 0 !== c)
                        for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, a = 0, b = c.length; a < b; a++) {
                            var d = c[a].name || String(a);
                            this.morphTargetInfluences.push(0);
                            this.morphTargetDictionary[d] = a
                        }
                }
            } else if (c = a.morphTargets, void 0 !== c && 0 < c.length)
                for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, a = 0, b = c.length; a < b; a++) d = c[a].name || String(a), this.morphTargetInfluences.push(0), this.morphTargetDictionary[d] = a
        },
        raycast: function() {
            function a(a, b,
                c, d, e, f, g) {
                ja.getBarycoord(a, b, c, d, v);
                e.multiplyScalar(v.x);
                f.multiplyScalar(v.y);
                g.multiplyScalar(v.z);
                e.add(f).add(g);
                return e.clone()
            }

            function b(a, b, c, d, e, f, g, h) {
                if (null === (1 === b.side ? d.intersectTriangle(g, f, e, !0, h) : d.intersectTriangle(e, f, g, 2 !== b.side, h))) return null;
                x.copy(h);
                x.applyMatrix4(a.matrixWorld);
                b = c.ray.origin.distanceTo(x);
                return b < c.near || b > c.far ? null : {
                    distance: b,
                    point: x.clone(),
                    object: a
                }
            }

            function c(c, d, e, f, m, l, n, q, p) {
                g.fromBufferAttribute(m, n);
                h.fromBufferAttribute(m, q);
                k.fromBufferAttribute(m,
                    p);
                if (c = b(c, d, e, f, g, h, k, y)) l && (t.fromBufferAttribute(l, n), u.fromBufferAttribute(l, q), r.fromBufferAttribute(l, p), c.uv = a(y, g, h, k, t, u, r)), l = new Ta(n, q, p), ja.getNormal(g, h, k, l.normal), c.face = l;
                return c
            }
            var d = new I,
                e = new mb,
                f = new Da,
                g = new p,
                h = new p,
                k = new p,
                m = new p,
                l = new p,
                n = new p,
                t = new z,
                u = new z,
                r = new z,
                v = new p,
                y = new p,
                x = new p;
            return function(q, p) {
                var v = this.geometry,
                    w = this.material,
                    x = this.matrixWorld;
                if (void 0 !== w && (null === v.boundingSphere && v.computeBoundingSphere(), f.copy(v.boundingSphere), f.applyMatrix4(x), !1 !== q.ray.intersectsSphere(f) && (d.getInverse(x), e.copy(q.ray).applyMatrix4(d), null === v.boundingBox || !1 !== e.intersectsBox(v.boundingBox))))
                    if (v.isBufferGeometry) {
                        var z = v.index,
                            B = v.attributes.position,
                            A = v.attributes.uv,
                            D = v.groups;
                        v = v.drawRange;
                        var C;
                        if (null !== z)
                            if (Array.isArray(w)) {
                                var H = 0;
                                for (C = D.length; H < C; H++) {
                                    var G = D[H];
                                    var K = w[G.materialIndex];
                                    x = Math.max(G.start, v.start);
                                    var L = Math.min(G.start + G.count, v.start + v.count);
                                    for (G = x; G < L; G += 3) {
                                        x = z.getX(G);
                                        var I = z.getX(G + 1);
                                        var J = z.getX(G + 2);
                                        if (x = c(this,
                                                K, q, e, B, A, x, I, J)) x.faceIndex = Math.floor(G / 3), p.push(x)
                                    }
                                }
                            } else
                                for (x = Math.max(0, v.start), L = Math.min(z.count, v.start + v.count), H = x, C = L; H < C; H += 3) {
                                    if (x = z.getX(H), I = z.getX(H + 1), J = z.getX(H + 2), x = c(this, w, q, e, B, A, x, I, J)) x.faceIndex = Math.floor(H / 3), p.push(x)
                                } else if (void 0 !== B)
                                    if (Array.isArray(w))
                                        for (H = 0, C = D.length; H < C; H++)
                                            for (G = D[H], K = w[G.materialIndex], x = Math.max(G.start, v.start), L = Math.min(G.start + G.count, v.start + v.count), G = x; G < L; G += 3) {
                                                if (x = G, I = G + 1, J = G + 2, x = c(this, K, q, e, B, A, x, I, J)) x.faceIndex = Math.floor(G /
                                                    3), p.push(x)
                                            } else
                                                for (x = Math.max(0, v.start), L = Math.min(B.count, v.start + v.count), H = x, C = L; H < C; H += 3)
                                                    if (x = H, I = H + 1, J = H + 2, x = c(this, w, q, e, B, A, x, I, J)) x.faceIndex = Math.floor(H / 3), p.push(x)
                    } else if (v.isGeometry)
                    for (B = Array.isArray(w), A = v.vertices, D = v.faces, x = v.faceVertexUvs[0], 0 < x.length && (z = x), G = 0, L = D.length; G < L; G++)
                        if (I = D[G], x = B ? w[I.materialIndex] : w, void 0 !== x) {
                            H = A[I.a];
                            C = A[I.b];
                            K = A[I.c];
                            if (!0 === x.morphTargets) {
                                J = v.morphTargets;
                                var R = this.morphTargetInfluences;
                                g.set(0, 0, 0);
                                h.set(0, 0, 0);
                                k.set(0, 0, 0);
                                for (var Q =
                                        0, S = J.length; Q < S; Q++) {
                                    var T = R[Q];
                                    if (0 !== T) {
                                        var V = J[Q].vertices;
                                        g.addScaledVector(m.subVectors(V[I.a], H), T);
                                        h.addScaledVector(l.subVectors(V[I.b], C), T);
                                        k.addScaledVector(n.subVectors(V[I.c], K), T)
                                    }
                                }
                                g.add(H);
                                h.add(C);
                                k.add(K);
                                H = g;
                                C = h;
                                K = k
                            }
                            if (x = b(this, x, q, e, H, C, K, y)) z && z[G] && (J = z[G], t.copy(J[0]), u.copy(J[1]), r.copy(J[2]), x.uv = a(y, H, C, K, t, u, r)), x.face = I, x.faceIndex = G, p.push(x)
                        }
            }
        }(),
        clone: function() {
            return (new this.constructor(this.geometry, this.material)).copy(this)
        }
    });
    Ua.prototype = Object.create(T.prototype);
    Ua.prototype.constructor = Ua;
    Ua.prototype.isCubeTexture = !0;
    Object.defineProperty(Ua.prototype, "images", {
        get: function() {
            return this.image
        },
        set: function(a) {
            this.image = a
        }
    });
    var Me = new T,
        Ne = new Ua,
        Ge = [],
        Ie = [],
        Le = new Float32Array(16),
        Ke = new Float32Array(9),
        Je = new Float32Array(4);
    Re.prototype.updateCache = function(a) {
        var b = this.cache;
        a instanceof Float32Array && b.length !== a.length && (this.cache = new Float32Array(a.length));
        qa(b, a)
    };
    Se.prototype.setValue = function(a, b, c) {
        for (var d = this.seq, e = 0, f = d.length; e !==
            f; ++e) {
            var g = d[e];
            g.setValue(a, b[g.id], c)
        }
    };
    var Vd = /([\w\d_]+)(\])?(\[|\.)?/g;
    Za.prototype.setValue = function(a, b, c) {
        b = this.map[b];
        void 0 !== b && b.setValue(a, c, this.renderer)
    };
    Za.prototype.setOptional = function(a, b, c) {
        b = b[c];
        void 0 !== b && this.setValue(a, c, b)
    };
    Za.upload = function(a, b, c, d) {
        for (var e = 0, f = b.length; e !== f; ++e) {
            var g = b[e],
                h = c[g.id];
            !1 !== h.needsUpdate && g.setValue(a, h.value, d)
        }
    };
    Za.seqWithValue = function(a, b) {
        for (var c = [], d = 0, e = a.length; d !== e; ++d) {
            var f = a[d];
            f.id in b && c.push(f)
        }
        return c
    };
    var yg =
        0,
        Hg = 0;
    $a.prototype = Object.create(J.prototype);
    $a.prototype.constructor = $a;
    $a.prototype.isMeshDepthMaterial = !0;
    $a.prototype.copy = function(a) {
        J.prototype.copy.call(this, a);
        this.depthPacking = a.depthPacking;
        this.skinning = a.skinning;
        this.morphTargets = a.morphTargets;
        this.map = a.map;
        this.alphaMap = a.alphaMap;
        this.displacementMap = a.displacementMap;
        this.displacementScale = a.displacementScale;
        this.displacementBias = a.displacementBias;
        this.wireframe = a.wireframe;
        this.wireframeLinewidth = a.wireframeLinewidth;
        return this
    };
    ab.prototype = Object.create(J.prototype);
    ab.prototype.constructor = ab;
    ab.prototype.isMeshDistanceMaterial = !0;
    ab.prototype.copy = function(a) {
        J.prototype.copy.call(this, a);
        this.referencePosition.copy(a.referencePosition);
        this.nearDistance = a.nearDistance;
        this.farDistance = a.farDistance;
        this.skinning = a.skinning;
        this.morphTargets = a.morphTargets;
        this.map = a.map;
        this.alphaMap = a.alphaMap;
        this.displacementMap = a.displacementMap;
        this.displacementScale = a.displacementScale;
        this.displacementBias = a.displacementBias;
        return this
    };
    Kb.prototype = Object.assign(Object.create(D.prototype), {
        constructor: Kb,
        isGroup: !0
    });
    Z.prototype = Object.assign(Object.create(Na.prototype), {
        constructor: Z,
        isPerspectiveCamera: !0,
        copy: function(a, b) {
            Na.prototype.copy.call(this, a, b);
            this.fov = a.fov;
            this.zoom = a.zoom;
            this.near = a.near;
            this.far = a.far;
            this.focus = a.focus;
            this.aspect = a.aspect;
            this.view = null === a.view ? null : Object.assign({}, a.view);
            this.filmGauge = a.filmGauge;
            this.filmOffset = a.filmOffset;
            return this
        },
        setFocalLength: function(a) {
            a = .5 * this.getFilmHeight() /
                a;
            this.fov = 2 * H.RAD2DEG * Math.atan(a);
            this.updateProjectionMatrix()
        },
        getFocalLength: function() {
            var a = Math.tan(.5 * H.DEG2RAD * this.fov);
            return .5 * this.getFilmHeight() / a
        },
        getEffectiveFOV: function() {
            return 2 * H.RAD2DEG * Math.atan(Math.tan(.5 * H.DEG2RAD * this.fov) / this.zoom)
        },
        getFilmWidth: function() {
            return this.filmGauge * Math.min(this.aspect, 1)
        },
        getFilmHeight: function() {
            return this.filmGauge / Math.max(this.aspect, 1)
        },
        setViewOffset: function(a, b, c, d, e, f) {
            this.aspect = a / b;
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            });
            this.view.enabled = !0;
            this.view.fullWidth = a;
            this.view.fullHeight = b;
            this.view.offsetX = c;
            this.view.offsetY = d;
            this.view.width = e;
            this.view.height = f;
            this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1);
            this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var a = this.near,
                b = a * Math.tan(.5 * H.DEG2RAD * this.fov) / this.zoom,
                c = 2 * b,
                d = this.aspect * c,
                e = -.5 * d,
                f = this.view;
            if (null !== this.view && this.view.enabled) {
                var g =
                    f.fullWidth,
                    h = f.fullHeight;
                e += f.offsetX * d / g;
                b -= f.offsetY * c / h;
                d *= f.width / g;
                c *= f.height / h
            }
            f = this.filmOffset;
            0 !== f && (e += a * f / this.getFilmWidth());
            this.projectionMatrix.makePerspective(e, e + d, b, b - c, a, this.far)
        },
        toJSON: function(a) {
            a = D.prototype.toJSON.call(this, a);
            a.object.fov = this.fov;
            a.object.zoom = this.zoom;
            a.object.near = this.near;
            a.object.far = this.far;
            a.object.focus = this.focus;
            a.object.aspect = this.aspect;
            null !== this.view && (a.object.view = Object.assign({}, this.view));
            a.object.filmGauge = this.filmGauge;
            a.object.filmOffset =
                this.filmOffset;
            return a
        }
    });
    yc.prototype = Object.assign(Object.create(Z.prototype), {
        constructor: yc,
        isArrayCamera: !0
    });
    Lb.prototype.isFogExp2 = !0;
    Lb.prototype.clone = function() {
        return new Lb(this.color, this.density)
    };
    Lb.prototype.toJSON = function() {
        return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density
        }
    };
    Mb.prototype.isFog = !0;
    Mb.prototype.clone = function() {
        return new Mb(this.color, this.near, this.far)
    };
    Mb.prototype.toJSON = function() {
        return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        }
    };
    qd.prototype = Object.assign(Object.create(D.prototype), {
        constructor: qd,
        copy: function(a, b) {
            D.prototype.copy.call(this, a, b);
            null !== a.background && (this.background = a.background.clone());
            null !== a.fog && (this.fog = a.fog.clone());
            null !== a.overrideMaterial && (this.overrideMaterial = a.overrideMaterial.clone());
            this.autoUpdate = a.autoUpdate;
            this.matrixAutoUpdate = a.matrixAutoUpdate;
            return this
        },
        toJSON: function(a) {
            var b = D.prototype.toJSON.call(this, a);
            null !== this.background && (b.object.background = this.background.toJSON(a));
            null !== this.fog && (b.object.fog = this.fog.toJSON());
            return b
        }
    });
    Object.defineProperty(ob.prototype, "needsUpdate", {
        set: function(a) {
            !0 === a && this.version++
        }
    });
    Object.assign(ob.prototype, {
        isInterleavedBuffer: !0,
        onUploadCallback: function() {},
        setArray: function(a) {
            if (Array.isArray(a)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.count = void 0 !== a ? a.length / this.stride : 0;
            this.array = a;
            return this
        },
        setDynamic: function(a) {
            this.dynamic = a;
            return this
        },
        copy: function(a) {
            this.array =
                new a.array.constructor(a.array);
            this.count = a.count;
            this.stride = a.stride;
            this.dynamic = a.dynamic;
            return this
        },
        copyAt: function(a, b, c) {
            a *= this.stride;
            c *= b.stride;
            for (var d = 0, e = this.stride; d < e; d++) this.array[a + d] = b.array[c + d];
            return this
        },
        set: function(a, b) {
            void 0 === b && (b = 0);
            this.array.set(a, b);
            return this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        onUpload: function(a) {
            this.onUploadCallback = a;
            return this
        }
    });
    Object.defineProperties(zc.prototype, {
        count: {
            get: function() {
                return this.data.count
            }
        },
        array: {
            get: function() {
                return this.data.array
            }
        }
    });
    Object.assign(zc.prototype, {
        isInterleavedBufferAttribute: !0,
        setX: function(a, b) {
            this.data.array[a * this.data.stride + this.offset] = b;
            return this
        },
        setY: function(a, b) {
            this.data.array[a * this.data.stride + this.offset + 1] = b;
            return this
        },
        setZ: function(a, b) {
            this.data.array[a * this.data.stride + this.offset + 2] = b;
            return this
        },
        setW: function(a, b) {
            this.data.array[a * this.data.stride + this.offset + 3] = b;
            return this
        },
        getX: function(a) {
            return this.data.array[a * this.data.stride +
                this.offset]
        },
        getY: function(a) {
            return this.data.array[a * this.data.stride + this.offset + 1]
        },
        getZ: function(a) {
            return this.data.array[a * this.data.stride + this.offset + 2]
        },
        getW: function(a) {
            return this.data.array[a * this.data.stride + this.offset + 3]
        },
        setXY: function(a, b, c) {
            a = a * this.data.stride + this.offset;
            this.data.array[a + 0] = b;
            this.data.array[a + 1] = c;
            return this
        },
        setXYZ: function(a, b, c, d) {
            a = a * this.data.stride + this.offset;
            this.data.array[a + 0] = b;
            this.data.array[a + 1] = c;
            this.data.array[a + 2] = d;
            return this
        },
        setXYZW: function(a,
            b, c, d, e) {
            a = a * this.data.stride + this.offset;
            this.data.array[a + 0] = b;
            this.data.array[a + 1] = c;
            this.data.array[a + 2] = d;
            this.data.array[a + 3] = e;
            return this
        }
    });
    cb.prototype = Object.create(J.prototype);
    cb.prototype.constructor = cb;
    cb.prototype.isSpriteMaterial = !0;
    cb.prototype.copy = function(a) {
        J.prototype.copy.call(this, a);
        this.color.copy(a.color);
        this.map = a.map;
        this.rotation = a.rotation;
        return this
    };
    var Nb;
    Ac.prototype = Object.assign(Object.create(D.prototype), {
        constructor: Ac,
        isSprite: !0,
        raycast: function() {
            function a(a,
                b, c, d, h, k) {
                e.subVectors(a, c).addScalar(.5).multiply(d);
                void 0 !== h ? (f.x = k * e.x - h * e.y, f.y = h * e.x + k * e.y) : f.copy(e);
                a.copy(b);
                a.x += f.x;
                a.y += f.y;
                a.applyMatrix4(g)
            }
            var b = new p,
                c = new p,
                d = new p,
                e = new z,
                f = new z,
                g = new I,
                h = new p,
                k = new p,
                m = new p;
            return function(e, f) {
                c.setFromMatrixScale(this.matrixWorld);
                g.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld);
                d.setFromMatrixPosition(this.modelViewMatrix);
                var l = this.material.rotation;
                if (0 !== l) {
                    var n = Math.cos(l);
                    var q = Math.sin(l)
                }
                l = this.center;
                a(h.set(-.5, -.5, 0), d, l, c, q, n);
                a(k.set(.5, -.5, 0), d, l, c, q, n);
                a(m.set(.5, .5, 0), d, l, c, q, n);
                var p = e.ray.intersectTriangle(h, k, m, !1, b);
                if (null === p && (a(k.set(-.5, .5, 0), d, l, c, q, n), p = e.ray.intersectTriangle(h, m, k, !1, b), null === p)) return;
                q = e.ray.origin.distanceTo(b);
                q < e.near || q > e.far || f.push({
                    distance: q,
                    point: b.clone(),
                    face: null,
                    object: this
                })
            }
        }(),
        clone: function() {
            return (new this.constructor(this.material)).copy(this)
        },
        copy: function(a) {
            D.prototype.copy.call(this, a);
            void 0 !== a.center && this.center.copy(a.center);
            return this
        }
    });
    Bc.prototype = Object.assign(Object.create(D.prototype), {
        constructor: Bc,
        copy: function(a) {
            D.prototype.copy.call(this, a, !1);
            a = a.levels;
            for (var b = 0, c = a.length; b < c; b++) {
                var d = a[b];
                this.addLevel(d.object.clone(), d.distance)
            }
            return this
        },
        addLevel: function(a, b) {
            void 0 === b && (b = 0);
            b = Math.abs(b);
            for (var c = this.levels, d = 0; d < c.length && !(b < c[d].distance); d++);
            c.splice(d, 0, {
                distance: b,
                object: a
            });
            this.add(a)
        },
        getObjectForDistance: function(a) {
            for (var b = this.levels, c = 1, d = b.length; c < d && !(a < b[c].distance); c++);
            return b[c -
                1].object
        },
        raycast: function() {
            var a = new p;
            return function(b, c) {
                a.setFromMatrixPosition(this.matrixWorld);
                var d = b.ray.origin.distanceTo(a);
                this.getObjectForDistance(d).raycast(b, c)
            }
        }(),
        update: function() {
            var a = new p,
                b = new p;
            return function(c) {
                var d = this.levels;
                if (1 < d.length) {
                    a.setFromMatrixPosition(c.matrixWorld);
                    b.setFromMatrixPosition(this.matrixWorld);
                    c = a.distanceTo(b);
                    d[0].object.visible = !0;
                    for (var e = 1, f = d.length; e < f; e++)
                        if (c >= d[e].distance) d[e - 1].object.visible = !1, d[e].object.visible = !0;
                        else break;
                    for (; e < f; e++) d[e].object.visible = !1
                }
            }
        }(),
        toJSON: function(a) {
            a = D.prototype.toJSON.call(this, a);
            a.object.levels = [];
            for (var b = this.levels, c = 0, d = b.length; c < d; c++) {
                var e = b[c];
                a.object.levels.push({
                    object: e.object.uuid,
                    distance: e.distance
                })
            }
            return a
        }
    });
    Object.assign(Cc.prototype, {
        calculateInverses: function() {
            this.boneInverses = [];
            for (var a = 0, b = this.bones.length; a < b; a++) {
                var c = new I;
                this.bones[a] && c.getInverse(this.bones[a].matrixWorld);
                this.boneInverses.push(c)
            }
        },
        pose: function() {
            var a, b;
            var c = 0;
            for (b = this.bones.length; c <
                b; c++)(a = this.bones[c]) && a.matrixWorld.getInverse(this.boneInverses[c]);
            c = 0;
            for (b = this.bones.length; c < b; c++)
                if (a = this.bones[c]) a.parent && a.parent.isBone ? (a.matrix.getInverse(a.parent.matrixWorld), a.matrix.multiply(a.matrixWorld)) : a.matrix.copy(a.matrixWorld), a.matrix.decompose(a.position, a.quaternion, a.scale)
        },
        update: function() {
            var a = new I,
                b = new I;
            return function() {
                for (var c = this.bones, d = this.boneInverses, e = this.boneMatrices, f = this.boneTexture, g = 0, h = c.length; g < h; g++) a.multiplyMatrices(c[g] ? c[g].matrixWorld :
                    b, d[g]), a.toArray(e, 16 * g);
                void 0 !== f && (f.needsUpdate = !0)
            }
        }(),
        clone: function() {
            return new Cc(this.bones, this.boneInverses)
        },
        getBoneByName: function(a) {
            for (var b = 0, c = this.bones.length; b < c; b++) {
                var d = this.bones[b];
                if (d.name === a) return d
            }
        }
    });
    rd.prototype = Object.assign(Object.create(D.prototype), {
        constructor: rd,
        isBone: !0
    });
    sd.prototype = Object.assign(Object.create(la.prototype), {
        constructor: sd,
        isSkinnedMesh: !0,
        initBones: function() {
            var a = [],
                b;
            if (this.geometry && void 0 !== this.geometry.bones) {
                var c = 0;
                for (b =
                    this.geometry.bones.length; c < b; c++) {
                    var d = this.geometry.bones[c];
                    var e = new rd;
                    a.push(e);
                    e.name = d.name;
                    e.position.fromArray(d.pos);
                    e.quaternion.fromArray(d.rotq);
                    void 0 !== d.scl && e.scale.fromArray(d.scl)
                }
                c = 0;
                for (b = this.geometry.bones.length; c < b; c++) d = this.geometry.bones[c], -1 !== d.parent && null !== d.parent && void 0 !== a[d.parent] ? a[d.parent].add(a[c]) : this.add(a[c])
            }
            this.updateMatrixWorld(!0);
            return a
        },
        bind: function(a, b) {
            this.skeleton = a;
            void 0 === b && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(),
                b = this.matrixWorld);
            this.bindMatrix.copy(b);
            this.bindMatrixInverse.getInverse(b)
        },
        pose: function() {
            this.skeleton.pose()
        },
        normalizeSkinWeights: function() {
            var a;
            if (this.geometry && this.geometry.isGeometry)
                for (a = 0; a < this.geometry.skinWeights.length; a++) {
                    var b = this.geometry.skinWeights[a];
                    var c = 1 / b.manhattanLength();
                    Infinity !== c ? b.multiplyScalar(c) : b.set(1, 0, 0, 0)
                } else if (this.geometry && this.geometry.isBufferGeometry) {
                    b = new V;
                    var d = this.geometry.attributes.skinWeight;
                    for (a = 0; a < d.count; a++) b.x = d.getX(a),
                        b.y = d.getY(a), b.z = d.getZ(a), b.w = d.getW(a), c = 1 / b.manhattanLength(), Infinity !== c ? b.multiplyScalar(c) : b.set(1, 0, 0, 0), d.setXYZW(a, b.x, b.y, b.z, b.w)
                }
        },
        updateMatrixWorld: function(a) {
            la.prototype.updateMatrixWorld.call(this, a);
            "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
        },
        clone: function() {
            return (new this.constructor(this.geometry,
                this.material)).copy(this)
        }
    });
    Y.prototype = Object.create(J.prototype);
    Y.prototype.constructor = Y;
    Y.prototype.isLineBasicMaterial = !0;
    Y.prototype.copy = function(a) {
        J.prototype.copy.call(this, a);
        this.color.copy(a.color);
        this.linewidth = a.linewidth;
        this.linecap = a.linecap;
        this.linejoin = a.linejoin;
        return this
    };
    sa.prototype = Object.assign(Object.create(D.prototype), {
        constructor: sa,
        isLine: !0,
        computeLineDistances: function() {
            var a = new p,
                b = new p;
            return function() {
                var c = this.geometry;
                if (c.isBufferGeometry)
                    if (null ===
                        c.index) {
                        for (var d = c.attributes.position, e = [0], f = 1, g = d.count; f < g; f++) a.fromBufferAttribute(d, f - 1), b.fromBufferAttribute(d, f), e[f] = e[f - 1], e[f] += a.distanceTo(b);
                        c.addAttribute("lineDistance", new A(e, 1))
                    } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else if (c.isGeometry)
                    for (d = c.vertices, e = c.lineDistances, e[0] = 0, f = 1, g = d.length; f < g; f++) e[f] = e[f - 1], e[f] += d[f - 1].distanceTo(d[f]);
                return this
            }
        }(),
        raycast: function() {
            var a = new I,
                b = new mb,
                c =
                new Da;
            return function(d, e) {
                var f = d.linePrecision;
                f *= f;
                var g = this.geometry,
                    h = this.matrixWorld;
                null === g.boundingSphere && g.computeBoundingSphere();
                c.copy(g.boundingSphere);
                c.applyMatrix4(h);
                if (!1 !== d.ray.intersectsSphere(c)) {
                    a.getInverse(h);
                    b.copy(d.ray).applyMatrix4(a);
                    var k = new p,
                        m = new p;
                    h = new p;
                    var l = new p,
                        n = this && this.isLineSegments ? 2 : 1;
                    if (g.isBufferGeometry) {
                        var t = g.index,
                            u = g.attributes.position.array;
                        if (null !== t) {
                            t = t.array;
                            g = 0;
                            for (var r = t.length - 1; g < r; g += n) {
                                var v = t[g + 1];
                                k.fromArray(u, 3 * t[g]);
                                m.fromArray(u, 3 * v);
                                v = b.distanceSqToSegment(k, m, l, h);
                                v > f || (l.applyMatrix4(this.matrixWorld), v = d.ray.origin.distanceTo(l), v < d.near || v > d.far || e.push({
                                    distance: v,
                                    point: h.clone().applyMatrix4(this.matrixWorld),
                                    index: g,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                }))
                            }
                        } else
                            for (g = 0, r = u.length / 3 - 1; g < r; g += n) k.fromArray(u, 3 * g), m.fromArray(u, 3 * g + 3), v = b.distanceSqToSegment(k, m, l, h), v > f || (l.applyMatrix4(this.matrixWorld), v = d.ray.origin.distanceTo(l), v < d.near || v > d.far || e.push({
                                distance: v,
                                point: h.clone().applyMatrix4(this.matrixWorld),
                                index: g,
                                face: null,
                                faceIndex: null,
                                object: this
                            }))
                    } else if (g.isGeometry)
                        for (k = g.vertices, m = k.length, g = 0; g < m - 1; g += n) v = b.distanceSqToSegment(k[g], k[g + 1], l, h), v > f || (l.applyMatrix4(this.matrixWorld), v = d.ray.origin.distanceTo(l), v < d.near || v > d.far || e.push({
                            distance: v,
                            point: h.clone().applyMatrix4(this.matrixWorld),
                            index: g,
                            face: null,
                            faceIndex: null,
                            object: this
                        }))
                }
            }
        }(),
        clone: function() {
            return (new this.constructor(this.geometry, this.material)).copy(this)
        }
    });
    W.prototype = Object.assign(Object.create(sa.prototype), {
        constructor: W,
        isLineSegments: !0,
        computeLineDistances: function() {
            var a = new p,
                b = new p;
            return function() {
                var c = this.geometry;
                if (c.isBufferGeometry)
                    if (null === c.index) {
                        for (var d = c.attributes.position, e = [], f = 0, g = d.count; f < g; f += 2) a.fromBufferAttribute(d, f), b.fromBufferAttribute(d, f + 1), e[f] = 0 === f ? 0 : e[f - 1], e[f + 1] = e[f] + a.distanceTo(b);
                        c.addAttribute("lineDistance", new A(e, 1))
                    } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else if (c.isGeometry)
                    for (d =
                        c.vertices, e = c.lineDistances, f = 0, g = d.length; f < g; f += 2) a.copy(d[f]), b.copy(d[f + 1]), e[f] = 0 === f ? 0 : e[f - 1], e[f + 1] = e[f] + a.distanceTo(b);
                return this
            }
        }()
    });
    td.prototype = Object.assign(Object.create(sa.prototype), {
        constructor: td,
        isLineLoop: !0
    });
    Ea.prototype = Object.create(J.prototype);
    Ea.prototype.constructor = Ea;
    Ea.prototype.isPointsMaterial = !0;
    Ea.prototype.copy = function(a) {
        J.prototype.copy.call(this, a);
        this.color.copy(a.color);
        this.map = a.map;
        this.size = a.size;
        this.sizeAttenuation = a.sizeAttenuation;
        this.morphTargets =
            a.morphTargets;
        return this
    };
    Ob.prototype = Object.assign(Object.create(D.prototype), {
        constructor: Ob,
        isPoints: !0,
        raycast: function() {
            var a = new I,
                b = new mb,
                c = new Da;
            return function(d, e) {
                function f(a, c) {
                    var f = b.distanceSqToPoint(a);
                    f < l && (b.closestPointToPoint(a, n), n.applyMatrix4(k), a = d.ray.origin.distanceTo(n), a < d.near || a > d.far || e.push({
                        distance: a,
                        distanceToRay: Math.sqrt(f),
                        point: n.clone(),
                        index: c,
                        face: null,
                        object: g
                    }))
                }
                var g = this,
                    h = this.geometry,
                    k = this.matrixWorld,
                    m = d.params.Points.threshold;
                null === h.boundingSphere &&
                    h.computeBoundingSphere();
                c.copy(h.boundingSphere);
                c.applyMatrix4(k);
                c.radius += m;
                if (!1 !== d.ray.intersectsSphere(c)) {
                    a.getInverse(k);
                    b.copy(d.ray).applyMatrix4(a);
                    m /= (this.scale.x + this.scale.y + this.scale.z) / 3;
                    var l = m * m;
                    m = new p;
                    var n = new p;
                    if (h.isBufferGeometry) {
                        var t = h.index;
                        h = h.attributes.position.array;
                        if (null !== t) {
                            var u = t.array;
                            t = 0;
                            for (var r = u.length; t < r; t++) {
                                var v = u[t];
                                m.fromArray(h, 3 * v);
                                f(m, v)
                            }
                        } else
                            for (t = 0, u = h.length / 3; t < u; t++) m.fromArray(h, 3 * t), f(m, t)
                    } else
                        for (m = h.vertices, t = 0, u = m.length; t <
                            u; t++) f(m[t], t)
                }
            }
        }(),
        clone: function() {
            return (new this.constructor(this.geometry, this.material)).copy(this)
        }
    });
    $d.prototype = Object.assign(Object.create(T.prototype), {
        constructor: $d,
        isVideoTexture: !0,
        update: function() {
            var a = this.image;
            a.readyState >= a.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
        }
    });
    Pb.prototype = Object.create(T.prototype);
    Pb.prototype.constructor = Pb;
    Pb.prototype.isCompressedTexture = !0;
    Dc.prototype = Object.create(T.prototype);
    Dc.prototype.constructor = Dc;
    Dc.prototype.isCanvasTexture = !0;
    Ec.prototype =
        Object.create(T.prototype);
    Ec.prototype.constructor = Ec;
    Ec.prototype.isDepthTexture = !0;
    Qb.prototype = Object.create(C.prototype);
    Qb.prototype.constructor = Qb;
    Fc.prototype = Object.create(R.prototype);
    Fc.prototype.constructor = Fc;
    Rb.prototype = Object.create(C.prototype);
    Rb.prototype.constructor = Rb;
    Gc.prototype = Object.create(R.prototype);
    Gc.prototype.constructor = Gc;
    na.prototype = Object.create(C.prototype);
    na.prototype.constructor = na;
    Hc.prototype = Object.create(R.prototype);
    Hc.prototype.constructor = Hc;
    Sb.prototype =
        Object.create(na.prototype);
    Sb.prototype.constructor = Sb;
    Ic.prototype = Object.create(R.prototype);
    Ic.prototype.constructor = Ic;
    pb.prototype = Object.create(na.prototype);
    pb.prototype.constructor = pb;
    Jc.prototype = Object.create(R.prototype);
    Jc.prototype.constructor = Jc;
    Tb.prototype = Object.create(na.prototype);
    Tb.prototype.constructor = Tb;
    Kc.prototype = Object.create(R.prototype);
    Kc.prototype.constructor = Kc;
    Ub.prototype = Object.create(na.prototype);
    Ub.prototype.constructor = Ub;
    Lc.prototype = Object.create(R.prototype);
    Lc.prototype.constructor = Lc;
    Vb.prototype = Object.create(C.prototype);
    Vb.prototype.constructor = Vb;
    Mc.prototype = Object.create(R.prototype);
    Mc.prototype.constructor = Mc;
    Wb.prototype = Object.create(C.prototype);
    Wb.prototype.constructor = Wb;
    Nc.prototype = Object.create(R.prototype);
    Nc.prototype.constructor = Nc;
    Xb.prototype = Object.create(C.prototype);
    Xb.prototype.constructor = Xb;
    var Ug = {
            triangulate: function(a, b, c) {
                c = c || 2;
                var d = b && b.length,
                    e = d ? b[0] * c : a.length,
                    f = bf(a, 0, e, c, !0),
                    g = [];
                if (!f) return g;
                var h;
                if (d) {
                    var k =
                        c;
                    d = [];
                    var m;
                    var l = 0;
                    for (m = b.length; l < m; l++) {
                        var n = b[l] * k;
                        var t = l < m - 1 ? b[l + 1] * k : a.length;
                        n = bf(a, n, t, k, !1);
                        n === n.next && (n.steiner = !0);
                        d.push(Pg(n))
                    }
                    d.sort(Ng);
                    for (l = 0; l < d.length; l++) {
                        b = d[l];
                        k = f;
                        if (k = Og(b, k)) b = ef(k, b), Pc(b, b.next);
                        f = Pc(f, f.next)
                    }
                }
                if (a.length > 80 * c) {
                    var p = h = a[0];
                    var r = d = a[1];
                    for (k = c; k < e; k += c) l = a[k], b = a[k + 1], l < p && (p = l), b < r && (r = b), l > h && (h = l), b > d && (d = b);
                    h = Math.max(h - p, d - r);
                    h = 0 !== h ? 1 / h : 0
                }
                Qc(f, g, c, p, r, h);
                return g
            }
        },
        Va = {
            area: function(a) {
                for (var b = a.length, c = 0, d = b - 1, e = 0; e < b; d = e++) c += a[d].x * a[e].y -
                    a[e].x * a[d].y;
                return .5 * c
            },
            isClockWise: function(a) {
                return 0 > Va.area(a)
            },
            triangulateShape: function(a, b) {
                var c = [],
                    d = [],
                    e = [];
                ff(a);
                gf(c, a);
                var f = a.length;
                b.forEach(ff);
                for (a = 0; a < b.length; a++) d.push(f), f += b[a].length, gf(c, b[a]);
                b = Ug.triangulate(c, d);
                for (a = 0; a < b.length; a += 3) e.push(b.slice(a, a + 3));
                return e
            }
        };
    rb.prototype = Object.create(R.prototype);
    rb.prototype.constructor = rb;
    rb.prototype.toJSON = function() {
        var a = R.prototype.toJSON.call(this);
        return hf(this.parameters.shapes, this.parameters.options, a)
    };
    Oa.prototype =
        Object.create(C.prototype);
    Oa.prototype.constructor = Oa;
    Oa.prototype.toJSON = function() {
        var a = C.prototype.toJSON.call(this);
        return hf(this.parameters.shapes, this.parameters.options, a)
    };
    var Qg = {
        generateTopUV: function(a, b, c, d, e) {
            a = b[3 * d];
            d = b[3 * d + 1];
            var f = b[3 * e];
            e = b[3 * e + 1];
            return [new z(b[3 * c], b[3 * c + 1]), new z(a, d), new z(f, e)]
        },
        generateSideWallUV: function(a, b, c, d, e, f) {
            a = b[3 * c];
            var g = b[3 * c + 1];
            c = b[3 * c + 2];
            var h = b[3 * d],
                k = b[3 * d + 1];
            d = b[3 * d + 2];
            var m = b[3 * e],
                l = b[3 * e + 1];
            e = b[3 * e + 2];
            var n = b[3 * f],
                t = b[3 * f + 1];
            b = b[3 * f +
                2];
            return .01 > Math.abs(g - k) ? [new z(a, 1 - c), new z(h, 1 - d), new z(m, 1 - e), new z(n, 1 - b)] : [new z(g, 1 - c), new z(k, 1 - d), new z(l, 1 - e), new z(t, 1 - b)]
        }
    };
    Sc.prototype = Object.create(R.prototype);
    Sc.prototype.constructor = Sc;
    Yb.prototype = Object.create(Oa.prototype);
    Yb.prototype.constructor = Yb;
    Tc.prototype = Object.create(R.prototype);
    Tc.prototype.constructor = Tc;
    sb.prototype = Object.create(C.prototype);
    sb.prototype.constructor = sb;
    Uc.prototype = Object.create(R.prototype);
    Uc.prototype.constructor = Uc;
    Zb.prototype = Object.create(C.prototype);
    Zb.prototype.constructor = Zb;
    Vc.prototype = Object.create(R.prototype);
    Vc.prototype.constructor = Vc;
    $b.prototype = Object.create(C.prototype);
    $b.prototype.constructor = $b;
    tb.prototype = Object.create(R.prototype);
    tb.prototype.constructor = tb;
    tb.prototype.toJSON = function() {
        var a = R.prototype.toJSON.call(this);
        return jf(this.parameters.shapes, a)
    };
    ub.prototype = Object.create(C.prototype);
    ub.prototype.constructor = ub;
    ub.prototype.toJSON = function() {
        var a = C.prototype.toJSON.call(this);
        return jf(this.parameters.shapes,
            a)
    };
    ac.prototype = Object.create(C.prototype);
    ac.prototype.constructor = ac;
    vb.prototype = Object.create(R.prototype);
    vb.prototype.constructor = vb;
    Wa.prototype = Object.create(C.prototype);
    Wa.prototype.constructor = Wa;
    Wc.prototype = Object.create(vb.prototype);
    Wc.prototype.constructor = Wc;
    Xc.prototype = Object.create(Wa.prototype);
    Xc.prototype.constructor = Xc;
    Yc.prototype = Object.create(R.prototype);
    Yc.prototype.constructor = Yc;
    bc.prototype = Object.create(C.prototype);
    bc.prototype.constructor = bc;
    var xa = Object.freeze({
        WireframeGeometry: Qb,
        ParametricGeometry: Fc,
        ParametricBufferGeometry: Rb,
        TetrahedronGeometry: Hc,
        TetrahedronBufferGeometry: Sb,
        OctahedronGeometry: Ic,
        OctahedronBufferGeometry: pb,
        IcosahedronGeometry: Jc,
        IcosahedronBufferGeometry: Tb,
        DodecahedronGeometry: Kc,
        DodecahedronBufferGeometry: Ub,
        PolyhedronGeometry: Gc,
        PolyhedronBufferGeometry: na,
        TubeGeometry: Lc,
        TubeBufferGeometry: Vb,
        TorusKnotGeometry: Mc,
        TorusKnotBufferGeometry: Wb,
        TorusGeometry: Nc,
        TorusBufferGeometry: Xb,
        TextGeometry: Sc,
        TextBufferGeometry: Yb,
        SphereGeometry: Tc,
        SphereBufferGeometry: sb,
        RingGeometry: Uc,
        RingBufferGeometry: Zb,
        PlaneGeometry: uc,
        PlaneBufferGeometry: lb,
        LatheGeometry: Vc,
        LatheBufferGeometry: $b,
        ShapeGeometry: tb,
        ShapeBufferGeometry: ub,
        ExtrudeGeometry: rb,
        ExtrudeBufferGeometry: Oa,
        EdgesGeometry: ac,
        ConeGeometry: Wc,
        ConeBufferGeometry: Xc,
        CylinderGeometry: vb,
        CylinderBufferGeometry: Wa,
        CircleGeometry: Yc,
        CircleBufferGeometry: bc,
        BoxGeometry: Ib,
        BoxBufferGeometry: kb
    });
    wb.prototype = Object.create(J.prototype);
    wb.prototype.constructor = wb;
    wb.prototype.isShadowMaterial = !0;
    wb.prototype.copy =
        function(a) {
            J.prototype.copy.call(this, a);
            this.color.copy(a.color);
            return this
        };
    cc.prototype = Object.create(ta.prototype);
    cc.prototype.constructor = cc;
    cc.prototype.isRawShaderMaterial = !0;
    Pa.prototype = Object.create(J.prototype);
    Pa.prototype.constructor = Pa;
    Pa.prototype.isMeshStandardMaterial = !0;
    Pa.prototype.copy = function(a) {
        J.prototype.copy.call(this, a);
        this.defines = {
            STANDARD: ""
        };
        this.color.copy(a.color);
        this.roughness = a.roughness;
        this.metalness = a.metalness;
        this.map = a.map;
        this.lightMap = a.lightMap;
        this.lightMapIntensity =
            a.lightMapIntensity;
        this.aoMap = a.aoMap;
        this.aoMapIntensity = a.aoMapIntensity;
        this.emissive.copy(a.emissive);
        this.emissiveMap = a.emissiveMap;
        this.emissiveIntensity = a.emissiveIntensity;
        this.bumpMap = a.bumpMap;
        this.bumpScale = a.bumpScale;
        this.normalMap = a.normalMap;
        this.normalMapType = a.normalMapType;
        this.normalScale.copy(a.normalScale);
        this.displacementMap = a.displacementMap;
        this.displacementScale = a.displacementScale;
        this.displacementBias = a.displacementBias;
        this.roughnessMap = a.roughnessMap;
        this.metalnessMap =
            a.metalnessMap;
        this.alphaMap = a.alphaMap;
        this.envMap = a.envMap;
        this.envMapIntensity = a.envMapIntensity;
        this.refractionRatio = a.refractionRatio;
        this.wireframe = a.wireframe;
        this.wireframeLinewidth = a.wireframeLinewidth;
        this.wireframeLinecap = a.wireframeLinecap;
        this.wireframeLinejoin = a.wireframeLinejoin;
        this.skinning = a.skinning;
        this.morphTargets = a.morphTargets;
        this.morphNormals = a.morphNormals;
        return this
    };
    xb.prototype = Object.create(Pa.prototype);
    xb.prototype.constructor = xb;
    xb.prototype.isMeshPhysicalMaterial = !0;
    xb.prototype.copy = function(a) {
        Pa.prototype.copy.call(this, a);
        this.defines = {
            PHYSICAL: ""
        };
        this.reflectivity = a.reflectivity;
        this.clearCoat = a.clearCoat;
        this.clearCoatRoughness = a.clearCoatRoughness;
        return this
    };
    Fa.prototype = Object.create(J.prototype);
    Fa.prototype.constructor = Fa;
    Fa.prototype.isMeshPhongMaterial = !0;
    Fa.prototype.copy = function(a) {
        J.prototype.copy.call(this, a);
        this.color.copy(a.color);
        this.specular.copy(a.specular);
        this.shininess = a.shininess;
        this.map = a.map;
        this.lightMap = a.lightMap;
        this.lightMapIntensity =
            a.lightMapIntensity;
        this.aoMap = a.aoMap;
        this.aoMapIntensity = a.aoMapIntensity;
        this.emissive.copy(a.emissive);
        this.emissiveMap = a.emissiveMap;
        this.emissiveIntensity = a.emissiveIntensity;
        this.bumpMap = a.bumpMap;
        this.bumpScale = a.bumpScale;
        this.normalMap = a.normalMap;
        this.normalMapType = a.normalMapType;
        this.normalScale.copy(a.normalScale);
        this.displacementMap = a.displacementMap;
        this.displacementScale = a.displacementScale;
        this.displacementBias = a.displacementBias;
        this.specularMap = a.specularMap;
        this.alphaMap = a.alphaMap;
        this.envMap = a.envMap;
        this.combine = a.combine;
        this.reflectivity = a.reflectivity;
        this.refractionRatio = a.refractionRatio;
        this.wireframe = a.wireframe;
        this.wireframeLinewidth = a.wireframeLinewidth;
        this.wireframeLinecap = a.wireframeLinecap;
        this.wireframeLinejoin = a.wireframeLinejoin;
        this.skinning = a.skinning;
        this.morphTargets = a.morphTargets;
        this.morphNormals = a.morphNormals;
        return this
    };
    yb.prototype = Object.create(Fa.prototype);
    yb.prototype.constructor = yb;
    yb.prototype.isMeshToonMaterial = !0;
    yb.prototype.copy = function(a) {
        Fa.prototype.copy.call(this,
            a);
        this.gradientMap = a.gradientMap;
        return this
    };
    zb.prototype = Object.create(J.prototype);
    zb.prototype.constructor = zb;
    zb.prototype.isMeshNormalMaterial = !0;
    zb.prototype.copy = function(a) {
        J.prototype.copy.call(this, a);
        this.bumpMap = a.bumpMap;
        this.bumpScale = a.bumpScale;
        this.normalMap = a.normalMap;
        this.normalMapType = a.normalMapType;
        this.normalScale.copy(a.normalScale);
        this.displacementMap = a.displacementMap;
        this.displacementScale = a.displacementScale;
        this.displacementBias = a.displacementBias;
        this.wireframe = a.wireframe;
        this.wireframeLinewidth = a.wireframeLinewidth;
        this.skinning = a.skinning;
        this.morphTargets = a.morphTargets;
        this.morphNormals = a.morphNormals;
        return this
    };
    Ab.prototype = Object.create(J.prototype);
    Ab.prototype.constructor = Ab;
    Ab.prototype.isMeshLambertMaterial = !0;
    Ab.prototype.copy = function(a) {
        J.prototype.copy.call(this, a);
        this.color.copy(a.color);
        this.map = a.map;
        this.lightMap = a.lightMap;
        this.lightMapIntensity = a.lightMapIntensity;
        this.aoMap = a.aoMap;
        this.aoMapIntensity = a.aoMapIntensity;
        this.emissive.copy(a.emissive);
        this.emissiveMap = a.emissiveMap;
        this.emissiveIntensity = a.emissiveIntensity;
        this.specularMap = a.specularMap;
        this.alphaMap = a.alphaMap;
        this.envMap = a.envMap;
        this.combine = a.combine;
        this.reflectivity = a.reflectivity;
        this.refractionRatio = a.refractionRatio;
        this.wireframe = a.wireframe;
        this.wireframeLinewidth = a.wireframeLinewidth;
        this.wireframeLinecap = a.wireframeLinecap;
        this.wireframeLinejoin = a.wireframeLinejoin;
        this.skinning = a.skinning;
        this.morphTargets = a.morphTargets;
        this.morphNormals = a.morphNormals;
        return this
    };
    Bb.prototype = Object.create(Y.prototype);
    Bb.prototype.constructor = Bb;
    Bb.prototype.isLineDashedMaterial = !0;
    Bb.prototype.copy = function(a) {
        Y.prototype.copy.call(this, a);
        this.scale = a.scale;
        this.dashSize = a.dashSize;
        this.gapSize = a.gapSize;
        return this
    };
    var Vg = Object.freeze({
            ShadowMaterial: wb,
            SpriteMaterial: cb,
            RawShaderMaterial: cc,
            ShaderMaterial: ta,
            PointsMaterial: Ea,
            MeshPhysicalMaterial: xb,
            MeshStandardMaterial: Pa,
            MeshPhongMaterial: Fa,
            MeshToonMaterial: yb,
            MeshNormalMaterial: zb,
            MeshLambertMaterial: Ab,
            MeshDepthMaterial: $a,
            MeshDistanceMaterial: ab,
            MeshBasicMaterial: da,
            LineDashedMaterial: Bb,
            LineBasicMaterial: Y,
            Material: J
        }),
        Fb = {
            enabled: !1,
            files: {},
            add: function(a, b) {
                !1 !== this.enabled && (this.files[a] = b)
            },
            get: function(a) {
                if (!1 !== this.enabled) return this.files[a]
            },
            remove: function(a) {
                delete this.files[a]
            },
            clear: function() {
                this.files = {}
            }
        },
        ka = new ce,
        Ya = {};
    Object.assign(Ga.prototype, {
        load: function(a, b, c, d) {
            void 0 === a && (a = "");
            void 0 !== this.path && (a = this.path + a);
            a = this.manager.resolveURL(a);
            var e = this,
                f = Fb.get(a);
            if (void 0 !== f) return e.manager.itemStart(a),
                setTimeout(function() {
                    b && b(f);
                    e.manager.itemEnd(a)
                }, 0), f;
            if (void 0 !== Ya[a]) Ya[a].push({
                onLoad: b,
                onProgress: c,
                onError: d
            });
            else {
                var g = a.match(/^data:(.*?)(;base64)?,(.*)$/);
                if (g) {
                    c = g[1];
                    var h = !!g[2];
                    g = g[3];
                    g = window.decodeURIComponent(g);
                    h && (g = window.atob(g));
                    try {
                        var k = (this.responseType || "").toLowerCase();
                        switch (k) {
                            case "arraybuffer":
                            case "blob":
                                var m = new Uint8Array(g.length);
                                for (h = 0; h < g.length; h++) m[h] = g.charCodeAt(h);
                                var l = "blob" === k ? new Blob([m.buffer], {
                                    type: c
                                }) : m.buffer;
                                break;
                            case "document":
                                l =
                                    (new DOMParser).parseFromString(g, c);
                                break;
                            case "json":
                                l = JSON.parse(g);
                                break;
                            default:
                                l = g
                        }
                        window.setTimeout(function() {
                            b && b(l);
                            e.manager.itemEnd(a)
                        }, 0)
                    } catch (t) {
                        window.setTimeout(function() {
                            d && d(t);
                            e.manager.itemEnd(a);
                            e.manager.itemError(a)
                        }, 0)
                    }
                } else {
                    Ya[a] = [];
                    Ya[a].push({
                        onLoad: b,
                        onProgress: c,
                        onError: d
                    });
                    var n = new XMLHttpRequest;
                    n.open("GET", a, !0);
                    n.addEventListener("load", function(b) {
                        var c = this.response;
                        Fb.add(a, c);
                        var d = Ya[a];
                        delete Ya[a];
                        if (200 === this.status || 0 === this.status) {
                            0 === this.status &&
                                console.warn("THREE.FileLoader: HTTP Status 0 received.");
                            for (var f = 0, g = d.length; f < g; f++) {
                                var h = d[f];
                                if (h.onLoad) h.onLoad(c)
                            }
                            e.manager.itemEnd(a)
                        } else {
                            f = 0;
                            for (g = d.length; f < g; f++)
                                if (h = d[f], h.onError) h.onError(b);
                            e.manager.itemEnd(a);
                            e.manager.itemError(a)
                        }
                    }, !1);
                    n.addEventListener("progress", function(b) {
                        for (var c = Ya[a], d = 0, e = c.length; d < e; d++) {
                            var f = c[d];
                            if (f.onProgress) f.onProgress(b)
                        }
                    }, !1);
                    n.addEventListener("error", function(b) {
                        var c = Ya[a];
                        delete Ya[a];
                        for (var d = 0, f = c.length; d < f; d++) {
                            var g = c[d];
                            if (g.onError) g.onError(b)
                        }
                        e.manager.itemEnd(a);
                        e.manager.itemError(a)
                    }, !1);
                    void 0 !== this.responseType && (n.responseType = this.responseType);
                    void 0 !== this.withCredentials && (n.withCredentials = this.withCredentials);
                    n.overrideMimeType && n.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                    for (h in this.requestHeader) n.setRequestHeader(h, this.requestHeader[h]);
                    n.send(null)
                }
                e.manager.itemStart(a);
                return n
            }
        },
        setPath: function(a) {
            this.path = a;
            return this
        },
        setResponseType: function(a) {
            this.responseType = a;
            return this
        },
        setWithCredentials: function(a) {
            this.withCredentials =
                a;
            return this
        },
        setMimeType: function(a) {
            this.mimeType = a;
            return this
        },
        setRequestHeader: function(a) {
            this.requestHeader = a;
            return this
        }
    });
    Object.assign(kf.prototype, {
        load: function(a, b, c, d) {
            function e(e) {
                k.load(a[e], function(a) {
                    a = f._parser(a, !0);
                    g[e] = {
                        width: a.width,
                        height: a.height,
                        format: a.format,
                        mipmaps: a.mipmaps
                    };
                    m += 1;
                    6 === m && (1 === a.mipmapCount && (h.minFilter = 1006), h.format = a.format, h.needsUpdate = !0, b && b(h))
                }, c, d)
            }
            var f = this,
                g = [],
                h = new Pb;
            h.image = g;
            var k = new Ga(this.manager);
            k.setPath(this.path);
            k.setResponseType("arraybuffer");
            if (Array.isArray(a))
                for (var m = 0, l = 0, n = a.length; l < n; ++l) e(l);
            else k.load(a, function(a) {
                a = f._parser(a, !0);
                if (a.isCubemap)
                    for (var c = a.mipmaps.length / a.mipmapCount, d = 0; d < c; d++) {
                        g[d] = {
                            mipmaps: []
                        };
                        for (var e = 0; e < a.mipmapCount; e++) g[d].mipmaps.push(a.mipmaps[d * a.mipmapCount + e]), g[d].format = a.format, g[d].width = a.width, g[d].height = a.height
                    } else h.image.width = a.width, h.image.height = a.height, h.mipmaps = a.mipmaps;
                1 === a.mipmapCount && (h.minFilter = 1006);
                h.format = a.format;
                h.needsUpdate = !0;
                b && b(h)
            }, c, d);
            return h
        },
        setPath: function(a) {
            this.path =
                a;
            return this
        }
    });
    Object.assign(de.prototype, {
        load: function(a, b, c, d) {
            var e = this,
                f = new gb,
                g = new Ga(this.manager);
            g.setResponseType("arraybuffer");
            g.load(a, function(a) {
                if (a = e._parser(a)) void 0 !== a.image ? f.image = a.image : void 0 !== a.data && (f.image.width = a.width, f.image.height = a.height, f.image.data = a.data), f.wrapS = void 0 !== a.wrapS ? a.wrapS : 1001, f.wrapT = void 0 !== a.wrapT ? a.wrapT : 1001, f.magFilter = void 0 !== a.magFilter ? a.magFilter : 1006, f.minFilter = void 0 !== a.minFilter ? a.minFilter : 1008, f.anisotropy = void 0 !== a.anisotropy ?
                    a.anisotropy : 1, void 0 !== a.format && (f.format = a.format), void 0 !== a.type && (f.type = a.type), void 0 !== a.mipmaps && (f.mipmaps = a.mipmaps), 1 === a.mipmapCount && (f.minFilter = 1006), f.needsUpdate = !0, b && b(f, a)
            }, c, d);
            return f
        }
    });
    Object.assign(Zc.prototype, {
        crossOrigin: "anonymous",
        load: function(a, b, c, d) {
            function e() {
                k.removeEventListener("load", e, !1);
                k.removeEventListener("error", f, !1);
                Fb.add(a, this);
                b && b(this);
                g.manager.itemEnd(a)
            }

            function f(b) {
                k.removeEventListener("load", e, !1);
                k.removeEventListener("error", f, !1);
                d && d(b);
                g.manager.itemEnd(a);
                g.manager.itemError(a)
            }
            void 0 === a && (a = "");
            void 0 !== this.path && (a = this.path + a);
            a = this.manager.resolveURL(a);
            var g = this,
                h = Fb.get(a);
            if (void 0 !== h) return g.manager.itemStart(a), setTimeout(function() {
                b && b(h);
                g.manager.itemEnd(a)
            }, 0), h;
            var k = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
            k.addEventListener("load", e, !1);
            k.addEventListener("error", f, !1);
            "data:" !== a.substr(0, 5) && void 0 !== this.crossOrigin && (k.crossOrigin = this.crossOrigin);
            g.manager.itemStart(a);
            k.src = a;
            return k
        },
        setCrossOrigin: function(a) {
            this.crossOrigin = a;
            return this
        },
        setPath: function(a) {
            this.path = a;
            return this
        }
    });
    Object.assign(ee.prototype, {
        crossOrigin: "anonymous",
        load: function(a, b, c, d) {
            function e(c) {
                g.load(a[c], function(a) {
                    f.images[c] = a;
                    h++;
                    6 === h && (f.needsUpdate = !0, b && b(f))
                }, void 0, d)
            }
            var f = new Ua,
                g = new Zc(this.manager);
            g.setCrossOrigin(this.crossOrigin);
            g.setPath(this.path);
            var h = 0;
            for (c = 0; c < a.length; ++c) e(c);
            return f
        },
        setCrossOrigin: function(a) {
            this.crossOrigin = a;
            return this
        },
        setPath: function(a) {
            this.path =
                a;
            return this
        }
    });
    Object.assign(vd.prototype, {
        crossOrigin: "anonymous",
        load: function(a, b, c, d) {
            var e = new T,
                f = new Zc(this.manager);
            f.setCrossOrigin(this.crossOrigin);
            f.setPath(this.path);
            f.load(a, function(c) {
                e.image = c;
                c = 0 < a.search(/\.(jpg|jpeg)$/) || 0 === a.search(/^data:image\/jpeg/);
                e.format = c ? 1022 : 1023;
                e.needsUpdate = !0;
                void 0 !== b && b(e)
            }, c, d);
            return e
        },
        setCrossOrigin: function(a) {
            this.crossOrigin = a;
            return this
        },
        setPath: function(a) {
            this.path = a;
            return this
        }
    });
    Object.assign(L.prototype, {
        getPoint: function() {
            console.warn("THREE.Curve: .getPoint() not implemented.");
            return null
        },
        getPointAt: function(a, b) {
            a = this.getUtoTmapping(a);
            return this.getPoint(a, b)
        },
        getPoints: function(a) {
            void 0 === a && (a = 5);
            for (var b = [], c = 0; c <= a; c++) b.push(this.getPoint(c / a));
            return b
        },
        getSpacedPoints: function(a) {
            void 0 === a && (a = 5);
            for (var b = [], c = 0; c <= a; c++) b.push(this.getPointAt(c / a));
            return b
        },
        getLength: function() {
            var a = this.getLengths();
            return a[a.length - 1]
        },
        getLengths: function(a) {
            void 0 === a && (a = this.arcLengthDivisions);
            if (this.cacheArcLengths && this.cacheArcLengths.length === a + 1 && !this.needsUpdate) return this.cacheArcLengths;
            this.needsUpdate = !1;
            var b = [],
                c = this.getPoint(0),
                d, e = 0;
            b.push(0);
            for (d = 1; d <= a; d++) {
                var f = this.getPoint(d / a);
                e += f.distanceTo(c);
                b.push(e);
                c = f
            }
            return this.cacheArcLengths = b
        },
        updateArcLengths: function() {
            this.needsUpdate = !0;
            this.getLengths()
        },
        getUtoTmapping: function(a, b) {
            var c = this.getLengths(),
                d = c.length;
            b = b ? b : a * c[d - 1];
            for (var e = 0, f = d - 1, g; e <= f;)
                if (a = Math.floor(e + (f - e) / 2), g = c[a] - b, 0 > g) e = a + 1;
                else if (0 < g) f = a - 1;
            else {
                f = a;
                break
            }
            a = f;
            if (c[a] === b) return a / (d - 1);
            e = c[a];
            return (a + (b - e) / (c[a + 1] - e)) / (d - 1)
        },
        getTangent: function(a) {
            var b =
                a - 1E-4;
            a += 1E-4;
            0 > b && (b = 0);
            1 < a && (a = 1);
            b = this.getPoint(b);
            return this.getPoint(a).clone().sub(b).normalize()
        },
        getTangentAt: function(a) {
            a = this.getUtoTmapping(a);
            return this.getTangent(a)
        },
        computeFrenetFrames: function(a, b) {
            var c = new p,
                d = [],
                e = [],
                f = [],
                g = new p,
                h = new I,
                k;
            for (k = 0; k <= a; k++) {
                var m = k / a;
                d[k] = this.getTangentAt(m);
                d[k].normalize()
            }
            e[0] = new p;
            f[0] = new p;
            k = Number.MAX_VALUE;
            m = Math.abs(d[0].x);
            var l = Math.abs(d[0].y),
                n = Math.abs(d[0].z);
            m <= k && (k = m, c.set(1, 0, 0));
            l <= k && (k = l, c.set(0, 1, 0));
            n <= k && c.set(0,
                0, 1);
            g.crossVectors(d[0], c).normalize();
            e[0].crossVectors(d[0], g);
            f[0].crossVectors(d[0], e[0]);
            for (k = 1; k <= a; k++) e[k] = e[k - 1].clone(), f[k] = f[k - 1].clone(), g.crossVectors(d[k - 1], d[k]), g.length() > Number.EPSILON && (g.normalize(), c = Math.acos(H.clamp(d[k - 1].dot(d[k]), -1, 1)), e[k].applyMatrix4(h.makeRotationAxis(g, c))), f[k].crossVectors(d[k], e[k]);
            if (!0 === b)
                for (c = Math.acos(H.clamp(e[0].dot(e[a]), -1, 1)), c /= a, 0 < d[0].dot(g.crossVectors(e[0], e[a])) && (c = -c), k = 1; k <= a; k++) e[k].applyMatrix4(h.makeRotationAxis(d[k],
                    c * k)), f[k].crossVectors(d[k], e[k]);
            return {
                tangents: d,
                normals: e,
                binormals: f
            }
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            this.arcLengthDivisions = a.arcLengthDivisions;
            return this
        },
        toJSON: function() {
            var a = {
                metadata: {
                    version: 4.5,
                    type: "Curve",
                    generator: "Curve.toJSON"
                }
            };
            a.arcLengthDivisions = this.arcLengthDivisions;
            a.type = this.type;
            return a
        },
        fromJSON: function(a) {
            this.arcLengthDivisions = a.arcLengthDivisions;
            return this
        }
    });
    za.prototype = Object.create(L.prototype);
    za.prototype.constructor =
        za;
    za.prototype.isEllipseCurve = !0;
    za.prototype.getPoint = function(a, b) {
        b = b || new z;
        for (var c = 2 * Math.PI, d = this.aEndAngle - this.aStartAngle, e = Math.abs(d) < Number.EPSILON; 0 > d;) d += c;
        for (; d > c;) d -= c;
        d < Number.EPSILON && (d = e ? 0 : c);
        !0 !== this.aClockwise || e || (d = d === c ? -c : d - c);
        c = this.aStartAngle + a * d;
        a = this.aX + this.xRadius * Math.cos(c);
        var f = this.aY + this.yRadius * Math.sin(c);
        0 !== this.aRotation && (c = Math.cos(this.aRotation), d = Math.sin(this.aRotation), e = a - this.aX, f -= this.aY, a = e * c - f * d + this.aX, f = e * d + f * c + this.aY);
        return b.set(a,
            f)
    };
    za.prototype.copy = function(a) {
        L.prototype.copy.call(this, a);
        this.aX = a.aX;
        this.aY = a.aY;
        this.xRadius = a.xRadius;
        this.yRadius = a.yRadius;
        this.aStartAngle = a.aStartAngle;
        this.aEndAngle = a.aEndAngle;
        this.aClockwise = a.aClockwise;
        this.aRotation = a.aRotation;
        return this
    };
    za.prototype.toJSON = function() {
        var a = L.prototype.toJSON.call(this);
        a.aX = this.aX;
        a.aY = this.aY;
        a.xRadius = this.xRadius;
        a.yRadius = this.yRadius;
        a.aStartAngle = this.aStartAngle;
        a.aEndAngle = this.aEndAngle;
        a.aClockwise = this.aClockwise;
        a.aRotation =
            this.aRotation;
        return a
    };
    za.prototype.fromJSON = function(a) {
        L.prototype.fromJSON.call(this, a);
        this.aX = a.aX;
        this.aY = a.aY;
        this.xRadius = a.xRadius;
        this.yRadius = a.yRadius;
        this.aStartAngle = a.aStartAngle;
        this.aEndAngle = a.aEndAngle;
        this.aClockwise = a.aClockwise;
        this.aRotation = a.aRotation;
        return this
    };
    dc.prototype = Object.create(za.prototype);
    dc.prototype.constructor = dc;
    dc.prototype.isArcCurve = !0;
    var Od = new p,
        Ae = new fe,
        Be = new fe,
        Ce = new fe;
    ca.prototype = Object.create(L.prototype);
    ca.prototype.constructor = ca;
    ca.prototype.isCatmullRomCurve3 = !0;
    ca.prototype.getPoint = function(a, b) {
        b = b || new p;
        var c = this.points,
            d = c.length;
        a *= d - (this.closed ? 0 : 1);
        var e = Math.floor(a);
        a -= e;
        this.closed ? e += 0 < e ? 0 : (Math.floor(Math.abs(e) / d) + 1) * d : 0 === a && e === d - 1 && (e = d - 2, a = 1);
        if (this.closed || 0 < e) var f = c[(e - 1) % d];
        else Od.subVectors(c[0], c[1]).add(c[0]), f = Od;
        var g = c[e % d];
        var h = c[(e + 1) % d];
        this.closed || e + 2 < d ? c = c[(e + 2) % d] : (Od.subVectors(c[d - 1], c[d - 2]).add(c[d - 1]), c = Od);
        if ("centripetal" === this.curveType || "chordal" === this.curveType) {
            var k = "chordal" === this.curveType ? .5 : .25;
            d = Math.pow(f.distanceToSquared(g), k);
            e = Math.pow(g.distanceToSquared(h), k);
            k = Math.pow(h.distanceToSquared(c), k);
            1E-4 > e && (e = 1);
            1E-4 > d && (d = e);
            1E-4 > k && (k = e);
            Ae.initNonuniformCatmullRom(f.x, g.x, h.x, c.x, d, e, k);
            Be.initNonuniformCatmullRom(f.y, g.y, h.y, c.y, d, e, k);
            Ce.initNonuniformCatmullRom(f.z, g.z, h.z, c.z, d, e, k)
        } else "catmullrom" === this.curveType && (Ae.initCatmullRom(f.x, g.x, h.x, c.x, this.tension), Be.initCatmullRom(f.y, g.y, h.y, c.y, this.tension), Ce.initCatmullRom(f.z, g.z, h.z, c.z, this.tension));
        b.set(Ae.calc(a),
            Be.calc(a), Ce.calc(a));
        return b
    };
    ca.prototype.copy = function(a) {
        L.prototype.copy.call(this, a);
        this.points = [];
        for (var b = 0, c = a.points.length; b < c; b++) this.points.push(a.points[b].clone());
        this.closed = a.closed;
        this.curveType = a.curveType;
        this.tension = a.tension;
        return this
    };
    ca.prototype.toJSON = function() {
        var a = L.prototype.toJSON.call(this);
        a.points = [];
        for (var b = 0, c = this.points.length; b < c; b++) a.points.push(this.points[b].toArray());
        a.closed = this.closed;
        a.curveType = this.curveType;
        a.tension = this.tension;
        return a
    };
    ca.prototype.fromJSON = function(a) {
        L.prototype.fromJSON.call(this, a);
        this.points = [];
        for (var b = 0, c = a.points.length; b < c; b++) {
            var d = a.points[b];
            this.points.push((new p).fromArray(d))
        }
        this.closed = a.closed;
        this.curveType = a.curveType;
        this.tension = a.tension;
        return this
    };
    Ha.prototype = Object.create(L.prototype);
    Ha.prototype.constructor = Ha;
    Ha.prototype.isCubicBezierCurve = !0;
    Ha.prototype.getPoint = function(a, b) {
        b = b || new z;
        var c = this.v0,
            d = this.v1,
            e = this.v2,
            f = this.v3;
        b.set(ad(a, c.x, d.x, e.x, f.x), ad(a, c.y, d.y, e.y,
            f.y));
        return b
    };
    Ha.prototype.copy = function(a) {
        L.prototype.copy.call(this, a);
        this.v0.copy(a.v0);
        this.v1.copy(a.v1);
        this.v2.copy(a.v2);
        this.v3.copy(a.v3);
        return this
    };
    Ha.prototype.toJSON = function() {
        var a = L.prototype.toJSON.call(this);
        a.v0 = this.v0.toArray();
        a.v1 = this.v1.toArray();
        a.v2 = this.v2.toArray();
        a.v3 = this.v3.toArray();
        return a
    };
    Ha.prototype.fromJSON = function(a) {
        L.prototype.fromJSON.call(this, a);
        this.v0.fromArray(a.v0);
        this.v1.fromArray(a.v1);
        this.v2.fromArray(a.v2);
        this.v3.fromArray(a.v3);
        return this
    };
    Qa.prototype = Object.create(L.prototype);
    Qa.prototype.constructor = Qa;
    Qa.prototype.isCubicBezierCurve3 = !0;
    Qa.prototype.getPoint = function(a, b) {
        b = b || new p;
        var c = this.v0,
            d = this.v1,
            e = this.v2,
            f = this.v3;
        b.set(ad(a, c.x, d.x, e.x, f.x), ad(a, c.y, d.y, e.y, f.y), ad(a, c.z, d.z, e.z, f.z));
        return b
    };
    Qa.prototype.copy = function(a) {
        L.prototype.copy.call(this, a);
        this.v0.copy(a.v0);
        this.v1.copy(a.v1);
        this.v2.copy(a.v2);
        this.v3.copy(a.v3);
        return this
    };
    Qa.prototype.toJSON = function() {
        var a = L.prototype.toJSON.call(this);
        a.v0 = this.v0.toArray();
        a.v1 = this.v1.toArray();
        a.v2 = this.v2.toArray();
        a.v3 = this.v3.toArray();
        return a
    };
    Qa.prototype.fromJSON = function(a) {
        L.prototype.fromJSON.call(this, a);
        this.v0.fromArray(a.v0);
        this.v1.fromArray(a.v1);
        this.v2.fromArray(a.v2);
        this.v3.fromArray(a.v3);
        return this
    };
    va.prototype = Object.create(L.prototype);
    va.prototype.constructor = va;
    va.prototype.isLineCurve = !0;
    va.prototype.getPoint = function(a, b) {
        b = b || new z;
        1 === a ? b.copy(this.v2) : (b.copy(this.v2).sub(this.v1), b.multiplyScalar(a).add(this.v1));
        return b
    };
    va.prototype.getPointAt =
        function(a, b) {
            return this.getPoint(a, b)
        };
    va.prototype.getTangent = function() {
        return this.v2.clone().sub(this.v1).normalize()
    };
    va.prototype.copy = function(a) {
        L.prototype.copy.call(this, a);
        this.v1.copy(a.v1);
        this.v2.copy(a.v2);
        return this
    };
    va.prototype.toJSON = function() {
        var a = L.prototype.toJSON.call(this);
        a.v1 = this.v1.toArray();
        a.v2 = this.v2.toArray();
        return a
    };
    va.prototype.fromJSON = function(a) {
        L.prototype.fromJSON.call(this, a);
        this.v1.fromArray(a.v1);
        this.v2.fromArray(a.v2);
        return this
    };
    Ia.prototype =
        Object.create(L.prototype);
    Ia.prototype.constructor = Ia;
    Ia.prototype.isLineCurve3 = !0;
    Ia.prototype.getPoint = function(a, b) {
        b = b || new p;
        1 === a ? b.copy(this.v2) : (b.copy(this.v2).sub(this.v1), b.multiplyScalar(a).add(this.v1));
        return b
    };
    Ia.prototype.getPointAt = function(a, b) {
        return this.getPoint(a, b)
    };
    Ia.prototype.copy = function(a) {
        L.prototype.copy.call(this, a);
        this.v1.copy(a.v1);
        this.v2.copy(a.v2);
        return this
    };
    Ia.prototype.toJSON = function() {
        var a = L.prototype.toJSON.call(this);
        a.v1 = this.v1.toArray();
        a.v2 = this.v2.toArray();
        return a
    };
    Ia.prototype.fromJSON = function(a) {
        L.prototype.fromJSON.call(this, a);
        this.v1.fromArray(a.v1);
        this.v2.fromArray(a.v2);
        return this
    };
    Ja.prototype = Object.create(L.prototype);
    Ja.prototype.constructor = Ja;
    Ja.prototype.isQuadraticBezierCurve = !0;
    Ja.prototype.getPoint = function(a, b) {
        b = b || new z;
        var c = this.v0,
            d = this.v1,
            e = this.v2;
        b.set($c(a, c.x, d.x, e.x), $c(a, c.y, d.y, e.y));
        return b
    };
    Ja.prototype.copy = function(a) {
        L.prototype.copy.call(this, a);
        this.v0.copy(a.v0);
        this.v1.copy(a.v1);
        this.v2.copy(a.v2);
        return this
    };
    Ja.prototype.toJSON = function() {
        var a = L.prototype.toJSON.call(this);
        a.v0 = this.v0.toArray();
        a.v1 = this.v1.toArray();
        a.v2 = this.v2.toArray();
        return a
    };
    Ja.prototype.fromJSON = function(a) {
        L.prototype.fromJSON.call(this, a);
        this.v0.fromArray(a.v0);
        this.v1.fromArray(a.v1);
        this.v2.fromArray(a.v2);
        return this
    };
    Ra.prototype = Object.create(L.prototype);
    Ra.prototype.constructor = Ra;
    Ra.prototype.isQuadraticBezierCurve3 = !0;
    Ra.prototype.getPoint = function(a, b) {
        b = b || new p;
        var c = this.v0,
            d = this.v1,
            e = this.v2;
        b.set($c(a, c.x,
            d.x, e.x), $c(a, c.y, d.y, e.y), $c(a, c.z, d.z, e.z));
        return b
    };
    Ra.prototype.copy = function(a) {
        L.prototype.copy.call(this, a);
        this.v0.copy(a.v0);
        this.v1.copy(a.v1);
        this.v2.copy(a.v2);
        return this
    };
    Ra.prototype.toJSON = function() {
        var a = L.prototype.toJSON.call(this);
        a.v0 = this.v0.toArray();
        a.v1 = this.v1.toArray();
        a.v2 = this.v2.toArray();
        return a
    };
    Ra.prototype.fromJSON = function(a) {
        L.prototype.fromJSON.call(this, a);
        this.v0.fromArray(a.v0);
        this.v1.fromArray(a.v1);
        this.v2.fromArray(a.v2);
        return this
    };
    Ka.prototype = Object.create(L.prototype);
    Ka.prototype.constructor = Ka;
    Ka.prototype.isSplineCurve = !0;
    Ka.prototype.getPoint = function(a, b) {
        b = b || new z;
        var c = this.points,
            d = (c.length - 1) * a;
        a = Math.floor(d);
        d -= a;
        var e = c[0 === a ? a : a - 1],
            f = c[a],
            g = c[a > c.length - 2 ? c.length - 1 : a + 1];
        c = c[a > c.length - 3 ? c.length - 1 : a + 2];
        b.set(lf(d, e.x, f.x, g.x, c.x), lf(d, e.y, f.y, g.y, c.y));
        return b
    };
    Ka.prototype.copy = function(a) {
        L.prototype.copy.call(this, a);
        this.points = [];
        for (var b = 0, c = a.points.length; b < c; b++) this.points.push(a.points[b].clone());
        return this
    };
    Ka.prototype.toJSON = function() {
        var a =
            L.prototype.toJSON.call(this);
        a.points = [];
        for (var b = 0, c = this.points.length; b < c; b++) a.points.push(this.points[b].toArray());
        return a
    };
    Ka.prototype.fromJSON = function(a) {
        L.prototype.fromJSON.call(this, a);
        this.points = [];
        for (var b = 0, c = a.points.length; b < c; b++) {
            var d = a.points[b];
            this.points.push((new z).fromArray(d))
        }
        return this
    };
    var Af = Object.freeze({
        ArcCurve: dc,
        CatmullRomCurve3: ca,
        CubicBezierCurve: Ha,
        CubicBezierCurve3: Qa,
        EllipseCurve: za,
        LineCurve: va,
        LineCurve3: Ia,
        QuadraticBezierCurve: Ja,
        QuadraticBezierCurve3: Ra,
        SplineCurve: Ka
    });
    Xa.prototype = Object.assign(Object.create(L.prototype), {
        constructor: Xa,
        add: function(a) {
            this.curves.push(a)
        },
        closePath: function() {
            var a = this.curves[0].getPoint(0),
                b = this.curves[this.curves.length - 1].getPoint(1);
            a.equals(b) || this.curves.push(new va(b, a))
        },
        getPoint: function(a) {
            var b = a * this.getLength(),
                c = this.getCurveLengths();
            for (a = 0; a < c.length;) {
                if (c[a] >= b) return b = c[a] - b, a = this.curves[a], c = a.getLength(), a.getPointAt(0 === c ? 0 : 1 - b / c);
                a++
            }
            return null
        },
        getLength: function() {
            var a = this.getCurveLengths();
            return a[a.length - 1]
        },
        updateArcLengths: function() {
            this.needsUpdate = !0;
            this.cacheLengths = null;
            this.getCurveLengths()
        },
        getCurveLengths: function() {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
            for (var a = [], b = 0, c = 0, d = this.curves.length; c < d; c++) b += this.curves[c].getLength(), a.push(b);
            return this.cacheLengths = a
        },
        getSpacedPoints: function(a) {
            void 0 === a && (a = 40);
            for (var b = [], c = 0; c <= a; c++) b.push(this.getPoint(c / a));
            this.autoClose && b.push(b[0]);
            return b
        },
        getPoints: function(a) {
            a =
                a || 12;
            for (var b = [], c, d = 0, e = this.curves; d < e.length; d++) {
                var f = e[d];
                f = f.getPoints(f && f.isEllipseCurve ? 2 * a : f && (f.isLineCurve || f.isLineCurve3) ? 1 : f && f.isSplineCurve ? a * f.points.length : a);
                for (var g = 0; g < f.length; g++) {
                    var h = f[g];
                    c && c.equals(h) || (b.push(h), c = h)
                }
            }
            this.autoClose && 1 < b.length && !b[b.length - 1].equals(b[0]) && b.push(b[0]);
            return b
        },
        copy: function(a) {
            L.prototype.copy.call(this, a);
            this.curves = [];
            for (var b = 0, c = a.curves.length; b < c; b++) this.curves.push(a.curves[b].clone());
            this.autoClose = a.autoClose;
            return this
        },
        toJSON: function() {
            var a = L.prototype.toJSON.call(this);
            a.autoClose = this.autoClose;
            a.curves = [];
            for (var b = 0, c = this.curves.length; b < c; b++) a.curves.push(this.curves[b].toJSON());
            return a
        },
        fromJSON: function(a) {
            L.prototype.fromJSON.call(this, a);
            this.autoClose = a.autoClose;
            this.curves = [];
            for (var b = 0, c = a.curves.length; b < c; b++) {
                var d = a.curves[b];
                this.curves.push((new Af[d.type]).fromJSON(d))
            }
            return this
        }
    });
    La.prototype = Object.assign(Object.create(Xa.prototype), {
        constructor: La,
        setFromPoints: function(a) {
            this.moveTo(a[0].x,
                a[0].y);
            for (var b = 1, c = a.length; b < c; b++) this.lineTo(a[b].x, a[b].y)
        },
        moveTo: function(a, b) {
            this.currentPoint.set(a, b)
        },
        lineTo: function(a, b) {
            var c = new va(this.currentPoint.clone(), new z(a, b));
            this.curves.push(c);
            this.currentPoint.set(a, b)
        },
        quadraticCurveTo: function(a, b, c, d) {
            a = new Ja(this.currentPoint.clone(), new z(a, b), new z(c, d));
            this.curves.push(a);
            this.currentPoint.set(c, d)
        },
        bezierCurveTo: function(a, b, c, d, e, f) {
            a = new Ha(this.currentPoint.clone(), new z(a, b), new z(c, d), new z(e, f));
            this.curves.push(a);
            this.currentPoint.set(e, f)
        },
        splineThru: function(a) {
            var b = [this.currentPoint.clone()].concat(a);
            b = new Ka(b);
            this.curves.push(b);
            this.currentPoint.copy(a[a.length - 1])
        },
        arc: function(a, b, c, d, e, f) {
            this.absarc(a + this.currentPoint.x, b + this.currentPoint.y, c, d, e, f)
        },
        absarc: function(a, b, c, d, e, f) {
            this.absellipse(a, b, c, c, d, e, f)
        },
        ellipse: function(a, b, c, d, e, f, g, h) {
            this.absellipse(a + this.currentPoint.x, b + this.currentPoint.y, c, d, e, f, g, h)
        },
        absellipse: function(a, b, c, d, e, f, g, h) {
            a = new za(a, b, c, d, e, f, g, h);
            0 < this.curves.length &&
                (b = a.getPoint(0), b.equals(this.currentPoint) || this.lineTo(b.x, b.y));
            this.curves.push(a);
            a = a.getPoint(1);
            this.currentPoint.copy(a)
        },
        copy: function(a) {
            Xa.prototype.copy.call(this, a);
            this.currentPoint.copy(a.currentPoint);
            return this
        },
        toJSON: function() {
            var a = Xa.prototype.toJSON.call(this);
            a.currentPoint = this.currentPoint.toArray();
            return a
        },
        fromJSON: function(a) {
            Xa.prototype.fromJSON.call(this, a);
            this.currentPoint.fromArray(a.currentPoint);
            return this
        }
    });
    db.prototype = Object.assign(Object.create(La.prototype), {
        constructor: db,
        getPointsHoles: function(a) {
            for (var b = [], c = 0, d = this.holes.length; c < d; c++) b[c] = this.holes[c].getPoints(a);
            return b
        },
        extractPoints: function(a) {
            return {
                shape: this.getPoints(a),
                holes: this.getPointsHoles(a)
            }
        },
        copy: function(a) {
            La.prototype.copy.call(this, a);
            this.holes = [];
            for (var b = 0, c = a.holes.length; b < c; b++) this.holes.push(a.holes[b].clone());
            return this
        },
        toJSON: function() {
            var a = La.prototype.toJSON.call(this);
            a.uuid = this.uuid;
            a.holes = [];
            for (var b = 0, c = this.holes.length; b < c; b++) a.holes.push(this.holes[b].toJSON());
            return a
        },
        fromJSON: function(a) {
            La.prototype.fromJSON.call(this, a);
            this.uuid = a.uuid;
            this.holes = [];
            for (var b = 0, c = a.holes.length; b < c; b++) {
                var d = a.holes[b];
                this.holes.push((new La).fromJSON(d))
            }
            return this
        }
    });
    X.prototype = Object.assign(Object.create(D.prototype), {
        constructor: X,
        isLight: !0,
        copy: function(a) {
            D.prototype.copy.call(this, a);
            this.color.copy(a.color);
            this.intensity = a.intensity;
            return this
        },
        toJSON: function(a) {
            a = D.prototype.toJSON.call(this, a);
            a.object.color = this.color.getHex();
            a.object.intensity =
                this.intensity;
            void 0 !== this.groundColor && (a.object.groundColor = this.groundColor.getHex());
            void 0 !== this.distance && (a.object.distance = this.distance);
            void 0 !== this.angle && (a.object.angle = this.angle);
            void 0 !== this.decay && (a.object.decay = this.decay);
            void 0 !== this.penumbra && (a.object.penumbra = this.penumbra);
            void 0 !== this.shadow && (a.object.shadow = this.shadow.toJSON());
            return a
        }
    });
    wd.prototype = Object.assign(Object.create(X.prototype), {
        constructor: wd,
        isHemisphereLight: !0,
        copy: function(a) {
            X.prototype.copy.call(this,
                a);
            this.groundColor.copy(a.groundColor);
            return this
        }
    });
    Object.assign(Cb.prototype, {
        copy: function(a) {
            this.camera = a.camera.clone();
            this.bias = a.bias;
            this.radius = a.radius;
            this.mapSize.copy(a.mapSize);
            return this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        toJSON: function() {
            var a = {};
            0 !== this.bias && (a.bias = this.bias);
            1 !== this.radius && (a.radius = this.radius);
            if (512 !== this.mapSize.x || 512 !== this.mapSize.y) a.mapSize = this.mapSize.toArray();
            a.camera = this.camera.toJSON(!1).object;
            delete a.camera.matrix;
            return a
        }
    });
    xd.prototype = Object.assign(Object.create(Cb.prototype), {
        constructor: xd,
        isSpotLightShadow: !0,
        update: function(a) {
            var b = this.camera,
                c = 2 * H.RAD2DEG * a.angle,
                d = this.mapSize.width / this.mapSize.height;
            a = a.distance || b.far;
            if (c !== b.fov || d !== b.aspect || a !== b.far) b.fov = c, b.aspect = d, b.far = a, b.updateProjectionMatrix()
        }
    });
    yd.prototype = Object.assign(Object.create(X.prototype), {
        constructor: yd,
        isSpotLight: !0,
        copy: function(a) {
            X.prototype.copy.call(this, a);
            this.distance = a.distance;
            this.angle = a.angle;
            this.penumbra =
                a.penumbra;
            this.decay = a.decay;
            this.target = a.target.clone();
            this.shadow = a.shadow.clone();
            return this
        }
    });
    zd.prototype = Object.assign(Object.create(X.prototype), {
        constructor: zd,
        isPointLight: !0,
        copy: function(a) {
            X.prototype.copy.call(this, a);
            this.distance = a.distance;
            this.decay = a.decay;
            this.shadow = a.shadow.clone();
            return this
        }
    });
    Ad.prototype = Object.assign(Object.create(Cb.prototype), {
        constructor: Ad
    });
    Bd.prototype = Object.assign(Object.create(X.prototype), {
        constructor: Bd,
        isDirectionalLight: !0,
        copy: function(a) {
            X.prototype.copy.call(this,
                a);
            this.target = a.target.clone();
            this.shadow = a.shadow.clone();
            return this
        }
    });
    Cd.prototype = Object.assign(Object.create(X.prototype), {
        constructor: Cd,
        isAmbientLight: !0
    });
    Dd.prototype = Object.assign(Object.create(X.prototype), {
        constructor: Dd,
        isRectAreaLight: !0,
        copy: function(a) {
            X.prototype.copy.call(this, a);
            this.width = a.width;
            this.height = a.height;
            return this
        },
        toJSON: function(a) {
            a = X.prototype.toJSON.call(this, a);
            a.object.width = this.width;
            a.object.height = this.height;
            return a
        }
    });
    var ia = {
        arraySlice: function(a,
            b, c) {
            return ia.isTypedArray(a) ? new a.constructor(a.subarray(b, void 0 !== c ? c : a.length)) : a.slice(b, c)
        },
        convertArray: function(a, b, c) {
            return !a || !c && a.constructor === b ? a : "number" === typeof b.BYTES_PER_ELEMENT ? new b(a) : Array.prototype.slice.call(a)
        },
        isTypedArray: function(a) {
            return ArrayBuffer.isView(a) && !(a instanceof DataView)
        },
        getKeyframeOrder: function(a) {
            for (var b = a.length, c = Array(b), d = 0; d !== b; ++d) c[d] = d;
            c.sort(function(b, c) {
                return a[b] - a[c]
            });
            return c
        },
        sortedArray: function(a, b, c) {
            for (var d = a.length, e =
                    new a.constructor(d), f = 0, g = 0; g !== d; ++f)
                for (var h = c[f] * b, k = 0; k !== b; ++k) e[g++] = a[h + k];
            return e
        },
        flattenJSON: function(a, b, c, d) {
            for (var e = 1, f = a[0]; void 0 !== f && void 0 === f[d];) f = a[e++];
            if (void 0 !== f) {
                var g = f[d];
                if (void 0 !== g)
                    if (Array.isArray(g)) {
                        do g = f[d], void 0 !== g && (b.push(f.time), c.push.apply(c, g)), f = a[e++]; while (void 0 !== f)
                    } else if (void 0 !== g.toArray) {
                    do g = f[d], void 0 !== g && (b.push(f.time), g.toArray(c, c.length)), f = a[e++]; while (void 0 !== f)
                } else {
                    do g = f[d], void 0 !== g && (b.push(f.time), c.push(g)), f = a[e++];
                    while (void 0 !== f)
                }
            }
        }
    };
    Object.assign(wa.prototype, {
        evaluate: function(a) {
            var b = this.parameterPositions,
                c = this._cachedIndex,
                d = b[c],
                e = b[c - 1];
            a: {
                b: {
                    c: {
                        d: if (!(a < d)) {
                            for (var f = c + 2;;) {
                                if (void 0 === d) {
                                    if (a < e) break d;
                                    this._cachedIndex = c = b.length;
                                    return this.afterEnd_(c - 1, a, e)
                                }
                                if (c === f) break;
                                e = d;
                                d = b[++c];
                                if (a < d) break b
                            }
                            d = b.length;
                            break c
                        }if (a >= e) break a;
                        else {
                            f = b[1];
                            a < f && (c = 2, e = f);
                            for (f = c - 2;;) {
                                if (void 0 === e) return this._cachedIndex = 0, this.beforeStart_(0, a, d);
                                if (c === f) break;
                                d = e;
                                e = b[--c - 1];
                                if (a >= e) break b
                            }
                            d = c;
                            c =
                                0
                        }
                    }
                    for (; c < d;) e = c + d >>> 1,
                    a < b[e] ? d = e : c = e + 1;d = b[c];e = b[c - 1];
                    if (void 0 === e) return this._cachedIndex = 0, this.beforeStart_(0, a, d);
                    if (void 0 === d) return this._cachedIndex = c = b.length, this.afterEnd_(c - 1, e, a)
                }
                this._cachedIndex = c;this.intervalChanged_(c, e, d)
            }
            return this.interpolate_(c, e, a, d)
        },
        settings: null,
        DefaultSettings_: {},
        getSettings_: function() {
            return this.settings || this.DefaultSettings_
        },
        copySampleValue_: function(a) {
            var b = this.resultBuffer,
                c = this.sampleValues,
                d = this.valueSize;
            a *= d;
            for (var e = 0; e !== d; ++e) b[e] =
                c[a + e];
            return b
        },
        interpolate_: function() {
            throw Error("call to abstract method");
        },
        intervalChanged_: function() {}
    });
    Object.assign(wa.prototype, {
        beforeStart_: wa.prototype.copySampleValue_,
        afterEnd_: wa.prototype.copySampleValue_
    });
    Ed.prototype = Object.assign(Object.create(wa.prototype), {
        constructor: Ed,
        DefaultSettings_: {
            endingStart: 2400,
            endingEnd: 2400
        },
        intervalChanged_: function(a, b, c) {
            var d = this.parameterPositions,
                e = a - 2,
                f = a + 1,
                g = d[e],
                h = d[f];
            if (void 0 === g) switch (this.getSettings_().endingStart) {
                case 2401:
                    e =
                        a;
                    g = 2 * b - c;
                    break;
                case 2402:
                    e = d.length - 2;
                    g = b + d[e] - d[e + 1];
                    break;
                default:
                    e = a, g = c
            }
            if (void 0 === h) switch (this.getSettings_().endingEnd) {
                case 2401:
                    f = a;
                    h = 2 * c - b;
                    break;
                case 2402:
                    f = 1;
                    h = c + d[1] - d[0];
                    break;
                default:
                    f = a - 1, h = b
            }
            a = .5 * (c - b);
            d = this.valueSize;
            this._weightPrev = a / (b - g);
            this._weightNext = a / (h - c);
            this._offsetPrev = e * d;
            this._offsetNext = f * d
        },
        interpolate_: function(a, b, c, d) {
            var e = this.resultBuffer,
                f = this.sampleValues,
                g = this.valueSize;
            a *= g;
            var h = a - g,
                k = this._offsetPrev,
                m = this._offsetNext,
                l = this._weightPrev,
                n = this._weightNext,
                p = (c - b) / (d - b);
            c = p * p;
            d = c * p;
            b = -l * d + 2 * l * c - l * p;
            l = (1 + l) * d + (-1.5 - 2 * l) * c + (-.5 + l) * p + 1;
            p = (-1 - n) * d + (1.5 + n) * c + .5 * p;
            n = n * d - n * c;
            for (c = 0; c !== g; ++c) e[c] = b * f[k + c] + l * f[h + c] + p * f[a + c] + n * f[m + c];
            return e
        }
    });
    bd.prototype = Object.assign(Object.create(wa.prototype), {
        constructor: bd,
        interpolate_: function(a, b, c, d) {
            var e = this.resultBuffer,
                f = this.sampleValues,
                g = this.valueSize;
            a *= g;
            var h = a - g;
            b = (c - b) / (d - b);
            c = 1 - b;
            for (d = 0; d !== g; ++d) e[d] = f[h + d] * c + f[a + d] * b;
            return e
        }
    });
    Fd.prototype = Object.assign(Object.create(wa.prototype), {
        constructor: Fd,
        interpolate_: function(a) {
            return this.copySampleValue_(a - 1)
        }
    });
    Object.assign(oa, {
        toJSON: function(a) {
            var b = a.constructor;
            if (void 0 !== b.toJSON) b = b.toJSON(a);
            else {
                b = {
                    name: a.name,
                    times: ia.convertArray(a.times, Array),
                    values: ia.convertArray(a.values, Array)
                };
                var c = a.getInterpolation();
                c !== a.DefaultInterpolation && (b.interpolation = c)
            }
            b.type = a.ValueTypeName;
            return b
        }
    });
    Object.assign(oa.prototype, {
        constructor: oa,
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodDiscrete: function(a) {
            return new Fd(this.times,
                this.values, this.getValueSize(), a)
        },
        InterpolantFactoryMethodLinear: function(a) {
            return new bd(this.times, this.values, this.getValueSize(), a)
        },
        InterpolantFactoryMethodSmooth: function(a) {
            return new Ed(this.times, this.values, this.getValueSize(), a)
        },
        setInterpolation: function(a) {
            switch (a) {
                case 2300:
                    var b = this.InterpolantFactoryMethodDiscrete;
                    break;
                case 2301:
                    b = this.InterpolantFactoryMethodLinear;
                    break;
                case 2302:
                    b = this.InterpolantFactoryMethodSmooth
            }
            if (void 0 === b) {
                b = "unsupported interpolation for " + this.ValueTypeName +
                    " keyframe track named " + this.name;
                if (void 0 === this.createInterpolant)
                    if (a !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
                    else throw Error(b);
                console.warn("THREE.KeyframeTrack:", b);
                return this
            }
            this.createInterpolant = b;
            return this
        },
        getInterpolation: function() {
            switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return 2300;
                case this.InterpolantFactoryMethodLinear:
                    return 2301;
                case this.InterpolantFactoryMethodSmooth:
                    return 2302
            }
        },
        getValueSize: function() {
            return this.values.length /
                this.times.length
        },
        shift: function(a) {
            if (0 !== a)
                for (var b = this.times, c = 0, d = b.length; c !== d; ++c) b[c] += a;
            return this
        },
        scale: function(a) {
            if (1 !== a)
                for (var b = this.times, c = 0, d = b.length; c !== d; ++c) b[c] *= a;
            return this
        },
        trim: function(a, b) {
            for (var c = this.times, d = c.length, e = 0, f = d - 1; e !== d && c[e] < a;) ++e;
            for (; - 1 !== f && c[f] > b;) --f;
            ++f;
            if (0 !== e || f !== d) e >= f && (f = Math.max(f, 1), e = f - 1), a = this.getValueSize(), this.times = ia.arraySlice(c, e, f), this.values = ia.arraySlice(this.values, e * a, f * a);
            return this
        },
        validate: function() {
            var a = !0,
                b = this.getValueSize();
            0 !== b - Math.floor(b) && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), a = !1);
            var c = this.times;
            b = this.values;
            var d = c.length;
            0 === d && (console.error("THREE.KeyframeTrack: Track is empty.", this), a = !1);
            for (var e = null, f = 0; f !== d; f++) {
                var g = c[f];
                if ("number" === typeof g && isNaN(g)) {
                    console.error("THREE.KeyframeTrack: Time is not a valid number.", this, f, g);
                    a = !1;
                    break
                }
                if (null !== e && e > g) {
                    console.error("THREE.KeyframeTrack: Out of order keys.", this, f, g, e);
                    a = !1;
                    break
                }
                e =
                    g
            }
            if (void 0 !== b && ia.isTypedArray(b))
                for (f = 0, c = b.length; f !== c; ++f)
                    if (d = b[f], isNaN(d)) {
                        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, f, d);
                        a = !1;
                        break
                    }
            return a
        },
        optimize: function() {
            for (var a = this.times, b = this.values, c = this.getValueSize(), d = 2302 === this.getInterpolation(), e = 1, f = a.length - 1, g = 1; g < f; ++g) {
                var h = !1,
                    k = a[g];
                if (k !== a[g + 1] && (1 !== g || k !== k[0]))
                    if (d) h = !0;
                    else {
                        var m = g * c,
                            l = m - c,
                            n = m + c;
                        for (k = 0; k !== c; ++k) {
                            var p = b[m + k];
                            if (p !== b[l + k] || p !== b[n + k]) {
                                h = !0;
                                break
                            }
                        }
                    }
                if (h) {
                    if (g !== e)
                        for (a[e] =
                            a[g], h = g * c, m = e * c, k = 0; k !== c; ++k) b[m + k] = b[h + k];
                    ++e
                }
            }
            if (0 < f) {
                a[e] = a[f];
                h = f * c;
                m = e * c;
                for (k = 0; k !== c; ++k) b[m + k] = b[h + k];
                ++e
            }
            e !== a.length && (this.times = ia.arraySlice(a, 0, e), this.values = ia.arraySlice(b, 0, e * c));
            return this
        }
    });
    Gd.prototype = Object.assign(Object.create(oa.prototype), {
        constructor: Gd,
        ValueTypeName: "bool",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    });
    Hd.prototype = Object.assign(Object.create(oa.prototype), {
        constructor: Hd,
        ValueTypeName: "color"
    });
    ec.prototype = Object.assign(Object.create(oa.prototype), {
        constructor: ec,
        ValueTypeName: "number"
    });
    Id.prototype = Object.assign(Object.create(wa.prototype), {
        constructor: Id,
        interpolate_: function(a, b, c, d) {
            var e = this.resultBuffer,
                f = this.sampleValues,
                g = this.valueSize;
            a *= g;
            b = (c - b) / (d - b);
            for (c = a + g; a !== c; a += 4) fa.slerpFlat(e, 0, f, a - g, f, a, b);
            return e
        }
    });
    cd.prototype = Object.assign(Object.create(oa.prototype), {
        constructor: cd,
        ValueTypeName: "quaternion",
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodLinear: function(a) {
            return new Id(this.times,
                this.values, this.getValueSize(), a)
        },
        InterpolantFactoryMethodSmooth: void 0
    });
    Jd.prototype = Object.assign(Object.create(oa.prototype), {
        constructor: Jd,
        ValueTypeName: "string",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    });
    fc.prototype = Object.assign(Object.create(oa.prototype), {
        constructor: fc,
        ValueTypeName: "vector"
    });
    Object.assign(Ca, {
        parse: function(a) {
            for (var b = [], c = a.tracks, d = 1 / (a.fps || 1), e = 0, f = c.length; e !== f; ++e) b.push(Sg(c[e]).scale(d));
            return new Ca(a.name, a.duration, b)
        },
        toJSON: function(a) {
            var b = [],
                c = a.tracks;
            a = {
                name: a.name,
                duration: a.duration,
                tracks: b,
                uuid: a.uuid
            };
            for (var d = 0, e = c.length; d !== e; ++d) b.push(oa.toJSON(c[d]));
            return a
        },
        CreateFromMorphTargetSequence: function(a, b, c, d) {
            for (var e = b.length, f = [], g = 0; g < e; g++) {
                var h = [],
                    k = [];
                h.push((g + e - 1) % e, g, (g + 1) % e);
                k.push(0, 1, 0);
                var m = ia.getKeyframeOrder(h);
                h = ia.sortedArray(h, 1, m);
                k = ia.sortedArray(k, 1, m);
                d || 0 !== h[0] || (h.push(e), k.push(k[0]));
                f.push((new ec(".morphTargetInfluences[" + b[g].name +
                    "]", h, k)).scale(1 / c))
            }
            return new Ca(a, -1, f)
        },
        findByName: function(a, b) {
            var c = a;
            Array.isArray(a) || (c = a.geometry && a.geometry.animations || a.animations);
            for (a = 0; a < c.length; a++)
                if (c[a].name === b) return c[a];
            return null
        },
        CreateClipsFromMorphTargetSequences: function(a, b, c) {
            for (var d = {}, e = /^([\w-]*?)([\d]+)$/, f = 0, g = a.length; f < g; f++) {
                var h = a[f],
                    k = h.name.match(e);
                if (k && 1 < k.length) {
                    var m = k[1];
                    (k = d[m]) || (d[m] = k = []);
                    k.push(h)
                }
            }
            a = [];
            for (m in d) a.push(Ca.CreateFromMorphTargetSequence(m, d[m], b, c));
            return a
        },
        parseAnimation: function(a,
            b) {
            if (!a) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
            var c = function(a, b, c, d, e) {
                    if (0 !== c.length) {
                        var f = [],
                            g = [];
                        ia.flattenJSON(c, f, g, d);
                        0 !== f.length && e.push(new a(b, f, g))
                    }
                },
                d = [],
                e = a.name || "default",
                f = a.length || -1,
                g = a.fps || 30;
            a = a.hierarchy || [];
            for (var h = 0; h < a.length; h++) {
                var k = a[h].keys;
                if (k && 0 !== k.length)
                    if (k[0].morphTargets) {
                        f = {};
                        for (var m = 0; m < k.length; m++)
                            if (k[m].morphTargets)
                                for (var l = 0; l < k[m].morphTargets.length; l++) f[k[m].morphTargets[l]] = -1;
                        for (var n in f) {
                            var p = [],
                                u = [];
                            for (l = 0; l !== k[m].morphTargets.length; ++l) {
                                var r = k[m];
                                p.push(r.time);
                                u.push(r.morphTarget === n ? 1 : 0)
                            }
                            d.push(new ec(".morphTargetInfluence[" + n + "]", p, u))
                        }
                        f = f.length * (g || 1)
                    } else m = ".bones[" + b[h].name + "]", c(fc, m + ".position", k, "pos", d), c(cd, m + ".quaternion", k, "rot", d), c(fc, m + ".scale", k, "scl", d)
            }
            return 0 === d.length ? null : new Ca(e, f, d)
        }
    });
    Object.assign(Ca.prototype, {
        resetDuration: function() {
            for (var a = 0, b = 0, c = this.tracks.length; b !== c; ++b) {
                var d = this.tracks[b];
                a = Math.max(a, d.times[d.times.length - 1])
            }
            this.duration =
                a;
            return this
        },
        trim: function() {
            for (var a = 0; a < this.tracks.length; a++) this.tracks[a].trim(0, this.duration);
            return this
        },
        validate: function() {
            for (var a = !0, b = 0; b < this.tracks.length; b++) a = a && this.tracks[b].validate();
            return a
        },
        optimize: function() {
            for (var a = 0; a < this.tracks.length; a++) this.tracks[a].optimize();
            return this
        }
    });
    Object.assign(Kd.prototype, {
        load: function(a, b, c, d) {
            var e = this;
            (new Ga(e.manager)).load(a, function(a) {
                b(e.parse(JSON.parse(a)))
            }, c, d)
        },
        setTextures: function(a) {
            this.textures = a
        },
        parse: function(a) {
            function b(a) {
                void 0 ===
                    c[a] && console.warn("THREE.MaterialLoader: Undefined texture", a);
                return c[a]
            }
            var c = this.textures,
                d = new Vg[a.type];
            void 0 !== a.uuid && (d.uuid = a.uuid);
            void 0 !== a.name && (d.name = a.name);
            void 0 !== a.color && d.color.setHex(a.color);
            void 0 !== a.roughness && (d.roughness = a.roughness);
            void 0 !== a.metalness && (d.metalness = a.metalness);
            void 0 !== a.emissive && d.emissive.setHex(a.emissive);
            void 0 !== a.specular && d.specular.setHex(a.specular);
            void 0 !== a.shininess && (d.shininess = a.shininess);
            void 0 !== a.clearCoat && (d.clearCoat =
                a.clearCoat);
            void 0 !== a.clearCoatRoughness && (d.clearCoatRoughness = a.clearCoatRoughness);
            void 0 !== a.uniforms && (d.uniforms = a.uniforms);
            void 0 !== a.vertexShader && (d.vertexShader = a.vertexShader);
            void 0 !== a.fragmentShader && (d.fragmentShader = a.fragmentShader);
            void 0 !== a.vertexColors && (d.vertexColors = a.vertexColors);
            void 0 !== a.fog && (d.fog = a.fog);
            void 0 !== a.flatShading && (d.flatShading = a.flatShading);
            void 0 !== a.blending && (d.blending = a.blending);
            void 0 !== a.side && (d.side = a.side);
            void 0 !== a.opacity && (d.opacity =
                a.opacity);
            void 0 !== a.transparent && (d.transparent = a.transparent);
            void 0 !== a.alphaTest && (d.alphaTest = a.alphaTest);
            void 0 !== a.depthTest && (d.depthTest = a.depthTest);
            void 0 !== a.depthWrite && (d.depthWrite = a.depthWrite);
            void 0 !== a.colorWrite && (d.colorWrite = a.colorWrite);
            void 0 !== a.wireframe && (d.wireframe = a.wireframe);
            void 0 !== a.wireframeLinewidth && (d.wireframeLinewidth = a.wireframeLinewidth);
            void 0 !== a.wireframeLinecap && (d.wireframeLinecap = a.wireframeLinecap);
            void 0 !== a.wireframeLinejoin && (d.wireframeLinejoin =
                a.wireframeLinejoin);
            void 0 !== a.rotation && (d.rotation = a.rotation);
            1 !== a.linewidth && (d.linewidth = a.linewidth);
            void 0 !== a.dashSize && (d.dashSize = a.dashSize);
            void 0 !== a.gapSize && (d.gapSize = a.gapSize);
            void 0 !== a.scale && (d.scale = a.scale);
            void 0 !== a.polygonOffset && (d.polygonOffset = a.polygonOffset);
            void 0 !== a.polygonOffsetFactor && (d.polygonOffsetFactor = a.polygonOffsetFactor);
            void 0 !== a.polygonOffsetUnits && (d.polygonOffsetUnits = a.polygonOffsetUnits);
            void 0 !== a.skinning && (d.skinning = a.skinning);
            void 0 !== a.morphTargets &&
                (d.morphTargets = a.morphTargets);
            void 0 !== a.dithering && (d.dithering = a.dithering);
            void 0 !== a.visible && (d.visible = a.visible);
            void 0 !== a.userData && (d.userData = a.userData);
            void 0 !== a.shading && (d.flatShading = 1 === a.shading);
            void 0 !== a.size && (d.size = a.size);
            void 0 !== a.sizeAttenuation && (d.sizeAttenuation = a.sizeAttenuation);
            void 0 !== a.map && (d.map = b(a.map));
            void 0 !== a.alphaMap && (d.alphaMap = b(a.alphaMap), d.transparent = !0);
            void 0 !== a.bumpMap && (d.bumpMap = b(a.bumpMap));
            void 0 !== a.bumpScale && (d.bumpScale = a.bumpScale);
            void 0 !== a.normalMap && (d.normalMap = b(a.normalMap));
            void 0 !== a.normalMapType && (d.normalMapType = a.normalMapType);
            if (void 0 !== a.normalScale) {
                var e = a.normalScale;
                !1 === Array.isArray(e) && (e = [e, e]);
                d.normalScale = (new z).fromArray(e)
            }
            void 0 !== a.displacementMap && (d.displacementMap = b(a.displacementMap));
            void 0 !== a.displacementScale && (d.displacementScale = a.displacementScale);
            void 0 !== a.displacementBias && (d.displacementBias = a.displacementBias);
            void 0 !== a.roughnessMap && (d.roughnessMap = b(a.roughnessMap));
            void 0 !==
                a.metalnessMap && (d.metalnessMap = b(a.metalnessMap));
            void 0 !== a.emissiveMap && (d.emissiveMap = b(a.emissiveMap));
            void 0 !== a.emissiveIntensity && (d.emissiveIntensity = a.emissiveIntensity);
            void 0 !== a.specularMap && (d.specularMap = b(a.specularMap));
            void 0 !== a.envMap && (d.envMap = b(a.envMap));
            void 0 !== a.reflectivity && (d.reflectivity = a.reflectivity);
            void 0 !== a.lightMap && (d.lightMap = b(a.lightMap));
            void 0 !== a.lightMapIntensity && (d.lightMapIntensity = a.lightMapIntensity);
            void 0 !== a.aoMap && (d.aoMap = b(a.aoMap));
            void 0 !==
                a.aoMapIntensity && (d.aoMapIntensity = a.aoMapIntensity);
            void 0 !== a.gradientMap && (d.gradientMap = b(a.gradientMap));
            return d
        }
    });
    Object.assign(ge.prototype, {
        load: function(a, b, c, d) {
            var e = this;
            (new Ga(e.manager)).load(a, function(a) {
                b(e.parse(JSON.parse(a)))
            }, c, d)
        },
        parse: function(a) {
            var b = new C,
                c = a.data.index;
            void 0 !== c && (c = new Bf[c.type](c.array), b.setIndex(new Q(c, 1)));
            var d = a.data.attributes;
            for (f in d) {
                var e = d[f];
                c = new Bf[e.type](e.array);
                b.addAttribute(f, new Q(c, e.itemSize, e.normalized))
            }
            var f = a.data.groups ||
                a.data.drawcalls || a.data.offsets;
            if (void 0 !== f)
                for (c = 0, d = f.length; c !== d; ++c) e = f[c], b.addGroup(e.start, e.count, e.materialIndex);
            a = a.data.boundingSphere;
            void 0 !== a && (f = new p, void 0 !== a.center && f.fromArray(a.center), b.boundingSphere = new Da(f, a.radius));
            return b
        }
    });
    var Bf = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: "undefined" !== typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    };
    gc.Handlers = {
        handlers: [],
        add: function(a, b) {
            this.handlers.push(a, b)
        },
        get: function(a) {
            for (var b = this.handlers, c = 0, d = b.length; c < d; c += 2) {
                var e = b[c + 1];
                if (b[c].test(a)) return e
            }
            return null
        }
    };
    Object.assign(gc.prototype, {
        crossOrigin: "anonymous",
        onLoadStart: function() {},
        onLoadProgress: function() {},
        onLoadComplete: function() {},
        initMaterials: function(a, b, c) {
            for (var d = [], e = 0; e < a.length; ++e) d[e] = this.createMaterial(a[e], b, c);
            return d
        },
        createMaterial: function() {
            var a = {
                    NoBlending: 0,
                    NormalBlending: 1,
                    AdditiveBlending: 2,
                    SubtractiveBlending: 3,
                    MultiplyBlending: 4,
                    CustomBlending: 5
                },
                b = new G,
                c = new vd,
                d = new Kd;
            return function(e, f, g) {
                function h(a, b, d, e, h) {
                    a = f + a;
                    var m = gc.Handlers.get(a);
                    null !== m ? a = m.load(a) : (c.setCrossOrigin(g), a = c.load(a));
                    void 0 !== b && (a.repeat.fromArray(b), 1 !== b[0] && (a.wrapS = 1E3), 1 !== b[1] && (a.wrapT = 1E3));
                    void 0 !== d && a.offset.fromArray(d);
                    void 0 !== e && ("repeat" === e[0] && (a.wrapS = 1E3), "mirror" === e[0] && (a.wrapS = 1002), "repeat" === e[1] && (a.wrapT = 1E3), "mirror" === e[1] && (a.wrapT = 1002));
                    void 0 !==
                        h && (a.anisotropy = h);
                    b = H.generateUUID();
                    k[b] = a;
                    return b
                }
                var k = {},
                    m = {
                        uuid: H.generateUUID(),
                        type: "MeshLambertMaterial"
                    },
                    l;
                for (l in e) {
                    var n = e[l];
                    switch (l) {
                        case "DbgColor":
                        case "DbgIndex":
                        case "opticalDensity":
                        case "illumination":
                            break;
                        case "DbgName":
                            m.name = n;
                            break;
                        case "blending":
                            m.blending = a[n];
                            break;
                        case "colorAmbient":
                        case "mapAmbient":
                            console.warn("THREE.Loader.createMaterial:", l, "is no longer supported.");
                            break;
                        case "colorDiffuse":
                            m.color = b.fromArray(n).getHex();
                            break;
                        case "colorSpecular":
                            m.specular =
                                b.fromArray(n).getHex();
                            break;
                        case "colorEmissive":
                            m.emissive = b.fromArray(n).getHex();
                            break;
                        case "specularCoef":
                            m.shininess = n;
                            break;
                        case "shading":
                            "basic" === n.toLowerCase() && (m.type = "MeshBasicMaterial");
                            "phong" === n.toLowerCase() && (m.type = "MeshPhongMaterial");
                            "standard" === n.toLowerCase() && (m.type = "MeshStandardMaterial");
                            break;
                        case "mapDiffuse":
                            m.map = h(n, e.mapDiffuseRepeat, e.mapDiffuseOffset, e.mapDiffuseWrap, e.mapDiffuseAnisotropy);
                            break;
                        case "mapDiffuseRepeat":
                        case "mapDiffuseOffset":
                        case "mapDiffuseWrap":
                        case "mapDiffuseAnisotropy":
                            break;
                        case "mapEmissive":
                            m.emissiveMap = h(n, e.mapEmissiveRepeat, e.mapEmissiveOffset, e.mapEmissiveWrap, e.mapEmissiveAnisotropy);
                            break;
                        case "mapEmissiveRepeat":
                        case "mapEmissiveOffset":
                        case "mapEmissiveWrap":
                        case "mapEmissiveAnisotropy":
                            break;
                        case "mapLight":
                            m.lightMap = h(n, e.mapLightRepeat, e.mapLightOffset, e.mapLightWrap, e.mapLightAnisotropy);
                            break;
                        case "mapLightRepeat":
                        case "mapLightOffset":
                        case "mapLightWrap":
                        case "mapLightAnisotropy":
                            break;
                        case "mapAO":
                            m.aoMap = h(n, e.mapAORepeat, e.mapAOOffset, e.mapAOWrap,
                                e.mapAOAnisotropy);
                            break;
                        case "mapAORepeat":
                        case "mapAOOffset":
                        case "mapAOWrap":
                        case "mapAOAnisotropy":
                            break;
                        case "mapBump":
                            m.bumpMap = h(n, e.mapBumpRepeat, e.mapBumpOffset, e.mapBumpWrap, e.mapBumpAnisotropy);
                            break;
                        case "mapBumpScale":
                            m.bumpScale = n;
                            break;
                        case "mapBumpRepeat":
                        case "mapBumpOffset":
                        case "mapBumpWrap":
                        case "mapBumpAnisotropy":
                            break;
                        case "mapNormal":
                            m.normalMap = h(n, e.mapNormalRepeat, e.mapNormalOffset, e.mapNormalWrap, e.mapNormalAnisotropy);
                            break;
                        case "mapNormalFactor":
                            m.normalScale = n;
                            break;
                        case "mapNormalRepeat":
                        case "mapNormalOffset":
                        case "mapNormalWrap":
                        case "mapNormalAnisotropy":
                            break;
                        case "mapSpecular":
                            m.specularMap = h(n, e.mapSpecularRepeat, e.mapSpecularOffset, e.mapSpecularWrap, e.mapSpecularAnisotropy);
                            break;
                        case "mapSpecularRepeat":
                        case "mapSpecularOffset":
                        case "mapSpecularWrap":
                        case "mapSpecularAnisotropy":
                            break;
                        case "mapMetalness":
                            m.metalnessMap = h(n, e.mapMetalnessRepeat, e.mapMetalnessOffset, e.mapMetalnessWrap, e.mapMetalnessAnisotropy);
                            break;
                        case "mapMetalnessRepeat":
                        case "mapMetalnessOffset":
                        case "mapMetalnessWrap":
                        case "mapMetalnessAnisotropy":
                            break;
                        case "mapRoughness":
                            m.roughnessMap = h(n, e.mapRoughnessRepeat, e.mapRoughnessOffset, e.mapRoughnessWrap, e.mapRoughnessAnisotropy);
                            break;
                        case "mapRoughnessRepeat":
                        case "mapRoughnessOffset":
                        case "mapRoughnessWrap":
                        case "mapRoughnessAnisotropy":
                            break;
                        case "mapAlpha":
                            m.alphaMap = h(n, e.mapAlphaRepeat, e.mapAlphaOffset, e.mapAlphaWrap, e.mapAlphaAnisotropy);
                            break;
                        case "mapAlphaRepeat":
                        case "mapAlphaOffset":
                        case "mapAlphaWrap":
                        case "mapAlphaAnisotropy":
                            break;
                        case "flipSided":
                            m.side = 1;
                            break;
                        case "doubleSided":
                            m.side =
                                2;
                            break;
                        case "transparency":
                            console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity");
                            m.opacity = n;
                            break;
                        case "depthTest":
                        case "depthWrite":
                        case "colorWrite":
                        case "opacity":
                        case "reflectivity":
                        case "transparent":
                        case "visible":
                        case "wireframe":
                            m[l] = n;
                            break;
                        case "vertexColors":
                            !0 === n && (m.vertexColors = 2);
                            "face" === n && (m.vertexColors = 1);
                            break;
                        default:
                            console.error("THREE.Loader.createMaterial: Unsupported", l, n)
                    }
                }
                "MeshBasicMaterial" === m.type && delete m.emissive;
                "MeshPhongMaterial" !==
                m.type && delete m.specular;
                1 > m.opacity && (m.transparent = !0);
                d.setTextures(k);
                return d.parse(m)
            }
        }()
    });
    var De = {
        decodeText: function(a) {
            if ("undefined" !== typeof TextDecoder) return (new TextDecoder).decode(a);
            for (var b = "", c = 0, d = a.length; c < d; c++) b += String.fromCharCode(a[c]);
            return decodeURIComponent(escape(b))
        },
        extractUrlBase: function(a) {
            var b = a.lastIndexOf("/");
            return -1 === b ? "./" : a.substr(0, b + 1)
        }
    };
    Object.assign(he.prototype, {
        crossOrigin: "anonymous",
        load: function(a, b, c, d) {
            var e = this,
                f = this.texturePath && "string" ===
                typeof this.texturePath ? this.texturePath : De.extractUrlBase(a),
                g = new Ga(this.manager);
            g.setWithCredentials(this.withCredentials);
            g.load(a, function(c) {
                c = JSON.parse(c);
                var d = c.metadata;
                if (void 0 !== d && (d = d.type, void 0 !== d && "object" === d.toLowerCase())) {
                    console.error("THREE.JSONLoader: " + a + " should be loaded with THREE.ObjectLoader instead.");
                    return
                }
                c = e.parse(c, f);
                b(c.geometry, c.materials)
            }, c, d)
        },
        setCrossOrigin: function(a) {
            this.crossOrigin = a;
            return this
        },
        setTexturePath: function(a) {
            this.texturePath = a;
            return this
        },
        parse: function() {
            return function(a, b) {
                void 0 !== a.data && (a = a.data);
                a.scale = void 0 !== a.scale ? 1 / a.scale : 1;
                var c = new R,
                    d = a,
                    e, f, g, h = d.faces;
                var k = d.vertices;
                var m = d.normals,
                    l = d.colors;
                var n = d.scale;
                var t = 0;
                if (void 0 !== d.uvs) {
                    for (e = 0; e < d.uvs.length; e++) d.uvs[e].length && t++;
                    for (e = 0; e < t; e++) c.faceVertexUvs[e] = []
                }
                var u = 0;
                for (g = k.length; u < g;) e = new p, e.x = k[u++] * n, e.y = k[u++] * n, e.z = k[u++] * n, c.vertices.push(e);
                u = 0;
                for (g = h.length; u < g;) {
                    k = h[u++];
                    var r = k & 1;
                    var v = k & 2;
                    e = k & 8;
                    var y = k & 16;
                    var x = k & 32;
                    n = k & 64;
                    k &= 128;
                    if (r) {
                        r =
                            new Ta;
                        r.a = h[u];
                        r.b = h[u + 1];
                        r.c = h[u + 3];
                        var w = new Ta;
                        w.a = h[u + 1];
                        w.b = h[u + 2];
                        w.c = h[u + 3];
                        u += 4;
                        v && (v = h[u++], r.materialIndex = v, w.materialIndex = v);
                        v = c.faces.length;
                        if (e)
                            for (e = 0; e < t; e++) {
                                var B = d.uvs[e];
                                c.faceVertexUvs[e][v] = [];
                                c.faceVertexUvs[e][v + 1] = [];
                                for (f = 0; 4 > f; f++) {
                                    var E = h[u++];
                                    var A = B[2 * E];
                                    E = B[2 * E + 1];
                                    A = new z(A, E);
                                    2 !== f && c.faceVertexUvs[e][v].push(A);
                                    0 !== f && c.faceVertexUvs[e][v + 1].push(A)
                                }
                            }
                        y && (y = 3 * h[u++], r.normal.set(m[y++], m[y++], m[y]), w.normal.copy(r.normal));
                        if (x)
                            for (e = 0; 4 > e; e++) y = 3 * h[u++], x = new p(m[y++],
                                m[y++], m[y]), 2 !== e && r.vertexNormals.push(x), 0 !== e && w.vertexNormals.push(x);
                        n && (n = h[u++], n = l[n], r.color.setHex(n), w.color.setHex(n));
                        if (k)
                            for (e = 0; 4 > e; e++) n = h[u++], n = l[n], 2 !== e && r.vertexColors.push(new G(n)), 0 !== e && w.vertexColors.push(new G(n));
                        c.faces.push(r);
                        c.faces.push(w)
                    } else {
                        r = new Ta;
                        r.a = h[u++];
                        r.b = h[u++];
                        r.c = h[u++];
                        v && (v = h[u++], r.materialIndex = v);
                        v = c.faces.length;
                        if (e)
                            for (e = 0; e < t; e++)
                                for (B = d.uvs[e], c.faceVertexUvs[e][v] = [], f = 0; 3 > f; f++) E = h[u++], A = B[2 * E], E = B[2 * E + 1], A = new z(A, E), c.faceVertexUvs[e][v].push(A);
                        y && (y = 3 * h[u++], r.normal.set(m[y++], m[y++], m[y]));
                        if (x)
                            for (e = 0; 3 > e; e++) y = 3 * h[u++], x = new p(m[y++], m[y++], m[y]), r.vertexNormals.push(x);
                        n && (n = h[u++], r.color.setHex(l[n]));
                        if (k)
                            for (e = 0; 3 > e; e++) n = h[u++], r.vertexColors.push(new G(l[n]));
                        c.faces.push(r)
                    }
                }
                d = a;
                u = void 0 !== d.influencesPerVertex ? d.influencesPerVertex : 2;
                if (d.skinWeights)
                    for (g = 0, h = d.skinWeights.length; g < h; g += u) c.skinWeights.push(new V(d.skinWeights[g], 1 < u ? d.skinWeights[g + 1] : 0, 2 < u ? d.skinWeights[g + 2] : 0, 3 < u ? d.skinWeights[g + 3] : 0));
                if (d.skinIndices)
                    for (g =
                        0, h = d.skinIndices.length; g < h; g += u) c.skinIndices.push(new V(d.skinIndices[g], 1 < u ? d.skinIndices[g + 1] : 0, 2 < u ? d.skinIndices[g + 2] : 0, 3 < u ? d.skinIndices[g + 3] : 0));
                c.bones = d.bones;
                c.bones && 0 < c.bones.length && (c.skinWeights.length !== c.skinIndices.length || c.skinIndices.length !== c.vertices.length) && console.warn("When skinning, number of vertices (" + c.vertices.length + "), skinIndices (" + c.skinIndices.length + "), and skinWeights (" + c.skinWeights.length + ") should match.");
                g = a;
                h = g.scale;
                if (void 0 !== g.morphTargets)
                    for (d =
                        0, u = g.morphTargets.length; d < u; d++)
                        for (c.morphTargets[d] = {}, c.morphTargets[d].name = g.morphTargets[d].name, c.morphTargets[d].vertices = [], m = c.morphTargets[d].vertices, l = g.morphTargets[d].vertices, t = 0, k = l.length; t < k; t += 3) n = new p, n.x = l[t] * h, n.y = l[t + 1] * h, n.z = l[t + 2] * h, m.push(n);
                if (void 0 !== g.morphColors && 0 < g.morphColors.length)
                    for (console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.'), h = c.faces, g = g.morphColors[0].colors, d = 0, u = h.length; d < u; d++) h[d].color.fromArray(g,
                        3 * d);
                g = a;
                d = [];
                u = [];
                void 0 !== g.animation && u.push(g.animation);
                void 0 !== g.animations && (g.animations.length ? u = u.concat(g.animations) : u.push(g.animations));
                for (g = 0; g < u.length; g++)(h = Ca.parseAnimation(u[g], c.bones)) && d.push(h);
                c.morphTargets && (u = Ca.CreateClipsFromMorphTargetSequences(c.morphTargets, 10), d = d.concat(u));
                0 < d.length && (c.animations = d);
                c.computeFaceNormals();
                c.computeBoundingSphere();
                if (void 0 === a.materials || 0 === a.materials.length) return {
                    geometry: c
                };
                a = gc.prototype.initMaterials(a.materials, b,
                    this.crossOrigin);
                return {
                    geometry: c,
                    materials: a
                }
            }
        }()
    });
    Object.assign(mf.prototype, {
        crossOrigin: "anonymous",
        load: function(a, b, c, d) {
            "" === this.texturePath && (this.texturePath = a.substring(0, a.lastIndexOf("/") + 1));
            var e = this;
            (new Ga(e.manager)).load(a, function(c) {
                var f = null;
                try {
                    f = JSON.parse(c)
                } catch (h) {
                    void 0 !== d && d(h);
                    console.error("THREE:ObjectLoader: Can't parse " + a + ".", h.message);
                    return
                }
                c = f.metadata;
                void 0 === c || void 0 === c.type || "geometry" === c.type.toLowerCase() ? console.error("THREE.ObjectLoader: Can't load " +
                    a + ". Use THREE.JSONLoader instead.") : e.parse(f, b)
            }, c, d)
        },
        setTexturePath: function(a) {
            this.texturePath = a;
            return this
        },
        setCrossOrigin: function(a) {
            this.crossOrigin = a;
            return this
        },
        parse: function(a, b) {
            var c = this.parseShape(a.shapes);
            c = this.parseGeometries(a.geometries, c);
            var d = this.parseImages(a.images, function() {
                void 0 !== b && b(e)
            });
            d = this.parseTextures(a.textures, d);
            d = this.parseMaterials(a.materials, d);
            var e = this.parseObject(a.object, c, d);
            a.animations && (e.animations = this.parseAnimations(a.animations));
            void 0 !== a.images && 0 !== a.images.length || void 0 === b || b(e);
            return e
        },
        parseShape: function(a) {
            var b = {};
            if (void 0 !== a)
                for (var c = 0, d = a.length; c < d; c++) {
                    var e = (new db).fromJSON(a[c]);
                    b[e.uuid] = e
                }
            return b
        },
        parseGeometries: function(a, b) {
            var c = {};
            if (void 0 !== a)
                for (var d = new he, e = new ge, f = 0, g = a.length; f < g; f++) {
                    var h = a[f];
                    switch (h.type) {
                        case "PlaneGeometry":
                        case "PlaneBufferGeometry":
                            var k = new xa[h.type](h.width, h.height, h.widthSegments, h.heightSegments);
                            break;
                        case "BoxGeometry":
                        case "BoxBufferGeometry":
                        case "CubeGeometry":
                            k =
                                new xa[h.type](h.width, h.height, h.depth, h.widthSegments, h.heightSegments, h.depthSegments);
                            break;
                        case "CircleGeometry":
                        case "CircleBufferGeometry":
                            k = new xa[h.type](h.radius, h.segments, h.thetaStart, h.thetaLength);
                            break;
                        case "CylinderGeometry":
                        case "CylinderBufferGeometry":
                            k = new xa[h.type](h.radiusTop, h.radiusBottom, h.height, h.radialSegments, h.heightSegments, h.openEnded, h.thetaStart, h.thetaLength);
                            break;
                        case "ConeGeometry":
                        case "ConeBufferGeometry":
                            k = new xa[h.type](h.radius, h.height, h.radialSegments,
                                h.heightSegments, h.openEnded, h.thetaStart, h.thetaLength);
                            break;
                        case "SphereGeometry":
                        case "SphereBufferGeometry":
                            k = new xa[h.type](h.radius, h.widthSegments, h.heightSegments, h.phiStart, h.phiLength, h.thetaStart, h.thetaLength);
                            break;
                        case "DodecahedronGeometry":
                        case "DodecahedronBufferGeometry":
                        case "IcosahedronGeometry":
                        case "IcosahedronBufferGeometry":
                        case "OctahedronGeometry":
                        case "OctahedronBufferGeometry":
                        case "TetrahedronGeometry":
                        case "TetrahedronBufferGeometry":
                            k = new xa[h.type](h.radius, h.detail);
                            break;
                        case "RingGeometry":
                        case "RingBufferGeometry":
                            k = new xa[h.type](h.innerRadius, h.outerRadius, h.thetaSegments, h.phiSegments, h.thetaStart, h.thetaLength);
                            break;
                        case "TorusGeometry":
                        case "TorusBufferGeometry":
                            k = new xa[h.type](h.radius, h.tube, h.radialSegments, h.tubularSegments, h.arc);
                            break;
                        case "TorusKnotGeometry":
                        case "TorusKnotBufferGeometry":
                            k = new xa[h.type](h.radius, h.tube, h.tubularSegments, h.radialSegments, h.p, h.q);
                            break;
                        case "LatheGeometry":
                        case "LatheBufferGeometry":
                            k = new xa[h.type](h.points,
                                h.segments, h.phiStart, h.phiLength);
                            break;
                        case "PolyhedronGeometry":
                        case "PolyhedronBufferGeometry":
                            k = new xa[h.type](h.vertices, h.indices, h.radius, h.details);
                            break;
                        case "ShapeGeometry":
                        case "ShapeBufferGeometry":
                            k = [];
                            for (var m = 0, l = h.shapes.length; m < l; m++) {
                                var n = b[h.shapes[m]];
                                k.push(n)
                            }
                            k = new xa[h.type](k, h.curveSegments);
                            break;
                        case "ExtrudeGeometry":
                        case "ExtrudeBufferGeometry":
                            k = [];
                            m = 0;
                            for (l = h.shapes.length; m < l; m++) n = b[h.shapes[m]], k.push(n);
                            m = h.options.extrudePath;
                            void 0 !== m && (h.options.extrudePath =
                                (new Af[m.type]).fromJSON(m));
                            k = new xa[h.type](k, h.options);
                            break;
                        case "BufferGeometry":
                            k = e.parse(h);
                            break;
                        case "Geometry":
                            k = d.parse(h, this.texturePath).geometry;
                            break;
                        default:
                            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + h.type + '"');
                            continue
                    }
                    k.uuid = h.uuid;
                    void 0 !== h.name && (k.name = h.name);
                    !0 === k.isBufferGeometry && void 0 !== h.userData && (k.userData = h.userData);
                    c[h.uuid] = k
                }
            return c
        },
        parseMaterials: function(a, b) {
            var c = {};
            if (void 0 !== a) {
                var d = new Kd;
                d.setTextures(b);
                b = 0;
                for (var e = a.length; b <
                    e; b++) {
                    var f = a[b];
                    if ("MultiMaterial" === f.type) {
                        for (var g = [], h = 0; h < f.materials.length; h++) g.push(d.parse(f.materials[h]));
                        c[f.uuid] = g
                    } else c[f.uuid] = d.parse(f)
                }
            }
            return c
        },
        parseAnimations: function(a) {
            for (var b = [], c = 0; c < a.length; c++) {
                var d = a[c],
                    e = Ca.parse(d);
                void 0 !== d.uuid && (e.uuid = d.uuid);
                b.push(e)
            }
            return b
        },
        parseImages: function(a, b) {
            function c(a) {
                d.manager.itemStart(a);
                return f.load(a, function() {
                    d.manager.itemEnd(a)
                }, void 0, function() {
                    d.manager.itemEnd(a);
                    d.manager.itemError(a)
                })
            }
            var d = this,
                e = {};
            if (void 0 !== a && 0 < a.length) {
                b = new ce(b);
                var f = new Zc(b);
                f.setCrossOrigin(this.crossOrigin);
                b = 0;
                for (var g = a.length; b < g; b++) {
                    var h = a[b],
                        k = h.url;
                    if (Array.isArray(k)) {
                        e[h.uuid] = [];
                        for (var m = 0, l = k.length; m < l; m++) {
                            var n = k[m];
                            n = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(n) ? n : d.texturePath + n;
                            e[h.uuid].push(c(n))
                        }
                    } else n = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(h.url) ? h.url : d.texturePath + h.url, e[h.uuid] = c(n)
                }
            }
            return e
        },
        parseTextures: function(a, b) {
            function c(a, b) {
                if ("number" === typeof a) return a;
                console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
                    a);
                return b[a]
            }
            var d = {};
            if (void 0 !== a)
                for (var e = 0, f = a.length; e < f; e++) {
                    var g = a[e];
                    void 0 === g.image && console.warn('THREE.ObjectLoader: No "image" specified for', g.uuid);
                    void 0 === b[g.image] && console.warn("THREE.ObjectLoader: Undefined image", g.image);
                    var h = Array.isArray(b[g.image]) ? new Ua(b[g.image]) : new T(b[g.image]);
                    h.needsUpdate = !0;
                    h.uuid = g.uuid;
                    void 0 !== g.name && (h.name = g.name);
                    void 0 !== g.mapping && (h.mapping = c(g.mapping, Wg));
                    void 0 !== g.offset && h.offset.fromArray(g.offset);
                    void 0 !== g.repeat && h.repeat.fromArray(g.repeat);
                    void 0 !== g.center && h.center.fromArray(g.center);
                    void 0 !== g.rotation && (h.rotation = g.rotation);
                    void 0 !== g.wrap && (h.wrapS = c(g.wrap[0], Cf), h.wrapT = c(g.wrap[1], Cf));
                    void 0 !== g.format && (h.format = g.format);
                    void 0 !== g.minFilter && (h.minFilter = c(g.minFilter, Df));
                    void 0 !== g.magFilter && (h.magFilter = c(g.magFilter, Df));
                    void 0 !== g.anisotropy && (h.anisotropy = g.anisotropy);
                    void 0 !== g.flipY && (h.flipY = g.flipY);
                    d[g.uuid] = h
                }
            return d
        },
        parseObject: function(a, b, c) {
            function d(a) {
                void 0 === b[a] && console.warn("THREE.ObjectLoader: Undefined geometry",
                    a);
                return b[a]
            }

            function e(a) {
                if (void 0 !== a) {
                    if (Array.isArray(a)) {
                        for (var b = [], d = 0, e = a.length; d < e; d++) {
                            var f = a[d];
                            void 0 === c[f] && console.warn("THREE.ObjectLoader: Undefined material", f);
                            b.push(c[f])
                        }
                        return b
                    }
                    void 0 === c[a] && console.warn("THREE.ObjectLoader: Undefined material", a);
                    return c[a]
                }
            }
            switch (a.type) {
                case "Scene":
                    var f = new qd;
                    void 0 !== a.background && Number.isInteger(a.background) && (f.background = new G(a.background));
                    void 0 !== a.fog && ("Fog" === a.fog.type ? f.fog = new Mb(a.fog.color, a.fog.near, a.fog.far) :
                        "FogExp2" === a.fog.type && (f.fog = new Lb(a.fog.color, a.fog.density)));
                    break;
                case "PerspectiveCamera":
                    f = new Z(a.fov, a.aspect, a.near, a.far);
                    void 0 !== a.focus && (f.focus = a.focus);
                    void 0 !== a.zoom && (f.zoom = a.zoom);
                    void 0 !== a.filmGauge && (f.filmGauge = a.filmGauge);
                    void 0 !== a.filmOffset && (f.filmOffset = a.filmOffset);
                    void 0 !== a.view && (f.view = Object.assign({}, a.view));
                    break;
                case "OrthographicCamera":
                    f = new Hb(a.left, a.right, a.top, a.bottom, a.near, a.far);
                    void 0 !== a.zoom && (f.zoom = a.zoom);
                    void 0 !== a.view && (f.view = Object.assign({},
                        a.view));
                    break;
                case "AmbientLight":
                    f = new Cd(a.color, a.intensity);
                    break;
                case "DirectionalLight":
                    f = new Bd(a.color, a.intensity);
                    break;
                case "PointLight":
                    f = new zd(a.color, a.intensity, a.distance, a.decay);
                    break;
                case "RectAreaLight":
                    f = new Dd(a.color, a.intensity, a.width, a.height);
                    break;
                case "SpotLight":
                    f = new yd(a.color, a.intensity, a.distance, a.angle, a.penumbra, a.decay);
                    break;
                case "HemisphereLight":
                    f = new wd(a.color, a.groundColor, a.intensity);
                    break;
                case "SkinnedMesh":
                    console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                case "Mesh":
                    f = d(a.geometry);
                    var g = e(a.material);
                    f = f.bones && 0 < f.bones.length ? new sd(f, g) : new la(f, g);
                    break;
                case "LOD":
                    f = new Bc;
                    break;
                case "Line":
                    f = new sa(d(a.geometry), e(a.material), a.mode);
                    break;
                case "LineLoop":
                    f = new td(d(a.geometry), e(a.material));
                    break;
                case "LineSegments":
                    f = new W(d(a.geometry), e(a.material));
                    break;
                case "PointCloud":
                case "Points":
                    f = new Ob(d(a.geometry), e(a.material));
                    break;
                case "Sprite":
                    f = new Ac(e(a.material));
                    break;
                case "Group":
                    f = new Kb;
                    break;
                default:
                    f = new D
            }
            f.uuid = a.uuid;
            void 0 !==
                a.name && (f.name = a.name);
            void 0 !== a.matrix ? (f.matrix.fromArray(a.matrix), void 0 !== a.matrixAutoUpdate && (f.matrixAutoUpdate = a.matrixAutoUpdate), f.matrixAutoUpdate && f.matrix.decompose(f.position, f.quaternion, f.scale)) : (void 0 !== a.position && f.position.fromArray(a.position), void 0 !== a.rotation && f.rotation.fromArray(a.rotation), void 0 !== a.quaternion && f.quaternion.fromArray(a.quaternion), void 0 !== a.scale && f.scale.fromArray(a.scale));
            void 0 !== a.castShadow && (f.castShadow = a.castShadow);
            void 0 !== a.receiveShadow &&
                (f.receiveShadow = a.receiveShadow);
            a.shadow && (void 0 !== a.shadow.bias && (f.shadow.bias = a.shadow.bias), void 0 !== a.shadow.radius && (f.shadow.radius = a.shadow.radius), void 0 !== a.shadow.mapSize && f.shadow.mapSize.fromArray(a.shadow.mapSize), void 0 !== a.shadow.camera && (f.shadow.camera = this.parseObject(a.shadow.camera)));
            void 0 !== a.visible && (f.visible = a.visible);
            void 0 !== a.frustumCulled && (f.frustumCulled = a.frustumCulled);
            void 0 !== a.renderOrder && (f.renderOrder = a.renderOrder);
            void 0 !== a.userData && (f.userData = a.userData);
            void 0 !== a.layers && (f.layers.mask = a.layers);
            if (void 0 !== a.children) {
                g = a.children;
                for (var h = 0; h < g.length; h++) f.add(this.parseObject(g[h], b, c))
            }
            if ("LOD" === a.type)
                for (a = a.levels, g = 0; g < a.length; g++) {
                    h = a[g];
                    var k = f.getObjectByProperty("uuid", h.object);
                    void 0 !== k && f.addLevel(k, h.distance)
                }
            return f
        }
    });
    var Wg = {
            UVMapping: 300,
            CubeReflectionMapping: 301,
            CubeRefractionMapping: 302,
            EquirectangularReflectionMapping: 303,
            EquirectangularRefractionMapping: 304,
            SphericalReflectionMapping: 305,
            CubeUVReflectionMapping: 306,
            CubeUVRefractionMapping: 307
        },
        Cf = {
            RepeatWrapping: 1E3,
            ClampToEdgeWrapping: 1001,
            MirroredRepeatWrapping: 1002
        },
        Df = {
            NearestFilter: 1003,
            NearestMipMapNearestFilter: 1004,
            NearestMipMapLinearFilter: 1005,
            LinearFilter: 1006,
            LinearMipMapNearestFilter: 1007,
            LinearMipMapLinearFilter: 1008
        };
    ie.prototype = {
        constructor: ie,
        setOptions: function(a) {
            this.options = a;
            return this
        },
        load: function(a, b, c, d) {
            void 0 === a && (a = "");
            void 0 !== this.path && (a = this.path + a);
            a = this.manager.resolveURL(a);
            var e = this,
                f = Fb.get(a);
            if (void 0 !== f) return e.manager.itemStart(a),
                setTimeout(function() {
                    b && b(f);
                    e.manager.itemEnd(a)
                }, 0), f;
            fetch(a).then(function(a) {
                return a.blob()
            }).then(function(a) {
                return createImageBitmap(a, e.options)
            }).then(function(c) {
                Fb.add(a, c);
                b && b(c);
                e.manager.itemEnd(a)
            }).catch(function(b) {
                d && d(b);
                e.manager.itemEnd(a);
                e.manager.itemError(a)
            })
        },
        setCrossOrigin: function() {
            return this
        },
        setPath: function(a) {
            this.path = a;
            return this
        }
    };
    Object.assign(je.prototype, {
        moveTo: function(a, b) {
            this.currentPath = new La;
            this.subPaths.push(this.currentPath);
            this.currentPath.moveTo(a,
                b)
        },
        lineTo: function(a, b) {
            this.currentPath.lineTo(a, b)
        },
        quadraticCurveTo: function(a, b, c, d) {
            this.currentPath.quadraticCurveTo(a, b, c, d)
        },
        bezierCurveTo: function(a, b, c, d, e, f) {
            this.currentPath.bezierCurveTo(a, b, c, d, e, f)
        },
        splineThru: function(a) {
            this.currentPath.splineThru(a)
        },
        toShapes: function(a, b) {
            function c(a) {
                for (var b = [], c = 0, d = a.length; c < d; c++) {
                    var e = a[c],
                        f = new db;
                    f.curves = e.curves;
                    b.push(f)
                }
                return b
            }

            function d(a, b) {
                for (var c = b.length, d = !1, e = c - 1, f = 0; f < c; e = f++) {
                    var g = b[e],
                        h = b[f],
                        k = h.x - g.x,
                        m = h.y - g.y;
                    if (Math.abs(m) >
                        Number.EPSILON) {
                        if (0 > m && (g = b[f], k = -k, h = b[e], m = -m), !(a.y < g.y || a.y > h.y))
                            if (a.y === g.y) {
                                if (a.x === g.x) return !0
                            } else {
                                e = m * (a.x - g.x) - k * (a.y - g.y);
                                if (0 === e) return !0;
                                0 > e || (d = !d)
                            }
                    } else if (a.y === g.y && (h.x <= a.x && a.x <= g.x || g.x <= a.x && a.x <= h.x)) return !0
                }
                return d
            }
            var e = Va.isClockWise,
                f = this.subPaths;
            if (0 === f.length) return [];
            if (!0 === b) return c(f);
            b = [];
            if (1 === f.length) {
                var g = f[0];
                var h = new db;
                h.curves = g.curves;
                b.push(h);
                return b
            }
            var k = !e(f[0].getPoints());
            k = a ? !k : k;
            h = [];
            var m = [],
                l = [],
                n = 0;
            m[n] = void 0;
            l[n] = [];
            for (var p =
                    0, u = f.length; p < u; p++) {
                g = f[p];
                var r = g.getPoints();
                var v = e(r);
                (v = a ? !v : v) ? (!k && m[n] && n++, m[n] = {
                    s: new db,
                    p: r
                }, m[n].s.curves = g.curves, k && n++, l[n] = []) : l[n].push({
                    h: g,
                    p: r[0]
                })
            }
            if (!m[0]) return c(f);
            if (1 < m.length) {
                p = !1;
                a = [];
                e = 0;
                for (f = m.length; e < f; e++) h[e] = [];
                e = 0;
                for (f = m.length; e < f; e++)
                    for (g = l[e], v = 0; v < g.length; v++) {
                        k = g[v];
                        n = !0;
                        for (r = 0; r < m.length; r++) d(k.p, m[r].p) && (e !== r && a.push({
                            froms: e,
                            tos: r,
                            hole: v
                        }), n ? (n = !1, h[r].push(k)) : p = !0);
                        n && h[e].push(k)
                    }
                0 < a.length && (p || (l = h))
            }
            p = 0;
            for (e = m.length; p < e; p++)
                for (h = m[p].s,
                    b.push(h), a = l[p], f = 0, g = a.length; f < g; f++) h.holes.push(a[f].h);
            return b
        }
    });
    Object.assign(ke.prototype, {
        isFont: !0,
        generateShapes: function(a, b) {
            void 0 === b && (b = 100);
            var c = [],
                d = b;
            b = this.data;
            var e = Array.from ? Array.from(a) : String(a).split("");
            d /= b.resolution;
            var f = (b.boundingBox.yMax - b.boundingBox.yMin + b.underlineThickness) * d;
            a = [];
            for (var g = 0, h = 0, k = 0; k < e.length; k++) {
                var m = e[k];
                if ("\n" === m) g = 0, h -= f;
                else {
                    var l = d;
                    var n = g,
                        p = h;
                    if (m = b.glyphs[m] || b.glyphs["?"]) {
                        var u = new je;
                        if (m.o)
                            for (var r = m._cachedOutline || (m._cachedOutline =
                                    m.o.split(" ")), v = 0, y = r.length; v < y;) switch (r[v++]) {
                                case "m":
                                    var x = r[v++] * l + n;
                                    var w = r[v++] * l + p;
                                    u.moveTo(x, w);
                                    break;
                                case "l":
                                    x = r[v++] * l + n;
                                    w = r[v++] * l + p;
                                    u.lineTo(x, w);
                                    break;
                                case "q":
                                    var z = r[v++] * l + n;
                                    var A = r[v++] * l + p;
                                    var C = r[v++] * l + n;
                                    var D = r[v++] * l + p;
                                    u.quadraticCurveTo(C, D, z, A);
                                    break;
                                case "b":
                                    z = r[v++] * l + n, A = r[v++] * l + p, C = r[v++] * l + n, D = r[v++] * l + p, x = r[v++] * l + n, w = r[v++] * l + p, u.bezierCurveTo(C, D, x, w, z, A)
                            }
                        l = {
                            offsetX: m.ha * l,
                            path: u
                        }
                    } else l = void 0;
                    g += l.offsetX;
                    a.push(l.path)
                }
            }
            b = 0;
            for (e = a.length; b < e; b++) Array.prototype.push.apply(c,
                a[b].toShapes());
            return c
        }
    });
    Object.assign(nf.prototype, {
        load: function(a, b, c, d) {
            var e = this,
                f = new Ga(this.manager);
            f.setPath(this.path);
            f.load(a, function(a) {
                try {
                    var c = JSON.parse(a)
                } catch (k) {
                    console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), c = JSON.parse(a.substring(65, a.length - 2))
                }
                a = e.parse(c);
                b && b(a)
            }, c, d)
        },
        parse: function(a) {
            return new ke(a)
        },
        setPath: function(a) {
            this.path = a;
            return this
        }
    });
    var Pd, ne = {
        getContext: function() {
            void 0 === Pd && (Pd = new(window.AudioContext ||
                window.webkitAudioContext));
            return Pd
        },
        setContext: function(a) {
            Pd = a
        }
    };
    Object.assign(le.prototype, {
        load: function(a, b, c, d) {
            var e = new Ga(this.manager);
            e.setResponseType("arraybuffer");
            e.load(a, function(a) {
                a = a.slice(0);
                ne.getContext().decodeAudioData(a, function(a) {
                    b(a)
                })
            }, c, d)
        }
    });
    Object.assign(of.prototype, {
        update: function() {
            var a, b, c, d, e, f, g, h, k = new I,
                l = new I;
            return function(m) {
                if (a !== this || b !== m.focus || c !== m.fov || d !== m.aspect * this.aspect || e !== m.near || f !== m.far || g !== m.zoom || h !== this.eyeSep) {
                    a = this;
                    b =
                        m.focus;
                    c = m.fov;
                    d = m.aspect * this.aspect;
                    e = m.near;
                    f = m.far;
                    g = m.zoom;
                    var n = m.projectionMatrix.clone();
                    h = this.eyeSep / 2;
                    var p = h * e / b,
                        q = e * Math.tan(H.DEG2RAD * c * .5) / g;
                    l.elements[12] = -h;
                    k.elements[12] = h;
                    var r = -q * d + p;
                    var v = q * d + p;
                    n.elements[0] = 2 * e / (v - r);
                    n.elements[8] = (v + r) / (v - r);
                    this.cameraL.projectionMatrix.copy(n);
                    r = -q * d - p;
                    v = q * d - p;
                    n.elements[0] = 2 * e / (v - r);
                    n.elements[8] = (v + r) / (v - r);
                    this.cameraR.projectionMatrix.copy(n)
                }
                this.cameraL.matrixWorld.copy(m.matrixWorld).multiply(l);
                this.cameraR.matrixWorld.copy(m.matrixWorld).multiply(k)
            }
        }()
    });
    dd.prototype = Object.create(D.prototype);
    dd.prototype.constructor = dd;
    me.prototype = Object.assign(Object.create(D.prototype), {
        constructor: me,
        getInput: function() {
            return this.gain
        },
        removeFilter: function() {
            null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null);
            return this
        },
        getFilter: function() {
            return this.filter
        },
        setFilter: function(a) {
            null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) :
                this.gain.disconnect(this.context.destination);
            this.filter = a;
            this.gain.connect(this.filter);
            this.filter.connect(this.context.destination);
            return this
        },
        getMasterVolume: function() {
            return this.gain.gain.value
        },
        setMasterVolume: function(a) {
            this.gain.gain.setTargetAtTime(a, this.context.currentTime, .01);
            return this
        },
        updateMatrixWorld: function() {
            var a = new p,
                b = new fa,
                c = new p,
                d = new p;
            return function(e) {
                D.prototype.updateMatrixWorld.call(this, e);
                e = this.context.listener;
                var f = this.up;
                this.matrixWorld.decompose(a,
                    b, c);
                d.set(0, 0, -1).applyQuaternion(b);
                e.positionX ? (e.positionX.setValueAtTime(a.x, this.context.currentTime), e.positionY.setValueAtTime(a.y, this.context.currentTime), e.positionZ.setValueAtTime(a.z, this.context.currentTime), e.forwardX.setValueAtTime(d.x, this.context.currentTime), e.forwardY.setValueAtTime(d.y, this.context.currentTime), e.forwardZ.setValueAtTime(d.z, this.context.currentTime), e.upX.setValueAtTime(f.x, this.context.currentTime), e.upY.setValueAtTime(f.y, this.context.currentTime), e.upZ.setValueAtTime(f.z,
                    this.context.currentTime)) : (e.setPosition(a.x, a.y, a.z), e.setOrientation(d.x, d.y, d.z, f.x, f.y, f.z))
            }
        }()
    });
    hc.prototype = Object.assign(Object.create(D.prototype), {
        constructor: hc,
        getOutput: function() {
            return this.gain
        },
        setNodeSource: function(a) {
            this.hasPlaybackControl = !1;
            this.sourceType = "audioNode";
            this.source = a;
            this.connect();
            return this
        },
        setMediaElementSource: function(a) {
            this.hasPlaybackControl = !1;
            this.sourceType = "mediaNode";
            this.source = this.context.createMediaElementSource(a);
            this.connect();
            return this
        },
        setBuffer: function(a) {
            this.buffer = a;
            this.sourceType = "buffer";
            this.autoplay && this.play();
            return this
        },
        play: function() {
            if (!0 === this.isPlaying) console.warn("THREE.Audio: Audio is already playing.");
            else if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control.");
            else {
                var a = this.context.createBufferSource();
                a.buffer = this.buffer;
                a.loop = this.loop;
                a.onended = this.onEnded.bind(this);
                a.playbackRate.setValueAtTime(this.playbackRate, this.startTime);
                this.startTime = this.context.currentTime;
                a.start(this.startTime, this.offset);
                this.isPlaying = !0;
                this.source = a;
                return this.connect()
            }
        },
        pause: function() {
            if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control.");
            else return !0 === this.isPlaying && (this.source.stop(), this.source.onended = null, this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this
        },
        stop: function() {
            if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control.");
            else return this.source.stop(),
                this.source.onended = null, this.offset = 0, this.isPlaying = !1, this
        },
        connect: function() {
            if (0 < this.filters.length) {
                this.source.connect(this.filters[0]);
                for (var a = 1, b = this.filters.length; a < b; a++) this.filters[a - 1].connect(this.filters[a]);
                this.filters[this.filters.length - 1].connect(this.getOutput())
            } else this.source.connect(this.getOutput());
            return this
        },
        disconnect: function() {
            if (0 < this.filters.length) {
                this.source.disconnect(this.filters[0]);
                for (var a = 1, b = this.filters.length; a < b; a++) this.filters[a - 1].disconnect(this.filters[a]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else this.source.disconnect(this.getOutput());
            return this
        },
        getFilters: function() {
            return this.filters
        },
        setFilters: function(a) {
            a || (a = []);
            !0 === this.isPlaying ? (this.disconnect(), this.filters = a, this.connect()) : this.filters = a;
            return this
        },
        getFilter: function() {
            return this.getFilters()[0]
        },
        setFilter: function(a) {
            return this.setFilters(a ? [a] : [])
        },
        setPlaybackRate: function(a) {
            if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control.");
            else return this.playbackRate = a, !0 === this.isPlaying && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime), this
        },
        getPlaybackRate: function() {
            return this.playbackRate
        },
        onEnded: function() {
            this.isPlaying = !1
        },
        getLoop: function() {
            return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
        },
        setLoop: function(a) {
            if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control.");
            else return this.loop =
                a, !0 === this.isPlaying && (this.source.loop = this.loop), this
        },
        getVolume: function() {
            return this.gain.gain.value
        },
        setVolume: function(a) {
            this.gain.gain.setTargetAtTime(a, this.context.currentTime, .01);
            return this
        }
    });
    oe.prototype = Object.assign(Object.create(hc.prototype), {
        constructor: oe,
        getOutput: function() {
            return this.panner
        },
        getRefDistance: function() {
            return this.panner.refDistance
        },
        setRefDistance: function(a) {
            this.panner.refDistance = a;
            return this
        },
        getRolloffFactor: function() {
            return this.panner.rolloffFactor
        },
        setRolloffFactor: function(a) {
            this.panner.rolloffFactor = a;
            return this
        },
        getDistanceModel: function() {
            return this.panner.distanceModel
        },
        setDistanceModel: function(a) {
            this.panner.distanceModel = a;
            return this
        },
        getMaxDistance: function() {
            return this.panner.maxDistance
        },
        setMaxDistance: function(a) {
            this.panner.maxDistance = a;
            return this
        },
        setDirectionalCone: function(a, b, c) {
            this.panner.coneInnerAngle = a;
            this.panner.coneOuterAngle = b;
            this.panner.coneOuterGain = c;
            return this
        },
        updateMatrixWorld: function() {
            var a = new p,
                b = new fa,
                c = new p,
                d = new p;
            return function(e) {
                D.prototype.updateMatrixWorld.call(this, e);
                e = this.panner;
                this.matrixWorld.decompose(a, b, c);
                d.set(0, 0, 1).applyQuaternion(b);
                e.setPosition(a.x, a.y, a.z);
                e.setOrientation(d.x, d.y, d.z)
            }
        }()
    });
    Object.assign(pe.prototype, {
        getFrequencyData: function() {
            this.analyser.getByteFrequencyData(this.data);
            return this.data
        },
        getAverageFrequency: function() {
            for (var a = 0, b = this.getFrequencyData(), c = 0; c < b.length; c++) a += b[c];
            return a / b.length
        }
    });
    Object.assign(qe.prototype, {
        accumulate: function(a,
            b) {
            var c = this.buffer,
                d = this.valueSize;
            a = a * d + d;
            var e = this.cumulativeWeight;
            if (0 === e) {
                for (e = 0; e !== d; ++e) c[a + e] = c[e];
                e = b
            } else e += b, this._mixBufferRegion(c, a, 0, b / e, d);
            this.cumulativeWeight = e
        },
        apply: function(a) {
            var b = this.valueSize,
                c = this.buffer;
            a = a * b + b;
            var d = this.cumulativeWeight,
                e = this.binding;
            this.cumulativeWeight = 0;
            1 > d && this._mixBufferRegion(c, a, 3 * b, 1 - d, b);
            d = b;
            for (var f = b + b; d !== f; ++d)
                if (c[d] !== c[d + b]) {
                    e.setValue(c, a);
                    break
                }
        },
        saveOriginalState: function() {
            var a = this.buffer,
                b = this.valueSize,
                c = 3 * b;
            this.binding.getValue(a,
                c);
            for (var d = b; d !== c; ++d) a[d] = a[c + d % b];
            this.cumulativeWeight = 0
        },
        restoreOriginalState: function() {
            this.binding.setValue(this.buffer, 3 * this.valueSize)
        },
        _select: function(a, b, c, d, e) {
            if (.5 <= d)
                for (d = 0; d !== e; ++d) a[b + d] = a[c + d]
        },
        _slerp: function(a, b, c, d) {
            fa.slerpFlat(a, b, a, b, a, c, d)
        },
        _lerp: function(a, b, c, d, e) {
            for (var f = 1 - d, g = 0; g !== e; ++g) {
                var h = b + g;
                a[h] = a[h] * f + a[c + g] * d
            }
        }
    });
    Object.assign(pf.prototype, {
        getValue: function(a, b) {
            this.bind();
            var c = this._bindings[this._targetGroup.nCachedObjects_];
            void 0 !== c && c.getValue(a,
                b)
        },
        setValue: function(a, b) {
            for (var c = this._bindings, d = this._targetGroup.nCachedObjects_, e = c.length; d !== e; ++d) c[d].setValue(a, b)
        },
        bind: function() {
            for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, c = a.length; b !== c; ++b) a[b].bind()
        },
        unbind: function() {
            for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, c = a.length; b !== c; ++b) a[b].unbind()
        }
    });
    Object.assign(pa, {
        Composite: pf,
        create: function(a, b, c) {
            return a && a.isAnimationObjectGroup ? new pa.Composite(a, b, c) : new pa(a, b, c)
        },
        sanitizeNodeName: function() {
            var a =
                /[\[\]\.:\/]/g;
            return function(b) {
                return b.replace(/\s/g, "_").replace(a, "")
            }
        }(),
        parseTrackName: function() {
            var a = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
                b = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]");
            a = /(WCOD+)?/.source.replace("WCOD", a);
            var c = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
                d = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
                e = new RegExp("^" + b + a + c + d + "$"),
                f = ["material", "materials", "bones"];
            return function(a) {
                var b = e.exec(a);
                if (!b) throw Error("PropertyBinding: Cannot parse trackName: " +
                    a);
                b = {
                    nodeName: b[2],
                    objectName: b[3],
                    objectIndex: b[4],
                    propertyName: b[5],
                    propertyIndex: b[6]
                };
                var c = b.nodeName && b.nodeName.lastIndexOf(".");
                if (void 0 !== c && -1 !== c) {
                    var d = b.nodeName.substring(c + 1); - 1 !== f.indexOf(d) && (b.nodeName = b.nodeName.substring(0, c), b.objectName = d)
                }
                if (null === b.propertyName || 0 === b.propertyName.length) throw Error("PropertyBinding: can not parse propertyName from trackName: " + a);
                return b
            }
        }(),
        findNode: function(a, b) {
            if (!b || "" === b || "root" === b || "." === b || -1 === b || b === a.name || b === a.uuid) return a;
            if (a.skeleton) {
                var c = a.skeleton.getBoneByName(b);
                if (void 0 !== c) return c
            }
            if (a.children) {
                var d = function(a) {
                    for (var c = 0; c < a.length; c++) {
                        var e = a[c];
                        if (e.name === b || e.uuid === b || (e = d(e.children))) return e
                    }
                    return null
                };
                if (a = d(a.children)) return a
            }
            return null
        }
    });
    Object.assign(pa.prototype, {
        _getValue_unavailable: function() {},
        _setValue_unavailable: function() {},
        BindingType: {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        Versioning: {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        GetterByBindingType: [function(a,
            b) {
            a[b] = this.node[this.propertyName]
        }, function(a, b) {
            for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) a[b++] = c[d]
        }, function(a, b) {
            a[b] = this.resolvedProperty[this.propertyIndex]
        }, function(a, b) {
            this.resolvedProperty.toArray(a, b)
        }],
        SetterByBindingTypeAndVersioning: [
            [function(a, b) {
                this.targetObject[this.propertyName] = a[b]
            }, function(a, b) {
                this.targetObject[this.propertyName] = a[b];
                this.targetObject.needsUpdate = !0
            }, function(a, b) {
                this.targetObject[this.propertyName] = a[b];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }],
            [function(a, b) {
                for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) c[d] = a[b++]
            }, function(a, b) {
                for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) c[d] = a[b++];
                this.targetObject.needsUpdate = !0
            }, function(a, b) {
                for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) c[d] = a[b++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }],
            [function(a, b) {
                this.resolvedProperty[this.propertyIndex] = a[b]
            }, function(a, b) {
                this.resolvedProperty[this.propertyIndex] = a[b];
                this.targetObject.needsUpdate = !0
            }, function(a,
                b) {
                this.resolvedProperty[this.propertyIndex] = a[b];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }],
            [function(a, b) {
                this.resolvedProperty.fromArray(a, b)
            }, function(a, b) {
                this.resolvedProperty.fromArray(a, b);
                this.targetObject.needsUpdate = !0
            }, function(a, b) {
                this.resolvedProperty.fromArray(a, b);
                this.targetObject.matrixWorldNeedsUpdate = !0
            }]
        ],
        getValue: function(a, b) {
            this.bind();
            this.getValue(a, b)
        },
        setValue: function(a, b) {
            this.bind();
            this.setValue(a, b)
        },
        bind: function() {
            var a = this.node,
                b = this.parsedPath,
                c = b.objectName,
                d = b.propertyName,
                e = b.propertyIndex;
            a || (this.node = a = pa.findNode(this.rootNode, b.nodeName) || this.rootNode);
            this.getValue = this._getValue_unavailable;
            this.setValue = this._setValue_unavailable;
            if (a) {
                if (c) {
                    var f = b.objectIndex;
                    switch (c) {
                        case "materials":
                            if (!a.material) {
                                console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                return
                            }
                            if (!a.material.materials) {
                                console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                                    this);
                                return
                            }
                            a = a.material.materials;
                            break;
                        case "bones":
                            if (!a.skeleton) {
                                console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                return
                            }
                            a = a.skeleton.bones;
                            for (c = 0; c < a.length; c++)
                                if (a[c].name === f) {
                                    f = c;
                                    break
                                }
                            break;
                        default:
                            if (void 0 === a[c]) {
                                console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                return
                            }
                            a = a[c]
                    }
                    if (void 0 !== f) {
                        if (void 0 === a[f]) {
                            console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                                this, a);
                            return
                        }
                        a = a[f]
                    }
                }
                f = a[d];
                if (void 0 === f) console.error("THREE.PropertyBinding: Trying to update property for track: " + b.nodeName + "." + d + " but it wasn't found.", a);
                else {
                    b = this.Versioning.None;
                    void 0 !== a.needsUpdate ? (b = this.Versioning.NeedsUpdate, this.targetObject = a) : void 0 !== a.matrixWorldNeedsUpdate && (b = this.Versioning.MatrixWorldNeedsUpdate, this.targetObject = a);
                    c = this.BindingType.Direct;
                    if (void 0 !== e) {
                        if ("morphTargetInfluences" === d) {
                            if (!a.geometry) {
                                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                                    this);
                                return
                            }
                            if (a.geometry.isBufferGeometry) {
                                if (!a.geometry.morphAttributes) {
                                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                    return
                                }
                                for (c = 0; c < this.node.geometry.morphAttributes.position.length; c++)
                                    if (a.geometry.morphAttributes.position[c].name === e) {
                                        e = c;
                                        break
                                    }
                            } else {
                                if (!a.geometry.morphTargets) {
                                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.",
                                        this);
                                    return
                                }
                                for (c = 0; c < this.node.geometry.morphTargets.length; c++)
                                    if (a.geometry.morphTargets[c].name === e) {
                                        e = c;
                                        break
                                    }
                            }
                        }
                        c = this.BindingType.ArrayElement;
                        this.resolvedProperty = f;
                        this.propertyIndex = e
                    } else void 0 !== f.fromArray && void 0 !== f.toArray ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = f) : Array.isArray(f) ? (c = this.BindingType.EntireArray, this.resolvedProperty = f) : this.propertyName = d;
                    this.getValue = this.GetterByBindingType[c];
                    this.setValue = this.SetterByBindingTypeAndVersioning[c][b]
                }
            } else console.error("THREE.PropertyBinding: Trying to update node for track: " +
                this.path + " but it wasn't found.")
        },
        unbind: function() {
            this.node = null;
            this.getValue = this._getValue_unbound;
            this.setValue = this._setValue_unbound
        }
    });
    Object.assign(pa.prototype, {
        _getValue_unbound: pa.prototype.getValue,
        _setValue_unbound: pa.prototype.setValue
    });
    Object.assign(qf.prototype, {
        isAnimationObjectGroup: !0,
        add: function() {
            for (var a = this._objects, b = a.length, c = this.nCachedObjects_, d = this._indicesByUUID, e = this._paths, f = this._parsedPaths, g = this._bindings, h = g.length, k = void 0, l = 0, p = arguments.length; l !==
                p; ++l) {
                var n = arguments[l],
                    t = n.uuid,
                    u = d[t];
                if (void 0 === u) {
                    u = b++;
                    d[t] = u;
                    a.push(n);
                    t = 0;
                    for (var r = h; t !== r; ++t) g[t].push(new pa(n, e[t], f[t]))
                } else if (u < c) {
                    k = a[u];
                    var v = --c;
                    r = a[v];
                    d[r.uuid] = u;
                    a[u] = r;
                    d[t] = v;
                    a[v] = n;
                    t = 0;
                    for (r = h; t !== r; ++t) {
                        var y = g[t],
                            x = y[u];
                        y[u] = y[v];
                        void 0 === x && (x = new pa(n, e[t], f[t]));
                        y[v] = x
                    }
                } else a[u] !== k && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
            }
            this.nCachedObjects_ =
                c
        },
        remove: function() {
            for (var a = this._objects, b = this.nCachedObjects_, c = this._indicesByUUID, d = this._bindings, e = d.length, f = 0, g = arguments.length; f !== g; ++f) {
                var h = arguments[f],
                    k = h.uuid,
                    l = c[k];
                if (void 0 !== l && l >= b) {
                    var p = b++,
                        n = a[p];
                    c[n.uuid] = l;
                    a[l] = n;
                    c[k] = p;
                    a[p] = h;
                    h = 0;
                    for (k = e; h !== k; ++h) {
                        n = d[h];
                        var t = n[l];
                        n[l] = n[p];
                        n[p] = t
                    }
                }
            }
            this.nCachedObjects_ = b
        },
        uncache: function() {
            for (var a = this._objects, b = a.length, c = this.nCachedObjects_, d = this._indicesByUUID, e = this._bindings, f = e.length, g = 0, h = arguments.length; g !== h; ++g) {
                var k =
                    arguments[g].uuid,
                    l = d[k];
                if (void 0 !== l)
                    if (delete d[k], l < c) {
                        k = --c;
                        var p = a[k],
                            n = --b,
                            t = a[n];
                        d[p.uuid] = l;
                        a[l] = p;
                        d[t.uuid] = k;
                        a[k] = t;
                        a.pop();
                        p = 0;
                        for (t = f; p !== t; ++p) {
                            var u = e[p],
                                r = u[n];
                            u[l] = u[k];
                            u[k] = r;
                            u.pop()
                        }
                    } else
                        for (n = --b, t = a[n], d[t.uuid] = l, a[l] = t, a.pop(), p = 0, t = f; p !== t; ++p) u = e[p], u[l] = u[n], u.pop()
            }
            this.nCachedObjects_ = c
        },
        subscribe_: function(a, b) {
            var c = this._bindingsIndicesByPath,
                d = c[a],
                e = this._bindings;
            if (void 0 !== d) return e[d];
            var f = this._paths,
                g = this._parsedPaths,
                h = this._objects,
                k = this.nCachedObjects_,
                l = Array(h.length);
            d = e.length;
            c[a] = d;
            f.push(a);
            g.push(b);
            e.push(l);
            c = k;
            for (d = h.length; c !== d; ++c) l[c] = new pa(h[c], a, b);
            return l
        },
        unsubscribe_: function(a) {
            var b = this._bindingsIndicesByPath,
                c = b[a];
            if (void 0 !== c) {
                var d = this._paths,
                    e = this._parsedPaths,
                    f = this._bindings,
                    g = f.length - 1,
                    h = f[g];
                b[a[g]] = c;
                f[c] = h;
                f.pop();
                e[c] = e[g];
                e.pop();
                d[c] = d[g];
                d.pop()
            }
        }
    });
    Object.assign(rf.prototype, {
        play: function() {
            this._mixer._activateAction(this);
            return this
        },
        stop: function() {
            this._mixer._deactivateAction(this);
            return this.reset()
        },
        reset: function() {
            this.paused = !1;
            this.enabled = !0;
            this.time = 0;
            this._loopCount = -1;
            this._startTime = null;
            return this.stopFading().stopWarping()
        },
        isRunning: function() {
            return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
        },
        isScheduled: function() {
            return this._mixer._isActiveAction(this)
        },
        startAt: function(a) {
            this._startTime = a;
            return this
        },
        setLoop: function(a, b) {
            this.loop = a;
            this.repetitions = b;
            return this
        },
        setEffectiveWeight: function(a) {
            this.weight = a;
            this._effectiveWeight = this.enabled ? a : 0;
            return this.stopFading()
        },
        getEffectiveWeight: function() {
            return this._effectiveWeight
        },
        fadeIn: function(a) {
            return this._scheduleFading(a, 0, 1)
        },
        fadeOut: function(a) {
            return this._scheduleFading(a, 1, 0)
        },
        crossFadeFrom: function(a, b, c) {
            a.fadeOut(b);
            this.fadeIn(b);
            if (c) {
                c = this._clip.duration;
                var d = a._clip.duration,
                    e = c / d;
                a.warp(1, d / c, b);
                this.warp(e, 1, b)
            }
            return this
        },
        crossFadeTo: function(a, b, c) {
            return a.crossFadeFrom(this, b, c)
        },
        stopFading: function() {
            var a = this._weightInterpolant;
            null !== a && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(a));
            return this
        },
        setEffectiveTimeScale: function(a) {
            this.timeScale = a;
            this._effectiveTimeScale = this.paused ? 0 : a;
            return this.stopWarping()
        },
        getEffectiveTimeScale: function() {
            return this._effectiveTimeScale
        },
        setDuration: function(a) {
            this.timeScale = this._clip.duration / a;
            return this.stopWarping()
        },
        syncWith: function(a) {
            this.time = a.time;
            this.timeScale = a.timeScale;
            return this.stopWarping()
        },
        halt: function(a) {
            return this.warp(this._effectiveTimeScale,
                0, a)
        },
        warp: function(a, b, c) {
            var d = this._mixer,
                e = d.time,
                f = this._timeScaleInterpolant,
                g = this.timeScale;
            null === f && (this._timeScaleInterpolant = f = d._lendControlInterpolant());
            d = f.parameterPositions;
            f = f.sampleValues;
            d[0] = e;
            d[1] = e + c;
            f[0] = a / g;
            f[1] = b / g;
            return this
        },
        stopWarping: function() {
            var a = this._timeScaleInterpolant;
            null !== a && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(a));
            return this
        },
        getMixer: function() {
            return this._mixer
        },
        getClip: function() {
            return this._clip
        },
        getRoot: function() {
            return this._localRoot ||
                this._mixer._root
        },
        _update: function(a, b, c, d) {
            if (this.enabled) {
                var e = this._startTime;
                if (null !== e) {
                    b = (a - e) * c;
                    if (0 > b || 0 === c) return;
                    this._startTime = null;
                    b *= c
                }
                b *= this._updateTimeScale(a);
                c = this._updateTime(b);
                a = this._updateWeight(a);
                if (0 < a) {
                    b = this._interpolants;
                    e = this._propertyBindings;
                    for (var f = 0, g = b.length; f !== g; ++f) b[f].evaluate(c), e[f].accumulate(d, a)
                }
            } else this._updateWeight(a)
        },
        _updateWeight: function(a) {
            var b = 0;
            if (this.enabled) {
                b = this.weight;
                var c = this._weightInterpolant;
                if (null !== c) {
                    var d = c.evaluate(a)[0];
                    b *= d;
                    a > c.parameterPositions[1] && (this.stopFading(), 0 === d && (this.enabled = !1))
                }
            }
            return this._effectiveWeight = b
        },
        _updateTimeScale: function(a) {
            var b = 0;
            if (!this.paused) {
                b = this.timeScale;
                var c = this._timeScaleInterpolant;
                if (null !== c) {
                    var d = c.evaluate(a)[0];
                    b *= d;
                    a > c.parameterPositions[1] && (this.stopWarping(), 0 === b ? this.paused = !0 : this.timeScale = b)
                }
            }
            return this._effectiveTimeScale = b
        },
        _updateTime: function(a) {
            var b = this.time + a,
                c = this._clip.duration,
                d = this.loop,
                e = this._loopCount,
                f = 2202 === d;
            if (0 === a) return -1 ===
                e ? b : f && 1 === (e & 1) ? c - b : b;
            if (2200 === d) a: {
                if (-1 === e && (this._loopCount = 0, this._setEndings(!0, !0, !1)), b >= c) b = c;
                else if (0 > b) b = 0;
                else break a;
                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1;
                this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: 0 > a ? -1 : 1
                })
            } else {
                -1 === e && (0 <= a ? (e = 0, this._setEndings(!0, 0 === this.repetitions, f)) : this._setEndings(0 === this.repetitions, !0, f));
                if (b >= c || 0 > b) {
                    d = Math.floor(b / c);
                    b -= c * d;
                    e += Math.abs(d);
                    var g = this.repetitions - e;
                    0 >= g ? (this.clampWhenFinished ? this.paused = !0 :
                        this.enabled = !1, b = 0 < a ? c : 0, this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: 0 < a ? 1 : -1
                        })) : (1 === g ? (a = 0 > a, this._setEndings(a, !a, f)) : this._setEndings(!1, !1, f), this._loopCount = e, this._mixer.dispatchEvent({
                        type: "loop",
                        action: this,
                        loopDelta: d
                    }))
                }
                if (f && 1 === (e & 1)) return this.time = b, c - b
            }
            return this.time = b
        },
        _setEndings: function(a, b, c) {
            var d = this._interpolantSettings;
            c ? (d.endingStart = 2401, d.endingEnd = 2401) : (d.endingStart = a ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, d.endingEnd = b ? this.zeroSlopeAtEnd ? 2401 :
                2400 : 2402)
        },
        _scheduleFading: function(a, b, c) {
            var d = this._mixer,
                e = d.time,
                f = this._weightInterpolant;
            null === f && (this._weightInterpolant = f = d._lendControlInterpolant());
            d = f.parameterPositions;
            f = f.sampleValues;
            d[0] = e;
            f[0] = b;
            d[1] = e + a;
            f[1] = c;
            return this
        }
    });
    re.prototype = Object.assign(Object.create(ya.prototype), {
        constructor: re,
        _bindAction: function(a, b) {
            var c = a._localRoot || this._root,
                d = a._clip.tracks,
                e = d.length,
                f = a._propertyBindings;
            a = a._interpolants;
            var g = c.uuid,
                h = this._bindingsByRootAndName,
                k = h[g];
            void 0 ===
                k && (k = {}, h[g] = k);
            for (h = 0; h !== e; ++h) {
                var l = d[h],
                    p = l.name,
                    n = k[p];
                if (void 0 === n) {
                    n = f[h];
                    if (void 0 !== n) {
                        null === n._cacheIndex && (++n.referenceCount, this._addInactiveBinding(n, g, p));
                        continue
                    }
                    n = new qe(pa.create(c, p, b && b._propertyBindings[h].binding.parsedPath), l.ValueTypeName, l.getValueSize());
                    ++n.referenceCount;
                    this._addInactiveBinding(n, g, p)
                }
                f[h] = n;
                a[h].resultBuffer = n.buffer
            }
        },
        _activateAction: function(a) {
            if (!this._isActiveAction(a)) {
                if (null === a._cacheIndex) {
                    var b = (a._localRoot || this._root).uuid,
                        c = a._clip.uuid,
                        d = this._actionsByClip[c];
                    this._bindAction(a, d && d.knownActions[0]);
                    this._addInactiveAction(a, c, b)
                }
                b = a._propertyBindings;
                c = 0;
                for (d = b.length; c !== d; ++c) {
                    var e = b[c];
                    0 === e.useCount++ && (this._lendBinding(e), e.saveOriginalState())
                }
                this._lendAction(a)
            }
        },
        _deactivateAction: function(a) {
            if (this._isActiveAction(a)) {
                for (var b = a._propertyBindings, c = 0, d = b.length; c !== d; ++c) {
                    var e = b[c];
                    0 === --e.useCount && (e.restoreOriginalState(), this._takeBackBinding(e))
                }
                this._takeBackAction(a)
            }
        },
        _initMemoryManager: function() {
            this._actions = [];
            this._nActiveActions = 0;
            this._actionsByClip = {};
            this._bindings = [];
            this._nActiveBindings = 0;
            this._bindingsByRootAndName = {};
            this._controlInterpolants = [];
            this._nActiveControlInterpolants = 0;
            var a = this;
            this.stats = {
                actions: {get total() {
                        return a._actions.length
                    },
                    get inUse() {
                        return a._nActiveActions
                    }
                },
                bindings: {get total() {
                        return a._bindings.length
                    },
                    get inUse() {
                        return a._nActiveBindings
                    }
                },
                controlInterpolants: {get total() {
                        return a._controlInterpolants.length
                    },
                    get inUse() {
                        return a._nActiveControlInterpolants
                    }
                }
            }
        },
        _isActiveAction: function(a) {
            a = a._cacheIndex;
            return null !== a && a < this._nActiveActions
        },
        _addInactiveAction: function(a, b, c) {
            var d = this._actions,
                e = this._actionsByClip,
                f = e[b];
            void 0 === f ? (f = {
                knownActions: [a],
                actionByRoot: {}
            }, a._byClipCacheIndex = 0, e[b] = f) : (b = f.knownActions, a._byClipCacheIndex = b.length, b.push(a));
            a._cacheIndex = d.length;
            d.push(a);
            f.actionByRoot[c] = a
        },
        _removeInactiveAction: function(a) {
            var b = this._actions,
                c = b[b.length - 1],
                d = a._cacheIndex;
            c._cacheIndex = d;
            b[d] = c;
            b.pop();
            a._cacheIndex = null;
            b = a._clip.uuid;
            c = this._actionsByClip;
            d = c[b];
            var e = d.knownActions,
                f = e[e.length - 1],
                g = a._byClipCacheIndex;
            f._byClipCacheIndex = g;
            e[g] = f;
            e.pop();
            a._byClipCacheIndex = null;
            delete d.actionByRoot[(a._localRoot || this._root).uuid];
            0 === e.length && delete c[b];
            this._removeInactiveBindingsForAction(a)
        },
        _removeInactiveBindingsForAction: function(a) {
            a = a._propertyBindings;
            for (var b = 0, c = a.length; b !== c; ++b) {
                var d = a[b];
                0 === --d.referenceCount && this._removeInactiveBinding(d)
            }
        },
        _lendAction: function(a) {
            var b = this._actions,
                c = a._cacheIndex,
                d = this._nActiveActions++,
                e = b[d];
            a._cacheIndex = d;
            b[d] = a;
            e._cacheIndex = c;
            b[c] = e
        },
        _takeBackAction: function(a) {
            var b = this._actions,
                c = a._cacheIndex,
                d = --this._nActiveActions,
                e = b[d];
            a._cacheIndex = d;
            b[d] = a;
            e._cacheIndex = c;
            b[c] = e
        },
        _addInactiveBinding: function(a, b, c) {
            var d = this._bindingsByRootAndName,
                e = d[b],
                f = this._bindings;
            void 0 === e && (e = {}, d[b] = e);
            e[c] = a;
            a._cacheIndex = f.length;
            f.push(a)
        },
        _removeInactiveBinding: function(a) {
            var b = this._bindings,
                c = a.binding,
                d = c.rootNode.uuid;
            c = c.path;
            var e = this._bindingsByRootAndName,
                f = e[d],
                g = b[b.length - 1];
            a = a._cacheIndex;
            g._cacheIndex = a;
            b[a] = g;
            b.pop();
            delete f[c];
            a: {
                for (var h in f) break a;
                delete e[d]
            }
        },
        _lendBinding: function(a) {
            var b = this._bindings,
                c = a._cacheIndex,
                d = this._nActiveBindings++,
                e = b[d];
            a._cacheIndex = d;
            b[d] = a;
            e._cacheIndex = c;
            b[c] = e
        },
        _takeBackBinding: function(a) {
            var b = this._bindings,
                c = a._cacheIndex,
                d = --this._nActiveBindings,
                e = b[d];
            a._cacheIndex = d;
            b[d] = a;
            e._cacheIndex = c;
            b[c] = e
        },
        _lendControlInterpolant: function() {
            var a = this._controlInterpolants,
                b = this._nActiveControlInterpolants++,
                c = a[b];
            void 0 === c && (c = new bd(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), c.__cacheIndex = b, a[b] = c);
            return c
        },
        _takeBackControlInterpolant: function(a) {
            var b = this._controlInterpolants,
                c = a.__cacheIndex,
                d = --this._nActiveControlInterpolants,
                e = b[d];
            a.__cacheIndex = d;
            b[d] = a;
            e.__cacheIndex = c;
            b[c] = e
        },
        _controlInterpolantsResultBuffer: new Float32Array(1),
        clipAction: function(a, b) {
            var c = b || this._root,
                d = c.uuid;
            c = "string" === typeof a ? Ca.findByName(c, a) : a;
            a = null !== c ? c.uuid : a;
            var e =
                this._actionsByClip[a],
                f = null;
            if (void 0 !== e) {
                f = e.actionByRoot[d];
                if (void 0 !== f) return f;
                f = e.knownActions[0];
                null === c && (c = f._clip)
            }
            if (null === c) return null;
            b = new rf(this, c, b);
            this._bindAction(b, f);
            this._addInactiveAction(b, a, d);
            return b
        },
        existingAction: function(a, b) {
            var c = b || this._root;
            b = c.uuid;
            c = "string" === typeof a ? Ca.findByName(c, a) : a;
            a = this._actionsByClip[c ? c.uuid : a];
            return void 0 !== a ? a.actionByRoot[b] || null : null
        },
        stopAllAction: function() {
            for (var a = this._actions, b = this._nActiveActions, c = this._bindings,
                    d = this._nActiveBindings, e = this._nActiveBindings = this._nActiveActions = 0; e !== b; ++e) a[e].reset();
            for (e = 0; e !== d; ++e) c[e].useCount = 0;
            return this
        },
        update: function(a) {
            a *= this.timeScale;
            for (var b = this._actions, c = this._nActiveActions, d = this.time += a, e = Math.sign(a), f = this._accuIndex ^= 1, g = 0; g !== c; ++g) b[g]._update(d, a, e, f);
            a = this._bindings;
            b = this._nActiveBindings;
            for (g = 0; g !== b; ++g) a[g].apply(f);
            return this
        },
        getRoot: function() {
            return this._root
        },
        uncacheClip: function(a) {
            var b = this._actions;
            a = a.uuid;
            var c = this._actionsByClip,
                d = c[a];
            if (void 0 !== d) {
                d = d.knownActions;
                for (var e = 0, f = d.length; e !== f; ++e) {
                    var g = d[e];
                    this._deactivateAction(g);
                    var h = g._cacheIndex,
                        k = b[b.length - 1];
                    g._cacheIndex = null;
                    g._byClipCacheIndex = null;
                    k._cacheIndex = h;
                    b[h] = k;
                    b.pop();
                    this._removeInactiveBindingsForAction(g)
                }
                delete c[a]
            }
        },
        uncacheRoot: function(a) {
            a = a.uuid;
            var b = this._actionsByClip;
            for (d in b) {
                var c = b[d].actionByRoot[a];
                void 0 !== c && (this._deactivateAction(c), this._removeInactiveAction(c))
            }
            var d = this._bindingsByRootAndName[a];
            if (void 0 !== d)
                for (var e in d) a =
                    d[e], a.restoreOriginalState(), this._removeInactiveBinding(a)
        },
        uncacheAction: function(a, b) {
            a = this.existingAction(a, b);
            null !== a && (this._deactivateAction(a), this._removeInactiveAction(a))
        }
    });
    Ld.prototype.clone = function() {
        return new Ld(void 0 === this.value.clone ? this.value : this.value.clone())
    };
    se.prototype = Object.assign(Object.create(C.prototype), {
        constructor: se,
        isInstancedBufferGeometry: !0,
        copy: function(a) {
            C.prototype.copy.call(this, a);
            this.maxInstancedCount = a.maxInstancedCount;
            return this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    });
    te.prototype = Object.assign(Object.create(ob.prototype), {
        constructor: te,
        isInstancedInterleavedBuffer: !0,
        copy: function(a) {
            ob.prototype.copy.call(this, a);
            this.meshPerAttribute = a.meshPerAttribute;
            return this
        }
    });
    ue.prototype = Object.assign(Object.create(Q.prototype), {
        constructor: ue,
        isInstancedBufferAttribute: !0,
        copy: function(a) {
            Q.prototype.copy.call(this, a);
            this.meshPerAttribute = a.meshPerAttribute;
            return this
        }
    });
    Object.assign(sf.prototype, {
        linePrecision: 1,
        set: function(a, b) {
            this.ray.set(a, b)
        },
        setFromCamera: function(a,
            b) {
            b && b.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(b.matrixWorld), this.ray.direction.set(a.x, a.y, .5).unproject(b).sub(this.ray.origin).normalize()) : b && b.isOrthographicCamera ? (this.ray.origin.set(a.x, a.y, (b.near + b.far) / (b.near - b.far)).unproject(b), this.ray.direction.set(0, 0, -1).transformDirection(b.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
        },
        intersectObject: function(a, b, c) {
            c = c || [];
            ve(a, this, c, b);
            c.sort(tf);
            return c
        },
        intersectObjects: function(a, b, c) {
            c = c || [];
            if (!1 === Array.isArray(a)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), c;
            for (var d = 0, e = a.length; d < e; d++) ve(a[d], this, c, b);
            c.sort(tf);
            return c
        }
    });
    Object.assign(uf.prototype, {
        start: function() {
            this.oldTime = this.startTime = ("undefined" === typeof performance ? Date : performance).now();
            this.elapsedTime = 0;
            this.running = !0
        },
        stop: function() {
            this.getElapsedTime();
            this.autoStart = this.running = !1
        },
        getElapsedTime: function() {
            this.getDelta();
            return this.elapsedTime
        },
        getDelta: function() {
            var a =
                0;
            if (this.autoStart && !this.running) return this.start(), 0;
            if (this.running) {
                var b = ("undefined" === typeof performance ? Date : performance).now();
                a = (b - this.oldTime) / 1E3;
                this.oldTime = b;
                this.elapsedTime += a
            }
            return a
        }
    });
    Object.assign(vf.prototype, {
        set: function(a, b, c) {
            this.radius = a;
            this.phi = b;
            this.theta = c;
            return this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            this.radius = a.radius;
            this.phi = a.phi;
            this.theta = a.theta;
            return this
        },
        makeSafe: function() {
            this.phi = Math.max(1E-6, Math.min(Math.PI -
                1E-6, this.phi));
            return this
        },
        setFromVector3: function(a) {
            this.radius = a.length();
            0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(a.x, a.z), this.phi = Math.acos(H.clamp(a.y / this.radius, -1, 1)));
            return this
        }
    });
    Object.assign(wf.prototype, {
        set: function(a, b, c) {
            this.radius = a;
            this.theta = b;
            this.y = c;
            return this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            this.radius = a.radius;
            this.theta = a.theta;
            this.y = a.y;
            return this
        },
        setFromVector3: function(a) {
            this.radius = Math.sqrt(a.x *
                a.x + a.z * a.z);
            this.theta = Math.atan2(a.x, a.z);
            this.y = a.y;
            return this
        }
    });
    Object.assign(we.prototype, {
        set: function(a, b) {
            this.min.copy(a);
            this.max.copy(b);
            return this
        },
        setFromPoints: function(a) {
            this.makeEmpty();
            for (var b = 0, c = a.length; b < c; b++) this.expandByPoint(a[b]);
            return this
        },
        setFromCenterAndSize: function() {
            var a = new z;
            return function(b, c) {
                c = a.copy(c).multiplyScalar(.5);
                this.min.copy(b).sub(c);
                this.max.copy(b).add(c);
                return this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            this.min.copy(a.min);
            this.max.copy(a.max);
            return this
        },
        makeEmpty: function() {
            this.min.x = this.min.y = Infinity;
            this.max.x = this.max.y = -Infinity;
            return this
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y
        },
        getCenter: function(a) {
            void 0 === a && (console.warn("THREE.Box2: .getCenter() target is now required"), a = new z);
            return this.isEmpty() ? a.set(0, 0) : a.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function(a) {
            void 0 === a && (console.warn("THREE.Box2: .getSize() target is now required"), a = new z);
            return this.isEmpty() ?
                a.set(0, 0) : a.subVectors(this.max, this.min)
        },
        expandByPoint: function(a) {
            this.min.min(a);
            this.max.max(a);
            return this
        },
        expandByVector: function(a) {
            this.min.sub(a);
            this.max.add(a);
            return this
        },
        expandByScalar: function(a) {
            this.min.addScalar(-a);
            this.max.addScalar(a);
            return this
        },
        containsPoint: function(a) {
            return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y ? !1 : !0
        },
        containsBox: function(a) {
            return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y
        },
        getParameter: function(a,
            b) {
            void 0 === b && (console.warn("THREE.Box2: .getParameter() target is now required"), b = new z);
            return b.set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y))
        },
        intersectsBox: function(a) {
            return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y ? !1 : !0
        },
        clampPoint: function(a, b) {
            void 0 === b && (console.warn("THREE.Box2: .clampPoint() target is now required"), b = new z);
            return b.copy(a).clamp(this.min, this.max)
        },
        distanceToPoint: function() {
            var a = new z;
            return function(b) {
                return a.copy(b).clamp(this.min, this.max).sub(b).length()
            }
        }(),
        intersect: function(a) {
            this.min.max(a.min);
            this.max.min(a.max);
            return this
        },
        union: function(a) {
            this.min.min(a.min);
            this.max.max(a.max);
            return this
        },
        translate: function(a) {
            this.min.add(a);
            this.max.add(a);
            return this
        },
        equals: function(a) {
            return a.min.equals(this.min) && a.max.equals(this.max)
        }
    });
    Object.assign(xe.prototype, {
        set: function(a, b) {
            this.start.copy(a);
            this.end.copy(b);
            return this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(a) {
            this.start.copy(a.start);
            this.end.copy(a.end);
            return this
        },
        getCenter: function(a) {
            void 0 === a && (console.warn("THREE.Line3: .getCenter() target is now required"), a = new p);
            return a.addVectors(this.start, this.end).multiplyScalar(.5)
        },
        delta: function(a) {
            void 0 === a && (console.warn("THREE.Line3: .delta() target is now required"), a = new p);
            return a.subVectors(this.end, this.start)
        },
        distanceSq: function() {
            return this.start.distanceToSquared(this.end)
        },
        distance: function() {
            return this.start.distanceTo(this.end)
        },
        at: function(a, b) {
            void 0 === b && (console.warn("THREE.Line3: .at() target is now required"), b = new p);
            return this.delta(b).multiplyScalar(a).add(this.start)
        },
        closestPointToPointParameter: function() {
            var a = new p,
                b = new p;
            return function(c, d) {
                a.subVectors(c, this.start);
                b.subVectors(this.end, this.start);
                c = b.dot(b);
                c = b.dot(a) / c;
                d && (c = H.clamp(c, 0, 1));
                return c
            }
        }(),
        closestPointToPoint: function(a, b, c) {
            a = this.closestPointToPointParameter(a, b);
            void 0 === c && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"),
                c = new p);
            return this.delta(c).multiplyScalar(a).add(this.start)
        },
        applyMatrix4: function(a) {
            this.start.applyMatrix4(a);
            this.end.applyMatrix4(a);
            return this
        },
        equals: function(a) {
            return a.start.equals(this.start) && a.end.equals(this.end)
        }
    });
    ed.prototype = Object.create(D.prototype);
    ed.prototype.constructor = ed;
    ed.prototype.isImmediateRenderObject = !0;
    fd.prototype = Object.create(W.prototype);
    fd.prototype.constructor = fd;
    fd.prototype.update = function() {
        var a = new p,
            b = new p,
            c = new ra;
        return function() {
            var d = ["a", "b",
                "c"
            ];
            this.object.updateMatrixWorld(!0);
            c.getNormalMatrix(this.object.matrixWorld);
            var e = this.object.matrixWorld,
                f = this.geometry.attributes.position,
                g = this.object.geometry;
            if (g && g.isGeometry)
                for (var h = g.vertices, k = g.faces, l = g = 0, p = k.length; l < p; l++)
                    for (var n = k[l], t = 0, u = n.vertexNormals.length; t < u; t++) {
                        var r = n.vertexNormals[t];
                        a.copy(h[n[d[t]]]).applyMatrix4(e);
                        b.copy(r).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a);
                        f.setXYZ(g, a.x, a.y, a.z);
                        g += 1;
                        f.setXYZ(g, b.x, b.y, b.z);
                        g += 1
                    } else if (g && g.isBufferGeometry)
                        for (d =
                            g.attributes.position, h = g.attributes.normal, t = g = 0, u = d.count; t < u; t++) a.set(d.getX(t), d.getY(t), d.getZ(t)).applyMatrix4(e), b.set(h.getX(t), h.getY(t), h.getZ(t)), b.applyMatrix3(c).normalize().multiplyScalar(this.size).add(a), f.setXYZ(g, a.x, a.y, a.z), g += 1, f.setXYZ(g, b.x, b.y, b.z), g += 1;
            f.needsUpdate = !0
        }
    }();
    ic.prototype = Object.create(D.prototype);
    ic.prototype.constructor = ic;
    ic.prototype.dispose = function() {
        this.cone.geometry.dispose();
        this.cone.material.dispose()
    };
    ic.prototype.update = function() {
        var a = new p,
            b = new p;
        return function() {
            this.light.updateMatrixWorld();
            var c = this.light.distance ? this.light.distance : 1E3,
                d = c * Math.tan(this.light.angle);
            this.cone.scale.set(d, d, c);
            a.setFromMatrixPosition(this.light.matrixWorld);
            b.setFromMatrixPosition(this.light.target.matrixWorld);
            this.cone.lookAt(b.sub(a));
            void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
        }
    }();
    jc.prototype = Object.create(W.prototype);
    jc.prototype.constructor = jc;
    jc.prototype.updateMatrixWorld =
        function() {
            var a = new p,
                b = new I,
                c = new I;
            return function(d) {
                var e = this.bones,
                    f = this.geometry,
                    g = f.getAttribute("position");
                c.getInverse(this.root.matrixWorld);
                for (var h = 0, k = 0; h < e.length; h++) {
                    var l = e[h];
                    l.parent && l.parent.isBone && (b.multiplyMatrices(c, l.matrixWorld), a.setFromMatrixPosition(b), g.setXYZ(k, a.x, a.y, a.z), b.multiplyMatrices(c, l.parent.matrixWorld), a.setFromMatrixPosition(b), g.setXYZ(k + 1, a.x, a.y, a.z), k += 2)
                }
                f.getAttribute("position").needsUpdate = !0;
                D.prototype.updateMatrixWorld.call(this, d)
            }
        }();
    kc.prototype = Object.create(la.prototype);
    kc.prototype.constructor = kc;
    kc.prototype.dispose = function() {
        this.geometry.dispose();
        this.material.dispose()
    };
    kc.prototype.update = function() {
        void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
    };
    lc.prototype = Object.create(D.prototype);
    lc.prototype.constructor = lc;
    lc.prototype.dispose = function() {
        this.children[0].geometry.dispose();
        this.children[0].material.dispose()
    };
    lc.prototype.update = function() {
        var a = .5 * this.light.width,
            b = .5 * this.light.height,
            c = this.line.geometry.attributes.position,
            d = c.array;
        d[0] = a;
        d[1] = -b;
        d[2] = 0;
        d[3] = a;
        d[4] = b;
        d[5] = 0;
        d[6] = -a;
        d[7] = b;
        d[8] = 0;
        d[9] = -a;
        d[10] = -b;
        d[11] = 0;
        d[12] = a;
        d[13] = -b;
        d[14] = 0;
        c.needsUpdate = !0;
        void 0 !== this.color ? this.line.material.color.set(this.color) : this.line.material.color.copy(this.light.color)
    };
    mc.prototype = Object.create(D.prototype);
    mc.prototype.constructor = mc;
    mc.prototype.dispose = function() {
        this.children[0].geometry.dispose();
        this.children[0].material.dispose()
    };
    mc.prototype.update =
        function() {
            var a = new p,
                b = new G,
                c = new G;
            return function() {
                var d = this.children[0];
                if (void 0 !== this.color) this.material.color.set(this.color);
                else {
                    var e = d.geometry.getAttribute("color");
                    b.copy(this.light.color);
                    c.copy(this.light.groundColor);
                    for (var f = 0, g = e.count; f < g; f++) {
                        var h = f < g / 2 ? b : c;
                        e.setXYZ(f, h.r, h.g, h.b)
                    }
                    e.needsUpdate = !0
                }
                d.lookAt(a.setFromMatrixPosition(this.light.matrixWorld).negate())
            }
        }();
    gd.prototype = Object.create(W.prototype);
    gd.prototype.constructor = gd;
    Md.prototype = Object.create(W.prototype);
    Md.prototype.constructor = Md;
    hd.prototype = Object.create(W.prototype);
    hd.prototype.constructor = hd;
    hd.prototype.update = function() {
        var a = new p,
            b = new p,
            c = new ra;
        return function() {
            this.object.updateMatrixWorld(!0);
            c.getNormalMatrix(this.object.matrixWorld);
            var d = this.object.matrixWorld,
                e = this.geometry.attributes.position,
                f = this.object.geometry,
                g = f.vertices;
            f = f.faces;
            for (var h = 0, k = 0, l = f.length; k < l; k++) {
                var p = f[k],
                    n = p.normal;
                a.copy(g[p.a]).add(g[p.b]).add(g[p.c]).divideScalar(3).applyMatrix4(d);
                b.copy(n).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a);
                e.setXYZ(h, a.x, a.y, a.z);
                h += 1;
                e.setXYZ(h, b.x, b.y, b.z);
                h += 1
            }
            e.needsUpdate = !0
        }
    }();
    nc.prototype = Object.create(D.prototype);
    nc.prototype.constructor = nc;
    nc.prototype.dispose = function() {
        this.lightPlane.geometry.dispose();
        this.lightPlane.material.dispose();
        this.targetLine.geometry.dispose();
        this.targetLine.material.dispose()
    };
    nc.prototype.update = function() {
        var a = new p,
            b = new p,
            c = new p;
        return function() {
            a.setFromMatrixPosition(this.light.matrixWorld);
            b.setFromMatrixPosition(this.light.target.matrixWorld);
            c.subVectors(b,
                a);
            this.lightPlane.lookAt(c);
            void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color));
            this.targetLine.lookAt(c);
            this.targetLine.scale.z = c.length()
        }
    }();
    id.prototype = Object.create(W.prototype);
    id.prototype.constructor = id;
    id.prototype.update = function() {
        function a(a, g, h, k) {
            d.set(g, h, k).unproject(e);
            a = c[a];
            if (void 0 !== a)
                for (g = b.getAttribute("position"),
                    h = 0, k = a.length; h < k; h++) g.setXYZ(a[h], d.x, d.y, d.z)
        }
        var b, c, d = new p,
            e = new Na;
        return function() {
            b = this.geometry;
            c = this.pointMap;
            e.projectionMatrix.copy(this.camera.projectionMatrix);
            a("c", 0, 0, -1);
            a("t", 0, 0, 1);
            a("n1", -1, -1, -1);
            a("n2", 1, -1, -1);
            a("n3", -1, 1, -1);
            a("n4", 1, 1, -1);
            a("f1", -1, -1, 1);
            a("f2", 1, -1, 1);
            a("f3", -1, 1, 1);
            a("f4", 1, 1, 1);
            a("u1", .7, 1.1, -1);
            a("u2", -.7, 1.1, -1);
            a("u3", 0, 2, -1);
            a("cf1", -1, 0, 1);
            a("cf2", 1, 0, 1);
            a("cf3", 0, -1, 1);
            a("cf4", 0, 1, 1);
            a("cn1", -1, 0, -1);
            a("cn2", 1, 0, -1);
            a("cn3", 0, -1, -1);
            a("cn4",
                0, 1, -1);
            b.getAttribute("position").needsUpdate = !0
        }
    }();
    Db.prototype = Object.create(W.prototype);
    Db.prototype.constructor = Db;
    Db.prototype.update = function() {
        var a = new Sa;
        return function(b) {
            void 0 !== b && console.warn("THREE.BoxHelper: .update() has no longer arguments.");
            void 0 !== this.object && a.setFromObject(this.object);
            if (!a.isEmpty()) {
                b = a.min;
                var c = a.max,
                    d = this.geometry.attributes.position,
                    e = d.array;
                e[0] = c.x;
                e[1] = c.y;
                e[2] = c.z;
                e[3] = b.x;
                e[4] = c.y;
                e[5] = c.z;
                e[6] = b.x;
                e[7] = b.y;
                e[8] = c.z;
                e[9] = c.x;
                e[10] = b.y;
                e[11] =
                    c.z;
                e[12] = c.x;
                e[13] = c.y;
                e[14] = b.z;
                e[15] = b.x;
                e[16] = c.y;
                e[17] = b.z;
                e[18] = b.x;
                e[19] = b.y;
                e[20] = b.z;
                e[21] = c.x;
                e[22] = b.y;
                e[23] = b.z;
                d.needsUpdate = !0;
                this.geometry.computeBoundingSphere()
            }
        }
    }();
    Db.prototype.setFromObject = function(a) {
        this.object = a;
        this.update();
        return this
    };
    jd.prototype = Object.create(W.prototype);
    jd.prototype.constructor = jd;
    jd.prototype.updateMatrixWorld = function(a) {
        var b = this.box;
        b.isEmpty() || (b.getCenter(this.position), b.getSize(this.scale), this.scale.multiplyScalar(.5), D.prototype.updateMatrixWorld.call(this,
            a))
    };
    kd.prototype = Object.create(sa.prototype);
    kd.prototype.constructor = kd;
    kd.prototype.updateMatrixWorld = function(a) {
        var b = -this.plane.constant;
        1E-8 > Math.abs(b) && (b = 1E-8);
        this.scale.set(.5 * this.size, .5 * this.size, b);
        this.children[0].material.side = 0 > b ? 1 : 0;
        this.lookAt(this.plane.normal);
        D.prototype.updateMatrixWorld.call(this, a)
    };
    var Nd, ye;
    Eb.prototype = Object.create(D.prototype);
    Eb.prototype.constructor = Eb;
    Eb.prototype.setDirection = function() {
        var a = new p,
            b;
        return function(c) {.99999 < c.y ? this.quaternion.set(0,
                0, 0, 1) : -.99999 > c.y ? this.quaternion.set(1, 0, 0, 0) : (a.set(c.z, 0, -c.x).normalize(), b = Math.acos(c.y), this.quaternion.setFromAxisAngle(a, b))
        }
    }();
    Eb.prototype.setLength = function(a, b, c) {
        void 0 === b && (b = .2 * a);
        void 0 === c && (c = .2 * b);
        this.line.scale.set(1, Math.max(0, a - b), 1);
        this.line.updateMatrix();
        this.cone.scale.set(c, b, c);
        this.cone.position.y = a;
        this.cone.updateMatrix()
    };
    Eb.prototype.setColor = function(a) {
        this.line.material.color.copy(a);
        this.cone.material.color.copy(a)
    };
    ld.prototype = Object.create(W.prototype);
    ld.prototype.constructor = ld;
    L.create = function(a, b) {
        console.log("THREE.Curve.create() has been deprecated");
        a.prototype = Object.create(L.prototype);
        a.prototype.constructor = a;
        a.prototype.getPoint = b;
        return a
    };
    Object.assign(Xa.prototype, {
        createPointsGeometry: function(a) {
            console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            a = this.getPoints(a);
            return this.createGeometry(a)
        },
        createSpacedPointsGeometry: function(a) {
            console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            a = this.getSpacedPoints(a);
            return this.createGeometry(a)
        },
        createGeometry: function(a) {
            console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            for (var b = new R, c = 0, d = a.length; c < d; c++) {
                var e = a[c];
                b.vertices.push(new p(e.x, e.y, e.z || 0))
            }
            return b
        }
    });
    Object.assign(La.prototype, {
        fromPoints: function(a) {
            console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
            this.setFromPoints(a)
        }
    });
    yf.prototype = Object.create(ca.prototype);
    zf.prototype = Object.create(ca.prototype);
    ze.prototype = Object.create(ca.prototype);
    Object.assign(ze.prototype, {
        initFromArray: function() {
            console.error("THREE.Spline: .initFromArray() has been removed.")
        },
        getControlPointsArray: function() {
            console.error("THREE.Spline: .getControlPointsArray() has been removed.")
        },
        reparametrizeByArcLength: function() {
            console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
        }
    });
    gd.prototype.setColors = function() {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
    };
    jc.prototype.update = function() {
        console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
    };
    Object.assign(gc.prototype, {
        extractUrlBase: function(a) {
            console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
            return De.extractUrlBase(a)
        }
    });
    Object.assign(we.prototype, {
        center: function(a) {
            console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
            return this.getCenter(a)
        },
        empty: function() {
            console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
            return this.isEmpty()
        },
        isIntersectionBox: function(a) {
            console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
            return this.intersectsBox(a)
        },
        size: function(a) {
            console.warn("THREE.Box2: .size() has been renamed to .getSize().");
            return this.getSize(a)
        }
    });
    Object.assign(Sa.prototype, {
        center: function(a) {
            console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
            return this.getCenter(a)
        },
        empty: function() {
            console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
            return this.isEmpty()
        },
        isIntersectionBox: function(a) {
            console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
            return this.intersectsBox(a)
        },
        isIntersectionSphere: function(a) {
            console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
            return this.intersectsSphere(a)
        },
        size: function(a) {
            console.warn("THREE.Box3: .size() has been renamed to .getSize().");
            return this.getSize(a)
        }
    });
    xe.prototype.center = function(a) {
        console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
        return this.getCenter(a)
    };
    Object.assign(H, {
        random16: function() {
            console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead.");
            return Math.random()
        },
        nearestPowerOfTwo: function(a) {
            console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().");
            return H.floorPowerOfTwo(a)
        },
        nextPowerOfTwo: function(a) {
            console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().");
            return H.ceilPowerOfTwo(a)
        }
    });
    Object.assign(ra.prototype, {
        flattenToArrayOffset: function(a,
            b) {
            console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
            return this.toArray(a, b)
        },
        multiplyVector3: function(a) {
            console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
            return a.applyMatrix3(this)
        },
        multiplyVector3Array: function() {
            console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
        },
        applyToBuffer: function(a) {
            console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.");
            return this.applyToBufferAttribute(a)
        },
        applyToVector3Array: function() {
            console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
        }
    });
    Object.assign(I.prototype, {
        extractPosition: function(a) {
            console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
            return this.copyPosition(a)
        },
        flattenToArrayOffset: function(a, b) {
            console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
            return this.toArray(a, b)
        },
        getPosition: function() {
            var a;
            return function() {
                void 0 === a && (a = new p);
                console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
                return a.setFromMatrixColumn(this, 3)
            }
        }(),
        setRotationFromQuaternion: function(a) {
            console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
            return this.makeRotationFromQuaternion(a)
        },
        multiplyToArray: function() {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
        },
        multiplyVector3: function(a) {
            console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
            return a.applyMatrix4(this)
        },
        multiplyVector4: function(a) {
            console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
            return a.applyMatrix4(this)
        },
        multiplyVector3Array: function() {
            console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
        },
        rotateAxis: function(a) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
            a.transformDirection(this)
        },
        crossVector: function(a) {
            console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
            return a.applyMatrix4(this)
        },
        translate: function() {
            console.error("THREE.Matrix4: .translate() has been removed.")
        },
        rotateX: function() {
            console.error("THREE.Matrix4: .rotateX() has been removed.")
        },
        rotateY: function() {
            console.error("THREE.Matrix4: .rotateY() has been removed.")
        },
        rotateZ: function() {
            console.error("THREE.Matrix4: .rotateZ() has been removed.")
        },
        rotateByAxis: function() {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
        },
        applyToBuffer: function(a) {
            console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.");
            return this.applyToBufferAttribute(a)
        },
        applyToVector3Array: function() {
            console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
        },
        makeFrustum: function(a, b, c, d, e, f) {
            console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
            return this.makePerspective(a, b, d, c, e, f)
        }
    });
    Ma.prototype.isIntersectionLine = function(a) {
        console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
        return this.intersectsLine(a)
    };
    fa.prototype.multiplyVector3 = function(a) {
        console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
        return a.applyQuaternion(this)
    };
    Object.assign(mb.prototype, {
        isIntersectionBox: function(a) {
            console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
            return this.intersectsBox(a)
        },
        isIntersectionPlane: function(a) {
            console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
            return this.intersectsPlane(a)
        },
        isIntersectionSphere: function(a) {
            console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
            return this.intersectsSphere(a)
        }
    });
    Object.assign(ja.prototype, {
        area: function() {
            console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
            return this.getArea()
        },
        barycoordFromPoint: function(a, b) {
            console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
            return this.getBarycoord(a, b)
        },
        midpoint: function(a) {
            console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
            return this.getMidpoint(a)
        },
        normal: function(a) {
            console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
            return this.getNormal(a)
        },
        plane: function(a) {
            console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
            return this.getPlane(a)
        }
    });
    Object.assign(ja, {
        barycoordFromPoint: function(a, b, c, d, e) {
            console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
            return ja.getBarycoord(a, b, c, d, e)
        },
        normal: function(a, b, c, d) {
            console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
            return ja.getNormal(a, b, c, d)
        }
    });
    Object.assign(db.prototype, {
        extractAllPoints: function(a) {
            console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
            return this.extractPoints(a)
        },
        extrude: function(a) {
            console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
            return new rb(this, a)
        },
        makeGeometry: function(a) {
            console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
            return new tb(this, a)
        }
    });
    Object.assign(z.prototype, {
        fromAttribute: function(a, b, c) {
            console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
            return this.fromBufferAttribute(a, b, c)
        },
        distanceToManhattan: function(a) {
            console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
            return this.manhattanDistanceTo(a)
        },
        lengthManhattan: function() {
            console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
            return this.manhattanLength()
        }
    });
    Object.assign(p.prototype, {
        setEulerFromRotationMatrix: function() {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
        },
        setEulerFromQuaternion: function() {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        },
        getPositionFromMatrix: function(a) {
            console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
            return this.setFromMatrixPosition(a)
        },
        getScaleFromMatrix: function(a) {
            console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
            return this.setFromMatrixScale(a)
        },
        getColumnFromMatrix: function(a, b) {
            console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
            return this.setFromMatrixColumn(b, a)
        },
        applyProjection: function(a) {
            console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
            return this.applyMatrix4(a)
        },
        fromAttribute: function(a, b, c) {
            console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
            return this.fromBufferAttribute(a,
                b, c)
        },
        distanceToManhattan: function(a) {
            console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
            return this.manhattanDistanceTo(a)
        },
        lengthManhattan: function() {
            console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
            return this.manhattanLength()
        }
    });
    Object.assign(V.prototype, {
        fromAttribute: function(a, b, c) {
            console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
            return this.fromBufferAttribute(a,
                b, c)
        },
        lengthManhattan: function() {
            console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
            return this.manhattanLength()
        }
    });
    Object.assign(R.prototype, {
        computeTangents: function() {
            console.error("THREE.Geometry: .computeTangents() has been removed.")
        },
        computeLineDistances: function() {
            console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
        }
    });
    Object.assign(D.prototype, {
        getChildByName: function(a) {
            console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
            return this.getObjectByName(a)
        },
        renderDepth: function() {
            console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
        },
        translate: function(a, b) {
            console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
            return this.translateOnAxis(b, a)
        },
        getWorldRotation: function() {
            console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
        }
    });
    Object.defineProperties(D.prototype, {
        eulerOrder: {
            get: function() {
                console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
                return this.rotation.order
            },
            set: function(a) {
                console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
                this.rotation.order = a
            }
        },
        useQuaternion: {
            get: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            },
            set: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            }
        }
    });
    Object.defineProperties(Bc.prototype, {
        objects: {
            get: function() {
                console.warn("THREE.LOD: .objects has been renamed to .levels.");
                return this.levels
            }
        }
    });
    Object.defineProperty(Cc.prototype, "useVertexTexture", {
        get: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        },
        set: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        }
    });
    Object.defineProperty(L.prototype, "__arcLengthDivisions", {
        get: function() {
            console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
            return this.arcLengthDivisions
        },
        set: function(a) {
            console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
            this.arcLengthDivisions = a
        }
    });
    Z.prototype.setLens = function(a, b) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
        void 0 !== b && (this.filmGauge = b);
        this.setFocalLength(a)
    };
    Object.defineProperties(X.prototype, {
        onlyShadow: {
            set: function() {
                console.warn("THREE.Light: .onlyShadow has been removed.")
            }
        },
        shadowCameraFov: {
            set: function(a) {
                console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
                this.shadow.camera.fov = a
            }
        },
        shadowCameraLeft: {
            set: function(a) {
                console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
                this.shadow.camera.left = a
            }
        },
        shadowCameraRight: {
            set: function(a) {
                console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
                this.shadow.camera.right = a
            }
        },
        shadowCameraTop: {
            set: function(a) {
                console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
                this.shadow.camera.top = a
            }
        },
        shadowCameraBottom: {
            set: function(a) {
                console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
                this.shadow.camera.bottom = a
            }
        },
        shadowCameraNear: {
            set: function(a) {
                console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
                this.shadow.camera.near = a
            }
        },
        shadowCameraFar: {
            set: function(a) {
                console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
                this.shadow.camera.far = a
            }
        },
        shadowCameraVisible: {
            set: function() {
                console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
            }
        },
        shadowBias: {
            set: function(a) {
                console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
                this.shadow.bias = a
            }
        },
        shadowDarkness: {
            set: function() {
                console.warn("THREE.Light: .shadowDarkness has been removed.")
            }
        },
        shadowMapWidth: {
            set: function(a) {
                console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
                this.shadow.mapSize.width = a
            }
        },
        shadowMapHeight: {
            set: function(a) {
                console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
                this.shadow.mapSize.height = a
            }
        }
    });
    Object.defineProperties(Q.prototype, {
        length: {
            get: function() {
                console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
                return this.array.length
            }
        },
        copyIndicesArray: function() {
            console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
        }
    });
    Object.assign(C.prototype, {
        addIndex: function(a) {
            console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
            this.setIndex(a)
        },
        addDrawCall: function(a, b, c) {
            void 0 !== c && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
            console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
            this.addGroup(a, b)
        },
        clearDrawCalls: function() {
            console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
            this.clearGroups()
        },
        computeTangents: function() {
            console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
        },
        computeOffsets: function() {
            console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
        }
    });
    Object.defineProperties(C.prototype, {
        drawcalls: {
            get: function() {
                console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
                return this.groups
            }
        },
        offsets: {
            get: function() {
                console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
                return this.groups
            }
        }
    });
    Object.assign(Oa.prototype, {
        getArrays: function() {
            console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
        },
        addShapeList: function() {
            console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
        },
        addShape: function() {
            console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
        }
    });
    Object.defineProperties(Ld.prototype, {
        dynamic: {
            set: function() {
                console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
            }
        },
        onUpdate: {
            value: function() {
                console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
                return this
            }
        }
    });
    Object.defineProperties(J.prototype, {
        wrapAround: {
            get: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            },
            set: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            }
        },
        wrapRGB: {
            get: function() {
                console.warn("THREE.Material: .wrapRGB has been removed.");
                return new G
            }
        },
        shading: {
            get: function() {
                console.error("THREE." + this.type +
                    ": .shading has been removed. Use the boolean .flatShading instead.")
            },
            set: function(a) {
                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
                this.flatShading = 1 === a
            }
        }
    });
    Object.defineProperties(Fa.prototype, {
        metal: {
            get: function() {
                console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.");
                return !1
            },
            set: function() {
                console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
            }
        }
    });
    Object.defineProperties(ta.prototype, {
        derivatives: {
            get: function() {
                console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
                return this.extensions.derivatives
            },
            set: function(a) {
                console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
                this.extensions.derivatives = a
            }
        }
    });
    Object.assign(Zd.prototype, {
        animate: function(a) {
            console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
            this.setAnimationLoop(a)
        },
        getCurrentRenderTarget: function() {
            console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
            return this.getRenderTarget()
        },
        getMaxAnisotropy: function() {
            console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
            return this.capabilities.getMaxAnisotropy()
        },
        getPrecision: function() {
            console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
            return this.capabilities.precision
        },
        resetGLState: function() {
            console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
            return this.state.reset()
        },
        supportsFloatTextures: function() {
            console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
            return this.extensions.get("OES_texture_float")
        },
        supportsHalfFloatTextures: function() {
            console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
            return this.extensions.get("OES_texture_half_float")
        },
        supportsStandardDerivatives: function() {
            console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
            return this.extensions.get("OES_standard_derivatives")
        },
        supportsCompressedTextureS3TC: function() {
            console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
            return this.extensions.get("WEBGL_compressed_texture_s3tc")
        },
        supportsCompressedTexturePVRTC: function() {
            console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
            return this.extensions.get("WEBGL_compressed_texture_pvrtc")
        },
        supportsBlendMinMax: function() {
            console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
            return this.extensions.get("EXT_blend_minmax")
        },
        supportsVertexTextures: function() {
            console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
            return this.capabilities.vertexTextures
        },
        supportsInstancedArrays: function() {
            console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
            return this.extensions.get("ANGLE_instanced_arrays")
        },
        enableScissorTest: function(a) {
            console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
            this.setScissorTest(a)
        },
        initMaterial: function() {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
        },
        addPrePlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
        },
        addPostPlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
        },
        updateShadowMap: function() {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
        },
        setFaceCulling: function() {
            console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
        }
    });
    Object.defineProperties(Zd.prototype, {
        shadowMapEnabled: {
            get: function() {
                return this.shadowMap.enabled
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
                this.shadowMap.enabled = a
            }
        },
        shadowMapType: {
            get: function() {
                return this.shadowMap.type
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
                this.shadowMap.type = a
            }
        },
        shadowMapCullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            }
        }
    });
    Object.defineProperties(Ze.prototype, {
        cullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            }
        },
        renderReverseSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            }
        },
        renderSingleSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            }
        }
    });
    Object.defineProperties(fb.prototype, {
        wrapS: {
            get: function() {
                console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
                return this.texture.wrapS
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
                this.texture.wrapS = a
            }
        },
        wrapT: {
            get: function() {
                console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
                return this.texture.wrapT
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
                this.texture.wrapT = a
            }
        },
        magFilter: {
            get: function() {
                console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
                return this.texture.magFilter
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
                this.texture.magFilter =
                    a
            }
        },
        minFilter: {
            get: function() {
                console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
                return this.texture.minFilter
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
                this.texture.minFilter = a
            }
        },
        anisotropy: {
            get: function() {
                console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
                return this.texture.anisotropy
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
                this.texture.anisotropy =
                    a
            }
        },
        offset: {
            get: function() {
                console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
                return this.texture.offset
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
                this.texture.offset = a
            }
        },
        repeat: {
            get: function() {
                console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
                return this.texture.repeat
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
                this.texture.repeat = a
            }
        },
        format: {
            get: function() {
                console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
                return this.texture.format
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
                this.texture.format = a
            }
        },
        type: {
            get: function() {
                console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
                return this.texture.type
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
                this.texture.type = a
            }
        },
        generateMipmaps: {
            get: function() {
                console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
                return this.texture.generateMipmaps
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
                this.texture.generateMipmaps = a
            }
        }
    });
    Object.defineProperties(af.prototype, {
        standing: {
            set: function() {
                console.warn("THREE.WebVRManager: .standing has been removed.")
            }
        }
    });
    hc.prototype.load = function(a) {
        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
        var b = this;
        (new le).load(a, function(a) {
            b.setBuffer(a)
        });
        return this
    };
    pe.prototype.getData = function() {
        console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
        return this.getFrequencyData()
    };
    dd.prototype.updateCubeMap = function(a, b) {
        console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
        return this.update(a, b)
    };
    eb.crossOrigin = void 0;
    eb.loadTexture = function(a, b, c, d) {
        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
        var e = new vd;
        e.setCrossOrigin(this.crossOrigin);
        a = e.load(a, c, void 0, d);
        b && (a.mapping = b);
        return a
    };
    eb.loadTextureCube = function(a, b, c, d) {
        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
        var e = new ee;
        e.setCrossOrigin(this.crossOrigin);
        a = e.load(a, c, void 0, d);
        b && (a.mapping = b);
        return a
    };
    eb.loadCompressedTexture = function() {
        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
    };
    eb.loadCompressedTextureCube = function() {
        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
    };
    l.WebGLRenderTargetCube = Gb;
    l.WebGLRenderTarget = fb;
    l.WebGLRenderer = Zd;
    l.ShaderLib = nb;
    l.UniformsLib = K;
    l.UniformsUtils =
        Aa;
    l.ShaderChunk = S;
    l.FogExp2 = Lb;
    l.Fog = Mb;
    l.Scene = qd;
    l.Sprite = Ac;
    l.LOD = Bc;
    l.SkinnedMesh = sd;
    l.Skeleton = Cc;
    l.Bone = rd;
    l.Mesh = la;
    l.LineSegments = W;
    l.LineLoop = td;
    l.Line = sa;
    l.Points = Ob;
    l.Group = Kb;
    l.VideoTexture = $d;
    l.DataTexture = gb;
    l.CompressedTexture = Pb;
    l.CubeTexture = Ua;
    l.CanvasTexture = Dc;
    l.DepthTexture = Ec;
    l.Texture = T;
    l.CompressedTextureLoader = kf;
    l.DataTextureLoader = de;
    l.CubeTextureLoader = ee;
    l.TextureLoader = vd;
    l.ObjectLoader = mf;
    l.MaterialLoader = Kd;
    l.BufferGeometryLoader = ge;
    l.DefaultLoadingManager = ka;
    l.LoadingManager =
        ce;
    l.JSONLoader = he;
    l.ImageLoader = Zc;
    l.ImageBitmapLoader = ie;
    l.FontLoader = nf;
    l.FileLoader = Ga;
    l.Loader = gc;
    l.LoaderUtils = De;
    l.Cache = Fb;
    l.AudioLoader = le;
    l.SpotLightShadow = xd;
    l.SpotLight = yd;
    l.PointLight = zd;
    l.RectAreaLight = Dd;
    l.HemisphereLight = wd;
    l.DirectionalLightShadow = Ad;
    l.DirectionalLight = Bd;
    l.AmbientLight = Cd;
    l.LightShadow = Cb;
    l.Light = X;
    l.StereoCamera = of;
    l.PerspectiveCamera = Z;
    l.OrthographicCamera = Hb;
    l.CubeCamera = dd;
    l.ArrayCamera = yc;
    l.Camera = Na;
    l.AudioListener = me;
    l.PositionalAudio = oe;
    l.AudioContext = ne;
    l.AudioAnalyser = pe;
    l.Audio = hc;
    l.VectorKeyframeTrack = fc;
    l.StringKeyframeTrack = Jd;
    l.QuaternionKeyframeTrack = cd;
    l.NumberKeyframeTrack = ec;
    l.ColorKeyframeTrack = Hd;
    l.BooleanKeyframeTrack = Gd;
    l.PropertyMixer = qe;
    l.PropertyBinding = pa;
    l.KeyframeTrack = oa;
    l.AnimationUtils = ia;
    l.AnimationObjectGroup = qf;
    l.AnimationMixer = re;
    l.AnimationClip = Ca;
    l.Uniform = Ld;
    l.InstancedBufferGeometry = se;
    l.BufferGeometry = C;
    l.Geometry = R;
    l.InterleavedBufferAttribute = zc;
    l.InstancedInterleavedBuffer = te;
    l.InterleavedBuffer = ob;
    l.InstancedBufferAttribute =
        ue;
    l.Face3 = Ta;
    l.Object3D = D;
    l.Raycaster = sf;
    l.Layers = Rd;
    l.EventDispatcher = ya;
    l.Clock = uf;
    l.QuaternionLinearInterpolant = Id;
    l.LinearInterpolant = bd;
    l.DiscreteInterpolant = Fd;
    l.CubicInterpolant = Ed;
    l.Interpolant = wa;
    l.Triangle = ja;
    l.Math = H;
    l.Spherical = vf;
    l.Cylindrical = wf;
    l.Plane = Ma;
    l.Frustum = md;
    l.Sphere = Da;
    l.Ray = mb;
    l.Matrix4 = I;
    l.Matrix3 = ra;
    l.Box3 = Sa;
    l.Box2 = we;
    l.Line3 = xe;
    l.Euler = hb;
    l.Vector4 = V;
    l.Vector3 = p;
    l.Vector2 = z;
    l.Quaternion = fa;
    l.Color = G;
    l.ImmediateRenderObject = ed;
    l.VertexNormalsHelper = fd;
    l.SpotLightHelper =
        ic;
    l.SkeletonHelper = jc;
    l.PointLightHelper = kc;
    l.RectAreaLightHelper = lc;
    l.HemisphereLightHelper = mc;
    l.GridHelper = gd;
    l.PolarGridHelper = Md;
    l.FaceNormalsHelper = hd;
    l.DirectionalLightHelper = nc;
    l.CameraHelper = id;
    l.BoxHelper = Db;
    l.Box3Helper = jd;
    l.PlaneHelper = kd;
    l.ArrowHelper = Eb;
    l.AxesHelper = ld;
    l.Shape = db;
    l.Path = La;
    l.ShapePath = je;
    l.Font = ke;
    l.CurvePath = Xa;
    l.Curve = L;
    l.ImageUtils = eb;
    l.ShapeUtils = Va;
    l.WebGLUtils = $e;
    l.WireframeGeometry = Qb;
    l.ParametricGeometry = Fc;
    l.ParametricBufferGeometry = Rb;
    l.TetrahedronGeometry =
        Hc;
    l.TetrahedronBufferGeometry = Sb;
    l.OctahedronGeometry = Ic;
    l.OctahedronBufferGeometry = pb;
    l.IcosahedronGeometry = Jc;
    l.IcosahedronBufferGeometry = Tb;
    l.DodecahedronGeometry = Kc;
    l.DodecahedronBufferGeometry = Ub;
    l.PolyhedronGeometry = Gc;
    l.PolyhedronBufferGeometry = na;
    l.TubeGeometry = Lc;
    l.TubeBufferGeometry = Vb;
    l.TorusKnotGeometry = Mc;
    l.TorusKnotBufferGeometry = Wb;
    l.TorusGeometry = Nc;
    l.TorusBufferGeometry = Xb;
    l.TextGeometry = Sc;
    l.TextBufferGeometry = Yb;
    l.SphereGeometry = Tc;
    l.SphereBufferGeometry = sb;
    l.RingGeometry = Uc;
    l.RingBufferGeometry =
        Zb;
    l.PlaneGeometry = uc;
    l.PlaneBufferGeometry = lb;
    l.LatheGeometry = Vc;
    l.LatheBufferGeometry = $b;
    l.ShapeGeometry = tb;
    l.ShapeBufferGeometry = ub;
    l.ExtrudeGeometry = rb;
    l.ExtrudeBufferGeometry = Oa;
    l.EdgesGeometry = ac;
    l.ConeGeometry = Wc;
    l.ConeBufferGeometry = Xc;
    l.CylinderGeometry = vb;
    l.CylinderBufferGeometry = Wa;
    l.CircleGeometry = Yc;
    l.CircleBufferGeometry = bc;
    l.BoxGeometry = Ib;
    l.BoxBufferGeometry = kb;
    l.ShadowMaterial = wb;
    l.SpriteMaterial = cb;
    l.RawShaderMaterial = cc;
    l.ShaderMaterial = ta;
    l.PointsMaterial = Ea;
    l.MeshPhysicalMaterial =
        xb;
    l.MeshStandardMaterial = Pa;
    l.MeshPhongMaterial = Fa;
    l.MeshToonMaterial = yb;
    l.MeshNormalMaterial = zb;
    l.MeshLambertMaterial = Ab;
    l.MeshDepthMaterial = $a;
    l.MeshDistanceMaterial = ab;
    l.MeshBasicMaterial = da;
    l.LineDashedMaterial = Bb;
    l.LineBasicMaterial = Y;
    l.Material = J;
    l.Float64BufferAttribute = tc;
    l.Float32BufferAttribute = A;
    l.Uint32BufferAttribute = jb;
    l.Int32BufferAttribute = sc;
    l.Uint16BufferAttribute = ib;
    l.Int16BufferAttribute = rc;
    l.Uint8ClampedBufferAttribute = qc;
    l.Uint8BufferAttribute = pc;
    l.Int8BufferAttribute = oc;
    l.BufferAttribute =
        Q;
    l.ArcCurve = dc;
    l.CatmullRomCurve3 = ca;
    l.CubicBezierCurve = Ha;
    l.CubicBezierCurve3 = Qa;
    l.EllipseCurve = za;
    l.LineCurve = va;
    l.LineCurve3 = Ia;
    l.QuadraticBezierCurve = Ja;
    l.QuadraticBezierCurve3 = Ra;
    l.SplineCurve = Ka;
    l.REVISION = "95";
    l.MOUSE = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2
    };
    l.CullFaceNone = 0;
    l.CullFaceBack = 1;
    l.CullFaceFront = 2;
    l.CullFaceFrontBack = 3;
    l.FrontFaceDirectionCW = 0;
    l.FrontFaceDirectionCCW = 1;
    l.BasicShadowMap = 0;
    l.PCFShadowMap = 1;
    l.PCFSoftShadowMap = 2;
    l.FrontSide = 0;
    l.BackSide = 1;
    l.DoubleSide = 2;
    l.FlatShading = 1;
    l.SmoothShading =
        2;
    l.NoColors = 0;
    l.FaceColors = 1;
    l.VertexColors = 2;
    l.NoBlending = 0;
    l.NormalBlending = 1;
    l.AdditiveBlending = 2;
    l.SubtractiveBlending = 3;
    l.MultiplyBlending = 4;
    l.CustomBlending = 5;
    l.AddEquation = 100;
    l.SubtractEquation = 101;
    l.ReverseSubtractEquation = 102;
    l.MinEquation = 103;
    l.MaxEquation = 104;
    l.ZeroFactor = 200;
    l.OneFactor = 201;
    l.SrcColorFactor = 202;
    l.OneMinusSrcColorFactor = 203;
    l.SrcAlphaFactor = 204;
    l.OneMinusSrcAlphaFactor = 205;
    l.DstAlphaFactor = 206;
    l.OneMinusDstAlphaFactor = 207;
    l.DstColorFactor = 208;
    l.OneMinusDstColorFactor =
        209;
    l.SrcAlphaSaturateFactor = 210;
    l.NeverDepth = 0;
    l.AlwaysDepth = 1;
    l.LessDepth = 2;
    l.LessEqualDepth = 3;
    l.EqualDepth = 4;
    l.GreaterEqualDepth = 5;
    l.GreaterDepth = 6;
    l.NotEqualDepth = 7;
    l.MultiplyOperation = 0;
    l.MixOperation = 1;
    l.AddOperation = 2;
    l.NoToneMapping = 0;
    l.LinearToneMapping = 1;
    l.ReinhardToneMapping = 2;
    l.Uncharted2ToneMapping = 3;
    l.CineonToneMapping = 4;
    l.UVMapping = 300;
    l.CubeReflectionMapping = 301;
    l.CubeRefractionMapping = 302;
    l.EquirectangularReflectionMapping = 303;
    l.EquirectangularRefractionMapping = 304;
    l.SphericalReflectionMapping =
        305;
    l.CubeUVReflectionMapping = 306;
    l.CubeUVRefractionMapping = 307;
    l.RepeatWrapping = 1E3;
    l.ClampToEdgeWrapping = 1001;
    l.MirroredRepeatWrapping = 1002;
    l.NearestFilter = 1003;
    l.NearestMipMapNearestFilter = 1004;
    l.NearestMipMapLinearFilter = 1005;
    l.LinearFilter = 1006;
    l.LinearMipMapNearestFilter = 1007;
    l.LinearMipMapLinearFilter = 1008;
    l.UnsignedByteType = 1009;
    l.ByteType = 1010;
    l.ShortType = 1011;
    l.UnsignedShortType = 1012;
    l.IntType = 1013;
    l.UnsignedIntType = 1014;
    l.FloatType = 1015;
    l.HalfFloatType = 1016;
    l.UnsignedShort4444Type = 1017;
    l.UnsignedShort5551Type = 1018;
    l.UnsignedShort565Type = 1019;
    l.UnsignedInt248Type = 1020;
    l.AlphaFormat = 1021;
    l.RGBFormat = 1022;
    l.RGBAFormat = 1023;
    l.LuminanceFormat = 1024;
    l.LuminanceAlphaFormat = 1025;
    l.RGBEFormat = 1023;
    l.DepthFormat = 1026;
    l.DepthStencilFormat = 1027;
    l.RGB_S3TC_DXT1_Format = 33776;
    l.RGBA_S3TC_DXT1_Format = 33777;
    l.RGBA_S3TC_DXT3_Format = 33778;
    l.RGBA_S3TC_DXT5_Format = 33779;
    l.RGB_PVRTC_4BPPV1_Format = 35840;
    l.RGB_PVRTC_2BPPV1_Format = 35841;
    l.RGBA_PVRTC_4BPPV1_Format = 35842;
    l.RGBA_PVRTC_2BPPV1_Format = 35843;
    l.RGB_ETC1_Format =
        36196;
    l.RGBA_ASTC_4x4_Format = 37808;
    l.RGBA_ASTC_5x4_Format = 37809;
    l.RGBA_ASTC_5x5_Format = 37810;
    l.RGBA_ASTC_6x5_Format = 37811;
    l.RGBA_ASTC_6x6_Format = 37812;
    l.RGBA_ASTC_8x5_Format = 37813;
    l.RGBA_ASTC_8x6_Format = 37814;
    l.RGBA_ASTC_8x8_Format = 37815;
    l.RGBA_ASTC_10x5_Format = 37816;
    l.RGBA_ASTC_10x6_Format = 37817;
    l.RGBA_ASTC_10x8_Format = 37818;
    l.RGBA_ASTC_10x10_Format = 37819;
    l.RGBA_ASTC_12x10_Format = 37820;
    l.RGBA_ASTC_12x12_Format = 37821;
    l.LoopOnce = 2200;
    l.LoopRepeat = 2201;
    l.LoopPingPong = 2202;
    l.InterpolateDiscrete = 2300;
    l.InterpolateLinear = 2301;
    l.InterpolateSmooth = 2302;
    l.ZeroCurvatureEnding = 2400;
    l.ZeroSlopeEnding = 2401;
    l.WrapAroundEnding = 2402;
    l.TrianglesDrawMode = 0;
    l.TriangleStripDrawMode = 1;
    l.TriangleFanDrawMode = 2;
    l.LinearEncoding = 3E3;
    l.sRGBEncoding = 3001;
    l.GammaEncoding = 3007;
    l.RGBEEncoding = 3002;
    l.LogLuvEncoding = 3003;
    l.RGBM7Encoding = 3004;
    l.RGBM16Encoding = 3005;
    l.RGBDEncoding = 3006;
    l.BasicDepthPacking = 3200;
    l.RGBADepthPacking = 3201;
    l.TangentSpaceNormalMap = 0;
    l.ObjectSpaceNormalMap = 1;
    l.CubeGeometry = Ib;
    l.Face4 = function(a, b,
        c, d, e, f, g) {
        console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead.");
        return new Ta(a, b, c, e, f, g)
    };
    l.LineStrip = 0;
    l.LinePieces = 1;
    l.MeshFaceMaterial = function(a) {
        console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead.");
        return a
    };
    l.MultiMaterial = function(a) {
        void 0 === a && (a = []);
        console.warn("THREE.MultiMaterial has been removed. Use an Array instead.");
        a.isMultiMaterial = !0;
        a.materials = a;
        a.clone = function() {
            return a.slice()
        };
        return a
    };
    l.PointCloud = function(a,
        b) {
        console.warn("THREE.PointCloud has been renamed to THREE.Points.");
        return new Ob(a, b)
    };
    l.Particle = function(a) {
        console.warn("THREE.Particle has been renamed to THREE.Sprite.");
        return new Ac(a)
    };
    l.ParticleSystem = function(a, b) {
        console.warn("THREE.ParticleSystem has been renamed to THREE.Points.");
        return new Ob(a, b)
    };
    l.PointCloudMaterial = function(a) {
        console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.");
        return new Ea(a)
    };
    l.ParticleBasicMaterial = function(a) {
        console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.");
        return new Ea(a)
    };
    l.ParticleSystemMaterial = function(a) {
        console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.");
        return new Ea(a)
    };
    l.Vertex = function(a, b, c) {
        console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead.");
        return new p(a, b, c)
    };
    l.DynamicBufferAttribute = function(a, b) {
        console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.");
        return (new Q(a, b)).setDynamic(!0)
    };
    l.Int8Attribute = function(a,
        b) {
        console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.");
        return new oc(a, b)
    };
    l.Uint8Attribute = function(a, b) {
        console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.");
        return new pc(a, b)
    };
    l.Uint8ClampedAttribute = function(a, b) {
        console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.");
        return new qc(a, b)
    };
    l.Int16Attribute = function(a, b) {
        console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.");
        return new rc(a, b)
    };
    l.Uint16Attribute = function(a, b) {
        console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.");
        return new ib(a, b)
    };
    l.Int32Attribute = function(a, b) {
        console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.");
        return new sc(a, b)
    };
    l.Uint32Attribute = function(a, b) {
        console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.");
        return new jb(a, b)
    };
    l.Float32Attribute =
        function(a, b) {
            console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.");
            return new A(a, b)
        };
    l.Float64Attribute = function(a, b) {
        console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.");
        return new tc(a, b)
    };
    l.ClosedSplineCurve3 = yf;
    l.SplineCurve3 = zf;
    l.Spline = ze;
    l.AxisHelper = function(a) {
        console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper.");
        return new ld(a)
    };
    l.BoundingBoxHelper = function(a, b) {
        console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.");
        return new Db(a, b)
    };
    l.EdgesHelper = function(a, b) {
        console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.");
        return new W(new ac(a.geometry), new Y({
            color: void 0 !== b ? b : 16777215
        }))
    };
    l.WireframeHelper = function(a, b) {
        console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.");
        return new W(new Qb(a.geometry), new Y({
            color: void 0 !== b ? b : 16777215
        }))
    };
    l.XHRLoader = function(a) {
        console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader.");
        return new Ga(a)
    };
    l.BinaryTextureLoader = function(a) {
        console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.");
        return new de(a)
    };
    l.GeometryUtils = {
        merge: function(a, b, c) {
            console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
            if (b.isMesh) {
                b.matrixAutoUpdate && b.updateMatrix();
                var d = b.matrix;
                b = b.geometry
            }
            a.merge(b, d, c)
        },
        center: function(a) {
            console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.");
            return a.center()
        }
    };
    l.Projector = function() {
        console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js.");
        this.projectVector = function(a, b) {
            console.warn("THREE.Projector: .projectVector() is now vector.project().");
            a.project(b)
        };
        this.unprojectVector = function(a, b) {
            console.warn("THREE.Projector: .unprojectVector() is now vector.unproject().");
            a.unproject(b)
        };
        this.pickingRay = function() {
            console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
        }
    };
    l.CanvasRenderer =
        function() {
            console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js");
            this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
            this.clear = function() {};
            this.render = function() {};
            this.setClearColor = function() {};
            this.setSize = function() {}
        };
    l.SceneUtils = {
        createMultiMaterialObject: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        },
        detach: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        },
        attach: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        }
    };
    l.LensFlare = function() {
        console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js")
    };
    Object.defineProperty(l, "__esModule", {
        value: !0
    })
});

/*! verb 2017-01-16 */
! function(a) {
    if ("object" == typeof exports && "undefined" != typeof module) module.exports = a();
    else if ("function" == typeof define && define.amd) define([], a);
    else {
        var b;
        b = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this, b.verb = a()
    }
}(function() {
    var a = {},
        b = this,
        c = (new Function("try {return this===window;}catch(e){ return false;}"), new Function("try {return this===global;}catch(e){return false;}")),
        d = new Function("try {return typeof importScripts === 'function';}catch(e){return false;}");
    if (c() && !d() && (console.log(typeof e), Worker = require("webworker-threads").Worker), c() || d()) {
        var e = b;
        if (d()) {
            var f = function(a, c) {
                var d = b;
                return a.split(".").forEach(function(a) {
                    d && (d = d[a])
                }), d ? d[c] : null
            };
            onmessage = function(a) {
                if (a.data.className && a.data.methodName) {
                    var b = f(a.data.className, a.data.methodName);
                    return b ? void postMessage({
                        result: b.apply(null, a.data.args),
                        id: a.data.id
                    }) : console.error("could not find " + a.data.className + "." + a.data.methodName)
                }
            }
        }
    }
    return function(a, b, c) {
        "use strict";

        function d(a, b) {
            function c() {}
            c.prototype = a;
            var d = new c;
            for (var e in b) d[e] = b[e];
            return b.toString !== Object.prototype.toString && (d.toString = b.toString), d
        }

        function e(a) {
            return a instanceof Array ? function() {
                return i.iter(a)
            } : "function" == typeof a.iterator ? f(a, a.iterator) : a.iterator
        }

        function f(a, b) {
            if (null == b) return null;
            null == b.__id__ && (b.__id__ = ib++);
            var c;
            return null == a.hx__closures__ ? a.hx__closures__ = {} : c = a.hx__closures__[b.__id__], null == c && (c = function() {
                return c.method.apply(c.scope, arguments)
            }, c.scope = a, c.method = b, a.hx__closures__[b.__id__] = c), c
        }
        b.geom = b.geom || {}, b.exe = b.exe || {}, b.eval = b.eval || {}, b.core = b.core || {}, b.promhx = b.promhx || {};
        var g = {},
            h = function() {
                return D.__string_rec(this, "")
            },
            i = function() {};
        g.HxOverrides = i, i.__name__ = ["HxOverrides"], i.strDate = function(a) {
            var b = a.length;
            switch (b) {
                case 8:
                    var c = a.split(":"),
                        d = new Date;
                    return d.setTime(0), d.setUTCHours(c[0]), d.setUTCMinutes(c[1]), d.setUTCSeconds(c[2]), d;
                case 10:
                    var e = a.split("-");
                    return new Date(e[0], e[1] - 1, e[2], 0, 0, 0);
                case 19:
                    var f = a.split(" "),
                        g = f[0].split("-"),
                        h = f[1].split(":");
                    return new Date(g[0], g[1] - 1, g[2], h[0], h[1], h[2]);
                default:
                    throw new C("Invalid date format : " + a)
            }
        }, i.cca = function(a, b) {
            var c = a.charCodeAt(b);
            if (c == c) return c
        }, i.substr = function(a, b, c) {
            return null != b && 0 != b && null != c && c < 0 ? "" : (null == c && (c = a.length), b < 0 ? (b = a.length + b, b < 0 && (b = 0)) : c < 0 && (c = a.length + c - b), a.substr(b, c))
        }, i.iter = function(a) {
            return {
                cur: 0,
                arr: a,
                hasNext: function() {
                    return this.cur < this.arr.length
                },
                next: function() {
                    return this.arr[this.cur++]
                }
            }
        };
        var j = function() {};
        g.Lambda = j, j.__name__ = ["Lambda"], j.fold = function(a, b, c) {
            for (var d = e(a)(); d.hasNext();) {
                var f = d.next();
                c = b(f, c)
            }
            return c
        };
        var k = function() {
            this.length = 0
        };
        g.List = k, k.__name__ = ["List"], k.prototype = {
            add: function(a) {
                var b = [a];
                null == this.h ? this.h = b : this.q[1] = b, this.q = b, this.length++
            },
            pop: function() {
                if (null == this.h) return null;
                var a = this.h[0];
                return this.h = this.h[1], null == this.h && (this.q = null), this.length--, a
            },
            isEmpty: function() {
                return null == this.h
            },
            __class__: k
        }, Math.__name__ = ["Math"];
        var l = function() {};
        g.Reflect = l, l.__name__ = ["Reflect"], l.field = function(a, b) {
            try {
                return a[b]
            } catch (c) {
                return c instanceof C && (c = c.val), null
            }
        }, l.callMethod = function(a, b, c) {
            return b.apply(a, c)
        }, l.fields = function(a) {
            var b = [];
            if (null != a) {
                var c = Object.prototype.hasOwnProperty;
                for (var d in a) "__id__" != d && "hx__closures__" != d && c.call(a, d) && b.push(d)
            }
            return b
        }, l.isFunction = function(a) {
            return "function" == typeof a && !(a.__name__ || a.__ename__)
        }, l.deleteField = function(a, b) {
            return !!Object.prototype.hasOwnProperty.call(a, b) && (delete a[b], !0)
        };
        var m = function() {};
        g.Std = m, m.__name__ = ["Std"], m.string = function(a) {
            return D.__string_rec(a, "")
        }, m.parseFloat = function(a) {
            return parseFloat(a)
        };
        var n = function() {
            this.b = ""
        };
        g.StringBuf = n, n.__name__ = ["StringBuf"], n.prototype = {
            add: function(a) {
                this.b += m.string(a)
            },
            __class__: n
        };
        var o = function() {};
        g.StringTools = o, o.__name__ = ["StringTools"], o.fastCodeAt = function(a, b) {
            return a.charCodeAt(b)
        };
        var p = g.ValueType = {
            __ename__: ["ValueType"],
            __constructs__: ["TNull", "TInt", "TFloat", "TBool", "TObject", "TFunction", "TClass", "TEnum", "TUnknown"]
        };
        p.TNull = ["TNull", 0], p.TNull.toString = h, p.TNull.__enum__ = p, p.TInt = ["TInt", 1], p.TInt.toString = h, p.TInt.__enum__ = p, p.TFloat = ["TFloat", 2], p.TFloat.toString = h, p.TFloat.__enum__ = p, p.TBool = ["TBool", 3], p.TBool.toString = h, p.TBool.__enum__ = p, p.TObject = ["TObject", 4], p.TObject.toString = h, p.TObject.__enum__ = p, p.TFunction = ["TFunction", 5], p.TFunction.toString = h, p.TFunction.__enum__ = p, p.TClass = function(a) {
            var b = ["TClass", 6, a];
            return b.__enum__ = p, b.toString = h, b
        }, p.TEnum = function(a) {
            var b = ["TEnum", 7, a];
            return b.__enum__ = p, b.toString = h, b
        }, p.TUnknown = ["TUnknown", 8], p.TUnknown.toString = h, p.TUnknown.__enum__ = p;
        var q = function() {};
        g.Type = q, q.__name__ = ["Type"], q.getClassName = function(a) {
            var b = a.__name__;
            return null == b ? null : b.join(".")
        }, q.getEnumName = function(a) {
            var b = a.__ename__;
            return b.join(".")
        }, q.resolveClass = function(a) {
            var b = g[a];
            return null != b && b.__name__ ? b : null
        }, q.resolveEnum = function(a) {
            var b = g[a];
            return null != b && b.__ename__ ? b : null
        }, q.createEmptyInstance = function(a) {
            function b() {}
            return b.prototype = a.prototype, new b
        }, q.createEnum = function(a, b, c) {
            var d = l.field(a, b);
            if (null == d) throw new C("No such constructor " + b);
            if (l.isFunction(d)) {
                if (null == c) throw new C("Constructor " + b + " need parameters");
                return l.callMethod(a, d, c)
            }
            if (null != c && 0 != c.length) throw new C("Constructor " + b + " does not need parameters");
            return d
        }, q.getEnumConstructs = function(a) {
            var b = a.__constructs__;
            return b.slice()
        }, q.typeof = function(a) {
            var b = typeof a;
            switch (b) {
                case "boolean":
                    return p.TBool;
                case "string":
                    return p.TClass(String);
                case "number":
                    return Math.ceil(a) == a % 2147483648 ? p.TInt : p.TFloat;
                case "object":
                    if (null == a) return p.TNull;
                    var c = a.__enum__;
                    if (null != c) return p.TEnum(c);
                    var d = D.getClass(a);
                    return null != d ? p.TClass(d) : p.TObject;
                case "function":
                    return a.__name__ || a.__ename__ ? p.TObject : p.TFunction;
                case "undefined":
                    return p.TNull;
                default:
                    return p.TUnknown
            }
        };
        var r = function() {};
        g["haxe.IMap"] = r, r.__name__ = ["haxe", "IMap"];
        var s = function(a, b) {
            this.high = a, this.low = b
        };
        g["haxe._Int64.___Int64"] = s, s.__name__ = ["haxe", "_Int64", "___Int64"], s.prototype = {
            __class__: s
        };
        var t = function() {
            this.buf = new n, this.cache = [], this.useCache = t.USE_CACHE, this.useEnumIndex = t.USE_ENUM_INDEX, this.shash = new y, this.scount = 0
        };
        g["haxe.Serializer"] = t, t.__name__ = ["haxe", "Serializer"], t.prototype = {
            toString: function() {
                return this.buf.b
            },
            serializeString: function(a) {
                var b = this.shash.get(a);
                return null != b ? (this.buf.b += "R", void(null == b ? this.buf.b += "null" : this.buf.b += "" + b)) : (this.shash.set(a, this.scount++), this.buf.b += "y", a = encodeURIComponent(a), null == a.length ? this.buf.b += "null" : this.buf.b += "" + a.length, this.buf.b += ":", void(null == a ? this.buf.b += "null" : this.buf.b += "" + a))
            },
            serializeRef: function(a) {
                for (var b = typeof a, c = 0, d = this.cache.length; c < d;) {
                    var e = c++,
                        f = this.cache[e];
                    if (typeof f == b && f == a) return this.buf.b += "r", null == e ? this.buf.b += "null" : this.buf.b += "" + e, !0
                }
                return this.cache.push(a), !1
            },
            serializeFields: function(a) {
                for (var b = 0, c = l.fields(a); b < c.length;) {
                    var d = c[b];
                    ++b, this.serializeString(d), this.serialize(l.field(a, d))
                }
                this.buf.b += "g"
            },
            serialize: function(a) {
                var b = q.typeof(a);
                switch (b[1]) {
                    case 0:
                        this.buf.b += "n";
                        break;
                    case 1:
                        var c = a;
                        if (0 == c) return void(this.buf.b += "z");
                        this.buf.b += "i", null == c ? this.buf.b += "null" : this.buf.b += "" + c;
                        break;
                    case 2:
                        var d = a;
                        isNaN(d) ? this.buf.b += "k" : isFinite(d) ? (this.buf.b += "d", null == d ? this.buf.b += "null" : this.buf.b += "" + d) : d < 0 ? this.buf.b += "m" : this.buf.b += "p";
                        break;
                    case 3:
                        a ? this.buf.b += "t" : this.buf.b += "f";
                        break;
                    case 6:
                        var e = b[2];
                        if (e == String) return void this.serializeString(a);
                        if (this.useCache && this.serializeRef(a)) return;
                        switch (e) {
                            case Array:
                                var f = 0;
                                this.buf.b += "a";
                                for (var g = a.length, h = 0; h < g;) {
                                    var i = h++;
                                    null == a[i] ? f++ : (f > 0 && (1 == f ? this.buf.b += "n" : (this.buf.b += "u", null == f ? this.buf.b += "null" : this.buf.b += "" + f), f = 0), this.serialize(a[i]))
                                }
                                f > 0 && (1 == f ? this.buf.b += "n" : (this.buf.b += "u", null == f ? this.buf.b += "null" : this.buf.b += "" + f)), this.buf.b += "h";
                                break;
                            case k:
                                this.buf.b += "l";
                                for (var j = a, o = j.h, p = null; null != o;) {
                                    var r;
                                    p = o[0], o = o[1], r = p, this.serialize(r)
                                }
                                this.buf.b += "h";
                                break;
                            case Date:
                                var s = a;
                                this.buf.b += "v", this.buf.add(s.getTime());
                                break;
                            case y:
                                this.buf.b += "b";
                                for (var u = a, x = u.keys(); x.hasNext();) {
                                    var A = x.next();
                                    this.serializeString(A), this.serialize(null != pb[A] ? u.getReserved(A) : u.h[A])
                                }
                                this.buf.b += "h";
                                break;
                            case v:
                                this.buf.b += "q";
                                for (var B = a, E = B.keys(); E.hasNext();) {
                                    var F = E.next();
                                    this.buf.b += ":", null == F ? this.buf.b += "null" : this.buf.b += "" + F, this.serialize(B.h[F])
                                }
                                this.buf.b += "h";
                                break;
                            case w:
                                this.buf.b += "M";
                                for (var G = a, H = G.keys(); H.hasNext();) {
                                    var I = H.next(),
                                        J = l.field(I, "__id__");
                                    l.deleteField(I, "__id__"), this.serialize(I), I.__id__ = J, this.serialize(G.h[I.__id__])
                                }
                                this.buf.b += "h";
                                break;
                            case z:
                                for (var K = a, L = 0, M = K.length - 2, N = new n, O = t.BASE64; L < M;) {
                                    var P = K.get(L++),
                                        Q = K.get(L++),
                                        R = K.get(L++);
                                    N.add(O.charAt(P >> 2)), N.add(O.charAt(63 & (P << 4 | Q >> 4))), N.add(O.charAt(63 & (Q << 2 | R >> 6))), N.add(O.charAt(63 & R))
                                }
                                if (L == M) {
                                    var S = K.get(L++),
                                        T = K.get(L++);
                                    N.add(O.charAt(S >> 2)), N.add(O.charAt(63 & (S << 4 | T >> 4))), N.add(O.charAt(T << 2 & 63))
                                } else if (L == M + 1) {
                                    var U = K.get(L++);
                                    N.add(O.charAt(U >> 2)), N.add(O.charAt(U << 4 & 63))
                                }
                                var V = N.b;
                                this.buf.b += "s", null == V.length ? this.buf.b += "null" : this.buf.b += "" + V.length, this.buf.b += ":", null == V ? this.buf.b += "null" : this.buf.b += "" + V;
                                break;
                            default:
                                this.useCache && this.cache.pop(), null != a.hxSerialize ? (this.buf.b += "C", this.serializeString(q.getClassName(e)), this.useCache && this.cache.push(a), a.hxSerialize(this), this.buf.b += "g") : (this.buf.b += "c", this.serializeString(q.getClassName(e)), this.useCache && this.cache.push(a), this.serializeFields(a))
                        }
                        break;
                    case 4:
                        if (D.__instanceof(a, nb)) {
                            var W = q.getClassName(a);
                            this.buf.b += "A", this.serializeString(W)
                        } else if (D.__instanceof(a, ob)) this.buf.b += "B", this.serializeString(q.getEnumName(a));
                        else {
                            if (this.useCache && this.serializeRef(a)) return;
                            this.buf.b += "o", this.serializeFields(a)
                        }
                        break;
                    case 7:
                        var X = b[2];
                        if (this.useCache) {
                            if (this.serializeRef(a)) return;
                            this.cache.pop()
                        }
                        this.useEnumIndex ? this.buf.b += "j" : this.buf.b += "w", this.serializeString(q.getEnumName(X)), this.useEnumIndex ? (this.buf.b += ":", this.buf.b += m.string(a[1])) : this.serializeString(a[0]), this.buf.b += ":";
                        var Y = a.length;
                        this.buf.b += m.string(Y - 2);
                        for (var Z = 2; Z < Y;) {
                            var $ = Z++;
                            this.serialize(a[$])
                        }
                        this.useCache && this.cache.push(a);
                        break;
                    case 5:
                        throw new C("Cannot serialize function");
                    default:
                        throw new C("Cannot serialize " + m.string(a))
                }
            },
            __class__: t
        };
        var u = function(a) {
            this.buf = a, this.length = a.length, this.pos = 0, this.scache = [], this.cache = [];
            var b = u.DEFAULT_RESOLVER;
            null == b && (b = q, u.DEFAULT_RESOLVER = b), this.setResolver(b)
        };
        g["haxe.Unserializer"] = u, u.__name__ = ["haxe", "Unserializer"], u.initCodes = function() {
            for (var a = [], b = 0, c = u.BASE64.length; b < c;) {
                var d = b++;
                a[u.BASE64.charCodeAt(d)] = d
            }
            return a
        }, u.prototype = {
            setResolver: function(a) {
                null == a ? this.resolver = {
                    resolveClass: function(a) {
                        return null
                    },
                    resolveEnum: function(a) {
                        return null
                    }
                } : this.resolver = a
            },
            get: function(a) {
                return this.buf.charCodeAt(a)
            },
            readDigits: function() {
                for (var a = 0, b = !1, c = this.pos;;) {
                    var d = this.buf.charCodeAt(this.pos);
                    if (d != d) break;
                    if (45 != d) {
                        if (d < 48 || d > 57) break;
                        a = 10 * a + (d - 48), this.pos++
                    } else {
                        if (this.pos != c) break;
                        b = !0, this.pos++
                    }
                }
                return b && (a *= -1), a
            },
            readFloat: function() {
                for (var a = this.pos;;) {
                    var b = this.buf.charCodeAt(this.pos);
                    if (!(b >= 43 && b < 58 || 101 == b || 69 == b)) break;
                    this.pos++
                }
                return m.parseFloat(i.substr(this.buf, a, this.pos - a))
            },
            unserializeObject: function(a) {
                for (;;) {
                    if (this.pos >= this.length) throw new C("Invalid object");
                    if (103 == this.buf.charCodeAt(this.pos)) break;
                    var b = this.unserialize();
                    if ("string" != typeof b) throw new C("Invalid object key");
                    var c = this.unserialize();
                    a[b] = c
                }
                this.pos++
            },
            unserializeEnum: function(a, b) {
                if (58 != this.get(this.pos++)) throw new C("Invalid enum format");
                var c = this.readDigits();
                if (0 == c) return q.createEnum(a, b);
                for (var d = []; c-- > 0;) d.push(this.unserialize());
                return q.createEnum(a, b, d)
            },
            unserialize: function() {
                var a = this.get(this.pos++);
                switch (a) {
                    case 110:
                        return null;
                    case 116:
                        return !0;
                    case 102:
                        return !1;
                    case 122:
                        return 0;
                    case 105:
                        return this.readDigits();
                    case 100:
                        return this.readFloat();
                    case 121:
                        var b = this.readDigits();
                        if (58 != this.get(this.pos++) || this.length - this.pos < b) throw new C("Invalid string length");
                        var c = i.substr(this.buf, this.pos, b);
                        return this.pos += b, c = decodeURIComponent(c.split("+").join(" ")), this.scache.push(c), c;
                    case 107:
                        return NaN;
                    case 109:
                        return -(1 / 0);
                    case 112:
                        return 1 / 0;
                    case 97:
                        var d = (this.buf, []);
                        for (this.cache.push(d);;) {
                            var e = this.buf.charCodeAt(this.pos);
                            if (104 == e) {
                                this.pos++;
                                break
                            }
                            if (117 == e) {
                                this.pos++;
                                var f = this.readDigits();
                                d[d.length + f - 1] = null
                            } else d.push(this.unserialize())
                        }
                        return d;
                    case 111:
                        var g = {};
                        return this.cache.push(g), this.unserializeObject(g), g;
                    case 114:
                        var h = this.readDigits();
                        if (h < 0 || h >= this.cache.length) throw new C("Invalid reference");
                        return this.cache[h];
                    case 82:
                        var j = this.readDigits();
                        if (j < 0 || j >= this.scache.length) throw new C("Invalid string reference");
                        return this.scache[j];
                    case 120:
                        throw new C(this.unserialize());
                    case 99:
                        var l = this.unserialize(),
                            m = this.resolver.resolveClass(l);
                        if (null == m) throw new C("Class not found " + l);
                        var n = q.createEmptyInstance(m);
                        return this.cache.push(n), this.unserializeObject(n), n;
                    case 119:
                        var p = this.unserialize(),
                            r = this.resolver.resolveEnum(p);
                        if (null == r) throw new C("Enum not found " + p);
                        var s = this.unserializeEnum(r, this.unserialize());
                        return this.cache.push(s), s;
                    case 106:
                        var t = this.unserialize(),
                            x = this.resolver.resolveEnum(t);
                        if (null == x) throw new C("Enum not found " + t);
                        this.pos++;
                        var A = this.readDigits(),
                            B = q.getEnumConstructs(x)[A];
                        if (null == B) throw new C("Unknown enum index " + t + "@" + A);
                        var D = this.unserializeEnum(x, B);
                        return this.cache.push(D), D;
                    case 108:
                        var E = new k;
                        this.cache.push(E);
                        for (this.buf; 104 != this.buf.charCodeAt(this.pos);) E.add(this.unserialize());
                        return this.pos++, E;
                    case 98:
                        var F = new y;
                        this.cache.push(F);
                        for (this.buf; 104 != this.buf.charCodeAt(this.pos);) {
                            var G = this.unserialize();
                            F.set(G, this.unserialize())
                        }
                        return this.pos++, F;
                    case 113:
                        var H = new v;
                        this.cache.push(H);
                        for (var I = (this.buf, this.get(this.pos++)); 58 == I;) {
                            var J = this.readDigits();
                            H.set(J, this.unserialize()), I = this.get(this.pos++)
                        }
                        if (104 != I) throw new C("Invalid IntMap format");
                        return H;
                    case 77:
                        var K = new w;
                        this.cache.push(K);
                        for (this.buf; 104 != this.buf.charCodeAt(this.pos);) {
                            var L = this.unserialize();
                            K.set(L, this.unserialize())
                        }
                        return this.pos++, K;
                    case 118:
                        var M;
                        if (this.buf.charCodeAt(this.pos) >= 48 && this.buf.charCodeAt(this.pos) <= 57 && this.buf.charCodeAt(this.pos + 1) >= 48 && this.buf.charCodeAt(this.pos + 1) <= 57 && this.buf.charCodeAt(this.pos + 2) >= 48 && this.buf.charCodeAt(this.pos + 2) <= 57 && this.buf.charCodeAt(this.pos + 3) >= 48 && this.buf.charCodeAt(this.pos + 3) <= 57 && 45 == this.buf.charCodeAt(this.pos + 4)) {
                            var N = i.substr(this.buf, this.pos, 19);
                            M = i.strDate(N), this.pos += 19
                        } else {
                            var O = this.readFloat(),
                                P = new Date;
                            P.setTime(O), M = P
                        }
                        return this.cache.push(M), M;
                    case 115:
                        var Q = this.readDigits(),
                            R = this.buf;
                        if (58 != this.get(this.pos++) || this.length - this.pos < Q) throw new C("Invalid bytes length");
                        var S = u.CODES;
                        null == S && (S = u.initCodes(), u.CODES = S);
                        var T, U = this.pos,
                            V = 3 & Q;
                        T = 3 * (Q >> 2) + (V >= 2 ? V - 1 : 0);
                        for (var W = U + (Q - V), X = z.alloc(T), Y = 0; U < W;) {
                            var Z = S[o.fastCodeAt(R, U++)],
                                $ = S[o.fastCodeAt(R, U++)];
                            X.set(Y++, Z << 2 | $ >> 4);
                            var _ = S[o.fastCodeAt(R, U++)];
                            X.set(Y++, $ << 4 | _ >> 2);
                            var aa = S[o.fastCodeAt(R, U++)];
                            X.set(Y++, _ << 6 | aa)
                        }
                        if (V >= 2) {
                            var ba = S[o.fastCodeAt(R, U++)],
                                ca = S[o.fastCodeAt(R, U++)];
                            if (X.set(Y++, ba << 2 | ca >> 4), 3 == V) {
                                var da = S[o.fastCodeAt(R, U++)];
                                X.set(Y++, ca << 4 | da >> 2)
                            }
                        }
                        return this.pos += Q, this.cache.push(X), X;
                    case 67:
                        var ea = this.unserialize(),
                            fa = this.resolver.resolveClass(ea);
                        if (null == fa) throw new C("Class not found " + ea);
                        var ga = q.createEmptyInstance(fa);
                        if (this.cache.push(ga), ga.hxUnserialize(this), 103 != this.get(this.pos++)) throw new C("Invalid custom data");
                        return ga;
                    case 65:
                        var ha = this.unserialize(),
                            ia = this.resolver.resolveClass(ha);
                        if (null == ia) throw new C("Class not found " + ha);
                        return ia;
                    case 66:
                        var ja = this.unserialize(),
                            ka = this.resolver.resolveEnum(ja);
                        if (null == ka) throw new C("Enum not found " + ja);
                        return ka
                }
                throw this.pos--, new C("Invalid char " + this.buf.charAt(this.pos) + " at position " + this.pos)
            },
            __class__: u
        };
        var v = function() {
            this.h = {}
        };
        g["haxe.ds.IntMap"] = v, v.__name__ = ["haxe", "ds", "IntMap"], v.__interfaces__ = [r], v.prototype = {
            set: function(a, b) {
                this.h[a] = b
            },
            remove: function(a) {
                return !!this.h.hasOwnProperty(a) && (delete this.h[a], !0)
            },
            keys: function() {
                var a = [];
                for (var b in this.h) this.h.hasOwnProperty(b) && a.push(0 | b);
                return i.iter(a)
            },
            __class__: v
        };
        var w = function() {
            this.h = {}, this.h.__keys__ = {}
        };
        g["haxe.ds.ObjectMap"] = w, w.__name__ = ["haxe", "ds", "ObjectMap"], w.__interfaces__ = [r], w.prototype = {
            set: function(a, b) {
                var c = a.__id__ || (a.__id__ = ++w.count);
                this.h[c] = b, this.h.__keys__[c] = a
            },
            keys: function() {
                var a = [];
                for (var b in this.h.__keys__) this.h.hasOwnProperty(b) && a.push(this.h.__keys__[b]);
                return i.iter(a)
            },
            __class__: w
        };
        var x = g["haxe.ds.Option"] = {
            __ename__: ["haxe", "ds", "Option"],
            __constructs__: ["Some", "None"]
        };
        x.Some = function(a) {
            var b = ["Some", 0, a];
            return b.__enum__ = x, b.toString = h, b
        }, x.None = ["None", 1], x.None.toString = h, x.None.__enum__ = x;
        var y = function() {
            this.h = {}
        };
        g["haxe.ds.StringMap"] = y, y.__name__ = ["haxe", "ds", "StringMap"], y.__interfaces__ = [r], y.prototype = {
            set: function(a, b) {
                null != pb[a] ? this.setReserved(a, b) : this.h[a] = b
            },
            get: function(a) {
                return null != pb[a] ? this.getReserved(a) : this.h[a]
            },
            setReserved: function(a, b) {
                null == this.rh && (this.rh = {}), this.rh["$" + a] = b
            },
            getReserved: function(a) {
                return null == this.rh ? null : this.rh["$" + a]
            },
            keys: function() {
                var a = this.arrayKeys();
                return i.iter(a)
            },
            arrayKeys: function() {
                var a = [];
                for (var b in this.h) this.h.hasOwnProperty(b) && a.push(b);
                if (null != this.rh)
                    for (var b in this.rh) 36 == b.charCodeAt(0) && a.push(b.substr(1));
                return a
            },
            __class__: y
        };
        var z = function(a) {
            this.length = a.byteLength, this.b = new rb(a), this.b.bufferValue = a, a.hxBytes = this, a.bytes = this.b
        };
        g["haxe.io.Bytes"] = z, z.__name__ = ["haxe", "io", "Bytes"], z.alloc = function(a) {
            return new z(new qb(a))
        }, z.prototype = {
            get: function(a) {
                return this.b[a]
            },
            set: function(a, b) {
                this.b[a] = 255 & b
            },
            __class__: z
        };
        var A = g["haxe.io.Error"] = {
            __ename__: ["haxe", "io", "Error"],
            __constructs__: ["Blocked", "Overflow", "OutsideBounds", "Custom"]
        };
        A.Blocked = ["Blocked", 0], A.Blocked.toString = h, A.Blocked.__enum__ = A, A.Overflow = ["Overflow", 1], A.Overflow.toString = h, A.Overflow.__enum__ = A, A.OutsideBounds = ["OutsideBounds", 2], A.OutsideBounds.toString = h, A.OutsideBounds.__enum__ = A, A.Custom = function(a) {
            var b = ["Custom", 3, a];
            return b.__enum__ = A, b.toString = h, b
        };
        var B = function() {};
        g["haxe.io.FPHelper"] = B, B.__name__ = ["haxe", "io", "FPHelper"], B.i32ToFloat = function(a) {
            var b = 1 - (a >>> 31 << 1),
                c = a >>> 23 & 255,
                d = 8388607 & a;
            return 0 == d && 0 == c ? 0 : b * (1 + Math.pow(2, -23) * d) * Math.pow(2, c - 127)
        }, B.floatToI32 = function(a) {
            if (0 == a) return 0;
            var b;
            b = a < 0 ? -a : a;
            var c = Math.floor(Math.log(b) / .6931471805599453);
            c < -127 ? c = -127 : c > 128 && (c = 128);
            var d = 8388607 & Math.round(8388608 * (b / Math.pow(2, c) - 1));
            return (a < 0 ? -2147483648 : 0) | c + 127 << 23 | d
        }, B.i64ToDouble = function(a, b) {
            var c = 1 - (b >>> 31 << 1),
                d = (b >> 20 & 2047) - 1023,
                e = 4294967296 * (1048575 & b) + 2147483648 * (a >>> 31) + (2147483647 & a);
            return 0 == e && d == -1023 ? 0 : c * (1 + Math.pow(2, -52) * e) * Math.pow(2, d)
        }, B.doubleToI64 = function(a) {
            var b = B.i64tmp;
            if (0 == a) b.low = 0, b.high = 0;
            else {
                var c;
                c = a < 0 ? -a : a;
                var d, e = Math.floor(Math.log(c) / .6931471805599453),
                    f = 4503599627370496 * (c / Math.pow(2, e) - 1);
                d = Math.round(f);
                var g = 0 | d,
                    h = d / 4294967296 | 0;
                b.low = g, b.high = (a < 0 ? -2147483648 : 0) | e + 1023 << 20 | h
            }
            return b
        };
        var C = function(a) {
            Error.call(this), this.val = a, this.message = String(a), Error.captureStackTrace && Error.captureStackTrace(this, C)
        };
        g["js._Boot.HaxeError"] = C, C.__name__ = ["js", "_Boot", "HaxeError"], C.__super__ = Error, C.prototype = d(Error.prototype, {
            __class__: C
        });
        var D = function() {};
        g["js.Boot"] = D, D.__name__ = ["js", "Boot"], D.getClass = function(a) {
            if (a instanceof Array && null == a.__enum__) return Array;
            var b = a.__class__;
            if (null != b) return b;
            var c = D.__nativeClassName(a);
            return null != c ? D.__resolveNativeClass(c) : null
        }, D.__string_rec = function(a, b) {
            if (null == a) return "null";
            if (b.length >= 5) return "<...>";
            var c = typeof a;
            switch ("function" == c && (a.__name__ || a.__ename__) && (c = "object"), c) {
                case "object":
                    if (a instanceof Array) {
                        if (a.__enum__) {
                            if (2 == a.length) return a[0];
                            var d = a[0] + "(";
                            b += "\t";
                            for (var e = 2, f = a.length; e < f;) {
                                var g = e++;
                                d += 2 != g ? "," + D.__string_rec(a[g], b) : D.__string_rec(a[g], b)
                            }
                            return d + ")"
                        }
                        var h = a.length,
                            i = "[";
                        b += "\t";
                        for (var j = 0; j < h;) {
                            var k = j++;
                            i += (k > 0 ? "," : "") + D.__string_rec(a[k], b)
                        }
                        return i += "]"
                    }
                    var l;
                    try {
                        l = a.toString
                    } catch (m) {
                        return m instanceof C && (m = m.val), "???"
                    }
                    if (null != l && l != Object.toString && "function" == typeof l) {
                        var n = a.toString();
                        if ("[object Object]" != n) return n
                    }
                    var o = null,
                        p = "{\n";
                    b += "\t";
                    var q = null != a.hasOwnProperty;
                    for (var o in a) q && !a.hasOwnProperty(o) || "prototype" != o && "__class__" != o && "__super__" != o && "__interfaces__" != o && "__properties__" != o && (2 != p.length && (p += ", \n"), p += b + o + " : " + D.__string_rec(a[o], b));
                    return b = b.substring(1), p += "\n" + b + "}";
                case "function":
                    return "<function>";
                case "string":
                    return a;
                default:
                    return String(a)
            }
        }, D.__interfLoop = function(a, b) {
            if (null == a) return !1;
            if (a == b) return !0;
            var c = a.__interfaces__;
            if (null != c)
                for (var d = 0, e = c.length; d < e;) {
                    var f = d++,
                        g = c[f];
                    if (g == b || D.__interfLoop(g, b)) return !0
                }
            return D.__interfLoop(a.__super__, b)
        }, D.__instanceof = function(a, b) {
            if (null == b) return !1;
            switch (b) {
                case jb:
                    return (0 | a) === a;
                case lb:
                    return "number" == typeof a;
                case mb:
                    return "boolean" == typeof a;
                case String:
                    return "string" == typeof a;
                case Array:
                    return a instanceof Array && null == a.__enum__;
                case kb:
                    return !0;
                default:
                    if (null == a) return !1;
                    if ("function" == typeof b) {
                        if (a instanceof b) return !0;
                        if (D.__interfLoop(D.getClass(a), b)) return !0
                    } else if ("object" == typeof b && D.__isNativeObj(b) && a instanceof b) return !0;
                    return b == nb && null != a.__name__ || (b == ob && null != a.__ename__ || a.__enum__ == b)
            }
        }, D.__nativeClassName = function(a) {
            var b = D.__toStr.call(a).slice(8, -1);
            return "Object" == b || "Function" == b || "Math" == b || "JSON" == b ? null : b
        }, D.__isNativeObj = function(a) {
            return null != D.__nativeClassName(a)
        }, D.__resolveNativeClass = function(a) {
            return c[a]
        };
        var E = function(a) {
            if (a instanceof Array && null == a.__enum__) this.a = a, this.byteLength = a.length;
            else {
                var b = a;
                this.a = [];
                for (var c = 0; c < b;) {
                    var d = c++;
                    this.a[d] = 0
                }
                this.byteLength = b
            }
        };
        g["js.html.compat.ArrayBuffer"] = E, E.__name__ = ["js", "html", "compat", "ArrayBuffer"], E.sliceImpl = function(a, b) {
            var c = new rb(this, a, null == b ? null : b - a),
                d = new qb(c.byteLength),
                e = new rb(d);
            return e.set(c), d
        }, E.prototype = {
            slice: function(a, b) {
                return new E(this.a.slice(a, b))
            },
            __class__: E
        };
        var F = function(a, b, c) {
            if (this.buf = a, null == b ? this.offset = 0 : this.offset = b, null == c ? this.length = a.byteLength - this.offset : this.length = c, this.offset < 0 || this.length < 0 || this.offset + this.length > a.byteLength) throw new C(A.OutsideBounds)
        };
        g["js.html.compat.DataView"] = F, F.__name__ = ["js", "html", "compat", "DataView"], F.prototype = {
            getInt8: function(a) {
                var b = this.buf.a[this.offset + a];
                return b >= 128 ? b - 256 : b
            },
            getUint8: function(a) {
                return this.buf.a[this.offset + a]
            },
            getInt16: function(a, b) {
                var c = this.getUint16(a, b);
                return c >= 32768 ? c - 65536 : c
            },
            getUint16: function(a, b) {
                return b ? this.buf.a[this.offset + a] | this.buf.a[this.offset + a + 1] << 8 : this.buf.a[this.offset + a] << 8 | this.buf.a[this.offset + a + 1]
            },
            getInt32: function(a, b) {
                var c = this.offset + a,
                    d = this.buf.a[c++],
                    e = this.buf.a[c++],
                    f = this.buf.a[c++],
                    g = this.buf.a[c++];
                return b ? d | e << 8 | f << 16 | g << 24 : g | f << 8 | e << 16 | d << 24
            },
            getUint32: function(a, b) {
                var c = this.getInt32(a, b);
                return c < 0 ? c + 4294967296 : c
            },
            getFloat32: function(a, b) {
                return B.i32ToFloat(this.getInt32(a, b))
            },
            getFloat64: function(a, b) {
                var c = this.getInt32(a, b),
                    d = this.getInt32(a + 4, b);
                return B.i64ToDouble(b ? c : d, b ? d : c)
            },
            setInt8: function(a, b) {
                b < 0 ? this.buf.a[a + this.offset] = b + 128 & 255 : this.buf.a[a + this.offset] = 255 & b
            },
            setUint8: function(a, b) {
                this.buf.a[a + this.offset] = 255 & b
            },
            setInt16: function(a, b, c) {
                this.setUint16(a, b < 0 ? b + 65536 : b, c)
            },
            setUint16: function(a, b, c) {
                var d = a + this.offset;
                c ? (this.buf.a[d] = 255 & b, this.buf.a[d++] = b >> 8 & 255) : (this.buf.a[d++] = b >> 8 & 255, this.buf.a[d] = 255 & b)
            },
            setInt32: function(a, b, c) {
                this.setUint32(a, b, c)
            },
            setUint32: function(a, b, c) {
                var d = a + this.offset;
                c ? (this.buf.a[d++] = 255 & b, this.buf.a[d++] = b >> 8 & 255, this.buf.a[d++] = b >> 16 & 255, this.buf.a[d++] = b >>> 24) : (this.buf.a[d++] = b >>> 24, this.buf.a[d++] = b >> 16 & 255, this.buf.a[d++] = b >> 8 & 255, this.buf.a[d++] = 255 & b)
            },
            setFloat32: function(a, b, c) {
                this.setUint32(a, B.floatToI32(b), c)
            },
            setFloat64: function(a, b, c) {
                var d = B.doubleToI64(b);
                c ? (this.setUint32(a, d.low), this.setUint32(a, d.high)) : (this.setUint32(a, d.high), this.setUint32(a, d.low))
            },
            __class__: F
        };
        var G = function() {};
        g["js.html.compat.Uint8Array"] = G, G.__name__ = ["js", "html", "compat", "Uint8Array"], G._new = function(a, b, c) {
            var d;
            if ("number" == typeof a) {
                d = [];
                for (var e = 0; e < a;) {
                    var f = e++;
                    d[f] = 0
                }
                d.byteLength = d.length, d.byteOffset = 0, d.buffer = new E(d)
            } else if (D.__instanceof(a, E)) {
                var g = a;
                null == b && (b = 0), null == c && (c = g.byteLength - b), d = 0 == b ? g.a : g.a.slice(b, b + c), d.byteLength = d.length, d.byteOffset = b, d.buffer = g
            } else {
                if (!(a instanceof Array && null == a.__enum__)) throw new C("TODO " + m.string(a));
                d = a.slice(), d.byteLength = d.length, d.byteOffset = 0, d.buffer = new E(d)
            }
            return d.subarray = G._subarray, d.set = G._set, d
        }, G._set = function(a, b) {
            var c = this;
            if (D.__instanceof(a.buffer, E)) {
                var d = a;
                if (a.byteLength + b > c.byteLength) throw new C("set() outside of range");
                for (var e = 0, f = a.byteLength; e < f;) {
                    var g = e++;
                    c[g + b] = d[g]
                }
            } else {
                if (!(a instanceof Array && null == a.__enum__)) throw new C("TODO");
                var h = a;
                if (h.length + b > c.byteLength) throw new C("set() outside of range");
                for (var i = 0, j = h.length; i < j;) {
                    var k = i++;
                    c[k + b] = h[k]
                }
            }
        }, G._subarray = function(a, b) {
            var c = this,
                d = G._new(c.slice(a, b));
            return d.byteOffset = a, d
        };
        var H = function(a) {
            this._resolved = !1, this._pending = !1, this._errorPending = !1, this._fulfilled = !1, this._update = [], this._error = [], this._errored = !1, null != a && H.link(a, this, function(a) {
                return a
            })
        };
        g["promhx.base.AsyncBase"] = H, H.__name__ = ["promhx", "base", "AsyncBase"], H.link = function(a, b, c) {
            a._update.push({
                async: b,
                linkf: function(a) {
                    b.handleResolve(c(a))
                }
            }), H.immediateLinkUpdate(a, b, c)
        }, H.immediateLinkUpdate = function(a, b, c) {
            if (!a._errored || a._errorPending || a._error.length > 0 || b.handleError(a._errorVal), a._resolved && !a._pending) try {
                b.handleResolve(c(a._val))
            } catch (d) {
                d instanceof C && (d = d.val), b.handleError(d)
            }
        }, H.linkAll = function(a, b) {
            for (var c = function(c, d, f) {
                    if (0 == c.length || H.allFulfilled(c)) {
                        for (var g, h = [], i = e(a)(); i.hasNext();) {
                            var j = i.next();
                            h.push(j == d ? f : j._val)
                        }
                        g = h, b.handleResolve(g)
                    }
                }, d = e(a)(); d.hasNext();) {
                var f = d.next();
                f._update.push({
                    async: b,
                    linkf: function(a, b, c) {
                        return function(d) {
                            a(b, c, d)
                        }
                    }(c, function(b) {
                        for (var c, d = [], g = e(a)(); g.hasNext();) {
                            var h = g.next();
                            h != f && d.push(h)
                        }
                        return c = d
                    }(this), f)
                })
            }
            H.allFulfilled(a) && b.handleResolve(function(b) {
                for (var c, d = [], f = e(a)(); f.hasNext();) {
                    var g = f.next();
                    d.push(g._val)
                }
                return c = d
            }(this))
        }, H.pipeLink = function(a, b, c) {
            var d = !1,
                e = function(a) {
                    if (!d) {
                        d = !0;
                        var e = c(a);
                        e._update.push({
                            async: b,
                            linkf: f(b, b.handleResolve)
                        }), H.immediateLinkUpdate(e, b, function(a) {
                            return a
                        })
                    }
                };
            if (a._update.push({
                    async: b,
                    linkf: e
                }), a._resolved && !a._pending) try {
                e(a._val)
            } catch (g) {
                g instanceof C && (g = g.val), b.handleError(g)
            }
        }, H.allResolved = function(a) {
            for (var b = e(a)(); b.hasNext();) {
                var c = b.next();
                if (!c._resolved) return !1
            }
            return !0
        }, H.allFulfilled = function(a) {
            for (var b = e(a)(); b.hasNext();) {
                var c = b.next();
                if (!c._fulfilled) return !1
            }
            return !0
        }, H.prototype = {
            catchError: function(a) {
                return this._error.push(a), this
            },
            errorThen: function(a) {
                return this._errorMap = a, this
            },
            isResolved: function() {
                return this._resolved
            },
            isErrored: function() {
                return this._errored
            },
            isErrorHandled: function() {
                return this._error.length > 0
            },
            isErrorPending: function() {
                return this._errorPending
            },
            isFulfilled: function() {
                return this._fulfilled
            },
            isPending: function() {
                return this._pending
            },
            handleResolve: function(a) {
                this._resolve(a)
            },
            _resolve: function(a) {
                var b = this;
                this._pending ? M.enqueue(function(a, b) {
                    return function() {
                        a(b)
                    }
                }(f(this, this._resolve), a)) : (this._resolved = !0, this._pending = !0, M.queue.add(function() {
                    b._val = a;
                    for (var c = 0, d = b._update; c < d.length;) {
                        var e = d[c];
                        ++c;
                        try {
                            e.linkf(a)
                        } catch (f) {
                            f instanceof C && (f = f.val), e.async.handleError(f)
                        }
                    }
                    b._fulfilled = !0, b._pending = !1
                }), M.continueOnNextLoop())
            },
            handleError: function(a) {
                this._handleError(a)
            },
            _handleError: function(a) {
                var b = this,
                    c = function(a) {
                        if (b._error.length > 0)
                            for (var c = 0, d = b._error; c < d.length;) {
                                var e = d[c];
                                ++c, e(a)
                            } else {
                                if (!(b._update.length > 0)) throw new C(a);
                                for (var f = 0, g = b._update; f < g.length;) {
                                    var h = g[f];
                                    ++f, h.async.handleError(a)
                                }
                            }
                        b._errorPending = !1
                    };
                this._errorPending || (this._errorPending = !0, this._errored = !0, this._errorVal = a, M.queue.add(function() {
                    if (null != b._errorMap) try {
                        b._resolve(b._errorMap(a))
                    } catch (d) {
                        d instanceof C && (d = d.val), c(d)
                    } else c(a)
                }), M.continueOnNextLoop())
            },
            then: function(a) {
                var b = new H(null);
                return H.link(this, b, a), b
            },
            unlink: function(a) {
                var b = this;
                M.queue.add(function() {
                    b._update = b._update.filter(function(b) {
                        return b.async != a
                    })
                }), M.continueOnNextLoop()
            },
            isLinked: function(a) {
                for (var b = !1, c = 0, d = this._update; c < d.length;) {
                    var e = d[c];
                    if (++c, e.async == a) return !0
                }
                return b
            },
            __class__: H
        };
        var I = b.promhx.Deferred = function() {
            H.call(this)
        };
        g["promhx.Deferred"] = I, I.__name__ = ["promhx", "Deferred"], I.__super__ = H, I.prototype = d(H.prototype, {
            resolve: function(a) {
                this.handleResolve(a)
            },
            throwError: function(a) {
                this.handleError(a)
            },
            promise: function() {
                return new J(this)
            },
            stream: function() {
                return new K(this)
            },
            publicStream: function() {
                return new L(this)
            },
            __class__: I
        });
        var J = b.promhx.Promise = function(a) {
            H.call(this, a), this._rejected = !1
        };
        g["promhx.Promise"] = J, J.__name__ = ["promhx", "Promise"], J.whenAll = function(a) {
            var b = new J(null);
            return H.linkAll(a, b), b
        }, J.promise = function(a) {
            var b = new J;
            return b.handleResolve(a), b
        }, J.__super__ = H, J.prototype = d(H.prototype, {
            isRejected: function() {
                return this._rejected
            },
            reject: function(a) {
                this._rejected = !0, this.handleError(a)
            },
            handleResolve: function(a) {
                if (this._resolved) {
                    var b = "Promise has already been resolved";
                    throw new C(N.AlreadyResolved(b))
                }
                this._resolve(a)
            },
            then: function(a) {
                var b = new J(null);
                return H.link(this, b, a), b
            },
            unlink: function(a) {
                var b = this;
                M.queue.add(function() {
                    if (b._fulfilled) b._update = b._update.filter(function(b) {
                        return b.async != a
                    });
                    else {
                        var c = "Downstream Promise is not fullfilled";
                        b.handleError(N.DownstreamNotFullfilled(c))
                    }
                }), M.continueOnNextLoop()
            },
            handleError: function(a) {
                this._rejected = !0, this._handleError(a)
            },
            pipe: function(a) {
                var b = new J(null);
                return H.pipeLink(this, b, a), b
            },
            errorPipe: function(a) {
                var b = new J;
                return this.catchError(function(c) {
                    var d = a(c);
                    d.then(f(b, b._resolve))
                }), this.then(f(b, b._resolve)), b
            },
            __class__: J
        });
        var K = b.promhx.Stream = function(a) {
            H.call(this, a), this._end_promise = new J
        };
        g["promhx.Stream"] = K, K.__name__ = ["promhx", "Stream"], K.foreach = function(a) {
            for (var b = new K(null), c = e(a)(); c.hasNext();) {
                var d = c.next();
                b.handleResolve(d)
            }
            return b.end(), b
        }, K.wheneverAll = function(a) {
            var b = new K(null);
            return H.linkAll(a, b), b
        }, K.concatAll = function(a) {
            for (var b = new K(null), c = e(a)(); c.hasNext();) {
                var d = c.next();
                b.concat(d)
            }
            return b
        }, K.mergeAll = function(a) {
            for (var b = new K(null), c = e(a)(); c.hasNext();) {
                var d = c.next();
                b.merge(d)
            }
            return b
        }, K.stream = function(a) {
            var b = new K(null);
            return b.handleResolve(a), b
        }, K.__super__ = H, K.prototype = d(H.prototype, {
            then: function(a) {
                var b = new K(null);
                return H.link(this, b, a), this._end_promise._update.push({
                    async: b._end_promise,
                    linkf: function(a) {
                        b.end()
                    }
                }), b
            },
            detachStream: function(a) {
                for (var b = [], c = !1, d = 0, e = this._update; d < e.length;) {
                    var f = e[d];
                    ++d, f.async == a ? (this._end_promise._update = this._end_promise._update.filter(function(b) {
                        return b.async != a._end_promise
                    }), c = !0) : b.push(f)
                }
                return this._update = b, c
            },
            first: function() {
                var a = new J(null);
                return this.then(function(b) {
                    a._resolved || a.handleResolve(b)
                }), a
            },
            handleResolve: function(a) {
                this._end || this._pause || this._resolve(a)
            },
            pause: function(a) {
                null == a && (a = !this._pause), this._pause = a
            },
            pipe: function(a) {
                var b = new K(null);
                return H.pipeLink(this, b, a), this._end_promise.then(function(a) {
                    b.end()
                }), b
            },
            errorPipe: function(a) {
                var b = new K(null);
                return this.catchError(function(c) {
                    var d = a(c);
                    d.then(f(b, b._resolve)), d._end_promise.then((hb = b._end_promise, f(hb, hb._resolve)))
                }), this.then(f(b, b._resolve)), this._end_promise.then(function(a) {
                    b.end()
                }), b
            },
            handleEnd: function() {
                if (this._pending) M.queue.add(f(this, this.handleEnd)), M.continueOnNextLoop();
                else {
                    if (this._end_promise._resolved) return;
                    this._end = !0;
                    var a;
                    a = this._resolved ? x.Some(this._val) : x.None, this._end_promise.handleResolve(a), this._update = [], this._error = []
                }
            },
            end: function() {
                return M.queue.add(f(this, this.handleEnd)), M.continueOnNextLoop(),
                    this
            },
            endThen: function(a) {
                return this._end_promise.then(a)
            },
            filter: function(a) {
                var b = new K(null);
                return this._update.push({
                    async: b,
                    linkf: function(c) {
                        a(c) && b.handleResolve(c)
                    }
                }), H.immediateLinkUpdate(this, b, function(a) {
                    return a
                }), b
            },
            concat: function(a) {
                var b = new K(null);
                return this._update.push({
                    async: b,
                    linkf: f(b, b.handleResolve)
                }), H.immediateLinkUpdate(this, b, function(a) {
                    return a
                }), this._end_promise.then(function(c) {
                    a.pipe(function(a) {
                        return b.handleResolve(a), b
                    }), a._end_promise.then(function(a) {
                        b.end()
                    })
                }), b
            },
            merge: function(a) {
                var b = new K(null);
                return this._update.push({
                    async: b,
                    linkf: f(b, b.handleResolve)
                }), a._update.push({
                    async: b,
                    linkf: f(b, b.handleResolve)
                }), H.immediateLinkUpdate(this, b, function(a) {
                    return a
                }), H.immediateLinkUpdate(a, b, function(a) {
                    return a
                }), b
            },
            __class__: K
        });
        var L = b.promhx.PublicStream = function(a) {
            K.call(this, a)
        };
        g["promhx.PublicStream"] = L, L.__name__ = ["promhx", "PublicStream"], L.publicstream = function(a) {
            var b = new L(null);
            return b.handleResolve(a), b
        }, L.__super__ = K, L.prototype = d(K.prototype, {
            resolve: function(a) {
                this.handleResolve(a)
            },
            throwError: function(a) {
                this.handleError(a)
            },
            update: function(a) {
                this.handleResolve(a)
            },
            __class__: L
        });
        var M = function() {};
        g["promhx.base.EventLoop"] = M, M.__name__ = ["promhx", "base", "EventLoop"], M.enqueue = function(a) {
            M.queue.add(a), M.continueOnNextLoop()
        }, M.set_nextLoop = function(a) {
            if (null != M.nextLoop) throw new C("nextLoop has already been set");
            return M.nextLoop = a, M.nextLoop
        }, M.queueEmpty = function() {
            return M.queue.isEmpty()
        }, M.finish = function(a) {
            null == a && (a = 1e3);
            for (var b = null; a-- > 0 && null != (b = M.queue.pop());) b();
            return M.queue.isEmpty()
        }, M.clear = function() {
            M.queue = new k
        }, M.f = function() {
            var a = M.queue.pop();
            null != a && a(), M.queue.isEmpty() || M.continueOnNextLoop()
        }, M.continueOnNextLoop = function() {
            null != M.nextLoop ? M.nextLoop(M.f) : setImmediate(M.f)
        };
        var N = g["promhx.error.PromiseError"] = {
            __ename__: ["promhx", "error", "PromiseError"],
            __constructs__: ["AlreadyResolved", "DownstreamNotFullfilled"]
        };
        N.AlreadyResolved = function(a) {
            var b = ["AlreadyResolved", 0, a];
            return b.__enum__ = N, b.toString = h, b
        }, N.DownstreamNotFullfilled = function(a) {
            var b = ["DownstreamNotFullfilled", 1, a];
            return b.__enum__ = N, b.toString = h, b
        };
        var O = function() {};
        g["verb.Verb"] = O, O.__name__ = ["verb", "Verb"], O.main = function() {
            a.log("verb 2.0.0")
        };
        var P = function() {};
        g["verb.core.ArrayExtensions"] = P, P.__name__ = ["verb", "core", "ArrayExtensions"], P.alloc = function(a, b) {
            if (!(b < 0))
                for (; a.length < b;) a.push(null)
        }, P.reversed = function(a) {
            var b = a.slice();
            return b.reverse(), b
        }, P.last = function(a) {
            return a[a.length - 1]
        }, P.first = function(a) {
            return a[0]
        }, P.spliceAndInsert = function(a, b, c, d) {
            a.splice(b, c), a.splice(b, 0, d)
        }, P.left = function(a) {
            if (0 == a.length) return [];
            var b = Math.ceil(a.length / 2);
            return a.slice(0, b)
        }, P.right = function(a) {
            if (0 == a.length) return [];
            var b = Math.ceil(a.length / 2);
            return a.slice(b)
        }, P.rightWithPivot = function(a) {
            if (0 == a.length) return [];
            var b = Math.ceil(a.length / 2);
            return a.slice(b - 1)
        }, P.unique = function(a, b) {
            if (0 == a.length) return [];
            for (var c = [a.pop()]; a.length > 0;) {
                for (var d = a.pop(), e = !0, f = 0; f < c.length;) {
                    var g = c[f];
                    if (++f, b(d, g)) {
                        e = !1;
                        break
                    }
                }
                e && c.push(d)
            }
            return c
        };
        var Q = function() {};
        g["verb.core.Binomial"] = Q, Q.__name__ = ["verb", "core", "Binomial"], Q.get = function(a, b) {
            if (0 == b) return 1;
            if (0 == a || b > a) return 0;
            if (b > a - b && (b = a - b), Q.memo_exists(a, b)) return Q.get_memo(a, b);
            for (var c = 1, d = a, e = 1, f = b + 1; e < f;) {
                var g = e++;
                Q.memo_exists(d, g) ? (a--, c = Q.get_memo(d, g)) : (c *= a--, c /= g, Q.memoize(d, g, c))
            }
            return c
        }, Q.get_no_memo = function(a, b) {
            if (0 == b) return 1;
            if (0 == a || b > a) return 0;
            b > a - b && (b = a - b);
            for (var c = 1, d = 1, e = b + 1; d < e;) {
                var f = d++;
                c *= a--, c /= f
            }
            return c
        }, Q.memo_exists = function(a, b) {
            return Q.memo.h.hasOwnProperty(a) && Q.memo.h[a].h.hasOwnProperty(b)
        }, Q.get_memo = function(a, b) {
            return Q.memo.h[a].h[b]
        }, Q.memoize = function(a, b, c) {
            Q.memo.h.hasOwnProperty(a) || Q.memo.set(a, new v), Q.memo.h[a].h[b] = c
        };
        var R = b.core.BoundingBox = function(a) {
            this.max = null, this.min = null, this.dim = 3, this.initialized = !1, null != a && this.addRange(a)
        };
        g["verb.core.BoundingBox"] = R, R.__name__ = ["verb", "core", "BoundingBox"], R.intervalsOverlap = function(a, b, c, d, e) {
            null == e && (e = -1);
            var f;
            f = e < -.5 ? S.TOLERANCE : e;
            var g = Math.min(a, b) - f,
                h = Math.max(a, b) + f,
                i = Math.min(c, d) - f,
                j = Math.max(c, d) + f;
            return g >= i && g <= j || h >= i && h <= j || i >= g && i <= h || j >= g && j <= h
        }, R.prototype = {
            fromPoint: function(a) {
                return new R([a])
            },
            add: function(a) {
                if (!this.initialized) return this.dim = a.length, this.min = a.slice(0), this.max = a.slice(0), this.initialized = !0, this;
                for (var b = 0, c = this.dim; b < c;) {
                    var d = b++;
                    a[d] > this.max[d] && (this.max[d] = a[d]), a[d] < this.min[d] && (this.min[d] = a[d])
                }
                return this
            },
            addRange: function(a) {
                for (var b = a.length, c = 0; c < b;) {
                    var d = c++;
                    this.add(a[d])
                }
                return this
            },
            contains: function(a, b) {
                return null == b && (b = -1), !!this.initialized && this.intersects(new R([a]), b)
            },
            intersects: function(a, b) {
                if (null == b && (b = -1), !this.initialized || !a.initialized) return !1;
                for (var c = this.min, d = this.max, e = a.min, f = a.max, g = 0, h = this.dim; g < h;) {
                    var i = g++;
                    if (!R.intervalsOverlap(c[i], d[i], e[i], f[i], b)) return !1
                }
                return !0
            },
            clear: function() {
                return this.initialized = !1, this
            },
            getLongestAxis: function() {
                for (var a = 0, b = 0, c = 0, d = this.dim; c < d;) {
                    var e = c++,
                        f = this.getAxisLength(e);
                    f > a && (a = f, b = e)
                }
                return b
            },
            getAxisLength: function(a) {
                return a < 0 || a > this.dim - 1 ? 0 : Math.abs(this.min[a] - this.max[a])
            },
            intersect: function(a, b) {
                if (!this.initialized) return null;
                var c = this.min,
                    d = this.max,
                    e = a.min,
                    f = a.max;
                if (!this.intersects(a, b)) return null;
                for (var g = [], h = [], i = 0, j = this.dim; i < j;) {
                    var k = i++;
                    g.push(Math.min(d[k], f[k])), h.push(Math.max(c[k], e[k]))
                }
                return new R([h, g])
            },
            __class__: R
        };
        var S = b.core.Constants = function() {};
        g["verb.core.Constants"] = S, S.__name__ = ["verb", "core", "Constants"];
        var T = b.core.SerializableBase = function() {};
        g["verb.core.SerializableBase"] = T, T.__name__ = ["verb", "core", "SerializableBase"], T.prototype = {
            serialize: function() {
                var a = new t;
                return a.serialize(this), a.toString()
            },
            __class__: T
        };
        var U = b.core.Plane = function(a, b) {
            this.origin = a, this.normal = b
        };
        g["verb.core.Plane"] = U, U.__name__ = ["verb", "core", "Plane"], U.__super__ = T, U.prototype = d(T.prototype, {
            __class__: U
        });
        var V = b.core.Ray = function(a, b) {
            this.origin = a, this.dir = b
        };
        g["verb.core.Ray"] = V, V.__name__ = ["verb", "core", "Ray"], V.__super__ = T, V.prototype = d(T.prototype, {
            __class__: V
        });
        var W = b.core.NurbsCurveData = function(a, b, c) {
            this.degree = a, this.controlPoints = c, this.knots = b
        };
        g["verb.core.NurbsCurveData"] = W, W.__name__ = ["verb", "core", "NurbsCurveData"], W.__super__ = T, W.prototype = d(T.prototype, {
            __class__: W
        });
        var X = b.core.NurbsSurfaceData = function(a, b, c, d, e) {
            this.degreeU = a, this.degreeV = b, this.knotsU = c, this.knotsV = d, this.controlPoints = e
        };
        g["verb.core.NurbsSurfaceData"] = X, X.__name__ = ["verb", "core", "NurbsSurfaceData"], X.__super__ = T, X.prototype = d(T.prototype, {
            __class__: X
        });
        var Y = b.core.MeshData = function(a, b, c, d) {
            this.faces = a, this.points = b, this.normals = c, this.uvs = d
        };
        g["verb.core.MeshData"] = Y, Y.__name__ = ["verb", "core", "MeshData"], Y.empty = function() {
            return new Y([], [], [], [])
        }, Y.__super__ = T, Y.prototype = d(T.prototype, {
            __class__: Y
        });
        var Z = b.core.PolylineData = function(a, b) {
            this.points = a, this.params = b
        };
        g["verb.core.PolylineData"] = Z, Z.__name__ = ["verb", "core", "PolylineData"], Z.__super__ = T, Z.prototype = d(T.prototype, {
            __class__: Z
        });
        var $ = b.core.VolumeData = function(a, b, c, d, e, f, g) {
            this.degreeU = a, this.degreeV = b, this.degreeW = c, this.knotsU = d, this.knotsV = e, this.knotsW = f, this.controlPoints = g
        };
        g["verb.core.VolumeData"] = $, $.__name__ = ["verb", "core", "VolumeData"], $.__super__ = T, $.prototype = d(T.prototype, {
            __class__: $
        });
        var _ = b.core.Pair = function(a, b) {
            this.item0 = a, this.item1 = b
        };
        g["verb.core.Pair"] = _, _.__name__ = ["verb", "core", "Pair"], _.prototype = {
            __class__: _
        };
        var aa = b.core.Interval = function(a, b) {
            this.min = a, this.max = b
        };
        g["verb.core.Interval"] = aa, aa.__name__ = ["verb", "core", "Interval"], aa.prototype = {
            __class__: aa
        };
        var ba = b.core.CurveCurveIntersection = function(a, b, c, d) {
            this.point0 = a, this.point1 = b, this.u0 = c, this.u1 = d
        };
        g["verb.core.CurveCurveIntersection"] = ba, ba.__name__ = ["verb", "core", "CurveCurveIntersection"], ba.prototype = {
            __class__: ba
        };
        var ca = b.core.CurveSurfaceIntersection = function(a, b, c, d) {
            this.u = a, this.uv = b, this.curvePoint = c, this.surfacePoint = d
        };
        g["verb.core.CurveSurfaceIntersection"] = ca, ca.__name__ = ["verb", "core", "CurveSurfaceIntersection"], ca.prototype = {
            __class__: ca
        };
        var da = b.core.MeshIntersectionPoint = function(a, b, c, d, e) {
            this.visited = !1, this.adj = null, this.opp = null, this.uv0 = a, this.uv1 = b, this.point = c, this.faceIndex0, this.faceIndex1
        };
        g["verb.core.MeshIntersectionPoint"] = da, da.__name__ = ["verb", "core", "MeshIntersectionPoint"], da.prototype = {
            __class__: da
        };
        var ea = b.core.PolylineMeshIntersection = function(a, b, c, d, e) {
            this.point = a, this.u = b, this.uv = c, this.polylineIndex = d, this.faceIndex = e
        };
        g["verb.core.PolylineMeshIntersection"] = ea, ea.__name__ = ["verb", "core", "PolylineMeshIntersection"], ea.prototype = {
            __class__: ea
        };
        var fa = b.core.SurfaceSurfaceIntersectionPoint = function(a, b, c, d) {
            this.uv0 = a, this.uv1 = b, this.point = c, this.dist = d
        };
        g["verb.core.SurfaceSurfaceIntersectionPoint"] = fa, fa.__name__ = ["verb", "core", "SurfaceSurfaceIntersectionPoint"], fa.prototype = {
            __class__: fa
        };
        var ga = b.core.TriSegmentIntersection = function(a, b, c, d) {
            this.point = a, this.s = b, this.t = c, this.p = d
        };
        g["verb.core.TriSegmentIntersection"] = ga, ga.__name__ = ["verb", "core", "TriSegmentIntersection"], ga.prototype = {
            __class__: ga
        };
        var ha = b.core.CurveTriPoint = function(a, b, c) {
            this.u = a, this.point = b, this.uv = c
        };
        g["verb.core.CurveTriPoint"] = ha, ha.__name__ = ["verb", "core", "CurveTriPoint"], ha.prototype = {
            __class__: ha
        };
        var ia = function(a, b, c, d, e) {
            null == e && (e = !1), null == d && (d = -1), this.uv = c, this.point = a, this.normal = b, this.id = d, this.degen = e
        };
        g["verb.core.SurfacePoint"] = ia, ia.__name__ = ["verb", "core", "SurfacePoint"], ia.fromUv = function(a, b) {
            return new ia(null, null, [a, b])
        }, ia.prototype = {
            __class__: ia
        };
        var ja = b.core.CurvePoint = function(a, b) {
            this.u = a, this.pt = b
        };
        g["verb.core.CurvePoint"] = ja, ja.__name__ = ["verb", "core", "CurvePoint"], ja.prototype = {
            __class__: ja
        };
        var ka = b.core.KdTree = function(a, b) {
            this.dim = 3, this.points = a, this.distanceFunction = b, this.dim = a[0].point.length, this.root = this.buildTree(a, 0, null)
        };
        g["verb.core.KdTree"] = ka, ka.__name__ = ["verb", "core", "KdTree"], ka.prototype = {
            buildTree: function(a, b, c) {
                var d, e, f = b % this.dim;
                return 0 == a.length ? null : 1 == a.length ? new na(a[0], f, c) : (a.sort(function(a, b) {
                    var c = a.point[f] - b.point[f];
                    return 0 == c ? 0 : c > 0 ? 1 : -1
                }), d = Math.floor(a.length / 2), e = new na(a[d], f, c), e.left = this.buildTree(a.slice(0, d), b + 1, e), e.right = this.buildTree(a.slice(d + 1), b + 1, e), e)
            },
            nearest: function(a, b, c) {
                var d, e = this,
                    f = new la(function(a) {
                        return -a.item1
                    }),
                    g = null;
                g = function(c) {
                    for (var d, h, i = c.dimension, j = e.distanceFunction(a, c.kdPoint.point), k = [], l = 0, m = e.dim; l < m;) {
                        l++;
                        k.push(0)
                    }
                    h = k;
                    for (var n, o, p = function(a, c) {
                            f.push(new _(a, c)), f.size() > b && f.pop()
                        }, q = 0, r = e.dim; q < r;) {
                        var s = q++;
                        s == c.dimension ? h[s] = a[s] : h[s] = c.kdPoint.point[s]
                    }
                    return n = e.distanceFunction(h, c.kdPoint.point), null == c.right && null == c.left ? void((f.size() < b || j < f.peek().item1) && p(c, j)) : (d = null == c.right ? c.left : null == c.left ? c.right : a[i] < c.kdPoint.point[i] ? c.left : c.right, g(d), (f.size() < b || j < f.peek().item1) && p(c, j), void((f.size() < b || Math.abs(n) < f.peek().item1) && (o = d == c.left ? c.right : c.left, null != o && g(o))))
                }, d = g;
                for (var h = 0; h < b;) {
                    h++;
                    f.push(new _(null, c))
                }
                d(this.root);
                for (var i = [], j = 0; j < b;) {
                    var k = j++;
                    null != f.content[k].item0 && i.push(new _(f.content[k].item0.kdPoint, f.content[k].item1))
                }
                return i
            },
            __class__: ka
        };
        var la = function(a) {
            this.content = [], this.scoreFunction = a
        };
        g["verb.core.BinaryHeap"] = la, la.__name__ = ["verb", "core", "BinaryHeap"], la.prototype = {
            push: function(a) {
                this.content.push(a), this.bubbleUp(this.content.length - 1)
            },
            pop: function() {
                var a = this.content[0],
                    b = this.content.pop();
                return this.content.length > 0 && (this.content[0] = b, this.sinkDown(0)), a
            },
            peek: function() {
                return this.content[0]
            },
            remove: function(a) {
                for (var b = this.content.length, c = 0; c < b;) {
                    var d = c++;
                    if (this.content[d] == a) {
                        var e = this.content.pop();
                        return void(d != b - 1 && (this.content[d] = e, this.scoreFunction(e) < this.scoreFunction(a) ? this.bubbleUp(d) : this.sinkDown(d)))
                    }
                }
                throw new C("Node not found.")
            },
            size: function() {
                return this.content.length
            },
            bubbleUp: function(a) {
                for (var b = this.content[a]; a > 0;) {
                    var c = Math.floor((a + 1) / 2) - 1,
                        d = this.content[c];
                    if (!(this.scoreFunction(b) < this.scoreFunction(d))) break;
                    this.content[c] = b, this.content[a] = d, a = c
                }
            },
            sinkDown: function(a) {
                for (var b = this.content.length, c = this.content[a], d = this.scoreFunction(c);;) {
                    var e = 2 * (a + 1),
                        f = e - 1,
                        g = -1,
                        h = 0;
                    if (f < b) {
                        var i = this.content[f];
                        h = this.scoreFunction(i), h < d && (g = f)
                    }
                    if (e < b) {
                        var j = this.content[e],
                            k = this.scoreFunction(j);
                        k < (g == -1 ? d : h) && (g = e)
                    }
                    if (g == -1) break;
                    this.content[a] = this.content[g], this.content[g] = c, a = g
                }
            },
            __class__: la
        };
        var ma = b.core.KdPoint = function(a, b) {
            this.point = a, this.obj = b
        };
        g["verb.core.KdPoint"] = ma, ma.__name__ = ["verb", "core", "KdPoint"], ma.prototype = {
            __class__: ma
        };
        var na = b.core.KdNode = function(a, b, c) {
            this.kdPoint = a, this.left = null, this.right = null, this.parent = c, this.dimension = b
        };
        g["verb.core.KdNode"] = na, na.__name__ = ["verb", "core", "KdNode"], na.prototype = {
            __class__: na
        };
        var oa = function() {};
        g["verb.eval.IBoundingBoxTree"] = oa, oa.__name__ = ["verb", "eval", "IBoundingBoxTree"], oa.prototype = {
            __class__: oa
        };
        var pa = function(a, b) {
            this._boundingBox = null, this._curve = a, null == b && (b = Ca.domain(this._curve.knots) / 64), this._knotTol = b
        };
        g["verb.core.LazyCurveBoundingBoxTree"] = pa, pa.__name__ = ["verb", "core", "LazyCurveBoundingBoxTree"], pa.__interfaces__ = [oa], pa.prototype = {
            split: function() {
                var a = P.first(this._curve.knots),
                    b = P.last(this._curve.knots),
                    c = b - a,
                    d = Ga.curveSplit(this._curve, (b + a) / 2 + .1 * c * Math.random());
                return new _(new pa(d[0], this._knotTol), new pa(d[1], this._knotTol))
            },
            boundingBox: function() {
                return null == this._boundingBox && (this._boundingBox = new R(Ia.dehomogenize1d(this._curve.controlPoints))), this._boundingBox
            },
            yield: function() {
                return this._curve
            },
            indivisible: function(a) {
                return Ca.domain(this._curve.knots) < this._knotTol
            },
            empty: function() {
                return !1
            },
            __class__: pa
        };
        var qa = function(a, b) {
            if (this._boundingBox = null, this._mesh = a, null == b) {
                for (var c = [], d = 0, e = a.faces.length; d < e;) {
                    var f = d++;
                    c.push(f)
                }
                b = c
            }
            this._faceIndices = b
        };
        g["verb.core.LazyMeshBoundingBoxTree"] = qa, qa.__name__ = ["verb", "core", "LazyMeshBoundingBoxTree"], qa.__interfaces__ = [oa], qa.prototype = {
            split: function() {
                var a = va.sortTrianglesOnLongestAxis(this.boundingBox(), this._mesh, this._faceIndices),
                    b = P.left(a),
                    c = P.right(a);
                return new _(new qa(this._mesh, b), new qa(this._mesh, c))
            },
            boundingBox: function() {
                return null == this._boundingBox && (this._boundingBox = va.makeMeshAabb(this._mesh, this._faceIndices)), this._boundingBox
            },
            yield: function() {
                return this._faceIndices[0]
            },
            indivisible: function(a) {
                return 1 == this._faceIndices.length
            },
            empty: function() {
                return 0 == this._faceIndices.length
            },
            __class__: qa
        };
        var ra = function(a, b) {
            this._boundingBox = null, this._polyline = a, null == b && (b = new aa(0, 0 != a.points.length ? a.points.length - 1 : 0)), this._interval = b
        };
        g["verb.core.LazyPolylineBoundingBoxTree"] = ra, ra.__name__ = ["verb", "core", "LazyPolylineBoundingBoxTree"], ra.__interfaces__ = [oa], ra.prototype = {
            split: function() {
                var a = this._interval.min,
                    b = this._interval.max,
                    c = a + Math.ceil((b - a) / 2),
                    d = new aa(a, c),
                    e = new aa(c, b);
                return new _(new ra(this._polyline, d), new ra(this._polyline, e))
            },
            boundingBox: function() {
                return null == this._boundingBox && (this._boundingBox = new R(this._polyline.points)), this._boundingBox
            },
            yield: function() {
                return this._interval.min
            },
            indivisible: function(a) {
                return this._interval.max - this._interval.min == 1
            },
            empty: function() {
                return this._interval.max - this._interval.min == 0
            },
            __class__: ra
        };
        var sa = function(a, b, c, d) {
            null == b && (b = !1), this._boundingBox = null, this._surface = a, this._splitV = b, null == c && (c = Ca.domain(a.knotsU) / 16), null == d && (d = Ca.domain(a.knotsV) / 16), this._knotTolU = c, this._knotTolV = d
        };
        g["verb.core.LazySurfaceBoundingBoxTree"] = sa, sa.__name__ = ["verb", "core", "LazySurfaceBoundingBoxTree"], sa.__interfaces__ = [oa], sa.prototype = {
            split: function() {
                var a, b;
                this._splitV ? (a = P.first(this._surface.knotsV), b = P.last(this._surface.knotsV)) : (a = P.first(this._surface.knotsU), b = P.last(this._surface.knotsU));
                var c = (a + b) / 2,
                    d = Ga.surfaceSplit(this._surface, c, this._splitV);
                return new _(new sa(d[0], !this._splitV, this._knotTolU, this._knotTolV), new sa(d[1], !this._splitV, this._knotTolU, this._knotTolV))
            },
            boundingBox: function() {
                if (null == this._boundingBox) {
                    this._boundingBox = new R;
                    for (var a = 0, b = this._surface.controlPoints; a < b.length;) {
                        var c = b[a];
                        ++a, this._boundingBox.addRange(Ia.dehomogenize1d(c))
                    }
                }
                return this._boundingBox
            },
            yield: function() {
                return this._surface
            },
            indivisible: function(a) {
                return Ca.domain(this._surface.knotsV) < this._knotTolV && Ca.domain(this._surface.knotsU) < this._knotTolU
            },
            empty: function() {
                return !1
            },
            __class__: sa
        };
        var ta = b.core.Mat = function() {};
        g["verb.core.Mat"] = ta, ta.__name__ = ["verb", "core", "Mat"], ta.mul = function(a, b) {
            for (var c = [], d = 0, e = b.length; d < e;) {
                var f = d++;
                c.push(Ca.mul(a, b[f]))
            }
            return c
        }, ta.mult = function(a, b) {
            var c, d, e, f, g, h, i, j;
            c = a.length, d = b.length, e = b[0].length, f = [];
            for (var k = c - 1, l = 0, m = 0; k >= 0;) {
                for (g = [], h = a[k], m = e - 1; m >= 0;) {
                    for (i = h[d - 1] * b[d - 1][m], l = d - 2; l >= 1;) j = l - 1, i += h[l] * b[l][m] + h[j] * b[j][m], l -= 2;
                    0 == l && (i += h[0] * b[0][m]), g[m] = i, m--
                }
                f[k] = g, k--
            }
            return f
        }, ta.add = function(a, b) {
            for (var c = [], d = 0, e = a.length; d < e;) {
                var f = d++;
                c.push(Ca.add(a[f], b[f]))
            }
            return c
        }, ta.div = function(a, b) {
            for (var c = [], d = 0, e = a.length; d < e;) {
                var f = d++;
                c.push(Ca.div(a[f], b))
            }
            return c
        }, ta.sub = function(a, b) {
            for (var c = [], d = 0, e = a.length; d < e;) {
                var f = d++;
                c.push(Ca.sub(a[f], b[f]))
            }
            return c
        }, ta.dot = function(a, b) {
            for (var c = [], d = 0, e = a.length; d < e;) {
                var f = d++;
                c.push(Ca.dot(a[f], b))
            }
            return c
        }, ta.identity = function(a) {
            for (var b = Ca.zeros2d(a, a), c = 0; c < a;) {
                var d = c++;
                b[d][d] = 1
            }
            return b
        }, ta.transpose = function(a) {
            if (0 == a.length) return [];
            for (var b = [], c = 0, d = a[0].length; c < d;) {
                var e = c++;
                b.push(function(b) {
                    for (var c, d = [], f = 0, g = a.length; f < g;) {
                        var h = f++;
                        d.push(a[h][e])
                    }
                    return c = d
                }(this))
            }
            return b
        }, ta.solve = function(a, b) {
            return ta.LUsolve(ta.LU(a), b)
        }, ta.LUsolve = function(a, b) {
            var c, d, e, f, g, h = a.LU,
                i = h.length,
                j = b.slice(),
                k = a.P;
            for (c = i - 1; c != -1;) j[c] = b[c], --c;
            for (c = 0; c < i;) {
                for (e = k[c], k[c] != c && (g = j[c], j[c] = j[e], j[e] = g), f = h[c], d = 0; d < c;) j[c] -= j[d] * f[d], ++d;
                ++c
            }
            for (c = i - 1; c >= 0;) {
                for (f = h[c], d = c + 1; d < i;) j[c] -= j[d] * f[d], ++d;
                j[c] /= f[c], --c
            }
            return j
        }, ta.LU = function(a) {
            for (var b, c, d, e, f, g, h, i, j, k = (Math.abs, []), l = 0, m = a.length; l < m;) {
                var n = l++;
                k.push(a[n].slice())
            }
            a = k;
            var o = a.length,
                p = o - 1,
                q = [];
            for (d = 0; d < o;) {
                for (h = d, g = a[d], j = Math.abs(g[d]), c = d + 1; c < o;) e = Math.abs(a[c][d]), j < e && (j = e, h = c), ++c;
                for (q[d] = h, h != d && (a[d] = a[h], a[h] = g, g = a[d]), f = g[d], b = d + 1; b < o;) a[b][d] /= f, ++b;
                for (b = d + 1; b < o;) {
                    for (i = a[b], c = d + 1; c < p;) i[c] -= i[d] * g[c], ++c, i[c] -= i[d] * g[c], ++c;
                    c == p && (i[c] -= i[d] * g[c]), ++b
                }++d
            }
            return new ua(a, q)
        };
        var ua = function(a, b) {
            this.LU = a, this.P = b
        };
        g["verb.core._Mat.LUDecomp"] = ua, ua.__name__ = ["verb", "core", "_Mat", "LUDecomp"], ua.prototype = {
            __class__: ua
        };
        var va = b.core.Mesh = function() {};
        g["verb.core.Mesh"] = va, va.__name__ = ["verb", "core", "Mesh"], va.getTriangleNorm = function(a, b) {
            var c = a[b[0]],
                d = a[b[1]],
                e = a[b[2]],
                f = Ca.sub(d, c),
                g = Ca.sub(e, c),
                h = Ca.cross(f, g);
            return Ca.mul(1 / Ca.norm(h), h)
        }, va.makeMeshAabb = function(a, b) {
            for (var c = new R, d = 0; d < b.length;) {
                var e = b[d];
                ++d, c.add(a.points[a.faces[e][0]]), c.add(a.points[a.faces[e][1]]), c.add(a.points[a.faces[e][2]])
            }
            return c
        }, va.sortTrianglesOnLongestAxis = function(a, b, c) {
            for (var d = a.getLongestAxis(), e = [], f = 0; f < c.length;) {
                var g = c[f];
                ++f;
                var h = va.getMinCoordOnAxis(b.points, b.faces[g], d);
                e.push(new _(h, g))
            }
            e.sort(function(a, b) {
                var c = a.item0,
                    d = b.item0;
                return c == d ? 0 : c > d ? 1 : -1
            });
            for (var i = [], j = 0, k = e.length; j < k;) {
                var l = j++;
                i.push(e[l].item1)
            }
            return i
        }, va.getMinCoordOnAxis = function(a, b, c) {
            for (var d = 1 / 0, e = 0; e < 3;) {
                var f = e++,
                    g = a[b[f]][c];
                g < d && (d = g)
            }
            return d
        }, va.getTriangleCentroid = function(a, b) {
            for (var c = [0, 0, 0], d = 0; d < 3;)
                for (var e = d++, f = 0; f < 3;) {
                    var g = f++;
                    c[g] += a[b[e]][g]
                }
            for (var h = 0; h < 3;) {
                var i = h++;
                c[i] /= 3
            }
            return c
        }, va.triangleUVFromPoint = function(a, b, c) {
            var d = a.faces[b],
                e = a.points[d[0]],
                f = a.points[d[1]],
                g = a.points[d[2]],
                h = a.uvs[d[0]],
                i = a.uvs[d[1]],
                j = a.uvs[d[2]],
                k = Ca.sub(e, c),
                l = Ca.sub(f, c),
                m = Ca.sub(g, c),
                n = Ca.norm(Ca.cross(Ca.sub(e, f), Ca.sub(e, g))),
                o = Ca.norm(Ca.cross(l, m)) / n,
                p = Ca.norm(Ca.cross(m, k)) / n,
                q = Ca.norm(Ca.cross(k, l)) / n;
            return Ca.add(Ca.mul(o, h), Ca.add(Ca.mul(p, i), Ca.mul(q, j)))
        };
        var wa = function(a, b) {
            if (this._empty = !1, this._face = -1, null == b) {
                for (var c = [], d = 0, e = a.faces.length; d < e;) {
                    var f = d++;
                    c.push(f)
                }
                b = c
            }
            if (this._boundingBox = va.makeMeshAabb(a, b), b.length < 1) return void(this._empty = !0);
            if (b.length < 2) return void(this._face = b[0]);
            var g = va.sortTrianglesOnLongestAxis(this._boundingBox, a, b),
                h = P.left(g),
                i = P.right(g);
            this._children = new _(new wa(a, h), new wa(a, i))
        };
        g["verb.core.MeshBoundingBoxTree"] = wa, wa.__name__ = ["verb", "core", "MeshBoundingBoxTree"], wa.__interfaces__ = [oa], wa.prototype = {
            split: function() {
                return this._children
            },
            boundingBox: function() {
                return this._boundingBox
            },
            yield: function() {
                return this._face
            },
            indivisible: function(a) {
                return null == this._children
            },
            empty: function() {
                return this._empty
            },
            __class__: wa
        };
        var xa = b.core.Minimizer = function() {};
        g["verb.core.Minimizer"] = xa, xa.__name__ = ["verb", "core", "Minimizer"], xa.uncmin = function(a, b, c, d, e) {
            null == c && (c = 1e-8), null == d && (d = function(b) {
                return xa.numericalGradient(a, b)
            }), null == e && (e = 1e3), b = b.slice(0);
            var f, g = b.length,
                h = a(b),
                i = h;
            if (isNaN(h)) throw new C("uncmin: f(x0) is a NaN!");
            c = Math.max(c, S.EPSILON);
            var j, k, l, m, n, o, p, q, r, s = ta.identity(g),
                t = 0,
                u = [],
                v = "";
            for (k = d(b); t < e;) {
                if (!Ca.all(Ca.finite(k))) {
                    v = "Gradient has Infinity or NaN";
                    break
                }
                if (j = Ca.neg(ta.dot(s, k)), !Ca.all(Ca.finite(j))) {
                    v = "Search direction has Infinity or NaN";
                    break
                }
                if (r = Ca.norm(j), r < c) {
                    v = "Newton step smaller than tol";
                    break
                }
                for (q = 1, f = Ca.dot(k, j), m = b; t < e && !(q * r < c) && (u = Ca.mul(q, j), m = Ca.add(b, u), i = a(m), i - h >= .1 * q * f || isNaN(i));) q *= .5, ++t;
                if (q * r < c) {
                    v = "Line search step size smaller than tol";
                    break
                }
                if (t == e) {
                    v = "maxit reached during line search";
                    break
                }
                l = d(m), n = Ca.sub(l, k), p = Ca.dot(n, u), o = ta.dot(s, n), s = ta.sub(ta.add(s, ta.mul((p + Ca.dot(n, o)) / (p * p), xa.tensor(u, u))), ta.div(ta.add(xa.tensor(o, u), xa.tensor(u, o)), p)), b = m, h = i, k = l, ++t
            }
            return new ya(b, h, k, s, t, v)
        }, xa.numericalGradient = function(a, b) {
            var c = b.length,
                d = a(b);
            if (NaN == d) throw new C("gradient: f(x) is a NaN!");
            for (var e, f, g, h, i, j, k, l, m, n = b.slice(0), o = [], p = .001, q = 0, r = 0; r < c;)
                for (var s = r++, t = Math.max(1e-6 * d, 1e-8);;) {
                    if (++q, q > 20) throw new C("Numerical gradient fails");
                    if (n[s] = b[s] + t, e = a(n), n[s] = b[s] - t, f = a(n), n[s] = b[s], isNaN(e) || isNaN(f)) t /= 16;
                    else {
                        if (o[s] = (e - f) / (2 * t), h = b[s] - t, i = b[s], j = b[s] + t, k = (e - d) / t, l = (d - f) / t, m = Ca.max([Math.abs(o[s]), Math.abs(d), Math.abs(e), Math.abs(f), Math.abs(h), Math.abs(i), Math.abs(j), 1e-8]), g = Math.min(Ca.max([Math.abs(k - o[s]), Math.abs(l - o[s]), Math.abs(k - l)]) / m, t / m), !(g > p)) break;
                        t /= 16
                    }
                }
            return o
        }, xa.tensor = function(a, b) {
            for (var c, d, e = a.length, f = b.length, g = [], h = e - 1; h >= 0;) {
                c = [], d = a[h];
                for (var i = f - 1; i >= 3;) c[i] = d * b[i], --i, c[i] = d * b[i], --i, c[i] = d * b[i], --i, c[i] = d * b[i], --i;
                for (; i >= 0;) c[i] = d * b[i], --i;
                g[h] = c, h--
            }
            return g
        };
        var ya = function(a, b, c, d, e, f) {
            this.solution = a, this.value = b, this.gradient = c, this.invHessian = d, this.iterations = e, this.message = f
        };
        g["verb.core.MinimizationResult"] = ya, ya.__name__ = ["verb", "core", "MinimizationResult"], ya.prototype = {
            __class__: ya
        };
        var za = function() {};
        g["verb.core.ISerializable"] = za, za.__name__ = ["verb", "core", "ISerializable"], za.prototype = {
            __class__: za
        };
        var Aa = b.core.Deserializer = function() {};
        g["verb.core.Deserializer"] = Aa, Aa.__name__ = ["verb", "core", "Deserializer"], Aa.deserialize = function(a) {
            var b = new u(a),
                c = b.unserialize();
            return c
        };
        var Ba = b.core.Trig = function() {};
        g["verb.core.Trig"] = Ba, Ba.__name__ = ["verb", "core", "Trig"], Ba.isPointInPlane = function(a, b, c) {
            return Math.abs(Ca.dot(Ca.sub(a, b.origin), b.normal)) < c
        }, Ba.distToSegment = function(a, b, c) {
            var d = Ba.segmentClosestPoint(b, a, c, 0, 1);
            return Ca.dist(b, d.pt)
        }, Ba.rayClosestPoint = function(a, b, c) {
            var d = Ca.sub(a, b),
                e = Ca.dot(d, c),
                f = Ca.add(b, Ca.mul(e, c));
            return f
        }, Ba.distToRay = function(a, b, c) {
            var d = Ba.rayClosestPoint(a, b, c),
                e = Ca.sub(d, a);
            return Ca.norm(e)
        }, Ba.threePointsAreFlat = function(a, b, c, d) {
            var e = Ca.sub(b, a),
                f = Ca.sub(c, a),
                g = Ca.cross(e, f),
                h = Ca.dot(g, g);
            return h < d
        }, Ba.segmentClosestPoint = function(a, b, c, d, e) {
            var f = Ca.sub(c, b),
                g = Ca.norm(f);
            if (g < S.EPSILON) return {
                u: d,
                pt: b
            };
            var h = b,
                i = Ca.mul(1 / g, f),
                j = Ca.sub(a, h),
                k = Ca.dot(j, i);
            return k < 0 ? {
                u: d,
                pt: b
            } : k > g ? {
                u: e,
                pt: c
            } : {
                u: d + (e - d) * k / g,
                pt: Ca.add(h, Ca.mul(k, i))
            }
        };
        var Ca = b.core.Vec = function() {};
        g["verb.core.Vec"] = Ca, Ca.__name__ = ["verb", "core", "Vec"], Ca.angleBetween = function(a, b) {
            return Math.acos(Ca.dot(a, b) / (Ca.norm(a) * Ca.norm(b)))
        }, Ca.positiveAngleBetween = function(a, b, c) {
            var d = Ca.cross(a, b),
                e = Ca.norm(a),
                f = Ca.norm(b),
                g = e * f,
                h = Ca.dot(a, b),
                i = Ca.norm(d) / g,
                j = h / g,
                k = Math.atan2(i, j),
                l = Ca.dot(c, d);
            return Math.abs(l) < S.EPSILON ? k : l > 0 ? k : -k
        }, Ca.signedAngleBetween = function(a, b, c) {
            var d = Ca.cross(a, b),
                e = Ca.norm(a),
                f = Ca.norm(b),
                g = e * f,
                h = Ca.dot(a, b),
                i = Ca.norm(d) / g,
                j = h / g,
                k = Math.atan2(i, j),
                l = Ca.dot(c, d);
            return l > 0 ? k : 2 * Math.PI - k
        }, Ca.angleBetweenNormalized2d = function(a, b) {
            var c = a[0] * b[1] - a[1] * b[0];
            return Math.atan2(c, Ca.dot(a, b))
        }, Ca.domain = function(a) {
            return P.last(a) - P.first(a)
        }, Ca.range = function(a) {
            for (var b = [], c = 0, d = 0; d < a;) {
                d++;
                b.push(c), c += 1
            }
            return b
        }, Ca.span = function(a, b, c) {
            if (null == c) return [];
            if (c < S.EPSILON) return [];
            if (a > b && c > 0) return [];
            if (b > a && c < 0) return [];
            for (var d = [], e = a; e <= b;) d.push(e), e += c;
            return d
        }, Ca.neg = function(a) {
            return a.map(function(a) {
                return -a
            })
        }, Ca.min = function(a) {
            return j.fold(a, function(a, b) {
                return Math.min(a, b)
            }, 1 / 0)
        }, Ca.max = function(a) {
            return j.fold(a, function(a, b) {
                return Math.max(a, b)
            }, -(1 / 0))
        }, Ca.all = function(a) {
            return j.fold(a, function(a, b) {
                return b && a
            }, !0)
        }, Ca.finite = function(a) {
            return a.map(function(a) {
                return isFinite(a)
            })
        }, Ca.onRay = function(a, b, c) {
            return Ca.add(a, Ca.mul(c, b))
        }, Ca.lerp = function(a, b, c) {
            return Ca.add(Ca.mul(a, b), Ca.mul(1 - a, c))
        }, Ca.normalized = function(a) {
            return Ca.div(a, Ca.norm(a))
        }, Ca.cross = function(a, b) {
            return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]]
        }, Ca.dist = function(a, b) {
            return Ca.norm(Ca.sub(a, b))
        }, Ca.distSquared = function(a, b) {
            return Ca.normSquared(Ca.sub(a, b))
        }, Ca.sum = function(a) {
            return j.fold(a, function(a, b) {
                return b + a
            }, 0)
        }, Ca.addAll = function(a) {
            var b = e(a)();
            if (!b.hasNext()) return null;
            var c = b.next().length;
            return j.fold(a, function(a, b) {
                return Ca.add(b, a)
            }, Ca.rep(c, 0))
        }, Ca.norm = function(a) {
            var b = Ca.normSquared(a);
            return 0 != b ? Math.sqrt(b) : b
        }, Ca.normSquared = function(a) {
            return j.fold(a, function(a, b) {
                return b + a * a
            }, 0)
        }, Ca.rep = function(a, b) {
            for (var c = [], d = 0; d < a;) {
                d++;
                c.push(b)
            }
            return c
        }, Ca.zeros1d = function(a) {
            for (var b = [], c = 0; c < a;) {
                c++;
                b.push(0)
            }
            return b
        }, Ca.zeros2d = function(a, b) {
            for (var c = [], d = 0; d < a;) {
                d++;
                c.push(Ca.zeros1d(b))
            }
            return c
        }, Ca.zeros3d = function(a, b, c) {
            for (var d = [], e = 0; e < a;) {
                e++;
                d.push(Ca.zeros2d(b, c))
            }
            return d
        }, Ca.dot = function(a, b) {
            for (var c = 0, d = 0, e = a.length; d < e;) {
                var f = d++;
                c += a[f] * b[f]
            }
            return c
        }, Ca.add = function(a, b) {
            for (var c = [], d = 0, e = a.length; d < e;) {
                var f = d++;
                c.push(a[f] + b[f])
            }
            return c
        }, Ca.mul = function(a, b) {
            for (var c = [], d = 0, e = b.length; d < e;) {
                var f = d++;
                c.push(a * b[f])
            }
            return c
        }, Ca.div = function(a, b) {
            for (var c = [], d = 0, e = a.length; d < e;) {
                var f = d++;
                c.push(a[f] / b)
            }
            return c
        }, Ca.sub = function(a, b) {
            for (var c = [], d = 0, e = a.length; d < e;) {
                var f = d++;
                c.push(a[f] - b[f])
            }
            return c
        }, Ca.isZero = function(a) {
            for (var b = 0, c = a.length; b < c;) {
                var d = b++;
                if (Math.abs(a[d]) > S.TOLERANCE) return !1
            }
            return !0
        }, Ca.sortedSetUnion = function(a, b) {
            for (var c = [], d = 0, e = 0; d < a.length || e < b.length;)
                if (d >= a.length) c.push(b[e]), e++;
                else if (e >= b.length) c.push(a[d]), d++;
            else {
                var f = a[d] - b[e];
                Math.abs(f) < S.EPSILON ? (c.push(a[d]), d++, e++) : f > 0 ? (c.push(b[e]), e++) : (c.push(a[d]), d++)
            }
            return c
        }, Ca.sortedSetSub = function(a, b) {
            for (var c = [], d = 0, e = 0; d < a.length;) e >= b.length ? (c.push(a[d]), d++) : Math.abs(a[d] - b[e]) < S.EPSILON ? (d++, e++) : (c.push(a[d]), d++);
            return c
        };
        var Da = b.eval.Analyze = function() {};
        g["verb.eval.Analyze"] = Da, Da.__name__ = ["verb", "eval", "Analyze"], Da.knotMultiplicities = function(a) {
            for (var b = [new Ea(a[0], 0)], c = b[0], d = 0; d < a.length;) {
                var e = a[d];
                ++d, Math.abs(e - c.knot) > S.EPSILON && (c = new Ea(e, 0), b.push(c)), c.inc()
            }
            return b
        }, Da.isRationalSurfaceClosed = function(a, b) {
            null == b && (b = !0);
            var c;
            c = b ? a.controlPoints : ta.transpose(a.controlPoints);
            for (var d = 0, e = c[0].length; d < e;) {
                var f = d++,
                    g = Ca.dist(P.first(c)[f], P.last(c)[f]) < S.EPSILON;
                if (!g) return !1
            }
            return !0
        }, Da.rationalSurfaceClosestPoint = function(a, b) {
            var c = Da.rationalSurfaceClosestParam(a, b);
            return Ia.rationalSurfacePoint(a, c[0], c[1])
        }, Da.rationalSurfaceClosestParam = function(a, b) {
            for (var c, d, e, f = 5, g = 0, h = 1e-4, i = 5e-4, j = a.knotsU[0], k = P.last(a.knotsU), l = a.knotsV[0], m = P.last(a.knotsV), n = Da.isRationalSurfaceClosed(a), o = Da.isRationalSurfaceClosed(a, !1), p = Ma.rationalSurfaceAdaptive(a, new Na), q = 1 / 0, r = 0, s = p.points.length; r < s;) {
                var t = r++,
                    u = p.points[t],
                    v = Ca.normSquared(Ca.sub(b, u));
                v < q && (q = v, e = p.uvs[t])
            }
            for (var w = function(b) {
                    return Ia.rationalSurfaceDerivatives(a, b[0], b[1], 2)
                }, x = function(a, b, c) {
                    var d = b[1][0],
                        e = b[0][1],
                        f = b[2][0],
                        g = b[0][2],
                        h = b[1][1],
                        i = b[1][1],
                        j = Ca.dot(d, c),
                        k = Ca.dot(e, c),
                        l = [-j, -k],
                        m = Ca.dot(d, d) + Ca.dot(f, c),
                        n = Ca.dot(d, e) + Ca.dot(h, c),
                        o = Ca.dot(d, e) + Ca.dot(i, c),
                        p = Ca.dot(e, e) + Ca.dot(g, c),
                        q = [
                            [m, n],
                            [o, p]
                        ],
                        r = ta.solve(q, l);
                    return Ca.add(r, a)
                }; g < f;) {
                c = w(e), d = Ca.sub(c[0][0], b);
                var y = Ca.norm(d),
                    z = Ca.dot(c[1][0], d),
                    A = Ca.norm(c[1][0]) * y,
                    B = Ca.dot(c[0][1], d),
                    C = Ca.norm(c[0][1]) * y,
                    D = z / A,
                    E = B / C,
                    F = y < h,
                    G = D < i,
                    H = E < i;
                if (F && G && H) return e;
                var I = x(e, c, d);
                I[0] < j ? I = n ? [k - (I[0] - j), I[1]] : [j + S.EPSILON, I[1]] : I[0] > k && (I = n ? [j + (I[0] - k), I[1]] : [k - S.EPSILON, I[1]]), I[1] < l ? I = o ? [I[0], m - (I[1] - l)] : [I[0], l + S.EPSILON] : I[1] > m && (I = o ? [I[0], l + (I[0] - m)] : [I[0], m - S.EPSILON]);
                var J = Ca.norm(Ca.mul(I[0] - e[0], c[1][0])),
                    K = Ca.norm(Ca.mul(I[1] - e[1], c[0][1]));
                if (J + K < h) return e;
                e = I, g++
            }
            return e
        }, Da.rationalCurveClosestPoint = function(a, b) {
            return Ia.rationalCurvePoint(a, Da.rationalCurveClosestParam(a, b))
        }, Da.rationalCurveClosestParam = function(a, b) {
            for (var c = 1 / 0, d = 0, e = Ma.rationalCurveRegularSample(a, a.controlPoints.length * a.degree, !0), f = 0, g = e.length - 1; f < g;) {
                var h = f++,
                    i = e[h][0],
                    j = e[h + 1][0],
                    k = e[h].slice(1),
                    l = e[h + 1].slice(1),
                    m = Ba.segmentClosestPoint(b, k, l, i, j),
                    n = Ca.norm(Ca.sub(b, m.pt));
                n < c && (c = n, d = m.u)
            }
            for (var o, p, q = 5, r = 0, s = 1e-4, t = 5e-4, u = a.knots[0], v = P.last(a.knots), w = Ca.normSquared(Ca.sub(a.controlPoints[0], P.last(a.controlPoints))) < S.EPSILON, x = d, y = function(b) {
                    return Ia.rationalCurveDerivatives(a, b, 2)
                }, z = function(a, b, c) {
                    var d = Ca.dot(b[1], c),
                        e = Ca.dot(b[2], c),
                        f = Ca.dot(b[1], b[1]),
                        g = e + f;
                    return a - d / g
                }; r < q;) {
                o = y(x), p = Ca.sub(o[0], b);
                var A = Ca.norm(p),
                    B = Ca.dot(o[1], p),
                    C = Ca.norm(o[1]) * A,
                    D = B / C,
                    E = A < s,
                    F = Math.abs(D) < t;
                if (E && F) return x;
                var G = z(x, o, p);
                G < u ? G = w ? v - (G - u) : u : G > v && (G = w ? u + (G - v) : v);
                var H = Ca.norm(Ca.mul(G - x, o[1]));
                if (H < s) return x;
                x = G, r++
            }
            return x
        }, Da.rationalCurveParamAtArcLength = function(a, b, c, d, e) {
            if (null == c && (c = .001), b < S.EPSILON) return a.knots[0];
            var f;
            f = null != d ? d : La.decomposeCurveIntoBeziers(a);
            var g, h = 0,
                i = (f[h], -S.EPSILON);
            for (g = null != e ? e : []; i < b && h < f.length;) {
                if (h < g.length ? g[h] = g[h] : g[h] = Da.rationalBezierCurveArcLength(a), i += g[h], b < i + S.EPSILON) return Da.rationalBezierCurveParamAtArcLength(a, b, c, g[h]);
                h++
            }
            return -1
        }, Da.rationalBezierCurveParamAtArcLength = function(a, b, c, d) {
            if (b < 0) return a.knots[0];
            var e;
            if (e = null != d ? d : Da.rationalBezierCurveArcLength(a), b > e) return P.last(a.knots);
            var f, g = a.knots[0],
                h = 0,
                i = P.last(a.knots),
                j = e,
                k = 0,
                l = 0;
            for (f = null != c ? c : 2 * S.TOLERANCE; j - h > f;) k = (g + i) / 2, l = Da.rationalBezierCurveArcLength(a, k), l > b ? (i = k, j = l) : (g = k, h = l);
            return (g + i) / 2
        }, Da.rationalCurveArcLength = function(a, b, c) {
            null == c && (c = 16), b = null == b ? P.last(a.knots) : b;
            for (var d = La.decomposeCurveIntoBeziers(a), e = 0, f = d[0], g = 0; e < d.length && f.knots[0] + S.EPSILON < b;) {
                var h = Math.min(P.last(f.knots), b);
                g += Da.rationalBezierCurveArcLength(f, h, c), f = d[++e]
            }
            return g
        }, Da.rationalBezierCurveArcLength = function(a, b, c) {
            null == c && (c = 16);
            var d;
            d = null == b ? P.last(a.knots) : b;
            for (var e, f, g = (d - a.knots[0]) / 2, h = 0, i = a.degree + c, j = 0; j < i;) {
                var k = j++;
                e = g * Da.Tvalues[i][k] + g + a.knots[0], f = Ia.rationalCurveDerivatives(a, e, 1), h += Da.Cvalues[i][k] * Ca.norm(f[1])
            }
            return g * h
        };
        var Ea = b.eval.KnotMultiplicity = function(a, b) {
            this.knot = a, this.mult = b
        };
        g["verb.eval.KnotMultiplicity"] = Ea, Ea.__name__ = ["verb", "eval", "KnotMultiplicity"], Ea.prototype = {
            inc: function() {
                this.mult++
            },
            __class__: Ea
        };
        var Fa = b.eval.Check = function() {};
        g["verb.eval.Check"] = Fa, Fa.__name__ = ["verb", "eval", "Check"], Fa.isValidKnotVector = function(a, b) {
                if (0 == a.length) return !1;
                if (a.length < 2 * (b + 1)) return !1;
                for (var c = P.first(a), d = 0, e = b + 1; d < e;) {
                    var f = d++;
                    if (Math.abs(a[f] - c) > S.EPSILON) return !1
                }
                c = P.last(a);
                for (var g = a.length - b - 1, h = a.length; g < h;) {
                    var i = g++;
                    if (Math.abs(a[i] - c) > S.EPSILON) return !1
                }
                return Fa.isNonDecreasing(a)
            }, Fa.isNonDecreasing = function(a) {
                for (var b = P.first(a), c = 0, d = a.length; c < d;) {
                    var e = c++;
                    if (a[e] < b - S.EPSILON) return !1;
                    b = a[e]
                }
                return !0
            },
            Fa.isValidNurbsCurveData = function(a) {
                if (null == a.controlPoints) throw new C("Control points array cannot be null!");
                if (null == a.degree) throw new C("Degree cannot be null!");
                if (a.degree < 1) throw new C("Degree must be greater than 1!");
                if (null == a.knots) throw new C("Knots cannot be null!");
                if (a.knots.length != a.controlPoints.length + a.degree + 1) throw new C("controlPoints.length + degree + 1 must equal knots.length!");
                if (!Fa.isValidKnotVector(a.knots, a.degree)) throw new C("Invalid knot vector format!  Should begin with degree + 1 repeats and end with degree + 1 repeats!");
                return a
            }, Fa.isValidNurbsSurfaceData = function(a) {
                if (null == a.controlPoints) throw new C("Control points array cannot be null!");
                if (null == a.degreeU) throw new C("DegreeU cannot be null!");
                if (null == a.degreeV) throw new C("DegreeV cannot be null!");
                if (a.degreeU < 1) throw new C("DegreeU must be greater than 1!");
                if (a.degreeV < 1) throw new C("DegreeV must be greater than 1!");
                if (null == a.knotsU) throw new C("KnotsU cannot be null!");
                if (null == a.knotsV) throw new C("KnotsV cannot be null!");
                if (a.knotsU.length != a.controlPoints.length + a.degreeU + 1) throw new C("controlPointsU.length + degreeU + 1 must equal knotsU.length!");
                if (a.knotsV.length != a.controlPoints[0].length + a.degreeV + 1) throw new C("controlPointsV.length + degreeV + 1 must equal knotsV.length!");
                if (!Fa.isValidKnotVector(a.knotsU, a.degreeU) || !Fa.isValidKnotVector(a.knotsV, a.degreeV)) throw new C("Invalid knot vector format!  Should begin with degree + 1 repeats and end with degree + 1 repeats!");
                return a
            };
        var Ga = b.eval.Divide = function() {};
        g["verb.eval.Divide"] = Ga, Ga.__name__ = ["verb", "eval", "Divide"], Ga.surfaceSplit = function(a, b, c) {
            null == c && (c = !1);
            var d, e, f;
            c ? (f = a.controlPoints, d = a.knotsV, e = a.degreeV) : (f = ta.transpose(a.controlPoints), d = a.knotsU, e = a.degreeU);
            for (var g, h = [], i = 0, j = e + 1; i < j;) {
                i++;
                h.push(b)
            }
            g = h;
            for (var k = [], l = [], m = Ia.knotSpan(e, b, d), n = null, o = 0; o < f.length;) {
                var p = f[o];
                ++o, n = La.curveKnotRefine(new W(e, d, p), g), k.push(n.controlPoints.slice(0, m + 1)), l.push(n.controlPoints.slice(m + 1))
            }
            var q = n.knots.slice(0, m + e + 2),
                r = n.knots.slice(m + 1);
            return c ? [new X(a.degreeU, e, a.knotsU.slice(), q, k), new X(a.degreeU, e, a.knotsU.slice(), r, l)] : (k = ta.transpose(k), l = ta.transpose(l), [new X(e, a.degreeV, q, a.knotsV.slice(), k), new X(e, a.degreeV, r, a.knotsV.slice(), l)])
        }, Ga.curveSplit = function(a, b) {
            for (var c, d = a.degree, e = (a.controlPoints, a.knots), f = [], g = 0, h = d + 1; g < h;) {
                g++;
                f.push(b)
            }
            c = f;
            var i = La.curveKnotRefine(a, c),
                j = Ia.knotSpan(d, b, e),
                k = i.knots.slice(0, j + d + 2),
                l = i.knots.slice(j + 1),
                m = i.controlPoints.slice(0, j + 1),
                n = i.controlPoints.slice(j + 1);
            return [new W(d, k, m), new W(d, l, n)]
        }, Ga.rationalCurveByEqualArcLength = function(a, b) {
            var c = Da.rationalCurveArcLength(a),
                d = c / b;
            return Ga.rationalCurveByArcLength(a, d)
        }, Ga.rationalCurveByArcLength = function(a, b) {
            var c = La.decomposeCurveIntoBeziers(a),
                d = c.map(function(a) {
                    return Da.rationalBezierCurveArcLength(a)
                }),
                e = Ca.sum(d),
                f = [new Ha(a.knots[0], 0)];
            if (b > e) return f;
            for (var g, h = b, i = 0, j = h, k = 0, l = 0; i < c.length;) {
                for (k += d[i]; j < k + S.EPSILON;) g = Da.rationalBezierCurveParamAtArcLength(c[i], j - l, S.TOLERANCE, d[i]), f.push(new Ha(g, j)), j += h;
                l += d[i], i++
            }
            return f
        };
        var Ha = b.eval.CurveLengthSample = function(a, b) {
            this.u = a, this.len = b
        };
        g["verb.eval.CurveLengthSample"] = Ha, Ha.__name__ = ["verb", "eval", "CurveLengthSample"], Ha.prototype = {
            __class__: Ha
        };
        var Ia = b.eval.Eval = function() {};
        g["verb.eval.Eval"] = Ia, Ia.__name__ = ["verb", "eval", "Eval"], Ia.rationalCurveTangent = function(a, b) {
            var c = Ia.rationalCurveDerivatives(a, b, 1);
            return c[1]
        }, Ia.rationalSurfaceNormal = function(a, b, c) {
            var d = Ia.rationalSurfaceDerivatives(a, b, c, 1);
            return Ca.cross(d[1][0], d[0][1])
        }, Ia.rationalSurfaceDerivatives = function(a, b, c, d) {
            null == d && (d = 1);
            for (var e = Ia.surfaceDerivatives(a, b, c, d), f = Ia.rational2d(e), g = Ia.weight2d(e), h = [], i = f[0][0].length, j = 0, k = d + 1; j < k;) {
                var l = j++;
                h.push([]);
                for (var m = 0, n = d - l + 1; m < n;) {
                    for (var o = m++, p = f[l][o], q = 1, r = o + 1; q < r;) {
                        var s = q++;
                        p = Ca.sub(p, Ca.mul(Q.get(o, s) * g[0][s], h[l][o - s]))
                    }
                    for (var t = 1, u = l + 1; t < u;) {
                        var v = t++;
                        p = Ca.sub(p, Ca.mul(Q.get(l, v) * g[v][0], h[l - v][o]));
                        for (var w = Ca.zeros1d(i), x = 1, y = o + 1; x < y;) {
                            var z = x++;
                            w = Ca.add(w, Ca.mul(Q.get(o, z) * g[v][z], h[l - v][o - z]))
                        }
                        p = Ca.sub(p, Ca.mul(Q.get(l, v), w))
                    }
                    h[l].push(Ca.mul(1 / g[0][0], p))
                }
            }
            return h
        }, Ia.rationalSurfacePoint = function(a, b, c) {
            return Ia.dehomogenize(Ia.surfacePoint(a, b, c))
        }, Ia.rationalCurveDerivatives = function(a, b, c) {
            null == c && (c = 1);
            for (var d = Ia.curveDerivatives(a, b, c), e = Ia.rational1d(d), f = Ia.weight1d(d), g = [], h = 0, i = c + 1; h < i;) {
                for (var j = h++, k = e[j], l = 1, m = j + 1; l < m;) {
                    var n = l++;
                    k = Ca.sub(k, Ca.mul(Q.get(j, n) * f[n], g[j - n]))
                }
                g.push(Ca.mul(1 / f[0], k))
            }
            return g
        }, Ia.rationalCurvePoint = function(a, b) {
            return Ia.dehomogenize(Ia.curvePoint(a, b))
        }, Ia.surfaceDerivatives = function(a, b, c, d) {
            var e = a.knotsU.length - a.degreeU - 2,
                f = a.knotsV.length - a.degreeV - 2;
            return Ia.surfaceDerivativesGivenNM(e, f, a, b, c, d)
        }, Ia.surfaceDerivativesGivenNM = function(a, b, c, d, e, f) {
            var g = c.degreeU,
                h = c.degreeV,
                i = c.controlPoints,
                j = c.knotsU,
                k = c.knotsV;
            if (!Ia.areValidRelations(g, i.length, j.length) || !Ia.areValidRelations(h, i[0].length, k.length)) throw new C("Invalid relations between control points, knot vector, and n");
            var l, m = i[0][0].length;
            l = f < g ? f : g;
            var n;
            n = f < h ? f : h;
            for (var o = Ca.zeros3d(f + 1, f + 1, m), p = Ia.knotSpanGivenN(a, g, d, j), q = Ia.knotSpanGivenN(b, h, e, k), r = Ia.derivativeBasisFunctionsGivenNI(p, d, g, a, j), s = Ia.derivativeBasisFunctionsGivenNI(q, e, h, b, k), t = Ca.zeros2d(h + 1, m), u = 0, v = 0, w = l + 1; v < w;) {
                for (var x = v++, y = 0, z = h + 1; y < z;) {
                    var A = y++;
                    t[A] = Ca.zeros1d(m);
                    for (var B = 0, D = g + 1; B < D;) {
                        var E = B++;
                        t[A] = Ca.add(t[A], Ca.mul(r[x][E], i[p - g + E][q - h + A]))
                    }
                }
                var F = f - x;
                u = F < n ? F : n;
                for (var G = 0, H = u + 1; G < H;) {
                    var I = G++;
                    o[x][I] = Ca.zeros1d(m);
                    for (var J = 0, K = h + 1; J < K;) {
                        var L = J++;
                        o[x][I] = Ca.add(o[x][I], Ca.mul(s[I][L], t[L]))
                    }
                }
            }
            return o
        }, Ia.surfacePoint = function(a, b, c) {
            var d = a.knotsU.length - a.degreeU - 2,
                e = a.knotsV.length - a.degreeV - 2;
            return Ia.surfacePointGivenNM(d, e, a, b, c)
        }, Ia.surfacePointGivenNM = function(a, b, c, d, e) {
            var f = c.degreeU,
                g = c.degreeV,
                h = c.controlPoints,
                i = c.knotsU,
                j = c.knotsV;
            if (!Ia.areValidRelations(f, h.length, i.length) || !Ia.areValidRelations(g, h[0].length, j.length)) throw new C("Invalid relations between control points, knot vector, and n");
            for (var k = h[0][0].length, l = Ia.knotSpanGivenN(a, f, d, i), m = Ia.knotSpanGivenN(b, g, e, j), n = Ia.basisFunctionsGivenKnotSpanIndex(l, d, f, i), o = Ia.basisFunctionsGivenKnotSpanIndex(m, e, g, j), p = l - f, q = m, r = Ca.zeros1d(k), s = Ca.zeros1d(k), t = 0, u = g + 1; t < u;) {
                var v = t++;
                s = Ca.zeros1d(k), q = m - g + v;
                for (var w = 0, x = f + 1; w < x;) {
                    var y = w++;
                    s = Ca.add(s, Ca.mul(n[y], h[p + y][q]))
                }
                r = Ca.add(r, Ca.mul(o[v], s))
            }
            return r
        }, Ia.curveDerivatives = function(a, b, c) {
            var d = a.knots.length - a.degree - 2;
            return Ia.curveDerivativesGivenN(d, a, b, c)
        }, Ia.curveDerivativesGivenN = function(a, b, c, d) {
            var e = b.degree,
                f = b.controlPoints,
                g = b.knots;
            if (!Ia.areValidRelations(e, f.length, g.length)) throw new C("Invalid relations between control points, knot vector, and n");
            var h, i = f[0].length;
            h = d < e ? d : e;
            for (var j = Ca.zeros2d(d + 1, i), k = Ia.knotSpanGivenN(a, e, c, g), l = Ia.derivativeBasisFunctionsGivenNI(k, c, e, h, g), m = 0, n = h + 1; m < n;)
                for (var o = m++, p = 0, q = e + 1; p < q;) {
                    var r = p++;
                    j[o] = Ca.add(j[o], Ca.mul(l[o][r], f[k - e + r]))
                }
            return j
        }, Ia.curvePoint = function(a, b) {
            var c = a.knots.length - a.degree - 2;
            return Ia.curvePointGivenN(c, a, b)
        }, Ia.areValidRelations = function(a, b, c) {
            return b + a + 1 - c == 0
        }, Ia.curvePointGivenN = function(a, b, c) {
            var d = b.degree,
                e = b.controlPoints,
                f = b.knots;
            if (!Ia.areValidRelations(d, e.length, f.length)) throw new C("Invalid relations between control points, knot Array, and n");
            for (var g = Ia.knotSpanGivenN(a, d, c, f), h = Ia.basisFunctionsGivenKnotSpanIndex(g, c, d, f), i = Ca.zeros1d(e[0].length), j = 0, k = d + 1; j < k;) {
                var l = j++;
                i = Ca.add(i, Ca.mul(h[l], e[g - d + l]))
            }
            return i
        }, Ia.volumePoint = function(a, b, c, d) {
            var e = a.knotsU.length - a.degreeU - 2,
                f = a.knotsV.length - a.degreeV - 2,
                g = a.knotsW.length - a.degreeW - 2;
            return Ia.volumePointGivenNML(a, e, f, g, b, c, d)
        }, Ia.volumePointGivenNML = function(a, b, c, d, e, f, g) {
            if (!Ia.areValidRelations(a.degreeU, a.controlPoints.length, a.knotsU.length) || !Ia.areValidRelations(a.degreeV, a.controlPoints[0].length, a.knotsV.length) || !Ia.areValidRelations(a.degreeW, a.controlPoints[0][0].length, a.knotsW.length)) throw new C("Invalid relations between control points and knot vector");
            for (var h = a.controlPoints, i = a.degreeU, j = a.degreeV, k = a.degreeW, l = a.knotsU, m = a.knotsV, n = a.knotsW, o = h[0][0][0].length, p = Ia.knotSpanGivenN(b, i, e, l), q = Ia.knotSpanGivenN(c, j, f, m), r = Ia.knotSpanGivenN(d, k, g, n), s = Ia.basisFunctionsGivenKnotSpanIndex(p, e, i, l), t = Ia.basisFunctionsGivenKnotSpanIndex(q, f, j, m), u = Ia.basisFunctionsGivenKnotSpanIndex(r, g, k, n), v = p - i, w = Ca.zeros1d(o), x = Ca.zeros1d(o), y = Ca.zeros1d(o), z = 0, A = k + 1; z < A;) {
                var B = z++;
                y = Ca.zeros1d(o);
                for (var D = r - k + B, E = 0, F = j + 1; E < F;) {
                    var G = E++;
                    x = Ca.zeros1d(o);
                    for (var H = q - j + G, I = 0, J = i + 1; I < J;) {
                        var K = I++;
                        x = Ca.add(x, Ca.mul(s[K], h[v + K][H][D]))
                    }
                    y = Ca.add(y, Ca.mul(t[G], x))
                }
                w = Ca.add(w, Ca.mul(u[B], y))
            }
            return w
        }, Ia.derivativeBasisFunctions = function(a, b, c) {
            var d = Ia.knotSpan(b, a, c),
                e = c.length - 1,
                f = e - b - 1;
            return Ia.derivativeBasisFunctionsGivenNI(d, a, b, f, c)
        }, Ia.derivativeBasisFunctionsGivenNI = function(a, b, c, d, e) {
            var f = Ca.zeros2d(c + 1, c + 1),
                g = Ca.zeros1d(c + 1),
                h = Ca.zeros1d(c + 1),
                i = 0,
                j = 0;
            f[0][0] = 1;
            for (var k = 1, l = c + 1; k < l;) {
                var m = k++;
                g[m] = b - e[a + 1 - m], h[m] = e[a + m] - b, i = 0;
                for (var n = 0; n < m;) {
                    var o = n++;
                    f[m][o] = h[o + 1] + g[m - o], j = f[o][m - 1] / f[m][o], f[o][m] = i + h[o + 1] * j, i = g[m - o] * j
                }
                f[m][m] = i
            }
            for (var p = Ca.zeros2d(d + 1, c + 1), q = Ca.zeros2d(2, c + 1), r = 0, s = 1, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = c + 1; y < z;) {
                var A = y++;
                p[0][A] = f[A][c]
            }
            for (var B = 0, C = c + 1; B < C;) {
                var D = B++;
                r = 0, s = 1, q[0][0] = 1;
                for (var E = 1, F = d + 1; E < F;) {
                    var G = E++;
                    t = 0, u = D - G, v = c - G, D >= G && (q[s][0] = q[r][0] / f[v + 1][u], t = q[s][0] * f[u][v]), w = u >= -1 ? 1 : -u, x = D - 1 <= v ? G - 1 : c - D;
                    for (var H = w, I = x + 1; H < I;) {
                        var J = H++;
                        q[s][J] = (q[r][J] - q[r][J - 1]) / f[v + 1][u + J], t += q[s][J] * f[u + J][v]
                    }
                    D <= v && (q[s][G] = -q[r][G - 1] / f[v + 1][D], t += q[s][G] * f[D][v]), p[G][D] = t;
                    var K = r;
                    r = s, s = K
                }
            }
            for (var L = c, M = 1, N = d + 1; M < N;) {
                for (var O = M++, P = 0, Q = c + 1; P < Q;) {
                    var R = P++;
                    p[O][R] *= L
                }
                L *= c - O
            }
            return p
        }, Ia.basisFunctions = function(a, b, c) {
            var d = Ia.knotSpan(b, a, c);
            return Ia.basisFunctionsGivenKnotSpanIndex(d, a, b, c)
        }, Ia.basisFunctionsGivenKnotSpanIndex = function(a, b, c, d) {
            var e = Ca.zeros1d(c + 1),
                f = Ca.zeros1d(c + 1),
                g = Ca.zeros1d(c + 1),
                h = 0,
                i = 0;
            e[0] = 1;
            for (var j = 1, k = c + 1; j < k;) {
                var l = j++;
                f[l] = b - d[a + 1 - l], g[l] = d[a + l] - b, h = 0;
                for (var m = 0; m < l;) {
                    var n = m++;
                    i = e[n] / (g[n + 1] + f[l - n]), e[n] = h + g[n + 1] * i, h = f[l - n] * i
                }
                e[l] = h
            }
            return e
        }, Ia.knotSpan = function(a, b, c) {
            return Ia.knotSpanGivenN(c.length - a - 2, a, b, c)
        }, Ia.knotSpanGivenN = function(a, b, c, d) {
            if (c > d[a + 1] - S.EPSILON) return a;
            if (c < d[b] + S.EPSILON) return b;
            for (var e = b, f = a + 1, g = Math.floor((e + f) / 2); c < d[g] || c >= d[g + 1];) c < d[g] ? f = g : e = g, g = Math.floor((e + f) / 2);
            return g
        }, Ia.dehomogenize = function(a) {
            for (var b = a.length, c = [], d = a[b - 1], e = a.length - 1, f = 0; f < e;) {
                var g = f++;
                c.push(a[g] / d)
            }
            return c
        }, Ia.rational1d = function(a) {
            var b = a[0].length - 1;
            return a.map(function(a) {
                return a.slice(0, b)
            })
        }, Ia.rational2d = function(a) {
            return a.map(Ia.rational1d)
        }, Ia.weight1d = function(a) {
            var b = a[0].length - 1;
            return a.map(function(a) {
                return a[b]
            })
        }, Ia.weight2d = function(a) {
            return a.map(Ia.weight1d)
        }, Ia.dehomogenize1d = function(a) {
            return a.map(Ia.dehomogenize)
        }, Ia.dehomogenize2d = function(a) {
            return a.map(Ia.dehomogenize1d)
        }, Ia.homogenize1d = function(a, b) {
            var c, d = a.length,
                e = a[0].length,
                f = [],
                g = 0,
                h = [];
            c = null != b ? b : Ca.rep(a.length, 1);
            for (var i = 0; i < d;) {
                var j = i++,
                    k = [];
                h = a[j], g = c[j];
                for (var l = 0; l < e;) {
                    var m = l++;
                    k.push(h[m] * g)
                }
                k.push(g), f.push(k)
            }
            return f
        }, Ia.homogenize2d = function(a, b) {
            var c, d = a.length,
                e = [];
            if (null != b) c = b;
            else {
                for (var f = [], g = 0; g < d;) {
                    g++;
                    f.push(Ca.rep(a[0].length, 1))
                }
                c = f
            }
            for (var h = 0; h < d;) {
                var i = h++;
                e.push(Ia.homogenize1d(a[i], c[i]))
            }
            return e
        };
        var Ja = b.eval.Intersect = function() {};
        g["verb.eval.Intersect"] = Ja, Ja.__name__ = ["verb", "eval", "Intersect"], Ja.surfaces = function(a, b, c) {
            var d = Ma.rationalSurfaceAdaptive(a),
                e = Ma.rationalSurfaceAdaptive(b),
                f = Ja.meshes(d, e),
                g = f.map(function(d) {
                    return d.map(function(d) {
                        return Ja.surfacesAtPointWithEstimate(a, b, d.uv0, d.uv1, c)
                    })
                });
            return g.map(function(a) {
                return Ka.rationalInterpCurve(a.map(function(a) {
                    return a.point
                }), 3)
            })
        }, Ja.surfacesAtPointWithEstimate = function(a, b, c, d, e) {
            var f, g, h, i, j, k, l, m, n, o, p, q, r, s = 5,
                t = 0;
            do {
                if (f = Ia.rationalSurfaceDerivatives(a, c[0], c[1], 1), g = f[0][0], i = f[1][0], j = f[0][1], h = Ca.normalized(Ca.cross(i, j)), k = Ca.dot(h, g), l = Ia.rationalSurfaceDerivatives(b, d[0], d[1], 1), m = l[0][0], o = l[1][0], p = l[0][1], n = Ca.normalized(Ca.cross(o, p)), q = Ca.dot(n, m), r = Ca.distSquared(g, m), r < e * e) break;
                var u = Ca.normalized(Ca.cross(h, n)),
                    v = Ca.dot(u, g),
                    w = Ja.threePlanes(h, k, n, q, u, v);
                if (null == w) throw new C("panic!");
                var x = Ca.sub(w, g),
                    y = Ca.sub(w, m),
                    z = Ca.cross(i, h),
                    A = Ca.cross(j, h),
                    B = Ca.cross(o, n),
                    D = Ca.cross(p, n),
                    E = Ca.dot(A, x) / Ca.dot(A, i),
                    F = Ca.dot(z, x) / Ca.dot(z, j),
                    G = Ca.dot(D, y) / Ca.dot(D, o),
                    H = Ca.dot(B, y) / Ca.dot(B, p);
                c = Ca.add([E, F], c), d = Ca.add([G, H], d), t++
            } while (t < s);
            return new fa(c, d, g, r)
        }, Ja.meshes = function(a, b, c, d) {
            null == c && (c = new qa(a)), null == d && (d = new qa(b));
            var e = Ja.boundingBoxTrees(c, d, 0),
                f = P.unique(e.map(function(c) {
                    return Ja.triangles(a, c.item0, b, c.item1)
                }).filter(function(a) {
                    return null != a
                }).filter(function(a) {
                    return Ca.distSquared(a.min.point, a.max.point) > S.EPSILON
                }), function(a, b) {
                    var c = Ca.sub(a.min.uv0, b.min.uv0),
                        d = Ca.dot(c, c),
                        e = Ca.sub(a.max.uv0, b.max.uv0),
                        f = Ca.dot(e, e),
                        g = Ca.sub(a.min.uv0, b.max.uv0),
                        h = Ca.dot(g, g),
                        i = Ca.sub(a.max.uv0, b.min.uv0),
                        j = Ca.dot(i, i);
                    return d < S.EPSILON && f < S.EPSILON || h < S.EPSILON && j < S.EPSILON
                });
            return Ja.makeMeshIntersectionPolylines(f)
        }, Ja.meshSlices = function(a, b, c, d) {
            for (var e = new wa(a), f = e.boundingBox(), g = f.min[0], h = f.min[1], i = f.max[0], j = f.max[1], k = Ca.span(b, c, d), l = [], m = 0; m < k.length;) {
                var n = k[m];
                ++m;
                var o = [
                        [g, h, n],
                        [i, h, n],
                        [i, j, n],
                        [g, j, n]
                    ],
                    p = [
                        [0, 0],
                        [1, 0],
                        [1, 1],
                        [0, 1]
                    ],
                    q = [
                        [0, 1, 2],
                        [0, 2, 3]
                    ],
                    r = new Y(q, o, null, p);
                l.push(Ja.meshes(a, r, e))
            }
            return l
        }, Ja.makeMeshIntersectionPolylines = function(a) {
            if (0 == a.length) return [];
            for (var b = 0; b < a.length;) {
                var c = a[b];
                ++b, c.max.opp = c.min, c.min.opp = c.max
            }
            for (var d = Ja.kdTreeFromSegments(a), e = [], f = 0; f < a.length;) {
                var g = a[f];
                ++f, e.push(g.min), e.push(g.max)
            }
            for (var h = 0; h < e.length;) {
                var i = e[h];
                if (++h, null == i.adj) {
                    var j = Ja.lookupAdjacentSegment(i, d, a.length);
                    null != j && null == j.adj && (i.adj = j, j.adj = i)
                }
            }
            var k = e.filter(function(a) {
                return null == a.adj
            });
            0 == k.length && (k = e);
            for (var l = [], m = 0, n = !1; 0 != k.length;) {
                var o = k.pop();
                if (!o.visited) {
                    for (var p = [], q = o; null != q && !q.visited && (q.visited = !0, q.opp.visited = !0, p.push(q), m += 2, q = q.opp.adj, q != o););
                    p.length > 0 && (p.push(p[p.length - 1].opp), l.push(p))
                }
                if (0 == k.length && e.length > 0 && (n || m < e.length)) {
                    n = !0;
                    var r = e.pop();
                    k.push(r)
                }
            }
            return l
        }, Ja.kdTreeFromSegments = function(a) {
            for (var b = [], c = 0; c < a.length;) {
                var d = a[c];
                ++c, b.push(new ma(d.min.point, d.min)), b.push(new ma(d.max.point, d.max))
            }
            return new ka(b, Ca.distSquared)
        }, Ja.lookupAdjacentSegment = function(a, b, c) {
            var d = b.nearest(a.point, c, S.EPSILON).filter(function(b) {
                return a != b.item0.obj
            }).map(function(a) {
                return a.item0.obj
            });
            return 1 == d.length ? d[0] : null
        }, Ja.curveAndSurface = function(a, b, c, d, e) {
            null == c && (c = .001), d = null != d ? d : new pa(a), e = null != e ? e : new sa(b);
            var f = Ja.boundingBoxTrees(d, e, c);
            return P.unique(f.map(function(a) {
                var b = a.item0,
                    d = a.item1,
                    e = P.first(b.knots),
                    f = P.last(b.knots),
                    g = (e + f) / 2,
                    h = P.first(d.knotsU),
                    i = P.last(d.knotsU),
                    j = P.first(d.knotsV),
                    k = P.last(d.knotsV),
                    l = [(h + i) / 2, (j + k) / 2];
                return Ja.curveAndSurfaceWithEstimate(b, d, [g].concat(l), c)
            }).filter(function(a) {
                return Ca.distSquared(a.curvePoint, a.surfacePoint) < c * c
            }), function(a, b) {
                return Math.abs(a.u - b.u) < .5 * c
            })
        }, Ja.curveAndSurfaceWithEstimate = function(a, b, c, d) {
            null == d && (d = .001);
            var e = function(c) {
                    var d = Ia.rationalCurvePoint(a, c[0]),
                        e = Ia.rationalSurfacePoint(b, c[1], c[2]),
                        f = Ca.sub(d, e);
                    return Ca.dot(f, f)
                },
                f = function(c) {
                    var d = Ia.rationalCurveDerivatives(a, c[0], 1),
                        e = Ia.rationalSurfaceDerivatives(b, c[1], c[2], 1),
                        f = Ca.sub(e[0][0], d[0]),
                        g = Ca.mul(-1, d[1]),
                        h = e[1][0],
                        i = e[0][1];
                    return [2 * Ca.dot(g, f), 2 * Ca.dot(h, f), 2 * Ca.dot(i, f)]
                },
                g = xa.uncmin(e, c, d * d, f),
                h = g.solution;
            return new ca(h[0], [h[1], h[2]], Ia.rationalCurvePoint(a, h[0]), Ia.rationalSurfacePoint(b, h[1], h[2]))
        }, Ja.polylineAndMesh = function(a, b, c) {
            for (var d = Ja.boundingBoxTrees(new ra(a), new qa(b), c), e = [], f = 0; f < d.length;) {
                var g = d[f];
                ++f;
                var h = g.item0,
                    i = g.item1,
                    j = Ja.segmentWithTriangle(a.points[h], a.points[h + 1], b.points, b.faces[i]);
                if (null != j) {
                    var k = j.point,
                        l = Ca.lerp(j.p, [a.params[h]], [a.params[h + 1]])[0],
                        m = va.triangleUVFromPoint(b, i, k);
                    e.push(new ea(k, l, m, h, i))
                }
            }
            return e
        }, Ja.boundingBoxTrees = function(a, b, c) {
            null == c && (c = 1e-9);
            var d = [],
                e = [];
            d.push(a), e.push(b);
            for (var f = []; d.length > 0;) {
                var g = d.pop(),
                    h = e.pop();
                if (!g.empty() && !h.empty() && g.boundingBox().intersects(h.boundingBox(), c)) {
                    var i = g.indivisible(c),
                        j = h.indivisible(c);
                    if (i && j) f.push(new _(g.yield(), h.yield()));
                    else if (!i || j)
                        if (i || !j) {
                            var k = g.split(),
                                l = h.split();
                            d.push(k.item1), e.push(l.item1), d.push(k.item1), e.push(l.item0), d.push(k.item0), e.push(l.item1), d.push(k.item0), e.push(l.item0)
                        } else {
                            var m = g.split();
                            d.push(m.item1), e.push(h), d.push(m.item0), e.push(h)
                        } else {
                        var n = h.split();
                        d.push(g), e.push(n.item1), d.push(g), e.push(n.item0)
                    }
                }
            }
            return f
        }, Ja.curves = function(a, b, c) {
            var d = Ja.boundingBoxTrees(new pa(a), new pa(b), 0);
            return P.unique(d.map(function(d) {
                return Ja.curvesWithEstimate(a, b, P.first(d.item0.knots), P.first(d.item1.knots), c)
            }).filter(function(a) {
                return Ca.distSquared(a.point0, a.point1) < c
            }), function(a, b) {
                return Math.abs(a.u0 - b.u0) < 5 * c
            })
        }, Ja.curvesWithEstimate = function(a, b, c, d, e) {
            var f = function(c) {
                    var d = Ia.rationalCurvePoint(a, c[0]),
                        e = Ia.rationalCurvePoint(b, c[1]),
                        f = Ca.sub(d, e);
                    return Ca.dot(f, f)
                },
                g = function(c) {
                    var d = Ia.rationalCurveDerivatives(a, c[0], 1),
                        e = Ia.rationalCurveDerivatives(b, c[1], 1),
                        f = Ca.sub(d[0], e[0]),
                        g = d[1],
                        h = Ca.mul(-1, e[1]);
                    return [2 * Ca.dot(g, f), 2 * Ca.dot(h, f)]
                },
                h = xa.uncmin(f, [c, d], e * e, g),
                i = h.solution[0],
                j = h.solution[1],
                k = Ia.rationalCurvePoint(a, i),
                l = Ia.rationalCurvePoint(b, j);
            return new ba(k, l, i, j)
        }, Ja.triangles = function(a, b, c, d) {
            var e = a.faces[b],
                f = c.faces[d],
                g = va.getTriangleNorm(a.points, e),
                h = va.getTriangleNorm(c.points, f),
                i = a.points[e[0]],
                j = c.points[f[0]],
                k = Ja.planes(i, g, j, h);
            if (null == k) return null;
            var l = Ja.clipRayInCoplanarTriangle(k, a, b);
            if (null == l) return null;
            var m = Ja.clipRayInCoplanarTriangle(k, c, d);
            if (null == m) return null;
            var n = Ja.mergeTriangleClipIntervals(l, m, a, b, c, d);
            return null == n ? null : new aa(new da(n.min.uv0, n.min.uv1, n.min.point, b, d), new da(n.max.uv0, n.max.uv1, n.max.point, b, d))
        }, Ja.clipRayInCoplanarTriangle = function(a, b, c) {
            for (var d = b.faces[c], e = [b.points[d[0]], b.points[d[1]], b.points[d[2]]], f = [b.uvs[d[0]], b.uvs[d[1]], b.uvs[d[2]]], g = [Ca.sub(f[1], f[0]), Ca.sub(f[2], f[1]), Ca.sub(f[0], f[2])], h = [Ca.sub(e[1], e[0]), Ca.sub(e[2], e[1]), Ca.sub(e[0], e[2])], i = h.map(Ca.normalized), j = h.map(Ca.norm), k = null, l = null, m = 0; m < 3;) {
                var n = m++,
                    o = e[n],
                    p = i[n],
                    q = Ja.rays(o, p, a.origin, a.dir);
                if (null != q) {
                    var r = q.u0,
                        s = q.u1;
                    r < -S.EPSILON || r > j[n] + S.EPSILON || ((null == k || s < k.u) && (k = new ha(s, Ca.onRay(a.origin, a.dir, s), Ca.onRay(f[n], g[n], r / j[n]))), (null == l || s > l.u) && (l = new ha(s, Ca.onRay(a.origin, a.dir, s), Ca.onRay(f[n], g[n], r / j[n]))))
                }
            }
            return null == l || null == k ? null : new aa(k, l)
        }, Ja.mergeTriangleClipIntervals = function(a, b, c, d, e, f) {
            if (b.min.u > a.max.u + S.EPSILON || a.min.u > b.max.u + S.EPSILON) return null;
            var g;
            g = a.min.u > b.min.u ? new _(a.min, 0) : new _(b.min, 1);
            var h;
            h = a.max.u < b.max.u ? new _(a.max, 0) : new _(b.max, 1);
            var i = new aa(new da(null, null, g.item0.point, d, f), new da(null, null, h.item0.point, d, f));
            return 0 == g.item1 ? (i.min.uv0 = g.item0.uv, i.min.uv1 = va.triangleUVFromPoint(e, f, g.item0.point)) : (i.min.uv0 = va.triangleUVFromPoint(c, d, g.item0.point), i.min.uv1 = g.item0.uv), 0 == h.item1 ? (i.max.uv0 = h.item0.uv, i.max.uv1 = va.triangleUVFromPoint(e, f, h.item0.point)) : (i.max.uv0 = va.triangleUVFromPoint(c, d, h.item0.point), i.max.uv1 = h.item0.uv), i
        }, Ja.planes = function(a, b, c, d) {
            var e = Ca.cross(b, d);
            if (Ca.dot(e, e) < S.EPSILON) return null;
            var f = 0,
                g = Math.abs(e[0]),
                h = Math.abs(e[1]),
                i = Math.abs(e[2]);
            h > g && (f = 1, g = h), i > g && (f = 2, g = i);
            var j, k, l, m;
            0 == f ? (j = b[1], k = b[2], l = d[1], m = d[2]) : 1 == f ? (j = b[0], k = b[2], l = d[0], m = d[2]) : (j = b[0], k = b[1], l = d[0], m = d[1]);
            var n, o = -Ca.dot(a, b),
                p = -Ca.dot(c, d),
                q = j * m - k * l,
                r = (k * p - o * m) / q,
                s = (o * l - j * p) / q;
            return n = 0 == f ? [0, r, s] : 1 == f ? [r, 0, s] : [r, s, 0], new V(n, Ca.normalized(e))
        }, Ja.threePlanes = function(a, b, c, d, e, f) {
            var g = Ca.cross(c, e),
                h = Ca.dot(a, g);
            if (Math.abs(h) < S.EPSILON) return null;
            var i = Ca.sub(Ca.mul(f, c), Ca.mul(d, e)),
                j = Ca.add(Ca.mul(b, g), Ca.cross(a, i));
            return Ca.mul(1 / h, j)
        }, Ja.polylines = function(a, b, c) {
            for (var d = Ja.boundingBoxTrees(new ra(a), new ra(b), c), e = [], f = 0; f < d.length;) {
                var g = d[f];
                ++f;
                var h = g.item0,
                    i = g.item1,
                    j = Ja.segments(a.points[h], a.points[h + 1], b.points[i], b.points[i + 1], c);
                null != j && (j.u0 = Ca.lerp(j.u0, [a.params[h]], [a.params[h + 1]])[0], j.u1 = Ca.lerp(j.u1, [b.params[i]], [b.params[i + 1]])[0], e.push(j))
            }
            return e
        }, Ja.segments = function(a, b, c, d, e) {
            var f = Ca.sub(b, a),
                g = Math.sqrt(Ca.dot(f, f)),
                h = Ca.mul(1 / g, f),
                i = Ca.sub(d, c),
                j = Math.sqrt(Ca.dot(i, i)),
                k = Ca.mul(1 / j, i),
                l = Ja.rays(a, h, c, k);
            if (null != l) {
                var m = Math.min(Math.max(0, l.u0 / g), 1),
                    n = Math.min(Math.max(0, l.u1 / j), 1),
                    o = Ca.onRay(a, f, m),
                    p = Ca.onRay(c, i, n),
                    q = Ca.distSquared(o, p);
                if (q < e * e) return new ba(o, p, m, n)
            }
            return null
        }, Ja.rays = function(a, b, c, d) {
            var e = Ca.dot(b, d),
                f = Ca.dot(b, c),
                g = Ca.dot(b, a),
                h = Ca.dot(d, c),
                i = Ca.dot(d, a),
                j = Ca.dot(b, b),
                k = Ca.dot(d, d),
                l = j * k - e * e;
            if (Math.abs(l) < S.EPSILON) return null;
            var m = e * (f - g) - j * (h - i),
                n = m / l,
                o = (f - g + n * e) / j,
                p = Ca.onRay(a, b, o),
                q = Ca.onRay(c, d, n);
            return new ba(p, q, o, n)
        }, Ja.segmentWithTriangle = function(a, b, c, d) {
            var e = c[d[0]],
                f = c[d[1]],
                g = c[d[2]],
                h = Ca.sub(f, e),
                i = Ca.sub(g, e),
                j = Ca.cross(h, i),
                k = Ca.sub(b, a),
                l = Ca.sub(a, e),
                m = -Ca.dot(j, l),
                n = Ca.dot(j, k);
            if (Math.abs(n) < S.EPSILON) return null;
            var o = m / n;
            if (o < 0 || o > 1) return null;
            var p = Ca.add(a, Ca.mul(o, k)),
                q = Ca.dot(h, i),
                r = Ca.dot(h, h),
                s = Ca.dot(i, i),
                t = Ca.sub(p, e),
                u = Ca.dot(t, h),
                v = Ca.dot(t, i),
                w = q * q - r * s;
            if (Math.abs(w) < S.EPSILON) return null;
            var x = (q * v - s * u) / w,
                y = (q * u - r * v) / w;
            return x > 1 + S.EPSILON || y > 1 + S.EPSILON || y < -S.EPSILON || x < -S.EPSILON || x + y > 1 + S.EPSILON ? null : new ga(p, x, y, o)
        }, Ja.segmentAndPlane = function(a, b, c, d) {
            var e = Ca.dot(d, Ca.sub(b, a));
            if (Math.abs(e) < S.EPSILON) return null;
            var f = Ca.dot(d, Ca.sub(c, a)),
                g = f / e;
            return g > 1 + S.EPSILON || g < -S.EPSILON ? null : {
                p: g
            }
        };
        var Ka = b.eval.Make = function() {};
        g["verb.eval.Make"] = Ka, Ka.__name__ = ["verb", "eval", "Make"], Ka.rationalTranslationalSurface = function(a, b) {
            for (var c = Ia.rationalCurvePoint(b, P.first(b.knots)), d = P.first(b.knots), e = P.last(b.knots), f = 2 * b.controlPoints.length, g = (e - d) / (f - 1), h = [], i = 0; i < f;) {
                var j = i++,
                    k = Ca.sub(Ia.rationalCurvePoint(b, d + j * g), c),
                    l = La.rationalCurveTransform(a, [
                        [1, 0, 0, k[0]],
                        [0, 1, 0, k[1]],
                        [0, 0, 1, k[2]],
                        [0, 0, 0, 1]
                    ]);
                h.push(l)
            }
            return Ka.loftedSurface(h)
        }, Ka.surfaceBoundaryCurves = function(a) {
            var b = Ka.surfaceIsocurve(a, P.first(a.knotsU), !1),
                c = Ka.surfaceIsocurve(a, P.last(a.knotsU), !1),
                d = Ka.surfaceIsocurve(a, P.first(a.knotsV), !0),
                e = Ka.surfaceIsocurve(a, P.last(a.knotsV), !0);
            return [b, c, d, e]
        }, Ka.surfaceIsocurve = function(a, b, c) {
            null == c && (c = !1);
            var d;
            d = c ? a.knotsV : a.knotsU;
            var e;
            e = c ? a.degreeV : a.degreeU;
            for (var f = Da.knotMultiplicities(d), g = -1, h = 0, i = f.length; h < i;) {
                var j = h++;
                if (Math.abs(b - f[j].knot) < S.EPSILON) {
                    g = j;
                    break
                }
            }
            var k = e + 1;
            g >= 0 && (k -= f[g].mult);
            var l;
            l = k > 0 ? La.surfaceKnotRefine(a, Ca.rep(k, b), c) : a;
            var m = Ia.knotSpan(e, b, d);
            return Math.abs(b - P.first(d)) < S.EPSILON ? m = 0 : Math.abs(b - P.last(d)) < S.EPSILON && (m = (c ? l.controlPoints[0].length : l.controlPoints.length) - 1), c ? new W(l.degreeU, l.knotsU, function(a) {
                for (var b, c = [], d = 0, e = l.controlPoints; d < e.length;) {
                    var f = e[d];
                    ++d, c.push(f[m])
                }
                return b = c
            }(this)) : new W(l.degreeV, l.knotsV, l.controlPoints[m])
        }, Ka.loftedSurface = function(a, b) {
            a = La.unifyCurveKnotVectors(a);
            var c = a[0].degree;
            null == b && (b = 3), b > a.length - 1 && (b = a.length - 1);
            for (var d = a[0].knots, e = [], f = [], g = 0, h = a[0].controlPoints.length; g < h;) {
                var i = [g++],
                    j = a.map(function(a) {
                        return function(b) {
                            return b.controlPoints[a[0]]
                        }
                    }(i)),
                    k = Ka.rationalInterpCurve(j, b, !0);
                f.push(k.controlPoints), e = k.knots
            }
            return new X(c, b, d, e, f)
        }, Ka.clonedCurve = function(a) {
            return new W(a.degree, a.knots.slice(), a.controlPoints.map(function(a) {
                return a.slice()
            }))
        }, Ka.rationalBezierCurve = function(a, b) {
            for (var c = a.length - 1, d = [], e = 0, f = c + 1; e < f;) {
                e++;
                d.push(0)
            }
            for (var g = 0, h = c + 1; g < h;) {
                g++;
                d.push(1)
            }
            return null == b && (b = Ca.rep(a.length, 1)), new W(c, d, Ia.homogenize1d(a, b))
        }, Ka.fourPointSurface = function(a, b, c, d, e) {
            null == e && (e = 3);
            for (var f = e, g = [], h = 0, i = e + 1; h < i;) {
                for (var j = h++, k = [], l = 0, m = e + 1; l < m;) {
                    var n = l++,
                        o = 1 - j / f,
                        p = Ca.lerp(o, a, b),
                        q = Ca.lerp(o, d, c),
                        r = Ca.lerp(1 - n / f, p, q);
                    r.push(1), k.push(r)
                }
                g.push(k)
            }
            var s = Ca.rep(e + 1, 0),
                t = Ca.rep(e + 1, 1);
            return new X(e, e, s.concat(t), s.concat(t), g)
        }, Ka.ellipseArc = function(a, b, c, d, e) {
            var f = Ca.norm(b),
                g = Ca.norm(c);
            b = Ca.normalized(b), c = Ca.normalized(c), e < d && (e = 2 * Math.PI + d);
            var h = e - d,
                i = 0;
            i = h <= Math.PI / 2 ? 1 : h <= Math.PI ? 2 : h <= 3 * Math.PI / 2 ? 3 : 4;
            var j = h / i,
                k = Math.cos(j / 2),
                l = Ca.add(a, Ca.add(Ca.mul(f * Math.cos(d), b), Ca.mul(g * Math.sin(d), c))),
                m = Ca.sub(Ca.mul(Math.cos(d), c), Ca.mul(Math.sin(d), b)),
                n = [],
                o = Ca.zeros1d(2 * i + 3),
                p = 0,
                q = d,
                r = Ca.zeros1d(2 * i);
            n[0] = l, r[0] = 1;
            for (var s = 1, t = i + 1; s < t;) {
                var u = s++;
                q += j;
                var v = Ca.add(a, Ca.add(Ca.mul(f * Math.cos(q), b), Ca.mul(g * Math.sin(q), c)));
                r[p + 2] = 1, n[p + 2] = v;
                var w = Ca.sub(Ca.mul(Math.cos(q), c), Ca.mul(Math.sin(q), b)),
                    x = Ja.rays(l, Ca.mul(1 / Ca.norm(m), m), v, Ca.mul(1 / Ca.norm(w), w)),
                    y = Ca.add(l, Ca.mul(x.u0, m));
                r[p + 1] = k, n[p + 1] = y, p += 2, u < i && (l = v, m = w)
            }
            for (var z = 2 * i + 1, A = 0; A < 3;) {
                var B = A++;
                o[B] = 0, o[B + z] = 1
            }
            switch (i) {
                case 2:
                    o[3] = o[4] = .5;
                    break;
                case 3:
                    o[3] = o[4] = .3333333333333333, o[5] = o[6] = .6666666666666666;
                    break;
                case 4:
                    o[3] = o[4] = .25, o[5] = o[6] = .5, o[7] = o[8] = .75
            }
            return new W(2, o, Ia.homogenize1d(n, r))
        }, Ka.arc = function(a, b, c, d, e, f) {
            return Ka.ellipseArc(a, Ca.mul(d, Ca.normalized(b)), Ca.mul(d, Ca.normalized(c)), e, f)
        }, Ka.polyline = function(a) {
            for (var b = [0, 0], c = 0, d = 0, e = a.length - 1; d < e;) {
                var f = d++;
                c += Ca.dist(a[f], a[f + 1]), b.push(c)
            }
            b.push(c), b = Ca.mul(1 / c, b);
            for (var g, h = [], i = 0, j = a.length; i < j;) {
                i++;
                h.push(1)
            }
            return g = h, new W(1, b, Ia.homogenize1d(a.slice(0), g))
        }, Ka.extrudedSurface = function(a, b, c) {
            for (var d = [
                    [],
                    [],
                    []
                ], e = [
                    [],
                    [],
                    []
                ], f = Ia.dehomogenize1d(c.controlPoints), g = Ia.weight1d(c.controlPoints), h = Ca.mul(b, a), i = Ca.mul(.5 * b, a), j = 0, k = f.length; j < k;) {
                var l = j++;
                d[2][l] = f[l], d[1][l] = Ca.add(i, f[l]), d[0][l] = Ca.add(h, f[l]), e[0][l] = g[l], e[1][l] = g[l], e[2][l] = g[l]
            }
            return new X(2, c.degree, [0, 0, 0, 1, 1, 1], c.knots, Ia.homogenize2d(d, e))
        }, Ka.cylindricalSurface = function(a, b, c, d, e) {
            var f = Ca.cross(a, b),
                g = (2 * Math.PI, Ka.arc(c, b, f, e, 0, 2 * Math.PI));
            return Ka.extrudedSurface(a, d, g)
        }, Ka.revolvedSurface = function(a, b, c, d) {
            var e, f, g = Ia.dehomogenize1d(a.controlPoints),
                h = Ia.weight1d(a.controlPoints);
            d <= Math.PI / 2 ? (e = 1, f = Ca.zeros1d(6 + 2 * (e - 1))) : d <= Math.PI ? (e = 2, f = Ca.zeros1d(6 + 2 * (e - 1)), f[3] = f[4] = .5) : d <= 3 * Math.PI / 2 ? (e = 3, f = Ca.zeros1d(6 + 2 * (e - 1)), f[3] = f[4] = .3333333333333333, f[5] = f[6] = .6666666666666666) : (e = 4, f = Ca.zeros1d(6 + 2 * (e - 1)), f[3] = f[4] = .25, f[5] = f[6] = .5, f[7] = f[8] = .75);
            for (var i = d / e, j = 3 + 2 * (e - 1), k = 0; k < 3;) {
                var l = k++;
                f[l] = 0, f[j + l] = 1
            }
            for (var m = Math.cos(i / 2), n = 0, o = Ca.zeros1d(e + 1), p = Ca.zeros1d(e + 1), q = Ca.zeros3d(2 * e + 1, g.length, 3), r = Ca.zeros2d(2 * e + 1, g.length), s = 1, t = e + 1; s < t;) {
                var u = s++;
                n += i, p[u] = Math.cos(n), o[u] = Math.sin(n)
            }
            for (var v = 0, w = g.length; v < w;) {
                var x = v++,
                    y = Ba.rayClosestPoint(g[x], b, c),
                    z = Ca.sub(g[x], y),
                    A = Ca.norm(z),
                    B = Ca.cross(c, z);
                A > S.EPSILON && (z = Ca.mul(1 / A, z), B = Ca.mul(1 / A, B)), q[0][x] = g[x];
                var C = g[x];
                r[0][x] = h[x];
                for (var D = B, E = 0, F = 1, G = e + 1; F < G;) {
                    var H, I = F++;
                    H = 0 == A ? y : Ca.add(y, Ca.add(Ca.mul(A * p[I], z), Ca.mul(A * o[I], B))), q[E + 2][x] = H, r[E + 2][x] = h[x];
                    var J = Ca.sub(Ca.mul(p[I], B), Ca.mul(o[I], z));
                    if (0 == A) q[E + 1][x] = y;
                    else {
                        var K = Ja.rays(C, Ca.mul(1 / Ca.norm(D), D), H, Ca.mul(1 / Ca.norm(J), J)),
                            L = Ca.add(C, Ca.mul(K.u0, D));
                        q[E + 1][x] = L
                    }
                    r[E + 1][x] = m * h[x], E += 2, I < e && (C = H, D = J)
                }
            }
            return new X(2, a.degree, f, a.knots, Ia.homogenize2d(q, r))
        }, Ka.sphericalSurface = function(a, b, c, d) {
            var e = Ka.arc(a, Ca.mul(-1, b), c, d, 0, Math.PI);
            return Ka.revolvedSurface(e, a, b, 2 * Math.PI)
        }, Ka.conicalSurface = function(a, b, c, d, e) {
            var f = 2 * Math.PI,
                g = 1,
                h = [Ca.add(c, Ca.mul(d, a)), Ca.add(c, Ca.mul(e, b))],
                i = [0, 0, 1, 1],
                j = [1, 1],
                k = new W(g, i, Ia.homogenize1d(h, j));
            return Ka.revolvedSurface(k, c, a, f)
        }, Ka.rationalInterpCurve = function(a, b, c, d, e) {
            if (null == c && (c = !1), null == b && (b = 3), a.length < b + 1) throw new C("You need to supply at least degree + 1 points! You only supplied " + a.length + " points.");
            for (var f = [0], g = 1, h = a.length; g < h;) {
                var i = g++,
                    j = Ca.norm(Ca.sub(a[i], a[i - 1])),
                    k = f[f.length - 1];
                f.push(k + j)
            }
            for (var l = f[f.length - 1], m = 0, n = f.length; m < n;) {
                var o = m++;
                f[o] = f[o] / l
            }
            var p, q = Ca.rep(b + 1, 0),
                r = null != d && null != e;
            p = r ? 0 : 1;
            var s;
            s = r ? f.length - b + 1 : f.length - b;
            for (var t = p; t < s;) {
                for (var u = t++, v = 0, w = 0; w < b;) {
                    var x = w++;
                    v += f[u + x]
                }
                q.push(1 / b * v)
            }
            var y, z = q.concat(Ca.rep(b + 1, 1)),
                A = [];
            y = r ? a.length + 1 : a.length - 1;
            var B;
            B = r ? 1 : 0;
            var D;
            D = r ? a.length - (b - 1) : a.length - (b + 1);
            for (var E = 0; E < f.length;) {
                var F = f[E];
                ++E;
                var G = Ia.knotSpanGivenN(y, b, F, z),
                    H = Ia.basisFunctionsGivenKnotSpanIndex(G, F, b, z),
                    I = G - b,
                    J = Ca.zeros1d(I),
                    K = Ca.zeros1d(D - I);
                A.push(J.concat(H).concat(K))
            }
            if (r) {
                var L = A[0].length - 2,
                    M = [-1, 1].concat(Ca.zeros1d(L)),
                    N = Ca.zeros1d(L).concat([-1, 1]);
                P.spliceAndInsert(A, 1, 0, M), P.spliceAndInsert(A, A.length - 1, 0, N)
            }
            for (var O = a[0].length, Q = [], R = (1 - z[z.length - b - 2]) / b, S = z[b + 1] / b, T = 0; T < O;) {
                var U, V = [T++];
                if (r) {
                    U = [a[0][V[0]]], U.push(S * d[V[0]]);
                    for (var X = 1, Y = a.length - 1; X < Y;) {
                        var Z = X++;
                        U.push(a[Z][V[0]])
                    }
                    U.push(R * e[V[0]]), U.push(P.last(a)[V[0]])
                } else U = a.map(function(a) {
                    return function(b) {
                        return b[a[0]]
                    }
                }(V));
                var $ = ta.solve(A, U);
                Q.push($)
            }
            var _ = ta.transpose(Q);
            if (!c) {
                var aa = Ca.rep(_.length, 1);
                _ = Ia.homogenize1d(_, aa)
            }
            return new W(b, z, _)
        };
        var La = b.eval.Modify = function() {};
        g["verb.eval.Modify"] = La, La.__name__ = ["verb", "eval", "Modify"], La.curveReverse = function(a) {
            return new W(a.degree, La.knotsReverse(a.knots), P.reversed(a.controlPoints))
        }, La.surfaceReverse = function(a, b) {
            return null == b && (b = !1), b ? new X(a.degreeU, a.degreeV, a.knotsU, La.knotsReverse(a.knotsV), function(b) {
                for (var c, d = [], e = 0, f = a.controlPoints; e < f.length;) {
                    var g = f[e];
                    ++e, d.push(P.reversed(g))
                }
                return c = d
            }(this)) : new X(a.degreeU, a.degreeV, La.knotsReverse(a.knotsU), a.knotsV, P.reversed(a.controlPoints))
        }, La.knotsReverse = function(a) {
            for (var b = P.first(a), c = (P.last(a), [b]), d = a.length, e = 1; e < d;) {
                var f = e++;
                c.push(c[f - 1] + (a[d - f] - a[d - f - 1]))
            }
            return c
        }, La.unifyCurveKnotVectors = function(a) {
            a = a.map(Ka.clonedCurve);
            for (var b = j.fold(a, function(a, b) {
                    return La.imax(a.degree, b)
                }, 0), c = 0, d = a.length; c < d;) {
                var e = c++;
                a[e].degree < b && (a[e] = La.curveElevateDegree(a[e], b))
            }
            for (var f, g = [], h = 0; h < a.length;) {
                var i = a[h];
                ++h, g.push(new aa(P.first(i.knots), P.last(i.knots)))
            }
            f = g;
            for (var k = 0, l = a.length; k < l;) {
                var m = k++,
                    n = [f[m].min];
                a[m].knots = a[m].knots.map(function(a) {
                    return function(b) {
                        return b - a[0]
                    }
                }(n))
            }
            for (var o = f.map(function(a) {
                    return a.max - a.min
                }), p = j.fold(o, function(a, b) {
                    return Math.max(a, b)
                }, 0), q = 0, r = a.length; q < r;) {
                var s = q++,
                    t = [p / o[s]];
                a[s].knots = a[s].knots.map(function(a) {
                    return function(b) {
                        return b * a[0]
                    }
                }(t))
            }
            for (var u = j.fold(a, function(a, b) {
                    return Ca.sortedSetUnion(a.knots, b)
                }, []), v = 0, w = a.length; v < w;) {
                var x = v++,
                    y = Ca.sortedSetSub(u, a[x].knots);
                0 == y.length && (a[x] = a[x]), a[x] = La.curveKnotRefine(a[x], y)
            }
            return a
        }, La.imin = function(a, b) {
            return a < b ? a : b
        }, La.imax = function(a, b) {
            return a > b ? a : b
        }, La.curveElevateDegree = function(a, b) {
            if (b <= a.degree) return a;
            var c, d = a.knots.length - a.degree - 2,
                e = a.degree,
                f = a.knots,
                g = a.controlPoints,
                h = b - a.degree,
                i = a.controlPoints[0].length,
                j = Ca.zeros2d(e + h + 1, e + 1),
                k = [],
                l = [],
                m = [],
                n = d + e + 1,
                o = b,
                p = Math.floor(o / 2),
                q = [],
                r = [];
            j[0][0] = 1, j[o][e] = 1;
            for (var s = 1, t = p + 1; s < t;)
                for (var u = s++, v = 1 / Q.get(o, u), w = La.imin(e, u), x = La.imax(0, u - h), y = w + 1; x < y;) {
                    var z = x++;
                    j[u][z] = v * Q.get(e, z) * Q.get(h, u - z)
                }
            for (var A = p + 1; A < o;)
                for (var B = A++, C = La.imin(e, B), D = La.imax(0, B - h), E = C + 1; D < E;) {
                    var F = D++;
                    j[B][F] = j[o - B][e - F]
                }
            var G = o,
                H = o + 1,
                I = -1,
                J = e,
                K = e + 1,
                L = 1,
                M = f[0];
            q[0] = g[0];
            for (var N = 0, O = o + 1; N < O;) {
                var P = N++;
                r[P] = M
            }
            for (var R = 0, S = e + 1; R < S;) {
                var T = R++;
                k[T] = g[T]
            }
            for (; K < n;) {
                for (var U = K; K < n && f[K] == f[K + 1];) K += 1;
                var V = K - U + 1,
                    X = f[K],
                    Y = I;
                I = e - V;
                var Z;
                Z = Y > 0 ? Math.floor((Y + 2) / 2) : 1;
                var $;
                if ($ = I > 0 ? Math.floor(o - (I + 1) / 2) : o, I > 0) {
                    for (var _ = X - M, aa = [], ba = e; ba > V;) aa[ba - V - 1] = _ / (f[J + ba] - M), ba--;
                    for (var ca = 1, da = I + 1; ca < da;) {
                        for (var ea = ca++, fa = I - ea, ga = V + ea, ha = e; ha >= ga;) k[ha] = Ca.add(Ca.mul(aa[ha - ga], k[ha]), Ca.mul(1 - aa[ha - ga], k[ha - 1])), ha--;
                        m[fa] = k[e]
                    }
                }
                for (var ia = Z, ja = o + 1; ia < ja;) {
                    var ka = ia++;
                    l[ka] = Ca.zeros1d(i);
                    for (var la = La.imin(e, ka), ma = La.imax(0, ka - h), na = la + 1; ma < na;) {
                        var oa = ma++;
                        l[ka] = Ca.add(l[ka], Ca.mul(j[ka][oa], k[oa]))
                    }
                }
                if (Y > 1)
                    for (var pa = H - 2, qa = H, ra = X - M, sa = (X - r[H - 1]) / ra, ta = 1; ta < Y;) {
                        for (var ua = ta++, va = pa, wa = qa, xa = wa - H + 1; wa - va > ua;) {
                            if (va < L) {
                                var ya = (X - r[va]) / (M - r[va]);
                                q[va] = Ca.lerp(ya, q[va], q[va - 1])
                            }
                            if (wa >= Z) {
                                if (wa - ua <= H - o + Y) {
                                    var za = (X - r[wa - ua]) / ra;
                                    l[xa] = Ca.lerp(za, l[xa], l[xa + 1])
                                }
                            } else l[xa] = Ca.lerp(sa, l[xa], l[xa + 1]);
                            va += 1, wa -= 1, xa -= 1
                        }
                        pa -= 1, qa += 1
                    }
                if (J != e)
                    for (var Aa = 0, Ba = o - Y; Aa < Ba;) {
                        Aa++;
                        r[H] = M, H += 1
                    }
                for (var Da = Z, Ea = $ + 1; Da < Ea;) {
                    var Fa = Da++;
                    q[L] = l[Fa], L += 1
                }
                if (K < n) {
                    for (var Ga = 0; Ga < I;) {
                        var Ha = Ga++;
                        k[Ha] = m[Ha]
                    }
                    for (var Ia = I, Ja = e + 1; Ia < Ja;) {
                        var Ka = Ia++;
                        k[Ka] = g[K - e + Ka]
                    }
                    J = K, K += 1, M = X
                } else
                    for (var Ma = 0, Na = o + 1; Ma < Na;) {
                        var Oa = Ma++;
                        r[H + Oa] = X
                    }
            }
            return c = G - o - 1, new W(b, r, q)
        }, La.rationalSurfaceTransform = function(a, b) {
            for (var c = Ia.dehomogenize2d(a.controlPoints), d = 0, e = c.length; d < e;)
                for (var f = d++, g = 0, h = c[f].length; g < h;) {
                    var i = g++,
                        j = c[f][i];
                    j.push(1), c[f][i] = ta.dot(b, j).slice(0, j.length - 1)
                }
            return new X(a.degreeU, a.degreeV, a.knotsU.slice(), a.knotsV.slice(), Ia.homogenize2d(c, Ia.weight2d(a.controlPoints)))
        }, La.rationalCurveTransform = function(a, b) {
            for (var c = Ia.dehomogenize1d(a.controlPoints), d = 0, e = c.length; d < e;) {
                var f = d++,
                    g = c[f];
                g.push(1), c[f] = ta.dot(b, g).slice(0, g.length - 1)
            }
            return new W(a.degree, a.knots.slice(), Ia.homogenize1d(c, Ia.weight1d(a.controlPoints)))
        }, La.surfaceKnotRefine = function(a, b, c) {
            var d, e, f, g = [];
            c ? (f = a.controlPoints, d = a.knotsV, e = a.degreeV) : (f = ta.transpose(a.controlPoints), d = a.knotsU, e = a.degreeU);
            for (var h = null, i = 0; i < f.length;) {
                var j = f[i];
                ++i, h = La.curveKnotRefine(new W(e, d, j), b), g.push(h.controlPoints)
            }
            var k = h.knots;
            return c ? new X(a.degreeU, a.degreeV, a.knotsU.slice(), k, g) : (g = ta.transpose(g), new X(a.degreeU, a.degreeV, k, a.knotsV.slice(), g))
        }, La.decomposeCurveIntoBeziers = function(a) {
            for (var b = a.degree, c = a.controlPoints, d = a.knots, e = Da.knotMultiplicities(d), f = b + 1, g = 0; g < e.length;) {
                var h = e[g];
                if (++g, h.mult < f) {
                    var i = Ca.rep(f - h.mult, h.knot),
                        j = La.curveKnotRefine(new W(b, d, c), i);
                    d = j.knots, c = j.controlPoints
                }
            }
            for (var k = (d.length / f - 1, 2 * f), l = [], m = 0; m < c.length;) {
                var n = d.slice(m, m + k),
                    o = c.slice(m, m + f);
                l.push(new W(b, n, o)), m += f
            }
            return l
        }, La.curveKnotRefine = function(a, b) {
            if (0 == b.length) return Ka.clonedCurve(a);
            for (var c = a.degree, d = a.controlPoints, e = a.knots, f = d.length - 1, g = f + c + 1, h = b.length - 1, i = Ia.knotSpan(c, b[0], e), j = Ia.knotSpan(c, b[h], e), k = [], l = [], m = 0, n = i - c + 1; m < n;) {
                var o = m++;
                k[o] = d[o]
            }
            for (var p = j - 1, q = f + 1; p < q;) {
                var r = p++;
                k[r + h + 1] = d[r]
            }
            for (var s = 0, t = i + 1; s < t;) {
                var u = s++;
                l[u] = e[u]
            }
            for (var v = j + c, w = g + 1; v < w;) {
                var x = v++;
                l[x + h + 1] = e[x]
            }
            for (var y = j + c - 1, z = j + c + h, A = h; A >= 0;) {
                for (; b[A] <= e[y] && y > i;) k[z - c - 1] = d[y - c - 1], l[z] = e[y], z -= 1, y -= 1;
                k[z - c - 1] = k[z - c];
                for (var B = 1, C = c + 1; B < C;) {
                    var D = B++,
                        E = z - c + D,
                        F = l[z + D] - b[A];
                    Math.abs(F) < S.EPSILON ? k[E - 1] = k[E] : (F /= l[z + D] - e[y - c + D], k[E - 1] = Ca.add(Ca.mul(F, k[E - 1]), Ca.mul(1 - F, k[E])))
                }
                l[z] = b[A], z -= 1, A--
            }
            return new W(c, l, k)
        }, La.curveKnotInsert = function(a, b, c) {
            for (var d = a.degree, e = a.controlPoints, f = a.knots, g = 0, h = e.length, i = Ia.knotSpan(d, b, f), j = [], k = [], l = [], m = 1, n = i + 1; m < n;) {
                var o = m++;
                k[o] = f[o]
            }
            for (var p = 1, q = c + 1; p < q;) {
                var r = p++;
                k[i + r] = b
            }
            for (var s = i + 1, t = f.length; s < t;) {
                var u = s++;
                k[u + c] = f[u]
            }
            for (var v = 0, w = i - d + 1; v < w;) {
                var x = v++;
                l[x] = e[x]
            }
            for (var y = i - g; y < h;) {
                var z = y++;
                l[z + c] = e[z]
            }
            for (var A = 0, B = d - g + 1; A < B;) {
                var C = A++;
                j[C] = e[i - d + C]
            }
            for (var D = 0, E = 0, F = 1, G = c + 1; F < G;) {
                var H = F++;
                D = i - d + H;
                for (var I = 0, J = d - H - g + 1; I < J;) {
                    var K = I++;
                    E = (b - f[D + K]) / (f[K + i + 1] - f[D + K]), j[K] = Ca.add(Ca.mul(E, j[K + 1]), Ca.mul(1 - E, j[K]))
                }
                l[D] = j[0], l[i + c - H - g] = j[d - H - g]
            }
            for (var L = D + 1, M = i - g; L < M;) {
                var N = L++;
                l[N] = j[N - D]
            }
            return new W(d, k, l)
        };
        var Ma = b.eval.Tess = function() {};
        g["verb.eval.Tess"] = Ma, Ma.__name__ = ["verb", "eval", "Tess"], Ma.rationalCurveRegularSample = function(a, b, c) {
            return Ma.rationalCurveRegularSampleRange(a, a.knots[0], P.last(a.knots), b, c)
        }, Ma.rationalCurveRegularSampleRange = function(a, b, c, d, e) {
            d < 1 && (d = 2);
            for (var f = [], g = (c - b) / (d - 1), h = 0, i = 0; i < d;) {
                var j = i++;
                h = b + g * j, e ? f.push([h].concat(Ia.rationalCurvePoint(a, h))) : f.push(Ia.rationalCurvePoint(a, h))
            }
            return f
        }, Ma.rationalCurveAdaptiveSample = function(a, b, c) {
            if (null == c && (c = !1), null == b && (b = 1e-6), 1 == a.degree) {
                if (c) {
                    for (var d = [], e = 0, f = a.controlPoints.length; e < f;) {
                        var g = e++;
                        d.push([a.knots[g + 1]].concat(Ia.dehomogenize(a.controlPoints[g])))
                    }
                    return d
                }
                return a.controlPoints.map(Ia.dehomogenize)
            }
            return Ma.rationalCurveAdaptiveSampleRange(a, a.knots[0], P.last(a.knots), b, c)
        }, Ma.rationalCurveAdaptiveSampleRange = function(a, b, c, d, e) {
            var f = Ia.rationalCurvePoint(a, b),
                g = Ia.rationalCurvePoint(a, c),
                h = .5 + .2 * Math.random(),
                i = b + (c - b) * h,
                j = Ia.rationalCurvePoint(a, i),
                k = Ca.sub(f, g),
                l = Ca.sub(f, j);
            if (Ca.dot(k, k) < d && Ca.dot(l, l) > d || !Ba.threePointsAreFlat(f, j, g, d)) {
                var m = b + .5 * (c - b),
                    n = Ma.rationalCurveAdaptiveSampleRange(a, b, m, d, e),
                    o = Ma.rationalCurveAdaptiveSampleRange(a, m, c, d, e);
                return n.slice(0, -1).concat(o)
            }
            return e ? [
                [b].concat(f), [c].concat(g)
            ] : [f, g]
        }, Ma.rationalSurfaceNaive = function(a, b, c) {
            b < 1 && (b = 1), c < 1 && (c = 1);
            for (var d = (a.degreeU, a.degreeV, a.controlPoints, a.knotsU), e = a.knotsV, f = P.last(d) - d[0], g = P.last(e) - e[0], h = f / b, i = g / c, j = [], k = [], l = [], m = 0, n = b + 1; m < n;)
                for (var o = m++, p = 0, q = c + 1; p < q;) {
                    var r = p++,
                        s = o * h,
                        t = r * i;
                    k.push([s, t]);
                    var u = Ia.rationalSurfaceDerivatives(a, s, t, 1),
                        v = u[0][0];
                    j.push(v);
                    var w = Ca.normalized(Ca.cross(u[1][0], u[0][1]));
                    l.push(w)
                }
            for (var x = [], y = 0; y < b;)
                for (var z = y++, A = 0; A < c;) {
                    var B = A++,
                        C = z * (c + 1) + B,
                        D = (z + 1) * (c + 1) + B,
                        E = D + 1,
                        F = C + 1,
                        G = [C, D, E],
                        H = [C, E, F];
                    x.push(G), x.push(H)
                }
            return new Y(x, j, l, k)
        }, Ma.divideRationalSurfaceAdaptive = function(a, b) {
            null == b && (b = new Na), null != b.minDivsU ? b.minDivsU = b.minDivsU : b.minDivsU = 1, null != b.minDivsV ? b.minDivsU = b.minDivsV : b.minDivsU = 1, null != b.refine ? b.refine = b.refine : b.refine = !0;
            var c, d = 2 * (a.controlPoints.length - 1),
                e = 2 * (a.controlPoints[0].length - 1);
            c = b.minDivsU > d ? b.minDivsU = b.minDivsU : b.minDivsU = d;
            var f;
            f = b.minDivsV > e ? b.minDivsV = b.minDivsV : b.minDivsV = e;
            for (var g = P.last(a.knotsU), h = a.knotsU[0], i = P.last(a.knotsV), j = a.knotsV[0], k = (g - h) / c, l = (i - j) / f, m = [], n = [], o = 0, p = f + 1; o < p;) {
                for (var q = o++, r = [], s = 0, t = c + 1; s < t;) {
                    var u = s++,
                        v = h + k * u,
                        w = j + l * q,
                        x = Ia.rationalSurfaceDerivatives(a, v, w, 1),
                        y = Ca.normalized(Ca.cross(x[0][1], x[1][0]));
                    r.push(new ia(x[0][0], y, [v, w], -1, Ca.isZero(y)))
                }
                n.push(r)
            }
            for (var z = 0; z < f;)
                for (var A = z++, B = 0; B < c;) {
                    var C = B++,
                        D = [n[f - A - 1][C], n[f - A - 1][C + 1], n[f - A][C + 1], n[f - A][C]];
                    m.push(new Oa(a, D))
                }
            if (!b.refine) return m;
            for (var E = 0; E < f;)
                for (var F = E++, G = 0; G < c;) {
                    var H = G++,
                        I = F * c + H,
                        J = Ma.north(I, F, H, c, f, m),
                        K = Ma.east(I, F, H, c, f, m),
                        L = Ma.south(I, F, H, c, f, m),
                        M = Ma.west(I, F, H, c, f, m);
                    m[I].neighbors = [L, K, J, M], m[I].divide(b)
                }
            return m
        }, Ma.north = function(a, b, c, d, e, f) {
            return 0 == b ? null : f[a - d]
        }, Ma.south = function(a, b, c, d, e, f) {
            return b == e - 1 ? null : f[a + d]
        }, Ma.east = function(a, b, c, d, e, f) {
            return c == d - 1 ? null : f[a + 1]
        }, Ma.west = function(a, b, c, d, e, f) {
            return 0 == c ? null : f[a - 1]
        }, Ma.triangulateAdaptiveRefinementNodeTree = function(a) {
            for (var b = Y.empty(), c = 0; c < a.length;) {
                var d = a[c];
                ++c, d.triangulate(b)
            }
            return b
        }, Ma.rationalSurfaceAdaptive = function(a, b) {
            b = null != b ? b : new Na;
            var c = Ma.divideRationalSurfaceAdaptive(a, b);
            return Ma.triangulateAdaptiveRefinementNodeTree(c)
        };
        var Na = b.core.AdaptiveRefinementOptions = function() {
            this.minDivsV = 1, this.minDivsU = 1, this.refine = !0, this.maxDepth = 10, this.minDepth = 0, this.normTol = .025
        };
        g["verb.eval.AdaptiveRefinementOptions"] = Na, Na.__name__ = ["verb", "eval", "AdaptiveRefinementOptions"], Na.prototype = {
            __class__: Na
        };
        var Oa = b.core.AdaptiveRefinementNode = function(a, b, c) {
            if (this.srf = a, null == c ? this.neighbors = [null, null, null, null] : this.neighbors = c, this.corners = b, null == this.corners) {
                var d = a.knotsU[0],
                    e = P.last(a.knotsU),
                    f = a.knotsV[0],
                    g = P.last(a.knotsV);
                this.corners = [ia.fromUv(d, f), ia.fromUv(e, f), ia.fromUv(e, g), ia.fromUv(d, g)]
            }
        };
        g["verb.eval.AdaptiveRefinementNode"] = Oa, Oa.__name__ = ["verb", "eval", "AdaptiveRefinementNode"], Oa.prototype = {
            isLeaf: function() {
                return null == this.children
            },
            center: function() {
                return null != this.centerPoint ? this.centerPoint : this.evalSrf(this.u05, this.v05)
            },
            evalCorners: function() {
                this.u05 = (this.corners[0].uv[0] + this.corners[2].uv[0]) / 2, this.v05 = (this.corners[0].uv[1] + this.corners[2].uv[1]) / 2;
                for (var a = 0; a < 4;) {
                    var b = a++;
                    if (null == this.corners[b].point) {
                        var c = this.corners[b];
                        this.evalSrf(c.uv[0], c.uv[1], c)
                    }
                }
            },
            evalSrf: function(a, b, c) {
                var d = Ia.rationalSurfaceDerivatives(this.srf, a, b, 1),
                    e = d[0][0],
                    f = Ca.cross(d[0][1], d[1][0]),
                    g = Ca.isZero(f);
                return g || (f = Ca.normalized(f)), null != c ? (c.degen = g, c.point = e, c.normal = f, c) : new ia(e, f, [a, b], -1, g)
            },
            getEdgeCorners: function(a) {
                if (this.isLeaf()) return [this.corners[a]];
                if (this.horizontal) switch (a) {
                    case 0:
                        return this.children[0].getEdgeCorners(0);
                    case 1:
                        return this.children[0].getEdgeCorners(1).concat(this.children[1].getEdgeCorners(1));
                    case 2:
                        return this.children[1].getEdgeCorners(2);
                    case 3:
                        return this.children[1].getEdgeCorners(3).concat(this.children[0].getEdgeCorners(3))
                }
                switch (a) {
                    case 0:
                        return this.children[0].getEdgeCorners(0).concat(this.children[1].getEdgeCorners(0));
                    case 1:
                        return this.children[1].getEdgeCorners(1);
                    case 2:
                        return this.children[1].getEdgeCorners(2).concat(this.children[0].getEdgeCorners(2));
                    case 3:
                        return this.children[0].getEdgeCorners(3)
                }
                return null
            },
            getAllCorners: function(a) {
                var b = [this.corners[a]];
                if (null == this.neighbors[a]) return b;
                var c = this.neighbors[a].getEdgeCorners((a + 2) % 4),
                    d = a % 2,
                    e = S.EPSILON,
                    f = this,
                    g = [function(a) {
                        return a.uv[0] > f.corners[0].uv[0] + e && a.uv[0] < f.corners[2].uv[0] - e
                    }, function(a) {
                        return a.uv[1] > f.corners[0].uv[1] + e && a.uv[1] < f.corners[2].uv[1] - e
                    }],
                    h = c.filter(g[d]);
                return h.reverse(), b.concat(h)
            },
            midpoint: function(a) {
                if (null == this.midPoints && (this.midPoints = [null, null, null, null]), null != this.midPoints[a]) return this.midPoints[a];
                switch (a) {
                    case 0:
                        this.midPoints[0] = this.evalSrf(this.u05, this.corners[0].uv[1]);
                        break;
                    case 1:
                        this.midPoints[1] = this.evalSrf(this.corners[1].uv[0], this.v05);
                        break;
                    case 2:
                        this.midPoints[2] = this.evalSrf(this.u05, this.corners[2].uv[1]);
                        break;
                    case 3:
                        this.midPoints[3] = this.evalSrf(this.corners[0].uv[0], this.v05)
                }
                return this.midPoints[a]
            },
            hasBadNormals: function() {
                return this.corners[0].degen || this.corners[1].degen || this.corners[2].degen || this.corners[3].degen
            },
            fixNormals: function() {
                for (var a = this.corners.length, b = 0; b < a;) {
                    var c = b++;
                    this.corners[c];
                    if (this.corners[c].degen) {
                        var d = this.corners[(c + 1) % a],
                            e = this.corners[(c + 3) % a];
                        d.degen ? this.corners[c].normal = e.normal : this.corners[c].normal = d.normal
                    }
                }
            },
            shouldDivide: function(a, b) {
                if (b < a.minDepth) return !0;
                if (b >= a.maxDepth) return !1;
                if (this.hasBadNormals()) return this.fixNormals(), !1;
                if (this.splitVert = Ca.normSquared(Ca.sub(this.corners[0].normal, this.corners[1].normal)) > a.normTol || Ca.normSquared(Ca.sub(this.corners[2].normal, this.corners[3].normal)) > a.normTol, this.splitHoriz = Ca.normSquared(Ca.sub(this.corners[1].normal, this.corners[2].normal)) > a.normTol || Ca.normSquared(Ca.sub(this.corners[3].normal, this.corners[0].normal)) > a.normTol, this.splitVert || this.splitHoriz) return !0;
                var c = this.center();
                return Ca.normSquared(Ca.sub(c.normal, this.corners[0].normal)) > a.normTol || Ca.normSquared(Ca.sub(c.normal, this.corners[1].normal)) > a.normTol || Ca.normSquared(Ca.sub(c.normal, this.corners[2].normal)) > a.normTol || Ca.normSquared(Ca.sub(c.normal, this.corners[3].normal)) > a.normTol
            },
            divide: function(a) {
                null == a && (a = new Na), null == a.normTol && (a.normTol = .085), null == a.minDepth && (a.minDepth = 0), null == a.maxDepth && (a.maxDepth = 10), this._divide(a, 0, !0)
            },
            _divide: function(a, b, c) {
                if (this.evalCorners(), this.shouldDivide(a, b)) {
                    if (b++, this.splitVert && !this.splitHoriz ? c = !1 : !this.splitVert && this.splitHoriz && (c = !0), this.horizontal = c, this.horizontal) {
                        var d = [this.corners[0], this.corners[1], this.midpoint(1), this.midpoint(3)],
                            e = [this.midpoint(3), this.midpoint(1), this.corners[2], this.corners[3]];
                        this.children = [new Oa(this.srf, d), new Oa(this.srf, e)], this.children[0].neighbors = [this.neighbors[0], this.neighbors[1], this.children[1], this.neighbors[3]], this.children[1].neighbors = [this.children[0], this.neighbors[1], this.neighbors[2], this.neighbors[3]]
                    } else {
                        var f = [this.corners[0], this.midpoint(0), this.midpoint(2), this.corners[3]],
                            g = [this.midpoint(0), this.corners[1], this.corners[2], this.midpoint(2)];
                        this.children = [new Oa(this.srf, f), new Oa(this.srf, g)], this.children[0].neighbors = [this.neighbors[0], this.children[1], this.neighbors[2], this.neighbors[3]], this.children[1].neighbors = [this.neighbors[0], this.neighbors[1], this.neighbors[2], this.children[0]]
                    }
                    for (var h = 0, i = this.children; h < i.length;) {
                        var j = i[h];
                        ++h, j._divide(a, b, !c)
                    }
                }
            },
            triangulate: function(a) {
                if (null == a && (a = Y.empty()), this.isLeaf()) return this.triangulateLeaf(a);
                for (var b = 0, c = this.children; b < c.length;) {
                    var d = c[b];
                    if (++b, null == d) break;
                    d.triangulate(a)
                }
                return a
            },
            triangulateLeaf: function(a) {
                for (var b = a.points.length, c = [], d = [], e = 0, f = 0; f < 4;) {
                    var g = f++,
                        h = this.getAllCorners(g);
                    2 == h.length && (e = g + 1);
                    for (var i = 0, j = h.length; i < j;) {
                        var k = i++;
                        c.push(h[k])
                    }
                }
                for (var l = 0; l < c.length;) {
                    var m = c[l];
                    ++l, m.id == -1 ? (a.uvs.push(m.uv), a.points.push(m.point), a.normals.push(m.normal), m.id = b, d.push(b), b++) : d.push(m.id)
                }
                if (4 == c.length) return a.faces.push([d[0], d[3], d[1]]), a.faces.push([d[3], d[2], d[1]]), a;
                if (5 == c.length) {
                    var n = d.length;
                    return a.faces.push([d[e], d[(e + 2) % n], d[(e + 1) % n]]), a.faces.push([d[(e + 4) % n], d[(e + 3) % n], d[e]]), a.faces.push([d[e], d[(e + 3) % n], d[(e + 2) % n]]), a
                }
                var o = this.center();
                a.uvs.push(o.uv), a.points.push(o.point), a.normals.push(o.normal);
                for (var p = a.points.length - 1, q = 0, r = c.length - 1; q < c.length;) a.faces.push([p, d[q], d[r]]), r = q++;
                return a
            },
            __class__: Oa
        };
        var Pa = b.exe.Dispatcher = function() {};
        g["verb.exe.Dispatcher"] = Pa, Pa.__name__ = ["verb", "exe", "Dispatcher"], Pa.init = function() {
            Pa._init || (Pa._workerPool = new Qa(Pa.THREADS), Pa._init = !0)
        }, Pa.dispatchMethod = function(a, b, c) {
            Pa.init();
            var d = new I,
                e = function(a) {
                    d.resolve(a)
                };
            return Pa._workerPool.addWork(q.getClassName(a), b, c, e), new J(d)
        };
        var Qa = b.exe.WorkerPool = function(a, b) {
            null == b && (b = "verb.js"), null == a && (a = 1), this._callbacks = new v, this._working = new v, this._pool = [], this._queue = [];
            for (var c = 0; c < a;) {
                var d;
                c++;
                try {
                    d = new Worker(Qa.basePath + b)
                } catch (e) {
                    e instanceof C && (e = e.val), d = new Worker(Qa.basePath + b.substring(0, -3) + ".min.js")
                }
                this._pool.push(d)
            }
        };
        g["verb.exe.WorkerPool"] = Qa, Qa.__name__ = ["verb", "exe", "WorkerPool"], Qa.prototype = {
            addWork: function(a, b, c, d) {
                var e = new Ra(a, b, c);
                this._callbacks.set(e.id, d), this._queue.push(e), this.processQueue()
            },
            processQueue: function() {
                for (var b = this; this._queue.length > 0 && this._pool.length > 0;) {
                    var c = this._queue.shift(),
                        d = [c.id],
                        e = [this._pool.shift()];
                    this._working.h[d[0]] = e[0], e[0].onmessage = function(c, d) {
                        return function(e) {
                            b._working.remove(d[0]), b._pool.push(c[0]);
                            try {
                                b._callbacks.h.hasOwnProperty(d[0]) && (b._callbacks.h[d[0]](e.data.result), b._callbacks.remove(d[0]))
                            } catch (f) {
                                f instanceof C && (f = f.val), a.log(f)
                            }
                            b.processQueue()
                        }
                    }(e, d), e[0].postMessage(c)
                }
            },
            __class__: Qa
        };
        var Ra = function(a, b, c) {
            this.className = a, this.methodName = b, this.args = c, this.id = Ra.uuid++
        };
        g["verb.exe._WorkerPool.Work"] = Ra, Ra.__name__ = ["verb", "exe", "_WorkerPool", "Work"], Ra.prototype = {
            __class__: Ra
        };
        var Sa = function() {};
        g["verb.geom.ICurve"] = Sa, Sa.__name__ = ["verb", "geom", "ICurve"], Sa.__interfaces__ = [za], Sa.prototype = {
            __class__: Sa
        };
        var Ta = b.geom.NurbsCurve = function(a) {
            this._data = Fa.isValidNurbsCurveData(a)
        };
        g["verb.geom.NurbsCurve"] = Ta, Ta.__name__ = ["verb", "geom", "NurbsCurve"], Ta.__interfaces__ = [Sa], Ta.byKnotsControlPointsWeights = function(a, b, c, d) {
            return new Ta(new W(a, b.slice(), Ia.homogenize1d(c, d)))
        }, Ta.byPoints = function(a, b) {
            return null == b && (b = 3), new Ta(Ka.rationalInterpCurve(a, b))
        }, Ta.__super__ = T, Ta.prototype = d(T.prototype, {
            degree: function() {
                return this._data.degree
            },
            knots: function() {
                return this._data.knots.slice(0)
            },
            controlPoints: function() {
                return Ia.dehomogenize1d(this._data.controlPoints)
            },
            weights: function() {
                return Ia.weight1d(this._data.controlPoints)
            },
            asNurbs: function() {
                return new W(this.degree(), this.knots(), Ia.homogenize1d(this.controlPoints(), this.weights()))
            },
            clone: function() {
                return new Ta(this._data)
            },
            domain: function() {
                return new aa(P.first(this._data.knots), P.last(this._data.knots))
            },
            transform: function(a) {
                return new Ta(La.rationalCurveTransform(this._data, a))
            },
            transformAsync: function(a) {
                return Pa.dispatchMethod(La, "rationalCurveTransform", [this._data, a]).then(function(a) {
                    return new Ta(a)
                })
            },
            point: function(a) {
                return Ia.rationalCurvePoint(this._data, a)
            },
            pointAsync: function(a) {
                return Pa.dispatchMethod(Ia, "rationalCurvePoint", [this._data, a])
            },
            tangent: function(a) {
                return Ia.rationalCurveTangent(this._data, a)
            },
            tangentAsync: function(a) {
                return Pa.dispatchMethod(Ia, "rationalCurveTangent", [this._data, a])
            },
            derivatives: function(a, b) {
                return null == b && (b = 1), Ia.rationalCurveDerivatives(this._data, a, b)
            },
            derivativesAsync: function(a, b) {
                return null == b && (b = 1), Pa.dispatchMethod(Ia, "rationalCurveDerivatives", [this._data, a, b])
            },
            closestPoint: function(a) {
                return Da.rationalCurveClosestPoint(this._data, a)
            },
            closestPointAsync: function(a) {
                return Pa.dispatchMethod(Da, "rationalCurveClosestPoint", [this._data, a])
            },
            closestParam: function(a) {
                return Da.rationalCurveClosestParam(this._data, a)
            },
            closestParamAsync: function(a) {
                return Pa.dispatchMethod(Da, "rationalCurveClosestParam", [this._data, a])
            },
            length: function() {
                return Da.rationalCurveArcLength(this._data)
            },
            lengthAsync: function() {
                return Pa.dispatchMethod(Da, "rationalCurveArcLength", [this._data])
            },
            lengthAtParam: function(a) {
                return Da.rationalCurveArcLength(this._data, a)
            },
            lengthAtParamAsync: function() {
                return Pa.dispatchMethod(Da, "rationalCurveArcLength", [this._data])
            },
            paramAtLength: function(a, b) {
                return Da.rationalCurveParamAtArcLength(this._data, a, b)
            },
            paramAtLengthAsync: function(a, b) {
                return Pa.dispatchMethod(Da, "rationalCurveParamAtArcLength", [this._data, a, b])
            },
            divideByEqualArcLength: function(a) {
                return Ga.rationalCurveByEqualArcLength(this._data, a)
            },
            divideByEqualArcLengthAsync: function(a) {
                return Pa.dispatchMethod(Ga, "rationalCurveByEqualArcLength", [this._data, a])
            },
            divideByArcLength: function(a) {
                return Ga.rationalCurveByArcLength(this._data, a)
            },
            divideByArcLengthAsync: function(a) {
                return Pa.dispatchMethod(Ga, "rationalCurveByArcLength", [this._data, a])
            },
            split: function(a) {
                return Ga.curveSplit(this._data, a).map(function(a) {
                    return new Ta(a)
                })
            },
            splitAsync: function(a) {
                return Pa.dispatchMethod(Ga, "curveSplit", [this._data, a]).then(function(a) {
                    return a.map(function(a) {
                        return new Ta(a)
                    })
                })
            },
            reverse: function() {
                return new Ta(La.curveReverse(this._data))
            },
            reverseAsync: function() {
                return Pa.dispatchMethod(La, "curveReverse", [this._data]).then(function(a) {
                    return new Ta(a)
                })
            },
            tessellate: function(a) {
                return Ma.rationalCurveAdaptiveSample(this._data, a, !1)
            },
            tessellateAsync: function(a) {
                return Pa.dispatchMethod(Ma, "rationalCurveAdaptiveSample", [this._data, a, !1])
            },
            __class__: Ta
        });
        var Ua = b.geom.Arc = function(a, b, c, d, e, f) {
            Ta.call(this, Ka.arc(a, b, c, d, e, f)), this._center = a, this._xaxis = b, this._yaxis = c, this._radius = d, this._minAngle = e, this._maxAngle = f
        };
        g["verb.geom.Arc"] = Ua, Ua.__name__ = ["verb", "geom", "Arc"], Ua.__super__ = Ta, Ua.prototype = d(Ta.prototype, {
            center: function() {
                return this._center
            },
            xaxis: function() {
                return this._xaxis
            },
            yaxis: function() {
                return this._yaxis
            },
            radius: function() {
                return this._radius
            },
            minAngle: function() {
                return this._minAngle
            },
            maxAngle: function() {
                return this._maxAngle
            },
            __class__: Ua
        });
        var Va = b.geom.BezierCurve = function(a, b) {
            Ta.call(this, Ka.rationalBezierCurve(a, b))
        };
        g["verb.geom.BezierCurve"] = Va, Va.__name__ = ["verb", "geom", "BezierCurve"], Va.__super__ = Ta, Va.prototype = d(Ta.prototype, {
            __class__: Va
        });
        var Wa = b.geom.Circle = function(a, b, c, d) {
            Ua.call(this, a, b, c, d, 0, 2 * Math.PI)
        };
        g["verb.geom.Circle"] = Wa, Wa.__name__ = ["verb", "geom", "Circle"], Wa.__super__ = Ua, Wa.prototype = d(Ua.prototype, {
            __class__: Wa
        });
        var Xa = function() {};
        g["verb.geom.ISurface"] = Xa, Xa.__name__ = ["verb", "geom", "ISurface"], Xa.__interfaces__ = [za], Xa.prototype = {
            __class__: Xa
        };
        var Ya = b.geom.NurbsSurface = function(a) {
            this._data = Fa.isValidNurbsSurfaceData(a)
        };
        g["verb.geom.NurbsSurface"] = Ya, Ya.__name__ = ["verb", "geom", "NurbsSurface"], Ya.__interfaces__ = [Xa], Ya.byKnotsControlPointsWeights = function(a, b, c, d, e, f) {
            return new Ya(new X(a, b, c, d, Ia.homogenize2d(e, f)))
        }, Ya.byCorners = function(a, b, c, d) {
            return new Ya(Ka.fourPointSurface(a, b, c, d))
        }, Ya.byLoftingCurves = function(a, b) {
            return new Ya(Ka.loftedSurface(function(b) {
                for (var c, d = [], e = 0; e < a.length;) {
                    var f = a[e];
                    ++e, d.push(f.asNurbs())
                }
                return c = d
            }(this), b))
        }, Ya.__super__ = T, Ya.prototype = d(T.prototype, {
            degreeU: function() {
                return this._data.degreeU
            },
            degreeV: function() {
                return this._data.degreeV
            },
            knotsU: function() {
                return this._data.knotsU.slice(0)
            },
            knotsV: function() {
                return this._data.knotsV.slice(0)
            },
            controlPoints: function() {
                return Ia.dehomogenize2d(this._data.controlPoints)
            },
            weights: function() {
                return Ia.weight2d(this._data.controlPoints)
            },
            asNurbs: function() {
                return new X(this.degreeU(), this.degreeV(), this.knotsU(), this.knotsV(), Ia.homogenize2d(this.controlPoints(), this.weights()))
            },
            clone: function() {
                return new Ya(this.asNurbs())
            },
            domainU: function() {
                return new aa(P.first(this._data.knotsU), P.last(this._data.knotsU))
            },
            domainV: function() {
                return new aa(P.first(this._data.knotsV), P.last(this._data.knotsV))
            },
            point: function(a, b) {
                return Ia.rationalSurfacePoint(this._data, a, b)
            },
            pointAsync: function(a, b) {
                return Pa.dispatchMethod(Ia, "rationalSurfacePoint", [this._data, a, b])
            },
            normal: function(a, b) {
                return Ia.rationalSurfaceNormal(this._data, a, b)
            },
            normalAsync: function(a, b) {
                return Pa.dispatchMethod(Ia, "rationalSurfaceNormal", [this._data, a, b])
            },
            derivatives: function(a, b, c) {
                return null == c && (c = 1), Ia.rationalSurfaceDerivatives(this._data, a, b, c)
            },
            derivativesAsync: function(a, b, c) {
                return null == c && (c = 1), Pa.dispatchMethod(Ia, "rationalSurfaceDerivatives", [this._data, a, b, c])
            },
            closestParam: function(a) {
                return Da.rationalSurfaceClosestParam(this._data, a)
            },
            closestParamAsync: function(a) {
                return Pa.dispatchMethod(Da, "rationalSurfaceClosestParam", [this._data, a])
            },
            closestPoint: function(a) {
                return Da.rationalSurfaceClosestPoint(this._data, a)
            },
            closestPointAsync: function(a) {
                return Pa.dispatchMethod(Da, "rationalSurfaceClosestPoint", [this._data, a])
            },
            split: function(a, b) {
                return null == b && (b = !1), Ga.surfaceSplit(this._data, a, b).map(function(a) {
                    return new Ya(a)
                })
            },
            splitAsync: function(a, b) {
                return null == b && (b = !1), Pa.dispatchMethod(Ga, "surfaceSplit", [this._data, a, b]).then(function(a) {
                    return a.map(function(a) {
                        return new Ya(a)
                    })
                })
            },
            reverse: function(a) {
                return null == a && (a = !1), new Ya(La.surfaceReverse(this._data, a))
            },
            reverseAsync: function(a) {
                return null == a && (a = !1), Pa.dispatchMethod(La, "surfaceReverse", [this._data, a]).then(function(a) {
                    return new Ya(a)
                })
            },
            isocurve: function(a, b) {
                return null == b && (b = !1), new Ta(Ka.surfaceIsocurve(this._data, a, b))
            },
            isocurveAsync: function(a, b) {
                return null == b && (b = !1), Pa.dispatchMethod(Ka, "surfaceIsocurve", [this._data, a, b]).then(function(a) {
                    return new Ta(a)
                })
            },
            boundaries: function(a) {
                return Ka.surfaceBoundaryCurves(this._data).map(function(a) {
                    return new Ta(a)
                })
            },
            boundariesAsync: function(a) {
                return Pa.dispatchMethod(Ka, "surfaceBoundaryCurves", [this._data]).then(function(a) {
                    return a.map(function(a) {
                        return new Ta(a)
                    })
                })
            },
            tessellate: function(a) {
                return Ma.rationalSurfaceAdaptive(this._data, a)
            },
            tessellateAsync: function(a) {
                return Pa.dispatchMethod(Ma, "rationalSurfaceAdaptive", [this._data, a])
            },
            transform: function(a) {
                return new Ya(La.rationalSurfaceTransform(this._data, a))
            },
            transformAsync: function(a) {
                return Pa.dispatchMethod(La, "rationalSurfaceTransform", [this._data, a]).then(function(a) {
                    return new Ya(a)
                })
            },
            __class__: Ya
        });
        var Za = b.geom.ConicalSurface = function(a, b, c, d, e) {
            Ya.call(this, Ka.conicalSurface(a, b, c, d, e)), this._axis = a, this._xaxis = b, this._base = c, this._height = d, this._radius = e
        };
        g["verb.geom.ConicalSurface"] = Za, Za.__name__ = ["verb", "geom", "ConicalSurface"], Za.__super__ = Ya, Za.prototype = d(Ya.prototype, {
            axis: function() {
                return this._axis
            },
            xaxis: function() {
                return this._xaxis
            },
            base: function() {
                return this._base
            },
            height: function() {
                return this._height
            },
            radius: function() {
                return this._radius
            },
            __class__: Za
        });
        var $a = b.geom.CylindricalSurface = function(a, b, c, d, e) {
            Ya.call(this, Ka.cylindricalSurface(a, b, c, d, e)), this._axis = a, this._xaxis = b, this._base = c, this._height = d, this._radius = e
        };
        g["verb.geom.CylindricalSurface"] = $a, $a.__name__ = ["verb", "geom", "CylindricalSurface"], $a.__super__ = Ya, $a.prototype = d(Ya.prototype, {
            axis: function() {
                return this._axis
            },
            xaxis: function() {
                return this._xaxis
            },
            base: function() {
                return this._base
            },
            height: function() {
                return this._height
            },
            radius: function() {
                return this._radius
            },
            __class__: $a
        });
        var _a = b.geom.EllipseArc = function(a, b, c, d, e) {
            Ta.call(this, Ka.ellipseArc(a, b, c, d, e)), this._center = a, this._xaxis = b, this._yaxis = c, this._minAngle = d, this._maxAngle = e
        };
        g["verb.geom.EllipseArc"] = _a, _a.__name__ = ["verb", "geom", "EllipseArc"], _a.__super__ = Ta, _a.prototype = d(Ta.prototype, {
            center: function() {
                return this._center
            },
            xaxis: function() {
                return this._xaxis
            },
            yaxis: function() {
                return this._yaxis
            },
            minAngle: function() {
                return this._minAngle
            },
            maxAngle: function() {
                return this._maxAngle
            },
            __class__: _a
        });
        var ab = b.geom.Ellipse = function(a, b, c) {
            _a.call(this, a, b, c, 0, 2 * Math.PI)
        };
        g["verb.geom.Ellipse"] = ab, ab.__name__ = ["verb", "geom", "Ellipse"], ab.__super__ = _a, ab.prototype = d(_a.prototype, {
            __class__: ab
        });
        var bb = b.geom.ExtrudedSurface = function(a, b) {
            Ya.call(this, Ka.extrudedSurface(Ca.normalized(b), Ca.norm(b), a.asNurbs())), this._profile = a, this._direction = b
        };
        g["verb.geom.ExtrudedSurface"] = bb, bb.__name__ = ["verb", "geom", "ExtrudedSurface"], bb.__super__ = Ya, bb.prototype = d(Ya.prototype, {
            profile: function() {
                return this._profile
            },
            direction: function() {
                return this._direction
            },
            __class__: bb
        });
        var cb = b.geom.Intersect = function() {};
        g["verb.geom.Intersect"] = cb, cb.__name__ = ["verb", "geom", "Intersect"], cb.curves = function(a, b, c) {
            return null == c && (c = .001), Ja.curves(a.asNurbs(), b.asNurbs(), c)
        }, cb.curvesAsync = function(a, b, c) {
            return null == c && (c = .001), Pa.dispatchMethod(Ja, "curves", [a.asNurbs(), b.asNurbs(), c])
        }, cb.curveAndSurface = function(a, b, c) {
            return null == c && (c = .001), Ja.curveAndSurface(a.asNurbs(), b.asNurbs(), c)
        }, cb.curveAndSurfaceAsync = function(a, b, c) {
            return null == c && (c = .001), Pa.dispatchMethod(Ja, "curveAndSurface", [a.asNurbs(), b.asNurbs(), c])
        }, cb.surfaces = function(a, b, c) {
            return null == c && (c = .001), Ja.surfaces(a.asNurbs(), b.asNurbs(), c).map(function(a) {
                return new Ta(a)
            })
        }, cb.surfacesAsync = function(a, b, c) {
            return null == c && (c = .001), Pa.dispatchMethod(Ja, "surfaces", [a.asNurbs(), b.asNurbs(), c]).then(function(a) {
                return a.map(function(a) {
                    return new Ta(a)
                })
            })
        };
        var db = b.geom.Line = function(a, b) {
            Ta.call(this, Ka.polyline([a, b])), this._start = a, this._end = b
        };
        g["verb.geom.Line"] = db, db.__name__ = ["verb", "geom", "Line"], db.__super__ = Ta, db.prototype = d(Ta.prototype, {
            start: function() {
                return this._start
            },
            end: function() {
                return this._end
            },
            __class__: db
        });
        var eb = b.geom.RevolvedSurface = function(a, b, c, d) {
            Ya.call(this, Ka.revolvedSurface(a.asNurbs(), b, c, d)), this._profile = a, this._center = b, this._axis = c, this._angle = d
        };
        g["verb.geom.RevolvedSurface"] = eb, eb.__name__ = ["verb", "geom", "RevolvedSurface"], eb.__super__ = Ya, eb.prototype = d(Ya.prototype, {
            profile: function() {
                return this._profile
            },
            center: function() {
                return this._center
            },
            axis: function() {
                return this._center
            },
            angle: function() {
                return this._angle
            },
            __class__: eb
        });
        var fb = b.geom.SphericalSurface = function(a, b) {
            Ya.call(this, Ka.sphericalSurface(a, [0, 0, 1], [1, 0, 0], b)), this._center = a, this._radius = b
        };
        g["verb.geom.SphericalSurface"] = fb, fb.__name__ = ["verb", "geom", "SphericalSurface"], fb.__super__ = Ya, fb.prototype = d(Ya.prototype, {
            center: function() {
                return this._center
            },
            radius: function() {
                return this._radius
            },
            __class__: fb
        });
        var gb = b.geom.SweptSurface = function(a, b) {
            Ya.call(this, Ka.rationalTranslationalSurface(a.asNurbs(), b.asNurbs())), this._profile = a, this._rail = b
        };
        g["verb.geom.SweptSurface"] = gb, gb.__name__ = ["verb", "geom", "SweptSurface"], gb.__super__ = Ya, gb.prototype = d(Ya.prototype, {
            profile: function() {
                return this._profile
            },
            rail: function() {
                return this._rail
            },
            __class__: gb
        });
        var hb, ib = 0;
        g.Math = Math, String.prototype.__class__ = g.String = String, String.__name__ = ["String"], g.Array = Array, Array.__name__ = ["Array"], Date.prototype.__class__ = g.Date = Date, Date.__name__ = ["Date"];
        var jb = g.Int = {
                __name__: ["Int"]
            },
            kb = g.Dynamic = {
                __name__: ["Dynamic"]
            },
            lb = g.Float = Number;
        lb.__name__ = ["Float"];
        var mb = g.Bool = Boolean;
        mb.__ename__ = ["Bool"];
        var nb = g.Class = {
                __name__: ["Class"]
            },
            ob = {};
        null == Array.prototype.map && (Array.prototype.map = function(a) {
            for (var b = [], c = 0, d = this.length; c < d;) {
                var e = c++;
                b[e] = a(this[e])
            }
            return b
        }), null == Array.prototype.filter && (Array.prototype.filter = function(a) {
            for (var b = [], c = 0, d = this.length; c < d;) {
                var e = c++,
                    f = this[e];
                a(f) && b.push(f)
            }
            return b
        });
        var pb = {},
            qb = c.ArrayBuffer || E;
        null == qb.prototype.slice && (qb.prototype.slice = E.sliceImpl);
        var rb = (c.DataView || F, c.Uint8Array || G._new);
        ! function(a, b) {
            function c(a) {
                return o[n] = d.apply(b, a), n++
            }

            function d(a) {
                var c = [].slice.call(arguments, 1);
                return function() {
                    "function" == typeof a ? a.apply(b, c) : new Function("" + a)()
                }
            }

            function e(a) {
                if (p) setTimeout(d(e, a), 0);
                else {
                    var b = o[a];
                    if (b) {
                        p = !0;
                        try {
                            b()
                        } finally {
                            f(a), p = !1
                        }
                    }
                }
            }

            function f(a) {
                delete o[a]
            }

            function g() {
                m = function() {
                    var a = c(arguments);
                    return process.nextTick(d(e, a)), a
                }
            }

            function h() {
                if (a.postMessage && !a.importScripts) {
                    var b = !0,
                        c = a.onmessage;
                    return a.onmessage = function() {
                        b = !1
                    }, a.postMessage("", "*"), a.onmessage = c, b
                }
            }

            function i() {
                var b = "setImmediate$" + Math.random() + "$",
                    d = function(c) {
                        c.source === a && "string" == typeof c.data && 0 === c.data.indexOf(b) && e(+c.data.slice(b.length))
                    };
                a.addEventListener ? a.addEventListener("message", d, !1) : a.attachEvent("onmessage", d), m = function() {
                    var d = c(arguments);
                    return a.postMessage(b + d, "*"), d
                }
            }

            function j() {
                var a = new MessageChannel;
                a.port1.onmessage = function(a) {
                    var b = a.data;
                    e(b)
                }, m = function() {
                    var b = c(arguments);
                    return a.port2.postMessage(b), b
                }
            }

            function k() {
                var a = q.documentElement;
                m = function() {
                    var b = c(arguments),
                        d = q.createElement("script");
                    return d.onreadystatechange = function() {
                        e(b), d.onreadystatechange = null, a.removeChild(d), d = null
                    }, a.appendChild(d), b
                }
            }

            function l() {
                m = function() {
                    var a = c(arguments);
                    return setTimeout(d(e, a), 0), a
                }
            }
            if (!a.setImmediate) {
                var m, n = 1,
                    o = {},
                    p = !1,
                    q = a.document,
                    r = Object.getPrototypeOf && Object.getPrototypeOf(a);
                r = r && r.setTimeout ? r : a, "[object process]" === {}.toString.call(a.process) ? g() : h() ? i() : a.MessageChannel ? j() : q && "onreadystatechange" in q.createElement("script") ? k() : l(), r.setImmediate = m, r.clearImmediate = f
            }
        }(new Function("return this")()), t.USE_CACHE = !1, t.USE_ENUM_INDEX = !1, t.BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:", u.DEFAULT_RESOLVER = q, u.BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:", w.count = 0, B.i64tmp = function(a) {
                var b, c = new s(0, 0);
                return b = c
            }(this), D.__toStr = {}.toString, G.BYTES_PER_ELEMENT = 1, M.queue = new k, Q.memo = new v, S.TOLERANCE = 1e-6, S.EPSILON = 1e-10, S.VERSION = "2.0.0", Da.Tvalues = [
                [],
                [],
                [-.5773502691896257, .5773502691896257],
                [0, -.7745966692414834, .7745966692414834],
                [-.33998104358485626, .33998104358485626, -.8611363115940526, .8611363115940526],
                [0, -.5384693101056831, .5384693101056831, -.906179845938664, .906179845938664],
                [.6612093864662645, -.6612093864662645, -.2386191860831969, .2386191860831969, -.932469514203152, .932469514203152],
                [0, .4058451513773972, -.4058451513773972, -.7415311855993945, .7415311855993945, -.9491079123427585, .9491079123427585],
                [-.1834346424956498, .1834346424956498, -.525532409916329, .525532409916329, -.7966664774136267, .7966664774136267, -.9602898564975363, .9602898564975363],
                [0, -.8360311073266358, .8360311073266358, -.9681602395076261, .9681602395076261, -.3242534234038089, .3242534234038089, -.6133714327005904, .6133714327005904],
                [-.14887433898163122, .14887433898163122, -.4333953941292472, .4333953941292472, -.6794095682990244, .6794095682990244, -.8650633666889845, .8650633666889845, -.9739065285171717, .9739065285171717],
                [0, -.26954315595234496, .26954315595234496, -.5190961292068118, .5190961292068118, -.7301520055740494, .7301520055740494, -.8870625997680953, .8870625997680953, -.978228658146057, .978228658146057],
                [-.1252334085114689, .1252334085114689, -.3678314989981802, .3678314989981802, -.5873179542866175, .5873179542866175, -.7699026741943047, .7699026741943047, -.9041172563704749, .9041172563704749, -.9815606342467192, .9815606342467192],
                [0, -.2304583159551348, .2304583159551348, -.44849275103644687, .44849275103644687, -.6423493394403402, .6423493394403402, -.8015780907333099, .8015780907333099, -.9175983992229779, .9175983992229779, -.9841830547185881, .9841830547185881],
                [-.10805494870734367, .10805494870734367, -.31911236892788974, .31911236892788974, -.5152486363581541, .5152486363581541, -.6872929048116855, .6872929048116855, -.827201315069765, .827201315069765, -.9284348836635735, .9284348836635735, -.9862838086968123, .9862838086968123],
                [0, -.20119409399743451, .20119409399743451, -.3941513470775634, .3941513470775634, -.5709721726085388, .5709721726085388, -.7244177313601701, .7244177313601701, -.8482065834104272, .8482065834104272, -.937273392400706, .937273392400706, -.9879925180204854, .9879925180204854],
                [-.09501250983763744, .09501250983763744, -.2816035507792589, .2816035507792589, -.45801677765722737, .45801677765722737, -.6178762444026438, .6178762444026438, -.755404408355003, .755404408355003, -.8656312023878318, .8656312023878318, -.9445750230732326, .9445750230732326, -.9894009349916499, .9894009349916499],
                [0, -.17848418149584785, .17848418149584785, -.3512317634538763, .3512317634538763, -.5126905370864769, .5126905370864769, -.6576711592166907, .6576711592166907, -.7815140038968014, .7815140038968014, -.8802391537269859, .8802391537269859, -.9506755217687678, .9506755217687678, -.9905754753144174, .9905754753144174],
                [-.0847750130417353, .0847750130417353, -.2518862256915055, .2518862256915055, -.41175116146284263, .41175116146284263, -.5597708310739475, .5597708310739475, -.6916870430603532, .6916870430603532, -.8037049589725231, .8037049589725231, -.8926024664975557, .8926024664975557, -.9558239495713977, .9558239495713977, -.9915651684209309, .9915651684209309],
                [0, -.16035864564022537, .16035864564022537, -.31656409996362983, .31656409996362983, -.46457074137596094, .46457074137596094, -.600545304661681, .600545304661681, -.7209661773352294, .7209661773352294, -.8227146565371428, .8227146565371428, -.9031559036148179, .9031559036148179, -.96020815213483, .96020815213483, -.9924068438435844, .9924068438435844],
                [-.07652652113349734, .07652652113349734, -.22778585114164507, .22778585114164507, -.37370608871541955, .37370608871541955, -.5108670019508271, .5108670019508271, -.636053680726515, .636053680726515, -.7463319064601508, .7463319064601508, -.8391169718222188, .8391169718222188, -.912234428251326, .912234428251326, -.9639719272779138, .9639719272779138, -.9931285991850949, .9931285991850949],
                [0, -.1455618541608951, .1455618541608951, -.2880213168024011, .2880213168024011, -.4243421202074388, .4243421202074388, -.5516188358872198, .5516188358872198, -.6671388041974123, .6671388041974123, -.7684399634756779, .7684399634756779, -.8533633645833173, .8533633645833173, -.9200993341504008, .9200993341504008, -.9672268385663063, .9672268385663063, -.9937521706203895, .9937521706203895],
                [-.06973927331972223, .06973927331972223, -.20786042668822127, .20786042668822127, -.34193582089208424, .34193582089208424, -.469355837986757, .469355837986757, -.5876404035069116, .5876404035069116, -.6944872631866827, .6944872631866827, -.7878168059792081, .7878168059792081, -.8658125777203002, .8658125777203002, -.926956772187174, .926956772187174, -.9700604978354287, .9700604978354287, -.9942945854823992, .9942945854823992],
                [0, -.1332568242984661, .1332568242984661, -.26413568097034495, .26413568097034495, -.3903010380302908, .3903010380302908, -.5095014778460075, .5095014778460075, -.6196098757636461, .6196098757636461, -.7186613631319502, .7186613631319502, -.8048884016188399, .8048884016188399, -.8767523582704416, .8767523582704416, -.9329710868260161, .9329710868260161, -.9725424712181152, .9725424712181152, -.9947693349975522, .9947693349975522],
                [-.06405689286260563, .06405689286260563, -.1911188674736163, .1911188674736163, -.3150426796961634, .3150426796961634, -.4337935076260451, .4337935076260451, -.5454214713888396, .5454214713888396, -.6480936519369755, .6480936519369755, -.7401241915785544, .7401241915785544, -.820001985973903, .820001985973903, -.8864155270044011, .8864155270044011, -.9382745520027328, .9382745520027328, -.9747285559713095, .9747285559713095, -.9951872199970213, .9951872199970213]
            ],
            Da.Cvalues = [
                [],
                [],
                [1, 1],
                [.8888888888888888, .5555555555555556, .5555555555555556],
                [.6521451548625461, .6521451548625461, .34785484513745385, .34785484513745385],
                [.5688888888888889, .47862867049936647, .47862867049936647, .23692688505618908, .23692688505618908],
                [.3607615730481386, .3607615730481386, .46791393457269104, .46791393457269104, .17132449237917036, .17132449237917036],
                [.4179591836734694, .3818300505051189, .3818300505051189, .27970539148927664, .27970539148927664, .1294849661688697, .1294849661688697],
                [.362683783378362, .362683783378362, .31370664587788727, .31370664587788727, .22238103445337448, .22238103445337448, .10122853629037626, .10122853629037626],
                [.3302393550012598, .1806481606948574, .1806481606948574, .08127438836157441, .08127438836157441, .31234707704000286, .31234707704000286, .26061069640293544, .26061069640293544],
                [.29552422471475287, .29552422471475287, .26926671930999635, .26926671930999635, .21908636251598204, .21908636251598204, .1494513491505806, .1494513491505806, .06667134430868814, .06667134430868814],
                [.2729250867779006, .26280454451024665, .26280454451024665, .23319376459199048, .23319376459199048, .18629021092773426, .18629021092773426, .1255803694649046, .1255803694649046, .05566856711617366, .05566856711617366],
                [.24914704581340277, .24914704581340277, .2334925365383548, .2334925365383548, .20316742672306592, .20316742672306592, .16007832854334622, .16007832854334622, .10693932599531843, .10693932599531843, .04717533638651183, .04717533638651183],
                [.2325515532308739, .22628318026289723, .22628318026289723, .2078160475368885, .2078160475368885, .17814598076194574, .17814598076194574, .13887351021978725, .13887351021978725, .09212149983772845, .09212149983772845, .04048400476531588, .04048400476531588],
                [.2152638534631578, .2152638534631578, .2051984637212956, .2051984637212956, .18553839747793782, .18553839747793782, .15720316715819355, .15720316715819355, .12151857068790319, .12151857068790319, .08015808715976021, .08015808715976021, .03511946033175186, .03511946033175186],
                [.2025782419255613, .19843148532711158, .19843148532711158, .1861610000155622, .1861610000155622, .16626920581699392, .16626920581699392, .13957067792615432, .13957067792615432, .10715922046717194, .10715922046717194, .07036604748810812, .07036604748810812, .03075324199611727, .03075324199611727],
                [.1894506104550685, .1894506104550685, .18260341504492358, .18260341504492358, .16915651939500254, .16915651939500254, .14959598881657674, .14959598881657674, .12462897125553388, .12462897125553388, .09515851168249279, .09515851168249279, .062253523938647894, .062253523938647894, .027152459411754096, .027152459411754096],
                [.17944647035620653, .17656270536699264, .17656270536699264, .16800410215645004, .16800410215645004, .15404576107681028, .15404576107681028, .13513636846852548, .13513636846852548, .11188384719340397, .11188384719340397, .08503614831717918, .08503614831717918, .0554595293739872, .0554595293739872, .02414830286854793, .02414830286854793],
                [.1691423829631436, .1691423829631436, .16427648374583273, .16427648374583273, .15468467512626524, .15468467512626524, .14064291467065065, .14064291467065065, .12255520671147846, .12255520671147846, .10094204410628717, .10094204410628717, .07642573025488905, .07642573025488905, .0497145488949698, .0497145488949698, .02161601352648331, .02161601352648331],
                [.1610544498487837, .15896884339395434, .15896884339395434, .15276604206585967, .15276604206585967, .1426067021736066, .1426067021736066, .12875396253933621, .12875396253933621, .11156664554733399, .11156664554733399, .09149002162245, .09149002162245, .06904454273764123, .06904454273764123, .0448142267656996, .0448142267656996, .019461788229726478, .019461788229726478],
                [.15275338713072584, .15275338713072584, .14917298647260374, .14917298647260374, .14209610931838204, .14209610931838204, .13168863844917664, .13168863844917664, .11819453196151841, .11819453196151841, .10193011981724044, .10193011981724044, .08327674157670475, .08327674157670475, .06267204833410907, .06267204833410907, .04060142980038694, .04060142980038694, .017614007139152118, .017614007139152118],
                [.14608113364969041, .14452440398997005, .14452440398997005, .13988739479107315, .13988739479107315, .13226893863333747, .13226893863333747, .12183141605372853, .12183141605372853, .10879729916714838, .10879729916714838, .09344442345603386, .09344442345603386, .0761001136283793, .0761001136283793, .057134425426857205, .057134425426857205, .036953789770852494, .036953789770852494, .016017228257774335, .016017228257774335],
                [.13925187285563198, .13925187285563198, .13654149834601517, .13654149834601517, .13117350478706238, .13117350478706238, .12325237681051242, .12325237681051242, .11293229608053922, .11293229608053922, .10041414444288096, .10041414444288096, .08594160621706773, .08594160621706773, .06979646842452049, .06979646842452049, .052293335152683286, .052293335152683286, .03377490158481415, .03377490158481415, .0146279952982722, .0146279952982722],
                [.13365457218610619, .1324620394046966, .1324620394046966, .12890572218808216, .12890572218808216, .12304908430672953, .12304908430672953, .11499664022241136, .11499664022241136, .10489209146454141, .10489209146454141, .09291576606003515, .09291576606003515, .07928141177671895, .07928141177671895, .06423242140852585, .06423242140852585, .04803767173108467, .04803767173108467, .030988005856979445, .030988005856979445, .013411859487141771, .013411859487141771],
                [.12793819534675216, .12793819534675216, .1258374563468283, .1258374563468283, .12167047292780339, .12167047292780339, .1155056680537256, .1155056680537256, .10744427011596563, .10744427011596563, .09761865210411388, .09761865210411388, .08619016153195327, .08619016153195327, .0733464814110803, .0733464814110803, .05929858491543678, .05929858491543678, .04427743881741981, .04427743881741981, .028531388628933663, .028531388628933663, .0123412297999872, .0123412297999872]
            ], Pa.THREADS = 1, Pa._init = !1, Qa.basePath = "", Ra.uuid = 0, O.main()
    }("undefined" != typeof console ? console : {
        log: function() {}
    }, a, "undefined" != typeof e ? e : "undefined" != typeof b ? b : "undefined" != typeof self ? self : this), a
});
/* axios v0.18.0 | (c) 2018 by Matt Zabriskie */
! function(e, t) {
    "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.axios = t() : e.axios = t()
}(this, function() {
    return function(e) {
        function t(r) {
            if (n[r]) return n[r].exports;
            var o = n[r] = {
                exports: {},
                id: r,
                loaded: !1
            };
            return e[r].call(o.exports, o, o.exports, t), o.loaded = !0, o.exports
        }
        var n = {};
        return t.m = e, t.c = n, t.p = "", t(0)
    }([function(e, t, n) {
        e.exports = n(1)
    }, function(e, t, n) {
        "use strict";

        function r(e) {
            var t = new s(e),
                n = i(s.prototype.request, t);
            return o.extend(n, s.prototype, t), o.extend(n, t), n
        }
        var o = n(2),
            i = n(3),
            s = n(5),
            u = n(6),
            a = r(u);
        a.Axios = s, a.create = function(e) {
            return r(o.merge(u, e))
        }, a.Cancel = n(23), a.CancelToken = n(24), a.isCancel = n(20), a.all = function(e) {
            return Promise.all(e)
        }, a.spread = n(25), e.exports = a, e.exports.default = a
    }, function(e, t, n) {
        "use strict";

        function r(e) {
            return "[object Array]" === R.call(e)
        }

        function o(e) {
            return "[object ArrayBuffer]" === R.call(e)
        }

        function i(e) {
            return "undefined" != typeof FormData && e instanceof FormData
        }

        function s(e) {
            var t;
            return t = "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer && e.buffer instanceof ArrayBuffer
        }

        function u(e) {
            return "string" == typeof e
        }

        function a(e) {
            return "number" == typeof e
        }

        function c(e) {
            return "undefined" == typeof e
        }

        function f(e) {
            return null !== e && "object" == typeof e
        }

        function p(e) {
            return "[object Date]" === R.call(e)
        }

        function d(e) {
            return "[object File]" === R.call(e)
        }

        function l(e) {
            return "[object Blob]" === R.call(e)
        }

        function h(e) {
            return "[object Function]" === R.call(e)
        }

        function m(e) {
            return f(e) && h(e.pipe)
        }

        function y(e) {
            return "undefined" != typeof URLSearchParams && e instanceof URLSearchParams
        }

        function w(e) {
            return e.replace(/^\s*/, "").replace(/\s*$/, "")
        }

        function g() {
            return ("undefined" == typeof navigator || "ReactNative" !== navigator.product) && ("undefined" != typeof window && "undefined" != typeof document)
        }

        function v(e, t) {
            if (null !== e && "undefined" != typeof e)
                if ("object" != typeof e && (e = [e]), r(e))
                    for (var n = 0, o = e.length; n < o; n++) t.call(null, e[n], n, e);
                else
                    for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.call(null, e[i], i, e)
        }

        function x() {
            function e(e, n) {
                "object" == typeof t[n] && "object" == typeof e ? t[n] = x(t[n], e) : t[n] = e
            }
            for (var t = {}, n = 0, r = arguments.length; n < r; n++) v(arguments[n], e);
            return t
        }

        function b(e, t, n) {
            return v(t, function(t, r) {
                n && "function" == typeof t ? e[r] = E(t, n) : e[r] = t
            }), e
        }
        var E = n(3),
            C = n(4),
            R = Object.prototype.toString;
        e.exports = {
            isArray: r,
            isArrayBuffer: o,
            isBuffer: C,
            isFormData: i,
            isArrayBufferView: s,
            isString: u,
            isNumber: a,
            isObject: f,
            isUndefined: c,
            isDate: p,
            isFile: d,
            isBlob: l,
            isFunction: h,
            isStream: m,
            isURLSearchParams: y,
            isStandardBrowserEnv: g,
            forEach: v,
            merge: x,
            extend: b,
            trim: w
        }
    }, function(e, t) {
        "use strict";
        e.exports = function(e, t) {
            return function() {
                for (var n = new Array(arguments.length), r = 0; r < n.length; r++) n[r] = arguments[r];
                return e.apply(t, n)
            }
        }
    }, function(e, t) {
        function n(e) {
            return !!e.constructor && "function" == typeof e.constructor.isBuffer && e.constructor.isBuffer(e)
        }

        function r(e) {
            return "function" == typeof e.readFloatLE && "function" == typeof e.slice && n(e.slice(0, 0))
        }
        /*!
         * Determine if an object is a Buffer
         *
         * @author   Feross Aboukhadijeh <https://feross.org>
         * @license  MIT
         */
        e.exports = function(e) {
            return null != e && (n(e) || r(e) || !!e._isBuffer)
        }
    }, function(e, t, n) {
        "use strict";

        function r(e) {
            this.defaults = e, this.interceptors = {
                request: new s,
                response: new s
            }
        }
        var o = n(6),
            i = n(2),
            s = n(17),
            u = n(18);
        r.prototype.request = function(e) {
            "string" == typeof e && (e = i.merge({
                url: arguments[0]
            }, arguments[1])), e = i.merge(o, {
                method: "get"
            }, this.defaults, e), e.method = e.method.toLowerCase();
            var t = [u, void 0],
                n = Promise.resolve(e);
            for (this.interceptors.request.forEach(function(e) {
                    t.unshift(e.fulfilled, e.rejected)
                }), this.interceptors.response.forEach(function(e) {
                    t.push(e.fulfilled, e.rejected)
                }); t.length;) n = n.then(t.shift(), t.shift());
            return n
        }, i.forEach(["delete", "get", "head", "options"], function(e) {
            r.prototype[e] = function(t, n) {
                return this.request(i.merge(n || {}, {
                    method: e,
                    url: t
                }))
            }
        }), i.forEach(["post", "put", "patch"], function(e) {
            r.prototype[e] = function(t, n, r) {
                return this.request(i.merge(r || {}, {
                    method: e,
                    url: t,
                    data: n
                }))
            }
        }), e.exports = r
    }, function(e, t, n) {
        "use strict";

        function r(e, t) {
            !i.isUndefined(e) && i.isUndefined(e["Content-Type"]) && (e["Content-Type"] = t)
        }

        function o() {
            var e;
            return "undefined" != typeof XMLHttpRequest ? e = n(8) : "undefined" != typeof process && (e = n(8)), e
        }
        var i = n(2),
            s = n(7),
            u = {
                "Content-Type": "application/x-www-form-urlencoded"
            },
            a = {
                adapter: o(),
                transformRequest: [function(e, t) {
                    return s(t, "Content-Type"), i.isFormData(e) || i.isArrayBuffer(e) || i.isBuffer(e) || i.isStream(e) || i.isFile(e) || i.isBlob(e) ? e : i.isArrayBufferView(e) ? e.buffer : i.isURLSearchParams(e) ? (r(t, "application/x-www-form-urlencoded;charset=utf-8"), e.toString()) : i.isObject(e) ? (r(t, "application/json;charset=utf-8"), JSON.stringify(e)) : e
                }],
                transformResponse: [function(e) {
                    if ("string" == typeof e) try {
                        e = JSON.parse(e)
                    } catch (e) {}
                    return e
                }],
                timeout: 0,
                xsrfCookieName: "XSRF-TOKEN",
                xsrfHeaderName: "X-XSRF-TOKEN",
                maxContentLength: -1,
                validateStatus: function(e) {
                    return e >= 200 && e < 300
                }
            };
        a.headers = {
            common: {
                Accept: "application/json, text/plain, */*"
            }
        }, i.forEach(["delete", "get", "head"], function(e) {
            a.headers[e] = {}
        }), i.forEach(["post", "put", "patch"], function(e) {
            a.headers[e] = i.merge(u)
        }), e.exports = a
    }, function(e, t, n) {
        "use strict";
        var r = n(2);
        e.exports = function(e, t) {
            r.forEach(e, function(n, r) {
                r !== t && r.toUpperCase() === t.toUpperCase() && (e[t] = n, delete e[r])
            })
        }
    }, function(e, t, n) {
        "use strict";
        var r = n(2),
            o = n(9),
            i = n(12),
            s = n(13),
            u = n(14),
            a = n(10),
            c = "undefined" != typeof window && window.btoa && window.btoa.bind(window) || n(15);
        e.exports = function(e) {
            return new Promise(function(t, f) {
                var p = e.data,
                    d = e.headers;
                r.isFormData(p) && delete d["Content-Type"];
                var l = new XMLHttpRequest,
                    h = "onreadystatechange",
                    m = !1;
                if ("undefined" == typeof window || !window.XDomainRequest || "withCredentials" in l || u(e.url) || (l = new window.XDomainRequest, h = "onload", m = !0, l.onprogress = function() {}, l.ontimeout = function() {}), e.auth) {
                    var y = e.auth.username || "",
                        w = e.auth.password || "";
                    d.Authorization = "Basic " + c(y + ":" + w)
                }
                if (l.open(e.method.toUpperCase(), i(e.url, e.params, e.paramsSerializer), !0), l.timeout = e.timeout, l[h] = function() {
                        if (l && (4 === l.readyState || m) && (0 !== l.status || l.responseURL && 0 === l.responseURL.indexOf("file:"))) {
                            var n = "getAllResponseHeaders" in l ? s(l.getAllResponseHeaders()) : null,
                                r = e.responseType && "text" !== e.responseType ? l.response : l.responseText,
                                i = {
                                    data: r,
                                    status: 1223 === l.status ? 204 : l.status,
                                    statusText: 1223 === l.status ? "No Content" : l.statusText,
                                    headers: n,
                                    config: e,
                                    request: l
                                };
                            o(t, f, i), l = null
                        }
                    }, l.onerror = function() {
                        f(a("Network Error", e, null, l)), l = null
                    }, l.ontimeout = function() {
                        f(a("timeout of " + e.timeout + "ms exceeded", e, "ECONNABORTED", l)), l = null
                    }, r.isStandardBrowserEnv()) {
                    var g = n(16),
                        v = (e.withCredentials || u(e.url)) && e.xsrfCookieName ? g.read(e.xsrfCookieName) : void 0;
                    v && (d[e.xsrfHeaderName] = v)
                }
                if ("setRequestHeader" in l && r.forEach(d, function(e, t) {
                        "undefined" == typeof p && "content-type" === t.toLowerCase() ? delete d[t] : l.setRequestHeader(t, e)
                    }), e.withCredentials && (l.withCredentials = !0), e.responseType) try {
                    l.responseType = e.responseType
                } catch (t) {
                    if ("json" !== e.responseType) throw t
                }
                "function" == typeof e.onDownloadProgress && l.addEventListener("progress", e.onDownloadProgress), "function" == typeof e.onUploadProgress && l.upload && l.upload.addEventListener("progress", e.onUploadProgress), e.cancelToken && e.cancelToken.promise.then(function(e) {
                    l && (l.abort(), f(e), l = null)
                }), void 0 === p && (p = null), l.send(p)
            })
        }
    }, function(e, t, n) {
        "use strict";
        var r = n(10);
        e.exports = function(e, t, n) {
            var o = n.config.validateStatus;
            n.status && o && !o(n.status) ? t(r("Request failed with status code " + n.status, n.config, null, n.request, n)) : e(n)
        }
    }, function(e, t, n) {
        "use strict";
        var r = n(11);
        e.exports = function(e, t, n, o, i) {
            var s = new Error(e);
            return r(s, t, n, o, i)
        }
    }, function(e, t) {
        "use strict";
        e.exports = function(e, t, n, r, o) {
            return e.config = t, n && (e.code = n), e.request = r, e.response = o, e
        }
    }, function(e, t, n) {
        "use strict";

        function r(e) {
            return encodeURIComponent(e).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
        }
        var o = n(2);
        e.exports = function(e, t, n) {
            if (!t) return e;
            var i;
            if (n) i = n(t);
            else if (o.isURLSearchParams(t)) i = t.toString();
            else {
                var s = [];
                o.forEach(t, function(e, t) {
                    null !== e && "undefined" != typeof e && (o.isArray(e) ? t += "[]" : e = [e], o.forEach(e, function(e) {
                        o.isDate(e) ? e = e.toISOString() : o.isObject(e) && (e = JSON.stringify(e)), s.push(r(t) + "=" + r(e))
                    }))
                }), i = s.join("&")
            }
            return i && (e += (e.indexOf("?") === -1 ? "?" : "&") + i), e
        }
    }, function(e, t, n) {
        "use strict";
        var r = n(2),
            o = ["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"];
        e.exports = function(e) {
            var t, n, i, s = {};
            return e ? (r.forEach(e.split("\n"), function(e) {
                if (i = e.indexOf(":"), t = r.trim(e.substr(0, i)).toLowerCase(), n = r.trim(e.substr(i + 1)), t) {
                    if (s[t] && o.indexOf(t) >= 0) return;
                    "set-cookie" === t ? s[t] = (s[t] ? s[t] : []).concat([n]) : s[t] = s[t] ? s[t] + ", " + n : n
                }
            }), s) : s
        }
    }, function(e, t, n) {
        "use strict";
        var r = n(2);
        e.exports = r.isStandardBrowserEnv() ? function() {
            function e(e) {
                var t = e;
                return n && (o.setAttribute("href", t), t = o.href), o.setAttribute("href", t), {
                    href: o.href,
                    protocol: o.protocol ? o.protocol.replace(/:$/, "") : "",
                    host: o.host,
                    search: o.search ? o.search.replace(/^\?/, "") : "",
                    hash: o.hash ? o.hash.replace(/^#/, "") : "",
                    hostname: o.hostname,
                    port: o.port,
                    pathname: "/" === o.pathname.charAt(0) ? o.pathname : "/" + o.pathname
                }
            }
            var t, n = /(msie|trident)/i.test(navigator.userAgent),
                o = document.createElement("a");
            return t = e(window.location.href),
                function(n) {
                    var o = r.isString(n) ? e(n) : n;
                    return o.protocol === t.protocol && o.host === t.host
                }
        }() : function() {
            return function() {
                return !0
            }
        }()
    }, function(e, t) {
        "use strict";

        function n() {
            this.message = "String contains an invalid character"
        }

        function r(e) {
            for (var t, r, i = String(e), s = "", u = 0, a = o; i.charAt(0 | u) || (a = "=", u % 1); s += a.charAt(63 & t >> 8 - u % 1 * 8)) {
                if (r = i.charCodeAt(u += .75), r > 255) throw new n;
                t = t << 8 | r
            }
            return s
        }
        var o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        n.prototype = new Error, n.prototype.code = 5, n.prototype.name = "InvalidCharacterError", e.exports = r
    }, function(e, t, n) {
        "use strict";
        var r = n(2);
        e.exports = r.isStandardBrowserEnv() ? function() {
            return {
                write: function(e, t, n, o, i, s) {
                    var u = [];
                    u.push(e + "=" + encodeURIComponent(t)), r.isNumber(n) && u.push("expires=" + new Date(n).toGMTString()), r.isString(o) && u.push("path=" + o), r.isString(i) && u.push("domain=" + i), s === !0 && u.push("secure"), document.cookie = u.join("; ")
                },
                read: function(e) {
                    var t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
                    return t ? decodeURIComponent(t[3]) : null
                },
                remove: function(e) {
                    this.write(e, "", Date.now() - 864e5)
                }
            }
        }() : function() {
            return {
                write: function() {},
                read: function() {
                    return null
                },
                remove: function() {}
            }
        }()
    }, function(e, t, n) {
        "use strict";

        function r() {
            this.handlers = []
        }
        var o = n(2);
        r.prototype.use = function(e, t) {
            return this.handlers.push({
                fulfilled: e,
                rejected: t
            }), this.handlers.length - 1
        }, r.prototype.eject = function(e) {
            this.handlers[e] && (this.handlers[e] = null)
        }, r.prototype.forEach = function(e) {
            o.forEach(this.handlers, function(t) {
                null !== t && e(t)
            })
        }, e.exports = r
    }, function(e, t, n) {
        "use strict";

        function r(e) {
            e.cancelToken && e.cancelToken.throwIfRequested()
        }
        var o = n(2),
            i = n(19),
            s = n(20),
            u = n(6),
            a = n(21),
            c = n(22);
        e.exports = function(e) {
            r(e), e.baseURL && !a(e.url) && (e.url = c(e.baseURL, e.url)), e.headers = e.headers || {}, e.data = i(e.data, e.headers, e.transformRequest), e.headers = o.merge(e.headers.common || {}, e.headers[e.method] || {}, e.headers || {}), o.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function(t) {
                delete e.headers[t]
            });
            var t = e.adapter || u.adapter;
            return t(e).then(function(t) {
                return r(e), t.data = i(t.data, t.headers, e.transformResponse), t
            }, function(t) {
                return s(t) || (r(e), t && t.response && (t.response.data = i(t.response.data, t.response.headers, e.transformResponse))), Promise.reject(t)
            })
        }
    }, function(e, t, n) {
        "use strict";
        var r = n(2);
        e.exports = function(e, t, n) {
            return r.forEach(n, function(n) {
                e = n(e, t)
            }), e
        }
    }, function(e, t) {
        "use strict";
        e.exports = function(e) {
            return !(!e || !e.__CANCEL__)
        }
    }, function(e, t) {
        "use strict";
        e.exports = function(e) {
            return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(e)
        }
    }, function(e, t) {
        "use strict";
        e.exports = function(e, t) {
            return t ? e.replace(/\/+$/, "") + "/" + t.replace(/^\/+/, "") : e
        }
    }, function(e, t) {
        "use strict";

        function n(e) {
            this.message = e
        }
        n.prototype.toString = function() {
            return "Cancel" + (this.message ? ": " + this.message : "")
        }, n.prototype.__CANCEL__ = !0, e.exports = n
    }, function(e, t, n) {
        "use strict";

        function r(e) {
            if ("function" != typeof e) throw new TypeError("executor must be a function.");
            var t;
            this.promise = new Promise(function(e) {
                t = e
            });
            var n = this;
            e(function(e) {
                n.reason || (n.reason = new o(e), t(n.reason))
            })
        }
        var o = n(23);
        r.prototype.throwIfRequested = function() {
            if (this.reason) throw this.reason
        }, r.source = function() {
            var e, t = new r(function(t) {
                e = t
            });
            return {
                token: t,
                cancel: e
            }
        }, e.exports = r
    }, function(e, t) {
        "use strict";
        e.exports = function(e) {
            return function(t) {
                return e.apply(null, t)
            }
        }
    }])
});

'use strict';
var $jscomp = $jscomp || {};
$jscomp.scope = {};
$jscomp.ASSUME_ES5 = !1;
$jscomp.ASSUME_NO_NATIVE_MAP = !1;
$jscomp.ASSUME_NO_NATIVE_SET = !1;
$jscomp.defineProperty = $jscomp.ASSUME_ES5 || "function" == typeof Object.defineProperties ? Object.defineProperty : function(a, b, c) {
    a != Array.prototype && a != Object.prototype && (a[b] = c.value)
};
$jscomp.getGlobal = function(a) {
    return "undefined" != typeof window && window === a ? a : "undefined" != typeof global && null != global ? global : a
};
$jscomp.global = $jscomp.getGlobal(this);
$jscomp.SYMBOL_PREFIX = "jscomp_symbol_";
$jscomp.initSymbol = function() {
    $jscomp.initSymbol = function() {};
    $jscomp.global.Symbol || ($jscomp.global.Symbol = $jscomp.Symbol)
};
$jscomp.Symbol = function() {
    var a = 0;
    return function(b) {
        return $jscomp.SYMBOL_PREFIX + (b || "") + a++
    }
}();
$jscomp.initSymbolIterator = function() {
    $jscomp.initSymbol();
    var a = $jscomp.global.Symbol.iterator;
    a || (a = $jscomp.global.Symbol.iterator = $jscomp.global.Symbol("iterator"));
    "function" != typeof Array.prototype[a] && $jscomp.defineProperty(Array.prototype, a, {
        configurable: !0,
        writable: !0,
        value: function() {
            return $jscomp.arrayIterator(this)
        }
    });
    $jscomp.initSymbolIterator = function() {}
};
$jscomp.arrayIterator = function(a) {
    var b = 0;
    return $jscomp.iteratorPrototype(function() {
        return b < a.length ? {
            done: !1,
            value: a[b++]
        } : {
            done: !0
        }
    })
};
$jscomp.iteratorPrototype = function(a) {
    $jscomp.initSymbolIterator();
    a = {
        next: a
    };
    a[$jscomp.global.Symbol.iterator] = function() {
        return this
    };
    return a
};
$jscomp.makeIterator = function(a) {
    $jscomp.initSymbolIterator();
    var b = a[Symbol.iterator];
    return b ? b.call(a) : $jscomp.arrayIterator(a)
};
$jscomp.arrayFromIterator = function(a) {
    for (var b, c = []; !(b = a.next()).done;) c.push(b.value);
    return c
};
$jscomp.arrayFromIterable = function(a) {
    return a instanceof Array ? a : $jscomp.arrayFromIterator($jscomp.makeIterator(a))
};
$jscomp.checkStringArgs = function(a, b, c) {
    if (null == a) throw new TypeError("The 'this' value for String.prototype." + c + " must not be null or undefined");
    if (b instanceof RegExp) throw new TypeError("First argument to String.prototype." + c + " must not be a regular expression");
    return a + ""
};
$jscomp.polyfill = function(a, b, c, d) {
    if (b) {
        c = $jscomp.global;
        a = a.split(".");
        for (d = 0; d < a.length - 1; d++) {
            var e = a[d];
            e in c || (c[e] = {});
            c = c[e]
        }
        a = a[a.length - 1];
        d = c[a];
        b = b(d);
        b != d && null != b && $jscomp.defineProperty(c, a, {
            configurable: !0,
            writable: !0,
            value: b
        })
    }
};
$jscomp.polyfill("String.prototype.repeat", function(a) {
    return a ? a : function(a) {
        var b = $jscomp.checkStringArgs(this, null, "repeat");
        if (0 > a || 1342177279 < a) throw new RangeError("Invalid count value");
        a |= 0;
        for (var d = ""; a;)
            if (a & 1 && (d += b), a >>>= 1) b += b;
        return d
    }
}, "es6", "es3");
$jscomp.stringPadding = function(a, b) {
    a = void 0 !== a ? String(a) : " ";
    return 0 < b && a ? a.repeat(Math.ceil(b / a.length)).substring(0, b) : ""
};
$jscomp.polyfill("String.prototype.padStart", function(a) {
    return a ? a : function(a, c) {
        var b = $jscomp.checkStringArgs(this, null, "padStart");
        return $jscomp.stringPadding(c, a - b.length) + b
    }
}, "es8", "es3");
$jscomp.polyfill("String.prototype.padEnd", function(a) {
    return a ? a : function(a, c) {
        var b = $jscomp.checkStringArgs(this, null, "padStart");
        return b + $jscomp.stringPadding(c, a - b.length)
    }
}, "es8", "es3");
$jscomp.findInternal = function(a, b, c) {
    a instanceof String && (a = String(a));
    for (var d = a.length, e = 0; e < d; e++) {
        var f = a[e];
        if (b.call(c, f, e, a)) return {
            i: e,
            v: f
        }
    }
    return {
        i: -1,
        v: void 0
    }
};
$jscomp.polyfill("Array.prototype.findIndex", function(a) {
    return a ? a : function(a, c) {
        return $jscomp.findInternal(this, a, c).i
    }
}, "es6", "es3");
$jscomp.polyfill("String.prototype.endsWith", function(a) {
    return a ? a : function(a, c) {
        var b = $jscomp.checkStringArgs(this, a, "endsWith");
        a += "";
        void 0 === c && (c = b.length);
        c = Math.max(0, Math.min(c | 0, b.length));
        for (var e = a.length; 0 < e && 0 < c;)
            if (b[--c] != a[--e]) return !1;
        return 0 >= e
    }
}, "es6", "es3");
$jscomp.iteratorFromArray = function(a, b) {
    $jscomp.initSymbolIterator();
    a instanceof String && (a += "");
    var c = 0,
        d = {
            next: function() {
                if (c < a.length) {
                    var e = c++;
                    return {
                        value: b(e, a[e]),
                        done: !1
                    }
                }
                d.next = function() {
                    return {
                        done: !0,
                        value: void 0
                    }
                };
                return d.next()
            }
        };
    d[Symbol.iterator] = function() {
        return d
    };
    return d
};
$jscomp.polyfill("Array.prototype.keys", function(a) {
    return a ? a : function() {
        return $jscomp.iteratorFromArray(this, function(a) {
            return a
        })
    }
}, "es6", "es3");
$jscomp.polyfill("Object.is", function(a) {
    return a ? a : function(a, c) {
        return a === c ? 0 !== a || 1 / a === 1 / c : a !== a && c !== c
    }
}, "es6", "es3");
$jscomp.polyfill("Array.prototype.includes", function(a) {
    return a ? a : function(a, c) {
        var b = this;
        b instanceof String && (b = String(b));
        var e = b.length;
        c = c || 0;
        for (0 > c && (c = Math.max(c + e, 0)); c < e; c++) {
            var f = b[c];
            if (f === a || Object.is(f, a)) return !0
        }
        return !1
    }
}, "es7", "es3");
$jscomp.polyfill("String.prototype.includes", function(a) {
    return a ? a : function(a, c) {
        return -1 !== $jscomp.checkStringArgs(this, a, "includes").indexOf(a, c || 0)
    }
}, "es6", "es3");
$jscomp.polyfill("String.prototype.startsWith", function(a) {
    return a ? a : function(a, c) {
        var b = $jscomp.checkStringArgs(this, a, "startsWith");
        a += "";
        var e = b.length,
            f = a.length;
        c = Math.max(0, Math.min(c | 0, b.length));
        for (var g = 0; g < f && c < e;)
            if (b[c++] != a[g++]) return !1;
        return g >= f
    }
}, "es6", "es3");
$jscomp.FORCE_POLYFILL_PROMISE = !1;
$jscomp.polyfill("Promise", function(a) {
    function b() {
        this.batch_ = null
    }

    function c(a) {
        return a instanceof e ? a : new e(function(b, c) {
            b(a)
        })
    }
    if (a && !$jscomp.FORCE_POLYFILL_PROMISE) return a;
    b.prototype.asyncExecute = function(a) {
        null == this.batch_ && (this.batch_ = [], this.asyncExecuteBatch_());
        this.batch_.push(a);
        return this
    };
    b.prototype.asyncExecuteBatch_ = function() {
        var a = this;
        this.asyncExecuteFunction(function() {
            a.executeBatch_()
        })
    };
    var d = $jscomp.global.setTimeout;
    b.prototype.asyncExecuteFunction = function(a) {
        d(a,
            0)
    };
    b.prototype.executeBatch_ = function() {
        for (; this.batch_ && this.batch_.length;) {
            var a = this.batch_;
            this.batch_ = [];
            for (var b = 0; b < a.length; ++b) {
                var c = a[b];
                a[b] = null;
                try {
                    c()
                } catch (l) {
                    this.asyncThrow_(l)
                }
            }
        }
        this.batch_ = null
    };
    b.prototype.asyncThrow_ = function(a) {
        this.asyncExecuteFunction(function() {
            throw a;
        })
    };
    var e = function(a) {
        this.state_ = 0;
        this.result_ = void 0;
        this.onSettledCallbacks_ = [];
        var b = this.createResolveAndReject_();
        try {
            a(b.resolve, b.reject)
        } catch (k) {
            b.reject(k)
        }
    };
    e.prototype.createResolveAndReject_ =
        function() {
            function a(a) {
                return function(d) {
                    c || (c = !0, a.call(b, d))
                }
            }
            var b = this,
                c = !1;
            return {
                resolve: a(this.resolveTo_),
                reject: a(this.reject_)
            }
        };
    e.prototype.resolveTo_ = function(a) {
        if (a === this) this.reject_(new TypeError("A Promise cannot resolve to itself"));
        else if (a instanceof e) this.settleSameAsPromise_(a);
        else {
            a: switch (typeof a) {
                case "object":
                    var b = null != a;
                    break a;
                case "function":
                    b = !0;
                    break a;
                default:
                    b = !1
            }
            b ? this.resolveToNonPromiseObj_(a) : this.fulfill_(a)
        }
    };
    e.prototype.resolveToNonPromiseObj_ = function(a) {
        var b =
            void 0;
        try {
            b = a.then
        } catch (k) {
            this.reject_(k);
            return
        }
        "function" == typeof b ? this.settleSameAsThenable_(b, a) : this.fulfill_(a)
    };
    e.prototype.reject_ = function(a) {
        this.settle_(2, a)
    };
    e.prototype.fulfill_ = function(a) {
        this.settle_(1, a)
    };
    e.prototype.settle_ = function(a, b) {
        if (0 != this.state_) throw Error("Cannot settle(" + a + ", " + b + "): Promise already settled in state" + this.state_);
        this.state_ = a;
        this.result_ = b;
        this.executeOnSettledCallbacks_()
    };
    e.prototype.executeOnSettledCallbacks_ = function() {
        if (null != this.onSettledCallbacks_) {
            for (var a =
                    0; a < this.onSettledCallbacks_.length; ++a) f.asyncExecute(this.onSettledCallbacks_[a]);
            this.onSettledCallbacks_ = null
        }
    };
    var f = new b;
    e.prototype.settleSameAsPromise_ = function(a) {
        var b = this.createResolveAndReject_();
        a.callWhenSettled_(b.resolve, b.reject)
    };
    e.prototype.settleSameAsThenable_ = function(a, b) {
        var c = this.createResolveAndReject_();
        try {
            a.call(b, c.resolve, c.reject)
        } catch (l) {
            c.reject(l)
        }
    };
    e.prototype.then = function(a, b) {
        function c(a, b) {
            return "function" == typeof a ? function(b) {
                    try {
                        d(a(b))
                    } catch (t) {
                        f(t)
                    }
                } :
                b
        }
        var d, f, g = new e(function(a, b) {
            d = a;
            f = b
        });
        this.callWhenSettled_(c(a, d), c(b, f));
        return g
    };
    e.prototype.catch = function(a) {
        return this.then(void 0, a)
    };
    e.prototype.callWhenSettled_ = function(a, b) {
        function c() {
            switch (d.state_) {
                case 1:
                    a(d.result_);
                    break;
                case 2:
                    b(d.result_);
                    break;
                default:
                    throw Error("Unexpected state: " + d.state_);
            }
        }
        var d = this;
        null == this.onSettledCallbacks_ ? f.asyncExecute(c) : this.onSettledCallbacks_.push(c)
    };
    e.resolve = c;
    e.reject = function(a) {
        return new e(function(b, c) {
            c(a)
        })
    };
    e.race = function(a) {
        return new e(function(b,
            d) {
            for (var e = $jscomp.makeIterator(a), f = e.next(); !f.done; f = e.next()) c(f.value).callWhenSettled_(b, d)
        })
    };
    e.all = function(a) {
        var b = $jscomp.makeIterator(a),
            d = b.next();
        return d.done ? c([]) : new e(function(a, e) {
            function f(b) {
                return function(c) {
                    g[b] = c;
                    h--;
                    0 == h && a(g)
                }
            }
            var g = [],
                h = 0;
            do g.push(void 0), h++, c(d.value).callWhenSettled_(f(g.length - 1), e), d = b.next(); while (!d.done)
        })
    };
    return e
}, "es6", "es3");
$jscomp.polyfill("Array.prototype.find", function(a) {
    return a ? a : function(a, c) {
        return $jscomp.findInternal(this, a, c).v
    }
}, "es6", "es3");
$jscomp.polyfill("Number.EPSILON", function(a) {
    return Math.pow(2, -52)
}, "es6", "es3");
$jscomp.polyfill("Number.MAX_SAFE_INTEGER", function() {
    return 9007199254740991
}, "es6", "es3");
$jscomp.polyfill("Number.MIN_SAFE_INTEGER", function() {
    return -9007199254740991
}, "es6", "es3");
$jscomp.polyfill("Math.sign", function(a) {
    return a ? a : function(a) {
        a = Number(a);
        return 0 === a || isNaN(a) ? a : 0 < a ? 1 : -1
    }
}, "es6", "es3");
$jscomp.owns = function(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b)
};
$jscomp.assign = "function" == typeof Object.assign ? Object.assign : function(a, b) {
    for (var c = 1; c < arguments.length; c++) {
        var d = arguments[c];
        if (d)
            for (var e in d) $jscomp.owns(d, e) && (a[e] = d[e])
    }
    return a
};
$jscomp.polyfill("Object.assign", function(a) {
    return a || $jscomp.assign
}, "es6", "es3");
$jscomp.checkEs6ConformanceViaProxy = function() {
    try {
        var a = {},
            b = Object.create(new $jscomp.global.Proxy(a, {
                get: function(c, d, e) {
                    return c == a && "q" == d && e == b
                }
            }));
        return !0 === b.q
    } catch (c) {
        return !1
    }
};
$jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS = !1;
$jscomp.ES6_CONFORMANCE = $jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS && $jscomp.checkEs6ConformanceViaProxy();
$jscomp.polyfill("WeakMap", function(a) {
    function b() {
        if (!a || !Object.seal) return !1;
        try {
            var b = Object.seal({}),
                c = Object.seal({}),
                d = new a([
                    [b, 2],
                    [c, 3]
                ]);
            if (2 != d.get(b) || 3 != d.get(c)) return !1;
            d.delete(b);
            d.set(c, 4);
            return !d.has(b) && 4 == d.get(c)
        } catch (p) {
            return !1
        }
    }

    function c(a) {
        $jscomp.owns(a, e) || $jscomp.defineProperty(a, e, {
            value: {}
        })
    }

    function d(a) {
        var b = Object[a];
        b && (Object[a] = function(a) {
            c(a);
            return b(a)
        })
    }
    if ($jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS) {
        if (a && $jscomp.ES6_CONFORMANCE) return a
    } else if (b()) return a;
    var e = "$jscomp_hidden_" + Math.random();
    d("freeze");
    d("preventExtensions");
    d("seal");
    var f = 0,
        g = function(a) {
            this.id_ = (f += Math.random() + 1).toString();
            if (a) {
                $jscomp.initSymbol();
                $jscomp.initSymbolIterator();
                a = $jscomp.makeIterator(a);
                for (var b; !(b = a.next()).done;) b = b.value, this.set(b[0], b[1])
            }
        };
    g.prototype.set = function(a, b) {
        c(a);
        if (!$jscomp.owns(a, e)) throw Error("WeakMap key fail: " + a);
        a[e][this.id_] = b;
        return this
    };
    g.prototype.get = function(a) {
        return $jscomp.owns(a, e) ? a[e][this.id_] : void 0
    };
    g.prototype.has =
        function(a) {
            return $jscomp.owns(a, e) && $jscomp.owns(a[e], this.id_)
        };
    g.prototype.delete = function(a) {
        return $jscomp.owns(a, e) && $jscomp.owns(a[e], this.id_) ? delete a[e][this.id_] : !1
    };
    return g
}, "es6", "es3");
$jscomp.polyfill("Array.prototype.values", function(a) {
    return a ? a : function() {
        return $jscomp.iteratorFromArray(this, function(a, c) {
            return c
        })
    }
}, "es8", "es3");
$jscomp.polyfill("Number.isFinite", function(a) {
    return a ? a : function(a) {
        return "number" !== typeof a ? !1 : !isNaN(a) && Infinity !== a && -Infinity !== a
    }
}, "es6", "es3");
$jscomp.polyfill("Number.isInteger", function(a) {
    return a ? a : function(a) {
        return Number.isFinite(a) ? a === Math.floor(a) : !1
    }
}, "es6", "es3");
$jscomp.polyfill("Number.isNaN", function(a) {
    return a ? a : function(a) {
        return "number" === typeof a && isNaN(a)
    }
}, "es6", "es3");
var module$node_modules$tinycolor2$tinycolor = {
        default: function(a, b) {
            a = a ? a : "";
            b = b || {};
            if (a instanceof module$node_modules$tinycolor2$tinycolor.default) return a;
            if (!(this instanceof module$node_modules$tinycolor2$tinycolor.default)) return new module$node_modules$tinycolor2$tinycolor.default(a, b);
            var c = inputToRGB$$module$node_modules$tinycolor2$tinycolor(a);
            this._originalInput = a;
            this._r = c.r;
            this._g = c.g;
            this._b = c.b;
            this._a = c.a;
            this._roundA = mathRound$$module$node_modules$tinycolor2$tinycolor(100 * this._a) /
                100;
            this._format = b.format || c.format;
            this._gradientType = b.gradientType;
            1 > this._r && (this._r = mathRound$$module$node_modules$tinycolor2$tinycolor(this._r));
            1 > this._g && (this._g = mathRound$$module$node_modules$tinycolor2$tinycolor(this._g));
            1 > this._b && (this._b = mathRound$$module$node_modules$tinycolor2$tinycolor(this._b));
            this._ok = c.ok;
            this._tc_id = tinyCounter$$module$node_modules$tinycolor2$tinycolor++
        }
    },
    Math$$module$node_modules$tinycolor2$tinycolor = Math,
    trimLeft$$module$node_modules$tinycolor2$tinycolor =
    /^\s+/,
    trimRight$$module$node_modules$tinycolor2$tinycolor = /\s+$/,
    tinyCounter$$module$node_modules$tinycolor2$tinycolor = 0,
    mathRound$$module$node_modules$tinycolor2$tinycolor = Math$$module$node_modules$tinycolor2$tinycolor.round,
    mathMin$$module$node_modules$tinycolor2$tinycolor = Math$$module$node_modules$tinycolor2$tinycolor.min,
    mathMax$$module$node_modules$tinycolor2$tinycolor = Math$$module$node_modules$tinycolor2$tinycolor.max,
    mathRandom$$module$node_modules$tinycolor2$tinycolor = Math$$module$node_modules$tinycolor2$tinycolor.random;
module$node_modules$tinycolor2$tinycolor.default.prototype = {
    isDark: function() {
        return 128 > this.getBrightness()
    },
    isLight: function() {
        return !this.isDark()
    },
    isValid: function() {
        return this._ok
    },
    getOriginalInput: function() {
        return this._originalInput
    },
    getFormat: function() {
        return this._format
    },
    getAlpha: function() {
        return this._a
    },
    getBrightness: function() {
        var a = this.toRgb();
        return (299 * a.r + 587 * a.g + 114 * a.b) / 1E3
    },
    getLuminance: function() {
        var a = this.toRgb();
        var b = a.r / 255;
        var c = a.g / 255;
        a = a.b / 255;
        b = .03928 >= b ? b / 12.92 :
            Math$$module$node_modules$tinycolor2$tinycolor.pow((b + .055) / 1.055, 2.4);
        c = .03928 >= c ? c / 12.92 : Math$$module$node_modules$tinycolor2$tinycolor.pow((c + .055) / 1.055, 2.4);
        a = .03928 >= a ? a / 12.92 : Math$$module$node_modules$tinycolor2$tinycolor.pow((a + .055) / 1.055, 2.4);
        return .2126 * b + .7152 * c + .0722 * a
    },
    setAlpha: function(a) {
        this._a = boundAlpha$$module$node_modules$tinycolor2$tinycolor(a);
        this._roundA = mathRound$$module$node_modules$tinycolor2$tinycolor(100 * this._a) / 100;
        return this
    },
    toHsv: function() {
        var a = rgbToHsv$$module$node_modules$tinycolor2$tinycolor(this._r,
            this._g, this._b);
        return {
            h: 360 * a.h,
            s: a.s,
            v: a.v,
            a: this._a
        }
    },
    toHsvString: function() {
        var a = rgbToHsv$$module$node_modules$tinycolor2$tinycolor(this._r, this._g, this._b),
            b = mathRound$$module$node_modules$tinycolor2$tinycolor(360 * a.h),
            c = mathRound$$module$node_modules$tinycolor2$tinycolor(100 * a.s);
        a = mathRound$$module$node_modules$tinycolor2$tinycolor(100 * a.v);
        return 1 == this._a ? "hsv(" + b + ", " + c + "%, " + a + "%)" : "hsva(" + b + ", " + c + "%, " + a + "%, " + this._roundA + ")"
    },
    toHsl: function() {
        var a = rgbToHsl$$module$node_modules$tinycolor2$tinycolor(this._r,
            this._g, this._b);
        return {
            h: 360 * a.h,
            s: a.s,
            l: a.l,
            a: this._a
        }
    },
    toHslString: function() {
        var a = rgbToHsl$$module$node_modules$tinycolor2$tinycolor(this._r, this._g, this._b),
            b = mathRound$$module$node_modules$tinycolor2$tinycolor(360 * a.h),
            c = mathRound$$module$node_modules$tinycolor2$tinycolor(100 * a.s);
        a = mathRound$$module$node_modules$tinycolor2$tinycolor(100 * a.l);
        return 1 == this._a ? "hsl(" + b + ", " + c + "%, " + a + "%)" : "hsla(" + b + ", " + c + "%, " + a + "%, " + this._roundA + ")"
    },
    toHex: function(a) {
        return rgbToHex$$module$node_modules$tinycolor2$tinycolor(this._r,
            this._g, this._b, a)
    },
    toHexString: function(a) {
        return "#" + this.toHex(a)
    },
    toHex8: function(a) {
        return rgbaToHex$$module$node_modules$tinycolor2$tinycolor(this._r, this._g, this._b, this._a, a)
    },
    toHex8String: function(a) {
        return "#" + this.toHex8(a)
    },
    toRgb: function() {
        return {
            r: mathRound$$module$node_modules$tinycolor2$tinycolor(this._r),
            g: mathRound$$module$node_modules$tinycolor2$tinycolor(this._g),
            b: mathRound$$module$node_modules$tinycolor2$tinycolor(this._b),
            a: this._a
        }
    },
    toRgbString: function() {
        return 1 == this._a ? "rgb(" +
            mathRound$$module$node_modules$tinycolor2$tinycolor(this._r) + ", " + mathRound$$module$node_modules$tinycolor2$tinycolor(this._g) + ", " + mathRound$$module$node_modules$tinycolor2$tinycolor(this._b) + ")" : "rgba(" + mathRound$$module$node_modules$tinycolor2$tinycolor(this._r) + ", " + mathRound$$module$node_modules$tinycolor2$tinycolor(this._g) + ", " + mathRound$$module$node_modules$tinycolor2$tinycolor(this._b) + ", " + this._roundA + ")"
    },
    toPercentageRgb: function() {
        return {
            r: mathRound$$module$node_modules$tinycolor2$tinycolor(100 *
                bound01$$module$node_modules$tinycolor2$tinycolor(this._r, 255)) + "%",
            g: mathRound$$module$node_modules$tinycolor2$tinycolor(100 * bound01$$module$node_modules$tinycolor2$tinycolor(this._g, 255)) + "%",
            b: mathRound$$module$node_modules$tinycolor2$tinycolor(100 * bound01$$module$node_modules$tinycolor2$tinycolor(this._b, 255)) + "%",
            a: this._a
        }
    },
    toPercentageRgbString: function() {
        return 1 == this._a ? "rgb(" + mathRound$$module$node_modules$tinycolor2$tinycolor(100 * bound01$$module$node_modules$tinycolor2$tinycolor(this._r,
            255)) + "%, " + mathRound$$module$node_modules$tinycolor2$tinycolor(100 * bound01$$module$node_modules$tinycolor2$tinycolor(this._g, 255)) + "%, " + mathRound$$module$node_modules$tinycolor2$tinycolor(100 * bound01$$module$node_modules$tinycolor2$tinycolor(this._b, 255)) + "%)" : "rgba(" + mathRound$$module$node_modules$tinycolor2$tinycolor(100 * bound01$$module$node_modules$tinycolor2$tinycolor(this._r, 255)) + "%, " + mathRound$$module$node_modules$tinycolor2$tinycolor(100 * bound01$$module$node_modules$tinycolor2$tinycolor(this._g,
            255)) + "%, " + mathRound$$module$node_modules$tinycolor2$tinycolor(100 * bound01$$module$node_modules$tinycolor2$tinycolor(this._b, 255)) + "%, " + this._roundA + ")"
    },
    toName: function() {
        return 0 === this._a ? "transparent" : 1 > this._a ? !1 : hexNames$$module$node_modules$tinycolor2$tinycolor[rgbToHex$$module$node_modules$tinycolor2$tinycolor(this._r, this._g, this._b, !0)] || !1
    },
    toFilter: function(a) {
        var b = "#" + rgbaToArgbHex$$module$node_modules$tinycolor2$tinycolor(this._r, this._g, this._b, this._a),
            c = b,
            d = this._gradientType ?
            "GradientType = 1, " : "";
        a && (a = (0, module$node_modules$tinycolor2$tinycolor.default)(a), c = "#" + rgbaToArgbHex$$module$node_modules$tinycolor2$tinycolor(a._r, a._g, a._b, a._a));
        return "progid:DXImageTransform.Microsoft.gradient(" + d + "startColorstr=" + b + ",endColorstr=" + c + ")"
    },
    toString: function(a) {
        var b = !!a;
        a = a || this._format;
        var c = !1,
            d = 1 > this._a && 0 <= this._a;
        if (!b && d && ("hex" === a || "hex6" === a || "hex3" === a || "hex4" === a || "hex8" === a || "name" === a)) return "name" === a && 0 === this._a ? this.toName() : this.toRgbString();
        "rgb" ===
        a && (c = this.toRgbString());
        "prgb" === a && (c = this.toPercentageRgbString());
        if ("hex" === a || "hex6" === a) c = this.toHexString();
        "hex3" === a && (c = this.toHexString(!0));
        "hex4" === a && (c = this.toHex8String(!0));
        "hex8" === a && (c = this.toHex8String());
        "name" === a && (c = this.toName());
        "hsl" === a && (c = this.toHslString());
        "hsv" === a && (c = this.toHsvString());
        return c || this.toHexString()
    },
    clone: function() {
        return (0, module$node_modules$tinycolor2$tinycolor.default)(this.toString())
    },
    _applyModification: function(a, b) {
        a = a.apply(null, [this].concat([].slice.call(b)));
        this._r = a._r;
        this._g = a._g;
        this._b = a._b;
        this.setAlpha(a._a);
        return this
    },
    lighten: function() {
        return this._applyModification(lighten$$module$node_modules$tinycolor2$tinycolor, arguments)
    },
    brighten: function() {
        return this._applyModification(brighten$$module$node_modules$tinycolor2$tinycolor, arguments)
    },
    darken: function() {
        return this._applyModification(darken$$module$node_modules$tinycolor2$tinycolor, arguments)
    },
    desaturate: function() {
        return this._applyModification(desaturate$$module$node_modules$tinycolor2$tinycolor,
            arguments)
    },
    saturate: function() {
        return this._applyModification(saturate$$module$node_modules$tinycolor2$tinycolor, arguments)
    },
    greyscale: function() {
        return this._applyModification(greyscale$$module$node_modules$tinycolor2$tinycolor, arguments)
    },
    spin: function() {
        return this._applyModification(spin$$module$node_modules$tinycolor2$tinycolor, arguments)
    },
    _applyCombination: function(a, b) {
        return a.apply(null, [this].concat([].slice.call(b)))
    },
    analogous: function() {
        return this._applyCombination(analogous$$module$node_modules$tinycolor2$tinycolor,
            arguments)
    },
    complement: function() {
        return this._applyCombination(complement$$module$node_modules$tinycolor2$tinycolor, arguments)
    },
    monochromatic: function() {
        return this._applyCombination(monochromatic$$module$node_modules$tinycolor2$tinycolor, arguments)
    },
    splitcomplement: function() {
        return this._applyCombination(splitcomplement$$module$node_modules$tinycolor2$tinycolor, arguments)
    },
    triad: function() {
        return this._applyCombination(triad$$module$node_modules$tinycolor2$tinycolor, arguments)
    },
    tetrad: function() {
        return this._applyCombination(tetrad$$module$node_modules$tinycolor2$tinycolor,
            arguments)
    }
};
module$node_modules$tinycolor2$tinycolor.default.fromRatio = function(a, b) {
    if ("object" == typeof a) {
        var c = {},
            d;
        for (d in a) a.hasOwnProperty(d) && (c[d] = "a" === d ? a[d] : convertToPercentage$$module$node_modules$tinycolor2$tinycolor(a[d]));
        a = c
    }
    return (0, module$node_modules$tinycolor2$tinycolor.default)(a, b)
};

function inputToRGB$$module$node_modules$tinycolor2$tinycolor(a) {
    var b = {
            r: 0,
            g: 0,
            b: 0
        },
        c = 1,
        d, e = d = !1;
    "string" == typeof a && (a = stringInputToObject$$module$node_modules$tinycolor2$tinycolor(a));
    "object" == typeof a && (isValidCSSUnit$$module$node_modules$tinycolor2$tinycolor(a.r) && isValidCSSUnit$$module$node_modules$tinycolor2$tinycolor(a.g) && isValidCSSUnit$$module$node_modules$tinycolor2$tinycolor(a.b) ? (b = rgbToRgb$$module$node_modules$tinycolor2$tinycolor(a.r, a.g, a.b), d = !0, e = "%" === String(a.r).substr(-1) ? "prgb" :
            "rgb") : isValidCSSUnit$$module$node_modules$tinycolor2$tinycolor(a.h) && isValidCSSUnit$$module$node_modules$tinycolor2$tinycolor(a.s) && isValidCSSUnit$$module$node_modules$tinycolor2$tinycolor(a.v) ? (b = convertToPercentage$$module$node_modules$tinycolor2$tinycolor(a.s), d = convertToPercentage$$module$node_modules$tinycolor2$tinycolor(a.v), b = hsvToRgb$$module$node_modules$tinycolor2$tinycolor(a.h, b, d), d = !0, e = "hsv") : isValidCSSUnit$$module$node_modules$tinycolor2$tinycolor(a.h) && isValidCSSUnit$$module$node_modules$tinycolor2$tinycolor(a.s) &&
        isValidCSSUnit$$module$node_modules$tinycolor2$tinycolor(a.l) && (b = convertToPercentage$$module$node_modules$tinycolor2$tinycolor(a.s), d = convertToPercentage$$module$node_modules$tinycolor2$tinycolor(a.l), b = hslToRgb$$module$node_modules$tinycolor2$tinycolor(a.h, b, d), d = !0, e = "hsl"), a.hasOwnProperty("a") && (c = a.a));
    c = boundAlpha$$module$node_modules$tinycolor2$tinycolor(c);
    return {
        ok: d,
        format: a.format || e,
        r: mathMin$$module$node_modules$tinycolor2$tinycolor(255, mathMax$$module$node_modules$tinycolor2$tinycolor(b.r,
            0)),
        g: mathMin$$module$node_modules$tinycolor2$tinycolor(255, mathMax$$module$node_modules$tinycolor2$tinycolor(b.g, 0)),
        b: mathMin$$module$node_modules$tinycolor2$tinycolor(255, mathMax$$module$node_modules$tinycolor2$tinycolor(b.b, 0)),
        a: c
    }
}

function rgbToRgb$$module$node_modules$tinycolor2$tinycolor(a, b, c) {
    return {
        r: 255 * bound01$$module$node_modules$tinycolor2$tinycolor(a, 255),
        g: 255 * bound01$$module$node_modules$tinycolor2$tinycolor(b, 255),
        b: 255 * bound01$$module$node_modules$tinycolor2$tinycolor(c, 255)
    }
}

function rgbToHsl$$module$node_modules$tinycolor2$tinycolor(a, b, c) {
    a = bound01$$module$node_modules$tinycolor2$tinycolor(a, 255);
    b = bound01$$module$node_modules$tinycolor2$tinycolor(b, 255);
    c = bound01$$module$node_modules$tinycolor2$tinycolor(c, 255);
    var d = mathMax$$module$node_modules$tinycolor2$tinycolor(a, b, c),
        e = mathMin$$module$node_modules$tinycolor2$tinycolor(a, b, c),
        f = (d + e) / 2;
    if (d == e) var g = e = 0;
    else {
        var h = d - e;
        e = .5 < f ? h / (2 - d - e) : h / (d + e);
        switch (d) {
            case a:
                g = (b - c) / h + (b < c ? 6 : 0);
                break;
            case b:
                g = (c - a) / h + 2;
                break;
            case c:
                g = (a - b) / h + 4
        }
        g /= 6
    }
    return {
        h: g,
        s: e,
        l: f
    }
}

function hslToRgb$$module$node_modules$tinycolor2$tinycolor(a, b, c) {
    function d(a, b, c) {
        0 > c && (c += 1);
        1 < c && --c;
        return c < 1 / 6 ? a + 6 * (b - a) * c : .5 > c ? b : c < 2 / 3 ? a + (b - a) * (2 / 3 - c) * 6 : a
    }
    a = bound01$$module$node_modules$tinycolor2$tinycolor(a, 360);
    b = bound01$$module$node_modules$tinycolor2$tinycolor(b, 100);
    c = bound01$$module$node_modules$tinycolor2$tinycolor(c, 100);
    if (0 === b) c = b = a = c;
    else {
        var e = .5 > c ? c * (1 + b) : c + b - c * b,
            f = 2 * c - e;
        c = d(f, e, a + 1 / 3);
        b = d(f, e, a);
        a = d(f, e, a - 1 / 3)
    }
    return {
        r: 255 * c,
        g: 255 * b,
        b: 255 * a
    }
}

function rgbToHsv$$module$node_modules$tinycolor2$tinycolor(a, b, c) {
    a = bound01$$module$node_modules$tinycolor2$tinycolor(a, 255);
    b = bound01$$module$node_modules$tinycolor2$tinycolor(b, 255);
    c = bound01$$module$node_modules$tinycolor2$tinycolor(c, 255);
    var d = mathMax$$module$node_modules$tinycolor2$tinycolor(a, b, c),
        e = mathMin$$module$node_modules$tinycolor2$tinycolor(a, b, c),
        f = d - e;
    if (d == e) var g = 0;
    else {
        switch (d) {
            case a:
                g = (b - c) / f + (b < c ? 6 : 0);
                break;
            case b:
                g = (c - a) / f + 2;
                break;
            case c:
                g = (a - b) / f + 4
        }
        g /= 6
    }
    return {
        h: g,
        s: 0 ===
            d ? 0 : f / d,
        v: d
    }
}

function hsvToRgb$$module$node_modules$tinycolor2$tinycolor(a, b, c) {
    a = 6 * bound01$$module$node_modules$tinycolor2$tinycolor(a, 360);
    b = bound01$$module$node_modules$tinycolor2$tinycolor(b, 100);
    c = bound01$$module$node_modules$tinycolor2$tinycolor(c, 100);
    var d = Math$$module$node_modules$tinycolor2$tinycolor.floor(a),
        e = a - d;
    a = c * (1 - b);
    var f = c * (1 - e * b);
    b = c * (1 - (1 - e) * b);
    d %= 6;
    return {
        r: 255 * [c, f, a, a, b, c][d],
        g: 255 * [b, c, c, f, a, a][d],
        b: 255 * [a, a, b, c, c, f][d]
    }
}

function rgbToHex$$module$node_modules$tinycolor2$tinycolor(a, b, c, d) {
    a = [pad2$$module$node_modules$tinycolor2$tinycolor(mathRound$$module$node_modules$tinycolor2$tinycolor(a).toString(16)), pad2$$module$node_modules$tinycolor2$tinycolor(mathRound$$module$node_modules$tinycolor2$tinycolor(b).toString(16)), pad2$$module$node_modules$tinycolor2$tinycolor(mathRound$$module$node_modules$tinycolor2$tinycolor(c).toString(16))];
    return d && a[0].charAt(0) == a[0].charAt(1) && a[1].charAt(0) == a[1].charAt(1) && a[2].charAt(0) ==
        a[2].charAt(1) ? a[0].charAt(0) + a[1].charAt(0) + a[2].charAt(0) : a.join("")
}

function rgbaToHex$$module$node_modules$tinycolor2$tinycolor(a, b, c, d, e) {
    a = [pad2$$module$node_modules$tinycolor2$tinycolor(mathRound$$module$node_modules$tinycolor2$tinycolor(a).toString(16)), pad2$$module$node_modules$tinycolor2$tinycolor(mathRound$$module$node_modules$tinycolor2$tinycolor(b).toString(16)), pad2$$module$node_modules$tinycolor2$tinycolor(mathRound$$module$node_modules$tinycolor2$tinycolor(c).toString(16)), pad2$$module$node_modules$tinycolor2$tinycolor(convertDecimalToHex$$module$node_modules$tinycolor2$tinycolor(d))];
    return e &&
        a[0].charAt(0) == a[0].charAt(1) && a[1].charAt(0) == a[1].charAt(1) && a[2].charAt(0) == a[2].charAt(1) && a[3].charAt(0) == a[3].charAt(1) ? a[0].charAt(0) + a[1].charAt(0) + a[2].charAt(0) + a[3].charAt(0) : a.join("")
}

function rgbaToArgbHex$$module$node_modules$tinycolor2$tinycolor(a, b, c, d) {
    return [pad2$$module$node_modules$tinycolor2$tinycolor(convertDecimalToHex$$module$node_modules$tinycolor2$tinycolor(d)), pad2$$module$node_modules$tinycolor2$tinycolor(mathRound$$module$node_modules$tinycolor2$tinycolor(a).toString(16)), pad2$$module$node_modules$tinycolor2$tinycolor(mathRound$$module$node_modules$tinycolor2$tinycolor(b).toString(16)), pad2$$module$node_modules$tinycolor2$tinycolor(mathRound$$module$node_modules$tinycolor2$tinycolor(c).toString(16))].join("")
}
module$node_modules$tinycolor2$tinycolor.default.equals = function(a, b) {
    return a && b ? (0, module$node_modules$tinycolor2$tinycolor.default)(a).toRgbString() == (0, module$node_modules$tinycolor2$tinycolor.default)(b).toRgbString() : !1
};
module$node_modules$tinycolor2$tinycolor.default.random = function() {
    return module$node_modules$tinycolor2$tinycolor.default.fromRatio({
        r: mathRandom$$module$node_modules$tinycolor2$tinycolor(),
        g: mathRandom$$module$node_modules$tinycolor2$tinycolor(),
        b: mathRandom$$module$node_modules$tinycolor2$tinycolor()
    })
};

function desaturate$$module$node_modules$tinycolor2$tinycolor(a, b) {
    b = 0 === b ? 0 : b || 10;
    a = (0, module$node_modules$tinycolor2$tinycolor.default)(a).toHsl();
    a.s -= b / 100;
    a.s = clamp01$$module$node_modules$tinycolor2$tinycolor(a.s);
    return (0, module$node_modules$tinycolor2$tinycolor.default)(a)
}

function saturate$$module$node_modules$tinycolor2$tinycolor(a, b) {
    b = 0 === b ? 0 : b || 10;
    a = (0, module$node_modules$tinycolor2$tinycolor.default)(a).toHsl();
    a.s += b / 100;
    a.s = clamp01$$module$node_modules$tinycolor2$tinycolor(a.s);
    return (0, module$node_modules$tinycolor2$tinycolor.default)(a)
}

function greyscale$$module$node_modules$tinycolor2$tinycolor(a) {
    return (0, module$node_modules$tinycolor2$tinycolor.default)(a).desaturate(100)
}

function lighten$$module$node_modules$tinycolor2$tinycolor(a, b) {
    b = 0 === b ? 0 : b || 10;
    a = (0, module$node_modules$tinycolor2$tinycolor.default)(a).toHsl();
    a.l += b / 100;
    a.l = clamp01$$module$node_modules$tinycolor2$tinycolor(a.l);
    return (0, module$node_modules$tinycolor2$tinycolor.default)(a)
}

function brighten$$module$node_modules$tinycolor2$tinycolor(a, b) {
    b = 0 === b ? 0 : b || 10;
    a = (0, module$node_modules$tinycolor2$tinycolor.default)(a).toRgb();
    a.r = mathMax$$module$node_modules$tinycolor2$tinycolor(0, mathMin$$module$node_modules$tinycolor2$tinycolor(255, a.r - mathRound$$module$node_modules$tinycolor2$tinycolor(255 * -(b / 100))));
    a.g = mathMax$$module$node_modules$tinycolor2$tinycolor(0, mathMin$$module$node_modules$tinycolor2$tinycolor(255, a.g - mathRound$$module$node_modules$tinycolor2$tinycolor(255 * -(b /
        100))));
    a.b = mathMax$$module$node_modules$tinycolor2$tinycolor(0, mathMin$$module$node_modules$tinycolor2$tinycolor(255, a.b - mathRound$$module$node_modules$tinycolor2$tinycolor(255 * -(b / 100))));
    return (0, module$node_modules$tinycolor2$tinycolor.default)(a)
}

function darken$$module$node_modules$tinycolor2$tinycolor(a, b) {
    b = 0 === b ? 0 : b || 10;
    a = (0, module$node_modules$tinycolor2$tinycolor.default)(a).toHsl();
    a.l -= b / 100;
    a.l = clamp01$$module$node_modules$tinycolor2$tinycolor(a.l);
    return (0, module$node_modules$tinycolor2$tinycolor.default)(a)
}

function spin$$module$node_modules$tinycolor2$tinycolor(a, b) {
    a = (0, module$node_modules$tinycolor2$tinycolor.default)(a).toHsl();
    b = (a.h + b) % 360;
    a.h = 0 > b ? 360 + b : b;
    return (0, module$node_modules$tinycolor2$tinycolor.default)(a)
}

function complement$$module$node_modules$tinycolor2$tinycolor(a) {
    a = (0, module$node_modules$tinycolor2$tinycolor.default)(a).toHsl();
    a.h = (a.h + 180) % 360;
    return (0, module$node_modules$tinycolor2$tinycolor.default)(a)
}

function triad$$module$node_modules$tinycolor2$tinycolor(a) {
    var b = (0, module$node_modules$tinycolor2$tinycolor.default)(a).toHsl(),
        c = b.h;
    return [(0, module$node_modules$tinycolor2$tinycolor.default)(a), (0, module$node_modules$tinycolor2$tinycolor.default)({
        h: (c + 120) % 360,
        s: b.s,
        l: b.l
    }), (0, module$node_modules$tinycolor2$tinycolor.default)({
        h: (c + 240) % 360,
        s: b.s,
        l: b.l
    })]
}

function tetrad$$module$node_modules$tinycolor2$tinycolor(a) {
    var b = (0, module$node_modules$tinycolor2$tinycolor.default)(a).toHsl(),
        c = b.h;
    return [(0, module$node_modules$tinycolor2$tinycolor.default)(a), (0, module$node_modules$tinycolor2$tinycolor.default)({
        h: (c + 90) % 360,
        s: b.s,
        l: b.l
    }), (0, module$node_modules$tinycolor2$tinycolor.default)({
        h: (c + 180) % 360,
        s: b.s,
        l: b.l
    }), (0, module$node_modules$tinycolor2$tinycolor.default)({
        h: (c + 270) % 360,
        s: b.s,
        l: b.l
    })]
}

function splitcomplement$$module$node_modules$tinycolor2$tinycolor(a) {
    var b = (0, module$node_modules$tinycolor2$tinycolor.default)(a).toHsl(),
        c = b.h;
    return [(0, module$node_modules$tinycolor2$tinycolor.default)(a), (0, module$node_modules$tinycolor2$tinycolor.default)({
        h: (c + 72) % 360,
        s: b.s,
        l: b.l
    }), (0, module$node_modules$tinycolor2$tinycolor.default)({
        h: (c + 216) % 360,
        s: b.s,
        l: b.l
    })]
}

function analogous$$module$node_modules$tinycolor2$tinycolor(a, b, c) {
    b = b || 6;
    c = c || 30;
    var d = (0, module$node_modules$tinycolor2$tinycolor.default)(a).toHsl();
    c = 360 / c;
    a = [(0, module$node_modules$tinycolor2$tinycolor.default)(a)];
    for (d.h = (d.h - (c * b >> 1) + 720) % 360; --b;) d.h = (d.h + c) % 360, a.push((0, module$node_modules$tinycolor2$tinycolor.default)(d));
    return a
}

function monochromatic$$module$node_modules$tinycolor2$tinycolor(a, b) {
    b = b || 6;
    var c = (0, module$node_modules$tinycolor2$tinycolor.default)(a).toHsv();
    a = c.h;
    var d = c.s;
    c = c.v;
    for (var e = [], f = 1 / b; b--;) e.push((0, module$node_modules$tinycolor2$tinycolor.default)({
        h: a,
        s: d,
        v: c
    })), c = (c + f) % 1;
    return e
}
module$node_modules$tinycolor2$tinycolor.default.mix = function(a, b, c) {
    c = 0 === c ? 0 : c || 50;
    a = (0, module$node_modules$tinycolor2$tinycolor.default)(a).toRgb();
    b = (0, module$node_modules$tinycolor2$tinycolor.default)(b).toRgb();
    c /= 100;
    return (0, module$node_modules$tinycolor2$tinycolor.default)({
        r: (b.r - a.r) * c + a.r,
        g: (b.g - a.g) * c + a.g,
        b: (b.b - a.b) * c + a.b,
        a: (b.a - a.a) * c + a.a
    })
};
module$node_modules$tinycolor2$tinycolor.default.readability = function(a, b) {
    a = (0, module$node_modules$tinycolor2$tinycolor.default)(a);
    b = (0, module$node_modules$tinycolor2$tinycolor.default)(b);
    return (Math$$module$node_modules$tinycolor2$tinycolor.max(a.getLuminance(), b.getLuminance()) + .05) / (Math$$module$node_modules$tinycolor2$tinycolor.min(a.getLuminance(), b.getLuminance()) + .05)
};
module$node_modules$tinycolor2$tinycolor.default.isReadable = function(a, b, c) {
    a = module$node_modules$tinycolor2$tinycolor.default.readability(a, b);
    b = !1;
    c = validateWCAG2Parms$$module$node_modules$tinycolor2$tinycolor(c);
    switch (c.level + c.size) {
        case "AAsmall":
        case "AAAlarge":
            b = 4.5 <= a;
            break;
        case "AAlarge":
            b = 3 <= a;
            break;
        case "AAAsmall":
            b = 7 <= a
    }
    return b
};
module$node_modules$tinycolor2$tinycolor.default.mostReadable = function(a, b, c) {
    var d = null,
        e = 0;
    c = c || {};
    var f = c.includeFallbackColors;
    var g = c.level;
    var h = c.size;
    for (var k = 0; k < b.length; k++) {
        var l = module$node_modules$tinycolor2$tinycolor.default.readability(a, b[k]);
        l > e && (e = l, d = (0, module$node_modules$tinycolor2$tinycolor.default)(b[k]))
    }
    if (module$node_modules$tinycolor2$tinycolor.default.isReadable(a, d, {
            level: g,
            size: h
        }) || !f) return d;
    c.includeFallbackColors = !1;
    return module$node_modules$tinycolor2$tinycolor.default.mostReadable(a, ["#fff", "#000"], c)
};
var names$$module$node_modules$tinycolor2$tinycolor = module$node_modules$tinycolor2$tinycolor.default.names = {
        aliceblue: "f0f8ff",
        antiquewhite: "faebd7",
        aqua: "0ff",
        aquamarine: "7fffd4",
        azure: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "000",
        blanchedalmond: "ffebcd",
        blue: "00f",
        blueviolet: "8a2be2",
        brown: "a52a2a",
        burlywood: "deb887",
        burntsienna: "ea7e5d",
        cadetblue: "5f9ea0",
        chartreuse: "7fff00",
        chocolate: "d2691e",
        coral: "ff7f50",
        cornflowerblue: "6495ed",
        cornsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "0ff",
        darkblue: "00008b",
        darkcyan: "008b8b",
        darkgoldenrod: "b8860b",
        darkgray: "a9a9a9",
        darkgreen: "006400",
        darkgrey: "a9a9a9",
        darkkhaki: "bdb76b",
        darkmagenta: "8b008b",
        darkolivegreen: "556b2f",
        darkorange: "ff8c00",
        darkorchid: "9932cc",
        darkred: "8b0000",
        darksalmon: "e9967a",
        darkseagreen: "8fbc8f",
        darkslateblue: "483d8b",
        darkslategray: "2f4f4f",
        darkslategrey: "2f4f4f",
        darkturquoise: "00ced1",
        darkviolet: "9400d3",
        deeppink: "ff1493",
        deepskyblue: "00bfff",
        dimgray: "696969",
        dimgrey: "696969",
        dodgerblue: "1e90ff",
        firebrick: "b22222",
        floralwhite: "fffaf0",
        forestgreen: "228b22",
        fuchsia: "f0f",
        gainsboro: "dcdcdc",
        ghostwhite: "f8f8ff",
        gold: "ffd700",
        goldenrod: "daa520",
        gray: "808080",
        green: "008000",
        greenyellow: "adff2f",
        grey: "808080",
        honeydew: "f0fff0",
        hotpink: "ff69b4",
        indianred: "cd5c5c",
        indigo: "4b0082",
        ivory: "fffff0",
        khaki: "f0e68c",
        lavender: "e6e6fa",
        lavenderblush: "fff0f5",
        lawngreen: "7cfc00",
        lemonchiffon: "fffacd",
        lightblue: "add8e6",
        lightcoral: "f08080",
        lightcyan: "e0ffff",
        lightgoldenrodyellow: "fafad2",
        lightgray: "d3d3d3",
        lightgreen: "90ee90",
        lightgrey: "d3d3d3",
        lightpink: "ffb6c1",
        lightsalmon: "ffa07a",
        lightseagreen: "20b2aa",
        lightskyblue: "87cefa",
        lightslategray: "789",
        lightslategrey: "789",
        lightsteelblue: "b0c4de",
        lightyellow: "ffffe0",
        lime: "0f0",
        limegreen: "32cd32",
        linen: "faf0e6",
        magenta: "f0f",
        maroon: "800000",
        mediumaquamarine: "66cdaa",
        mediumblue: "0000cd",
        mediumorchid: "ba55d3",
        mediumpurple: "9370db",
        mediumseagreen: "3cb371",
        mediumslateblue: "7b68ee",
        mediumspringgreen: "00fa9a",
        mediumturquoise: "48d1cc",
        mediumvioletred: "c71585",
        midnightblue: "191970",
        mintcream: "f5fffa",
        mistyrose: "ffe4e1",
        moccasin: "ffe4b5",
        navajowhite: "ffdead",
        navy: "000080",
        oldlace: "fdf5e6",
        olive: "808000",
        olivedrab: "6b8e23",
        orange: "ffa500",
        orangered: "ff4500",
        orchid: "da70d6",
        palegoldenrod: "eee8aa",
        palegreen: "98fb98",
        paleturquoise: "afeeee",
        palevioletred: "db7093",
        papayawhip: "ffefd5",
        peachpuff: "ffdab9",
        peru: "cd853f",
        pink: "ffc0cb",
        plum: "dda0dd",
        powderblue: "b0e0e6",
        purple: "800080",
        rebeccapurple: "663399",
        red: "f00",
        rosybrown: "bc8f8f",
        royalblue: "4169e1",
        saddlebrown: "8b4513",
        salmon: "fa8072",
        sandybrown: "f4a460",
        seagreen: "2e8b57",
        seashell: "fff5ee",
        sienna: "a0522d",
        silver: "c0c0c0",
        skyblue: "87ceeb",
        slateblue: "6a5acd",
        slategray: "708090",
        slategrey: "708090",
        snow: "fffafa",
        springgreen: "00ff7f",
        steelblue: "4682b4",
        tan: "d2b48c",
        teal: "008080",
        thistle: "d8bfd8",
        tomato: "ff6347",
        turquoise: "40e0d0",
        violet: "ee82ee",
        wheat: "f5deb3",
        white: "fff",
        whitesmoke: "f5f5f5",
        yellow: "ff0",
        yellowgreen: "9acd32"
    },
    hexNames$$module$node_modules$tinycolor2$tinycolor = module$node_modules$tinycolor2$tinycolor.default.hexNames = flip$$module$node_modules$tinycolor2$tinycolor(names$$module$node_modules$tinycolor2$tinycolor);

function flip$$module$node_modules$tinycolor2$tinycolor(a) {
    var b = {},
        c;
    for (c in a) a.hasOwnProperty(c) && (b[a[c]] = c);
    return b
}

function boundAlpha$$module$node_modules$tinycolor2$tinycolor(a) {
    a = parseFloat(a);
    if (isNaN(a) || 0 > a || 1 < a) a = 1;
    return a
}

function bound01$$module$node_modules$tinycolor2$tinycolor(a, b) {
    isOnePointZero$$module$node_modules$tinycolor2$tinycolor(a) && (a = "100%");
    var c = isPercentage$$module$node_modules$tinycolor2$tinycolor(a);
    a = mathMin$$module$node_modules$tinycolor2$tinycolor(b, mathMax$$module$node_modules$tinycolor2$tinycolor(0, parseFloat(a)));
    c && (a = parseInt(a * b, 10) / 100);
    return 1E-6 > Math$$module$node_modules$tinycolor2$tinycolor.abs(a - b) ? 1 : a % b / parseFloat(b)
}

function clamp01$$module$node_modules$tinycolor2$tinycolor(a) {
    return mathMin$$module$node_modules$tinycolor2$tinycolor(1, mathMax$$module$node_modules$tinycolor2$tinycolor(0, a))
}

function parseIntFromHex$$module$node_modules$tinycolor2$tinycolor(a) {
    return parseInt(a, 16)
}

function isOnePointZero$$module$node_modules$tinycolor2$tinycolor(a) {
    return "string" == typeof a && -1 != a.indexOf(".") && 1 === parseFloat(a)
}

function isPercentage$$module$node_modules$tinycolor2$tinycolor(a) {
    return "string" === typeof a && -1 != a.indexOf("%")
}

function pad2$$module$node_modules$tinycolor2$tinycolor(a) {
    return 1 == a.length ? "0" + a : "" + a
}

function convertToPercentage$$module$node_modules$tinycolor2$tinycolor(a) {
    1 >= a && (a = 100 * a + "%");
    return a
}

function convertDecimalToHex$$module$node_modules$tinycolor2$tinycolor(a) {
    return Math$$module$node_modules$tinycolor2$tinycolor.round(255 * parseFloat(a)).toString(16)
}

function convertHexToDecimal$$module$node_modules$tinycolor2$tinycolor(a) {
    return parseIntFromHex$$module$node_modules$tinycolor2$tinycolor(a) / 255
}
var matchers$$module$node_modules$tinycolor2$tinycolor = function() {
    return {
        CSS_UNIT: /(?:[-\+]?\d*\.\d+%?)|(?:[-\+]?\d+%?)/,
        rgb: /rgb[\s|\(]+((?:[-\+]?\d*\.\d+%?)|(?:[-\+]?\d+%?))[,|\s]+((?:[-\+]?\d*\.\d+%?)|(?:[-\+]?\d+%?))[,|\s]+((?:[-\+]?\d*\.\d+%?)|(?:[-\+]?\d+%?))\s*\)?/,
        rgba: /rgba[\s|\(]+((?:[-\+]?\d*\.\d+%?)|(?:[-\+]?\d+%?))[,|\s]+((?:[-\+]?\d*\.\d+%?)|(?:[-\+]?\d+%?))[,|\s]+((?:[-\+]?\d*\.\d+%?)|(?:[-\+]?\d+%?))[,|\s]+((?:[-\+]?\d*\.\d+%?)|(?:[-\+]?\d+%?))\s*\)?/,
        hsl: /hsl[\s|\(]+((?:[-\+]?\d*\.\d+%?)|(?:[-\+]?\d+%?))[,|\s]+((?:[-\+]?\d*\.\d+%?)|(?:[-\+]?\d+%?))[,|\s]+((?:[-\+]?\d*\.\d+%?)|(?:[-\+]?\d+%?))\s*\)?/,
        hsla: /hsla[\s|\(]+((?:[-\+]?\d*\.\d+%?)|(?:[-\+]?\d+%?))[,|\s]+((?:[-\+]?\d*\.\d+%?)|(?:[-\+]?\d+%?))[,|\s]+((?:[-\+]?\d*\.\d+%?)|(?:[-\+]?\d+%?))[,|\s]+((?:[-\+]?\d*\.\d+%?)|(?:[-\+]?\d+%?))\s*\)?/,
        hsv: /hsv[\s|\(]+((?:[-\+]?\d*\.\d+%?)|(?:[-\+]?\d+%?))[,|\s]+((?:[-\+]?\d*\.\d+%?)|(?:[-\+]?\d+%?))[,|\s]+((?:[-\+]?\d*\.\d+%?)|(?:[-\+]?\d+%?))\s*\)?/,
        hsva: /hsva[\s|\(]+((?:[-\+]?\d*\.\d+%?)|(?:[-\+]?\d+%?))[,|\s]+((?:[-\+]?\d*\.\d+%?)|(?:[-\+]?\d+%?))[,|\s]+((?:[-\+]?\d*\.\d+%?)|(?:[-\+]?\d+%?))[,|\s]+((?:[-\+]?\d*\.\d+%?)|(?:[-\+]?\d+%?))\s*\)?/,
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    }
}();

function isValidCSSUnit$$module$node_modules$tinycolor2$tinycolor(a) {
    return !!matchers$$module$node_modules$tinycolor2$tinycolor.CSS_UNIT.exec(a)
}

function stringInputToObject$$module$node_modules$tinycolor2$tinycolor(a) {
    a = a.replace(trimLeft$$module$node_modules$tinycolor2$tinycolor, "").replace(trimRight$$module$node_modules$tinycolor2$tinycolor, "").toLowerCase();
    var b = !1;
    if (names$$module$node_modules$tinycolor2$tinycolor[a]) a = names$$module$node_modules$tinycolor2$tinycolor[a], b = !0;
    else if ("transparent" == a) return {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
        format: "name"
    };
    var c;
    return (c = matchers$$module$node_modules$tinycolor2$tinycolor.rgb.exec(a)) ? {
            r: c[1],
            g: c[2],
            b: c[3]
        } :
        (c = matchers$$module$node_modules$tinycolor2$tinycolor.rgba.exec(a)) ? {
            r: c[1],
            g: c[2],
            b: c[3],
            a: c[4]
        } : (c = matchers$$module$node_modules$tinycolor2$tinycolor.hsl.exec(a)) ? {
            h: c[1],
            s: c[2],
            l: c[3]
        } : (c = matchers$$module$node_modules$tinycolor2$tinycolor.hsla.exec(a)) ? {
            h: c[1],
            s: c[2],
            l: c[3],
            a: c[4]
        } : (c = matchers$$module$node_modules$tinycolor2$tinycolor.hsv.exec(a)) ? {
            h: c[1],
            s: c[2],
            v: c[3]
        } : (c = matchers$$module$node_modules$tinycolor2$tinycolor.hsva.exec(a)) ? {
            h: c[1],
            s: c[2],
            v: c[3],
            a: c[4]
        } : (c = matchers$$module$node_modules$tinycolor2$tinycolor.hex8.exec(a)) ? {
            r: parseIntFromHex$$module$node_modules$tinycolor2$tinycolor(c[1]),
            g: parseIntFromHex$$module$node_modules$tinycolor2$tinycolor(c[2]),
            b: parseIntFromHex$$module$node_modules$tinycolor2$tinycolor(c[3]),
            a: convertHexToDecimal$$module$node_modules$tinycolor2$tinycolor(c[4]),
            format: b ? "name" : "hex8"
        } : (c = matchers$$module$node_modules$tinycolor2$tinycolor.hex6.exec(a)) ? {
            r: parseIntFromHex$$module$node_modules$tinycolor2$tinycolor(c[1]),
            g: parseIntFromHex$$module$node_modules$tinycolor2$tinycolor(c[2]),
            b: parseIntFromHex$$module$node_modules$tinycolor2$tinycolor(c[3]),
            format: b ? "name" : "hex"
        } : (c = matchers$$module$node_modules$tinycolor2$tinycolor.hex4.exec(a)) ? {
            r: parseIntFromHex$$module$node_modules$tinycolor2$tinycolor(c[1] + "" + c[1]),
            g: parseIntFromHex$$module$node_modules$tinycolor2$tinycolor(c[2] + "" + c[2]),
            b: parseIntFromHex$$module$node_modules$tinycolor2$tinycolor(c[3] + "" + c[3]),
            a: convertHexToDecimal$$module$node_modules$tinycolor2$tinycolor(c[4] + "" + c[4]),
            format: b ? "name" : "hex8"
        } : (c = matchers$$module$node_modules$tinycolor2$tinycolor.hex3.exec(a)) ? {
            r: parseIntFromHex$$module$node_modules$tinycolor2$tinycolor(c[1] +
                "" + c[1]),
            g: parseIntFromHex$$module$node_modules$tinycolor2$tinycolor(c[2] + "" + c[2]),
            b: parseIntFromHex$$module$node_modules$tinycolor2$tinycolor(c[3] + "" + c[3]),
            format: b ? "name" : "hex"
        } : !1
}

function validateWCAG2Parms$$module$node_modules$tinycolor2$tinycolor(a) {
    a = a || {
        level: "AA",
        size: "small"
    };
    var b = (a.level || "AA").toUpperCase();
    a = (a.size || "small").toLowerCase();
    "AA" !== b && "AAA" !== b && (b = "AA");
    "small" !== a && "large" !== a && (a = "small");
    return {
        level: b,
        size: a
    }
};
var module$src$externals$three = {};
try {
    module$src$externals$three.default = eval("THREE")
} catch (a) {
    "function" === typeof require && (module$src$externals$three.default = eval("require('three')"))
};
var module$src$polyfills$padStart = {
    default: {}
};
String.prototype.padStart || (String.prototype.padStart = function(a, b) {
    a >>= 0;
    b = String("undefined" !== typeof b ? b : " ");
    if (this.length > a) return String(this);
    a -= this.length;
    a > b.length && (b += b.repeat(a / b.length));
    return b.slice(0, a) + String(this)
});
var module$src$polyfills$padEnd = {
    default: {}
};
String.prototype.padEnd || (String.prototype.padEnd = function(a, b) {
    a >>= 0;
    b = String("undefined" !== typeof b ? b : " ");
    if (this.length > a) return String(this);
    a -= this.length;
    a > b.length && (b += b.repeat(a / b.length));
    return String(this) + b.slice(0, a)
});
var module$src$shared$util$toTinyColor = {},
    tinycolor$$module$src$shared$util$toTinyColor = module$node_modules$tinycolor2$tinycolor.default;
if (void 0 === module$node_modules$tinycolor2$tinycolor.default.prototype.toThreeColor) {
    var THREE$$module$src$shared$util$toTinyColor = module$src$externals$three.default;
    module$node_modules$tinycolor2$tinycolor.default.prototype.toThreeColor = function() {
        return new module$src$externals$three.default.Color(this.toRgbString())
    }
}
module$src$shared$util$toTinyColor.default = function(a, b) {
    if (a.hasOwnProperty("getOriginalInput")) return a;
    var c = null;
    b && (c = (0, module$node_modules$tinycolor2$tinycolor.default)(b));
    if ("number" === typeof a) return a = a.toString(16), b = a.length, 3 > b ? a = a.padStart(3, 0) : 6 > b ? a = a.padStart(6, 0) : 8 > b && (a = a.padEnd(8, 0)), a = (0, module$node_modules$tinycolor2$tinycolor.default)(a), a.isValid() ? a : c;
    if (a.isColor && "function" == typeof a.getHexString) return a = (0, module$node_modules$tinycolor2$tinycolor.default)(a.getHexString()),
        a.isValid() ? a : c;
    if (Array.isArray(a) && (3 == a.length || 4 == a.length)) {
        b = !0;
        for (var d = 0; 3 > d; ++d) a[d] = parseFloat(a[d]), isNaN(a[d]) && (b = !1);
        if (!b) return c;
        b = (0, module$node_modules$tinycolor2$tinycolor.default)({
            r: Math.max(0, Math.min(a[0], 255)),
            g: Math.max(0, Math.min(a[1], 255)),
            b: Math.max(0, Math.min(a[2], 255))
        });
        4 == a.length && (a = parseFloat(a[3]), isNaN(a) || b.setAlpha(Math.max(0, Math.min(a, 255)) / 255));
        return b.isValid() ? b : c
    }
    if ("string" !== typeof a) return a = (0, module$node_modules$tinycolor2$tinycolor.default)(a),
        a.isValid() ? a : c;
    a = a.replace("0x", "#");
    if (null !== a.match(/^#[a-f0-9]{6}$/i)) return a = (0, module$node_modules$tinycolor2$tinycolor.default)(a + "ff"), a.isValid() ? a : c;
    if (null !== a.match(/^#[a-f0-9]{8}$/i)) return a = (0, module$node_modules$tinycolor2$tinycolor.default)(a), a.isValid() ? a : c;
    if (null !== a.match(/^#[a-f0-9]{7}$/i)) return a = (0, module$node_modules$tinycolor2$tinycolor.default)(a.slice(0, 7) + "0" + a.slice(-1)), a.isValid() ? a : c;
    a = (0, module$node_modules$tinycolor2$tinycolor.default)(a);
    return a.isValid() ?
        a : c
};
var module$src$shared$util$GlobalUtils = {},
    toTinyColor$$module$src$shared$util$GlobalUtils = module$src$shared$util$toTinyColor.default,
    THREE$$module$src$shared$util$GlobalUtils = module$src$externals$three.default,
    GlobalUtils$$module$src$shared$util$GlobalUtils = function() {
        var a = this;
        this.isArrayOfType = function(a, c) {
            return Array.isArray(a) ? -1 === a.findIndex(function(a) {
                return typeof a !== c
            }) : !1
        };
        this.deepCopyReplacer = function(a, c) {
            return "number" === typeof c && isNaN(c) ? "___NaN___" : c === Number.POSITIVE_INFINITY ?
                "___PosInfinity___" : c === Number.NEGATIVE_INFINITY ? "___NegInfinity___" : c
        };
        this.deepCopyReviver = function(a, c) {
            if ("string" === typeof c) {
                if ("___NaN___" === c) return Number.NaN;
                if ("___PosInfinity___" === c) return Number.POSITIVE_INFINITY;
                if ("___NegInfinity___" === c) return Number.NEGATIVE_INFINITY
            }
            return c
        };
        this.deepCopy = function(b, c) {
            if (void 0 !== b) {
                if (c) {
                    Array.isArray(c) || (c = [c]);
                    var d = [];
                    if (a.getPaths(b, d, "", c) || 0 === d.length) return a.deepCopy(b);
                    var e = {},
                        f = {};
                    d = $jscomp.makeIterator(d);
                    for (var g = d.next(); !g.done; f = {
                            p: f.p
                        }, g = d.next()) {
                        f.p = g.value;
                        g = a.getAtPath(b, f.p);
                        if (c.every(function(a) {
                                return function(b) {
                                    return a.p === b || a.p.endsWith("." + b) ? !1 : !0
                                }
                            }(f)))
                            if (Array.isArray(g)) {
                                var h = g;
                                g = [];
                                h = $jscomp.makeIterator(h);
                                for (var k = h.next(); !k.done; k = h.next()) g.push(a.deepCopy(k.value, c))
                            } else g = a.deepCopy(g);
                        a.forceAtPath(e, f.p, g)
                    }
                    return e
                }
                return JSON.parse(JSON.stringify(b, a.deepCopyReplacer), a.deepCopyReviver)
            }
        };
        this.setIfUndefined = function(a, c) {
            return "undefined" === typeof a ? c : a
        };
        this.inject = function(a, c, d) {
            void 0 ===
                d && (d = !0);
            Object.keys(a).forEach(function(b) {
                if (d || !c.hasOwnProperty(b)) c[b] = a[b]
            });
            return c
        };
        this.defineHiddenProperty = function(a, c) {
            Object.defineProperty(this, a, {
                enumerable: !1,
                configurable: !1,
                writable: !0,
                value: c
            })
        };
        this.defineConstantProperty = function(a, c) {
            Object.defineProperty(this, a, {
                enumerable: !0,
                configurable: !1,
                writable: !1,
                value: c
            })
        };
        this.stringChecksum = function(a) {
            var b = 0,
                d = a.length,
                e;
            if (0 === d) return b;
            for (e = 0; e < d; e++) {
                var f = a.charCodeAt(e);
                b = (b << 5) - b + f;
                b &= b
            }
            return b
        };
        this.toBoolean = function(a) {
            return "string" ===
                typeof a ? "true" === a.toLowerCase() : "boolean" === typeof a ? a : !1
        };
        this.createRandomId = function() {
            return Math.random().toString(36).substring(2, 15)
        };
        this.getAt = function(a, c) {
            return c.reduce(function(a, b) {
                return a && void 0 !== a[b] ? a[b] : void 0
            }, a)
        };
        this.getAtPath = function(b, c) {
            c = c.replace(/\]$/, "").split(/[.[\]]+/);
            return a.getAt(b, c)
        };
        this.setAt = function(a, c, d, e) {
            var b = c.pop();
            if ("string" === typeof b && (0 < c.length && (a = c.reduce(function(a, b) {
                    return a && void 0 !== a[b] ? a[b] : void 0
                }, a)), a && (void 0 !== a[b] || e))) return a[b] =
                d
        };
        this.setAtPath = function(b, c, d, e) {
            c = c.replace(/\]$/, "").split(/[.[\]]+/);
            return a.setAt(b, c, d, e)
        };
        this.forceAt = function(a, c, d) {
            if (void 0 !== a && "object" === typeof a) {
                var b = c.pop();
                if ("string" === typeof b) return 0 < c.length && (a = c.reduce(function(a, b) {
                    return a && void 0 !== a[b] && "object" === typeof a[b] ? a[b] : a[b] = {}
                }, a)), a[b] = d
            }
        };
        this.forceAtPath = function(b, c, d) {
            c = c.replace(/\]$/, "").split(/[.[\]]+/);
            return a.forceAt(b, c, d)
        };
        this.deleteAt = function(a, c) {
            var b = c.pop();
            if ("string" === typeof b && (0 < c.length && (a =
                    c.reduce(function(a, b) {
                        return a && void 0 !== a[b] ? a[b] : void 0
                    }, a)), a)) return c = a[b], delete a[b], c
        };
        this.deleteAtPath = function(b, c) {
            c = c.replace(/\]$/, "").split(/[.[\]]+/);
            return a.deleteAt(b, c)
        };
        this.getPaths = function(b, c, d, e) {
            Array.isArray(c) || (c = []);
            "string" !== typeof d && (d = "");
            Array.isArray(e) || (e = []);
            if (void 0 === b || null === b || "object" !== typeof b || Array.isArray(b)) return !0;
            var f = Object.keys(b);
            if (0 === f.length) return !0;
            f.forEach(function(f) {
                var g = 0 === d.length ? f : d + "." + f;
                e.includes(f) ? c.push(g) : a.getPaths(b[f],
                    c, g, e) && c.push(g)
            });
            return !1
        };
        this.defaults = function(b, c, d) {
            if (Array.isArray(c)) return c.reduce(function(b, c) {
                return a.defaults(b, c, d)
            }, b);
            for (var e in c) b.hasOwnProperty(e) ? Array.isArray(b[e]) || "object" !== typeof b[e] || "object" !== typeof c[e] ? d && (b[e] = a.deepCopy(c[e])) : a.defaults(b[e], c[e], d) : b[e] = a.deepCopy(c[e]);
            return b
        };
        this.cartesianToPolar = function(a, c, d) {
            var b = Math.sqrt(Math.pow(a, 2) + Math.pow(c, 2) + Math.pow(d, 2));
            return [b, Math.acos(d / b), Math.atan2(c, a)]
        };
        this.polarToCartesian = function(a, c, d) {
            return [a *
                Math.sin(c) * Math.cos(d), a * Math.sin(c) * Math.sin(d), a * Math.cos(c)
            ]
        };
        this.check = {
            string: function(a) {
                return "string" === typeof a || a instanceof String
            },
            number: function(a) {
                return ("number" === typeof a || a instanceof Number) && !isNaN(a)
            },
            float: function(a) {
                return ("number" === typeof a || a instanceof Number) && !isNaN(a)
            },
            notnegative: function(a) {
                return ("number" === typeof a || a instanceof Number) && 0 <= a
            },
            notpositive: function(a) {
                return ("number" === typeof a || a instanceof Number) && 0 >= a
            },
            factor: function(a) {
                return ("number" ===
                    typeof a || a instanceof Number) && 0 <= a && 1 >= a
            },
            color: function(a) {
                return null !== (0, module$src$shared$util$toTinyColor.default)(a)
            },
            integer: function(a) {
                return ("number" === typeof a || a instanceof Number) && !isNaN(a) && a === parseInt(a, 10)
            },
            boolean: function(a) {
                return "boolean" === typeof a || a instanceof Boolean
            },
            object: function(a) {
                return void 0 !== a && "object" === typeof a
            },
            hexadecimal: function(b) {
                if (a.typeCheck(b, "string")) {
                    b = b.replace("#", "");
                    var c = parseInt(b, 16);
                    return !(!b.endsWith(c.toString(16)) || 0 > c || 16777215 <
                        c)
                }
                return a.typeCheck(b, "number") ? !(0 > b || 16777215 < b) : !1
            },
            vector2obj: function(b) {
                return !b.x && 0 !== b.x || !b.y && 0 !== b.y ? !1 : a.typeCheck(b.x, "number") && a.typeCheck(b.y, "number") ? !0 : !1
            },
            vector2arr: function(b) {
                return Array.isArray(b) && 2 <= b.length ? a.typeCheck(b[0], "number") && a.typeCheck(b[1], "number") ? !0 : !1 : !1
            },
            vector2any: function(b) {
                return a.typeCheck(b, "vector2arr") || a.typeCheck(b, "vector2obj") ? !0 : !1
            },
            vector3obj: function(b) {
                return !b.x && 0 !== b.x || !b.y && 0 !== b.y || !b.z && 0 !== b.z ? !1 : a.typeCheck(b.x, "number") && a.typeCheck(b.y,
                    "number") && a.typeCheck(b.z, "number") ? !0 : !1
            },
            vector3arr: function(b) {
                return Array.isArray(b) && 3 <= b.length ? a.typeCheck(b[0], "number") && a.typeCheck(b[1], "number") && a.typeCheck(b[2], "number") ? !0 : !1 : !1
            },
            vector3any: function(b) {
                return a.typeCheck(b, "vector3arr") || a.typeCheck(b, "vector3obj") ? !0 : !1
            }
        };
        this.typeCheck = function(a, c, d, e, f) {
            for (var b = [], h = 4; h < arguments.length; ++h) b[h - 4] = arguments[h];
            if (void 0 === a) {
                h = "The given input is undefined.";
                var k = !1
            } else null === a ? (h = "The given input is null.", k = !1) : (c = c.toLowerCase(),
                this.check[c] ? h = (k = this.check[c](a)) ? "" : "Value " + a + " is not a " + c : (h = "No type check available for type " + c + ". The possible types are [" + Object.getOwnPropertyNames(this.check).map(function(a) {
                    return " " + a
                }) + " ]. Choose one of them.", k = !1));
            d && !1 === k && (e ? d.apply(null, [e, h].concat($jscomp.arrayFromIterable(b))) : d.apply(null, [h].concat($jscomp.arrayFromIterable(b))));
            return k
        };
        this.toVector3 = function(a) {
            if (a.isVector3) return a;
            if (Array.isArray(a) && 2 <= a.length) {
                var b = new module$src$externals$three.default.Vector3;
                b.fromArray(a);
                return b
            }
            return new module$src$externals$three.default.Vector3(a.x, a.y, a.z)
        };
        return this
    };
module$src$shared$util$GlobalUtils.default = new GlobalUtils$$module$src$shared$util$GlobalUtils;
var module$build$build_data = {
    default: {
        build_version: "2.0.8",
        build_date: "2018-08-30T06:30:58.923Z"
    }
};
var module$src$shared$constants$LoggingConstants = {},
    loggingLevels$$module$src$shared$constants$LoggingConstants = {
        NONE: -1,
        ERROR: 0,
        WARN: 1,
        INFO: 2,
        DEBUG: 3,
        LVLBITS: 3,
        ERROR_S: 8,
        WARN_S: 9,
        INFO_S: 10,
        DEBUG_S: 11
    },
    defaultSettings$$module$src$shared$constants$LoggingConstants = {
        loggingLevel: loggingLevels$$module$src$shared$constants$LoggingConstants.NONE
    },
    loggingConstants$$module$src$shared$constants$LoggingConstants = {
        loggingLevels: loggingLevels$$module$src$shared$constants$LoggingConstants,
        defaultSettings: defaultSettings$$module$src$shared$constants$LoggingConstants
    },
    GlobalUtils$$module$src$shared$constants$LoggingConstants = module$src$shared$util$GlobalUtils.default;
module$src$shared$constants$LoggingConstants.default = module$src$shared$util$GlobalUtils.default.deepCopy(loggingConstants$$module$src$shared$constants$LoggingConstants);
var module$src$shared$constants$MessagingConstants = {},
    GlobalUtils$$module$src$shared$constants$MessagingConstants = module$src$shared$util$GlobalUtils.default,
    messageTopics$$module$src$shared$constants$MessagingConstants = {
        DATA: "data",
        EXPORT: "export",
        EXPORT_AVAILABLE: "export.available",
        EXPORT_REGISTER: "export.register",
        EXPORT_REGISTERED: "export.registered",
        EXPORT_STATUS: "export.status",
        PARAMETER: "parameter",
        PARAMETER_REGISTER: "parameter.register",
        PARAMETER_REGISTERED: "parameter.registered",
        PARAMETER_VALUE_UPDATE: "parameter.value.update",
        PLUGIN: "plugin",
        PLUGIN_ACTIVE: "plugin.active",
        PLUGIN_FAILED: "plugin.failed",
        PLUGIN_LOADED: "plugin.loaded",
        PLUGIN_REGISTERED: "plugin.registered",
        PLUGIN_UNLOADED: "plugin.unloaded",
        PROCESS: "process",
        SETTINGS: "settings",
        SETTINGS_REGISTER: "settings.register",
        SETTINGS_UPDATE: "settings.update",
        SCENE: "scene",
        SCENE_DRAG: "scene.drag",
        SCENE_DRAG_START: "scene.drag.start",
        SCENE_DRAG_MOVE: "scene.drag.move",
        SCENE_DRAG_END: "scene.drag.end",
        SCENE_HOVER: "scene.hover",
        SCENE_HOVER_ON: "scene.hover.on",
        SCENE_HOVER_OVER: "scene.hover.over",
        SCENE_HOVER_OFF: "scene.hover.off",
        SCENE_RENDER: "scene.render",
        SCENE_RENDER_BEAUTY: "scene.render.beauty",
        SCENE_RENDER_BEAUTY_START: "scene.render.beauty.start",
        SCENE_RENDER_BEAUTY_END: "scene.render.beauty.end",
        SCENE_SELECT: "scene.select",
        SCENE_SELECT_ON: "scene.select.on",
        SCENE_SELECT_OFF: "scene.select.off",
        SCENE_SUBSCENE: "scene.subscene",
        SCENE_SUBSCENE_INIT: "scene.subscene.init",
        SCENE_SUBSCENE_OUTPUTVERSION: "scene.subscene.outputversion",
        SCENE_SUBSCENE_READY: "scene.subscene.ready",
        SCENE_SUBSCENE_PUBLISHED: "scene.subscene.published",
        SCENE_VISIBILITY: "scene.visibility",
        SCENE_VISIBILITY_ON: "scene.visibility.on",
        SCENE_VISIBILITY_OFF: "scene.visibility.off",
        STATUS: "status",
        STATUS_BUSY: "status.busy",
        STATUS_IDLE: "status.idle"
    },
    messageDataTypes$$module$src$shared$constants$MessagingConstants = {
        GENERIC: "generic",
        APP_SETTINGS: "app.settings",
        APP_STATUS: "app.status",
        DATA: "data",
        EXPORT_DEFINITION: "export.definition",
        EXPORT_RESULT: "export.result",
        EXPORT_STATUS: "export.status",
        PARAMETER_DEFINITION: "parameter.definition",
        PARAMETER_UPDATE: "parameter.update",
        PLUGIN_RUNTIME_ID: "plugin.runtimeId",
        PROCESS_ERROR: "process.error",
        PROCESS_ABORT: "process.abort",
        PROCESS_FORK: "process.fork",
        PROCESS_STATUS: "process.status",
        PROCESS_INITIAL: "process.initial",
        PROCESS_SUCCESS: "process.success",
        SCENE_INTERACTION: "scene.interaction",
        SUBSCENE_DEFINITION: "subscene.definition",
        SUBSCENE_OUTPUTVERSION_JSON: "subscene.outputversion.json",
        SUBSCENE_OUTPUTVERSION_OBJ: "subscene.outputversion.obj",
        SUBSCENE_INIT: "subscene.init"
    },
    makeMessageToken$$module$src$shared$constants$MessagingConstants =
    function(a, b) {
        var c = {};
        "string" === typeof a ? c.id = a + "" : null !== a && "object" === typeof a && ("string" === typeof a.id && (c.id = a.id + ""), "string" === typeof a.creator && (c.creator = a.creator + ""), "number" === typeof a.serial && (c.serial = a.serial + ""), c.payload = a.payload, c.attributes = a.attributes);
        if ("string" !== typeof c.id || 0 === c.id.length) c.id = module$src$shared$util$GlobalUtils.default.createRandomId();
        "string" !== typeof c.creator && "string" === typeof b && (c.creator = b + "");
        "number" !== typeof c.serial && (c.serial = Date.now());
        return c
    },
    loggingConstants$$module$src$shared$constants$MessagingConstants = module$src$shared$constants$LoggingConstants.default,
    loggingLevels$$module$src$shared$constants$MessagingConstants = module$src$shared$constants$LoggingConstants.default.loggingLevels,
    defaultSettings$$module$src$shared$constants$MessagingConstants = {
        messageLoggingLevel: loggingLevels$$module$src$shared$constants$MessagingConstants.NONE
    },
    messagingConstants$$module$src$shared$constants$MessagingConstants = {
        messageTopics: messageTopics$$module$src$shared$constants$MessagingConstants,
        messageDataTypes: messageDataTypes$$module$src$shared$constants$MessagingConstants,
        defaultSettings: defaultSettings$$module$src$shared$constants$MessagingConstants
    };
module$src$shared$constants$MessagingConstants.default = module$src$shared$util$GlobalUtils.default.deepCopy(messagingConstants$$module$src$shared$constants$MessagingConstants);
module$src$shared$constants$MessagingConstants.default.makeMessageToken = makeMessageToken$$module$src$shared$constants$MessagingConstants;
var module$src$shared$materials$MaterialPresets = {},
    THREE$$module$src$shared$materials$MaterialPresets = module$src$externals$three.default,
    MaterialPresets$$module$src$shared$materials$MaterialPresets = function() {
        var a = function(a) {
            var b = {};
            Object.keys(a).forEach(function(c) {
                Object.defineProperty(b, c, {
                    enumerable: !0,
                    readable: !0,
                    configurable: !1,
                    get: function() {
                        return a[c]
                    },
                    set: function() {}
                })
            });
            Object.defineProperty(b, "version", {
                enumerable: !0,
                readable: !0,
                configurable: !1,
                get: function() {
                    return "2.0"
                },
                set: function() {}
            });
            return b
        };
        this.defaultMaterial = a({
            color: [211, 211, 211, 255],
            roughness: 1,
            metalness: 0
        });
        this.groundplaneMaterial = a({
            color: [211, 211, 211, 255],
            roughness: 1,
            metalness: 0,
            side: module$src$externals$three.default.FrontSide
        });
        this.defaultPlasticMaterial = a({
            color: [211, 211, 211, 255],
            roughness: 1,
            metalness: 0,
            normaltexture: "https://d363mqea3saz7f.cloudfront.net/textures_presets/02/00/normalMap.jpg",
            roughnesstexture: "https://d363mqea3saz7f.cloudfront.net/textures_presets/02/00/roughnessMap.jpg"
        });
        this.defaultMetalMaterial =
            a({
                color: [205, 205, 205, 255],
                roughness: .25,
                metalness: 1
            });
        this.usedMetalMaterial = a({
            color: [205, 205, 205, 255],
            roughness: 1,
            metalness: 1,
            roughnesstexture: "https://d363mqea3saz7f.cloudfront.net/textures_presets/03/01/roughnessMap.jpg"
        });
        this.metalVariation1Material = a({
            color: [205, 205, 205, 255],
            roughness: 1,
            metalness: 1,
            roughnesstexture: "https://d363mqea3saz7f.cloudfront.net/textures_presets/03/02/roughnessMap.jpg"
        });
        this.metalVariation2Material = a({
            color: [205, 205, 205, 255],
            roughness: 1,
            metalness: 1,
            roughnesstexture: "https://d363mqea3saz7f.cloudfront.net/textures_presets/03/03/roughnessMap.jpg"
        });
        this.goldMaterial = a({
            color: [230, 207, 92, 255],
            roughness: 0,
            metalness: 1
        });
        this.usedGoldMaterial = a({
            color: [230, 207, 92, 255],
            roughness: 1,
            metalness: 1,
            roughnesstexture: "https://d363mqea3saz7f.cloudfront.net/textures_presets/03/11/roughnessMap.jpg"
        });
        this.defaultGlassMaterial = a({
            color: [211, 211, 211, 255],
            roughness: 0,
            metalness: 1,
            transparency: .75
        });
        this.defaultWoodMaterial = a({
            color: [211, 211, 211, 255],
            roughness: 1,
            metalness: 0,
            bitmaptexture: "https://d363mqea3saz7f.cloudfront.net/textures_presets/05/00/map.jpg",
            normaltexture: "https://d363mqea3saz7f.cloudfront.net/textures_presets/05/00/normalMap.jpg",
            metalnesstexture: "https://d363mqea3saz7f.cloudfront.net/textures_presets/05/00/metalnessMap.jpg",
            roughnesstexture: "https://d363mqea3saz7f.cloudfront.net/textures_presets/05/00/roughnessMap.jpg"
        });
        this.woodFloorMaterial = a({
            color: [211, 211, 211, 255],
            roughness: 1,
            metalness: 0,
            bitmaptexture: "https://d363mqea3saz7f.cloudfront.net/textures_presets/05/01/map.jpg",
            normaltexture: "https://d363mqea3saz7f.cloudfront.net/textures_presets/05/01/normalMap.jpg",
            metalnesstexture: "https://d363mqea3saz7f.cloudfront.net/textures_presets/05/01/metalnessMap.jpg",
            roughnesstexture: "https://d363mqea3saz7f.cloudfront.net/textures_presets/05/01/roughnessMap.jpg"
        });
        this.naturalOakMaterial = a({
            roughness: 1,
            metalness: 0,
            bitmaptexture: "https://d363mqea3saz7f.cloudfront.net/textures_presets/05/10/map.jpg",
            normaltexture: "https://d363mqea3saz7f.cloudfront.net/textures_presets/05/10/normalMap.jpg",
            roughnesstexture: "https://d363mqea3saz7f.cloudfront.net/textures_presets/05/10/roughnessMap.jpg"
        });
        this.premiumOakMaterial = a({
            roughness: 1,
            metalness: 0,
            bitmaptexture: "https://d363mqea3saz7f.cloudfront.net/textures_presets/05/11/map.jpg",
            roughnesstexture: "https://d363mqea3saz7f.cloudfront.net/textures_presets/05/11/roughnessMap.jpg"
        });
        var b = function(b) {
            a({
                roughness: 1,
                metalness: 0,
                bitmaptexture: "https://d363mqea3saz7f.cloudfront.net/textures_presets/06/" + b + "/map.jpg",
                normaltexture: "https://d363mqea3saz7f.cloudfront.net/textures_presets/06/" + b + "/normalMap.jpg",
                metalnesstexture: "https://d363mqea3saz7f.cloudfront.net/textures_presets/06/" + b + "/metalnessMap.jpg",
                roughnesstexture: "https://d363mqea3saz7f.cloudfront.net/textures_presets/06/" +
                    b + "/roughnessMap.jpg"
            })
        };
        this.defaultLeatherMaterial = b("00");
        this.darkBrownLeatherMaterial = b("01");
        this.blackLeatherMaterial = b("02");
        this.wornLeatherMaterial = b("10");
        this.defaultFabricMaterial = a({
            roughness: 1,
            metalness: 1,
            bitmaptexture: "https://d363mqea3saz7f.cloudfront.net/textures_presets/07/00/map.jpg",
            normaltexture: "https://d363mqea3saz7f.cloudfront.net/textures_presets/07/00/normalMap.jpg",
            roughnesstexture: "https://d363mqea3saz7f.cloudfront.net/textures_presets/07/00/roughnessMap.jpg",
            metalnesstexture: "https://d363mqea3saz7f.cloudfront.net/textures_presets/07/00/metalnessMap.jpg"
        });
        this.greyFabricMaterial = a({
            roughness: 1,
            metalness: 1,
            bitmaptexture: "https://d363mqea3saz7f.cloudfront.net/textures_presets/07/01/map.jpg",
            normaltexture: "https://d363mqea3saz7f.cloudfront.net/textures_presets/07/01/normalMap.jpg",
            roughnesstexture: "https://d363mqea3saz7f.cloudfront.net/textures_presets/07/01/roughnessMap.jpg",
            metalnesstexture: "https://d363mqea3saz7f.cloudfront.net/textures_presets/07/01/metalnessMap.jpg"
        });
        this.fromId = Object.defineProperty(this, "fromId", {
            readable: !0,
            configurable: !1,
            enumerable: !0,
            get: function() {
                return function(a) {
                    a = Number(String(a));
                    100 > a && 0 == a % 10 && (a /= 10);
                    0 == Math.floor(Math.log(a) / Math.log(10)) && (a *= 100);
                    var b = Math.floor(a / 100);
                    a -= 100 * b;
                    switch (b) {
                        case 1:
                            switch (a) {
                                case 1:
                                    return this.groundplaneMaterial;
                                default:
                                    return this.defaultMaterial
                            }
                        case 2:
                            return this.defaultPlasticMaterial;
                        case 3:
                            switch (a) {
                                case 1:
                                    return this.usedMetalMaterial;
                                case 2:
                                    return this.metalVariation1Material;
                                case 3:
                                    return this.metalVariation2Material;
                                case 10:
                                    return this.goldMaterial;
                                case 11:
                                    return this.usedGoldMaterial;
                                default:
                                    return this.defaultMetalMaterial
                            }
                        case 4:
                            return this.defaultGlassMaterial;
                        case 5:
                            switch (a) {
                                case 1:
                                    return this.woodFloorMaterial;
                                case 10:
                                    return this.naturalOakMaterial;
                                case 11:
                                    return this.premiumOakMaterial;
                                default:
                                    return this.defaultWoodMaterial
                            }
                        case 6:
                            switch (a) {
                                case 1:
                                    return this.darkBrownLeatherMaterial;
                                case 2:
                                    return this.blackLeatherMaterial;
                                case 10:
                                    return this.wornLeatherMaterial;
                                default:
                                    return this.defaultLeatherMaterial
                            }
                        case 7:
                            switch (a) {
                                case 1:
                                    return this.greyFabricMaterial;
                                default:
                                    return this.defaultFabricMaterial
                            }
                        default:
                            return this.defaultMaterial
                    }
                }
            },
            set: function() {}
        });
        return this
    };
module$src$shared$materials$MaterialPresets.default = new MaterialPresets$$module$src$shared$materials$MaterialPresets;
var module$src$app$ViewerAppConstants = {},
    loggingConstants$$module$src$app$ViewerAppConstants = module$src$shared$constants$LoggingConstants.default,
    loggingLevels$$module$src$app$ViewerAppConstants = module$src$shared$constants$LoggingConstants.default.loggingLevels,
    messagingConstants$$module$src$app$ViewerAppConstants = module$src$shared$constants$MessagingConstants.default,
    messageTopics$$module$src$app$ViewerAppConstants = module$src$shared$constants$MessagingConstants.default.messageTopics,
    messageDataTypes$$module$src$app$ViewerAppConstants =
    module$src$shared$constants$MessagingConstants.default.messageDataTypes,
    materialPresets$$module$src$app$ViewerAppConstants = module$src$shared$materials$MaterialPresets.default,
    showSceneModes$$module$src$app$ViewerAppConstants = {
        INSTANT: 0,
        ON_SHOW: 1,
        ON_FIRST_PLUGIN: 2,
        ON_ALL_PLUGINS: 3
    },
    defaultSettings$$module$src$app$ViewerAppConstants = {
        brandedMode: !0,
        defaultMaterial: module$src$shared$materials$MaterialPresets.default.defaultMaterial,
        loggingLevel: loggingLevels$$module$src$app$ViewerAppConstants.NONE,
        messageLoggingLevel: loggingLevels$$module$src$app$ViewerAppConstants.NONE,
        showScene: !1,
        showSceneMode: showSceneModes$$module$src$app$ViewerAppConstants.ON_FIRST_PLUGIN,
        showSceneTransition: "1s"
    },
    viewerAppConstants$$module$src$app$ViewerAppConstants = {
        loggingLevels: loggingLevels$$module$src$app$ViewerAppConstants,
        messageTopics: messageTopics$$module$src$app$ViewerAppConstants,
        messageDataTypes: messageDataTypes$$module$src$app$ViewerAppConstants,
        showSceneModes: showSceneModes$$module$src$app$ViewerAppConstants,
        defaultSettings: defaultSettings$$module$src$app$ViewerAppConstants
    },
    GlobalUtils$$module$src$app$ViewerAppConstants = module$src$shared$util$GlobalUtils.default;
module$src$app$ViewerAppConstants.default = module$src$shared$util$GlobalUtils.default.deepCopy(viewerAppConstants$$module$src$app$ViewerAppConstants);
var module$src$externals$axios = {};
try {
    module$src$externals$axios.default = eval("axios")
} catch (a) {
    "function" === typeof require && (module$src$externals$axios.default = eval("require('axios')"))
};
var module$src$plugins$comm$CommPluginConstants = {},
    baseUrl$$module$src$plugins$comm$CommPluginConstants = "https://model-view.shapediver.com:443",
    defaultSettings$$module$src$plugins$comm$CommPluginConstants = {
        modelViewUrl: baseUrl$$module$src$plugins$comm$CommPluginConstants,
        loadDefaultGeometry: !0,
        ajaxTimeout: 3E4
    },
    commPluginConstants$$module$src$plugins$comm$CommPluginConstants = {
        defaultSettings: defaultSettings$$module$src$plugins$comm$CommPluginConstants
    },
    GlobalUtils$$module$src$plugins$comm$CommPluginConstants =
    module$src$shared$util$GlobalUtils.default;
module$src$plugins$comm$CommPluginConstants.default = module$src$shared$util$GlobalUtils.default.deepCopy(commPluginConstants$$module$src$plugins$comm$CommPluginConstants);
var module$src$shared$constants$PluginConstantsGlobal = {},
    pluginCapabilities$$module$src$shared$constants$PluginConstantsGlobal = {
        NONE: 0,
        SHAPEDIVER_MODEL_VIEW: 1,
        INTERACTIVE: 2,
        DRAGANDDROP: 3,
        MESSAGECALLBACKS: 4,
        LOGGING: 5,
        SETTINGS: 6,
        DEFAULTPARAM: 7
    },
    pluginStatuses$$module$src$shared$constants$PluginConstantsGlobal = {
        NONE: "none",
        READY: "ready",
        FAILED: "failed",
        LOADED: "loaded",
        ACTIVE: "active",
        UNLOADED: "unloaded"
    },
    setParameterResults$$module$src$shared$constants$PluginConstantsGlobal = {
        PARAM_NOT_FOUND: "param_not_found",
        NO_VALUE: "no_value",
        VALUE_REJECT: "value_reject",
        VALUE_EXISTS: "value_exists",
        VALUE_OK: "value_ok",
        PLUGIN_NOT_FOUND: "plugin_not_found",
        ERROR: "error",
        LIVE: "live",
        CACHE: "cache",
        LOAD: "load",
        ABORT: "abort"
    },
    requestExportResults$$module$src$shared$constants$PluginConstantsGlobal = {
        EXPORT_NOT_FOUND: "export_not_found",
        PLUGIN_NOT_FOUND: "plugin_not_found",
        ERROR: "error",
        CACHE: "cache",
        LOAD: "load",
        ABORT: "abort"
    },
    pluginConstants$$module$src$shared$constants$PluginConstantsGlobal = {
        pluginCapabilities: pluginCapabilities$$module$src$shared$constants$PluginConstantsGlobal,
        pluginStatuses: pluginStatuses$$module$src$shared$constants$PluginConstantsGlobal,
        setParameterResults: setParameterResults$$module$src$shared$constants$PluginConstantsGlobal,
        requestExportResults: requestExportResults$$module$src$shared$constants$PluginConstantsGlobal
    },
    GlobalUtils$$module$src$shared$constants$PluginConstantsGlobal = module$src$shared$util$GlobalUtils.default;
module$src$shared$constants$PluginConstantsGlobal.default = module$src$shared$util$GlobalUtils.default.deepCopy(pluginConstants$$module$src$shared$constants$PluginConstantsGlobal);
var module$src$plugins$PluginConstants = {},
    loggingConstants$$module$src$plugins$PluginConstants = module$src$shared$constants$LoggingConstants.default,
    loggingLevels$$module$src$plugins$PluginConstants = module$src$shared$constants$LoggingConstants.default.loggingLevels,
    messagingConstants$$module$src$plugins$PluginConstants = module$src$shared$constants$MessagingConstants.default,
    messageTopics$$module$src$plugins$PluginConstants = module$src$shared$constants$MessagingConstants.default.messageTopics,
    messageDataTypes$$module$src$plugins$PluginConstants =
    module$src$shared$constants$MessagingConstants.default.messageDataTypes,
    pluginConstantsGlobal$$module$src$plugins$PluginConstants = module$src$shared$constants$PluginConstantsGlobal.default,
    defaultSettings$$module$src$plugins$PluginConstants = {
        loggingLevel: loggingLevels$$module$src$plugins$PluginConstants.NONE
    },
    pluginConstants$$module$src$plugins$PluginConstants = {
        loggingLevels: loggingLevels$$module$src$plugins$PluginConstants,
        messageTopics: messageTopics$$module$src$plugins$PluginConstants,
        messageDataTypes: messageDataTypes$$module$src$plugins$PluginConstants,
        pluginCapabilities: module$src$shared$constants$PluginConstantsGlobal.default.pluginCapabilities,
        pluginStatuses: module$src$shared$constants$PluginConstantsGlobal.default.pluginStatuses,
        setParameterResults: module$src$shared$constants$PluginConstantsGlobal.default.setParameterResults,
        requestExportResults: module$src$shared$constants$PluginConstantsGlobal.default.requestExportResults,
        defaultSettings: defaultSettings$$module$src$plugins$PluginConstants
    },
    GlobalUtils$$module$src$plugins$PluginConstants = module$src$shared$util$GlobalUtils.default;
module$src$plugins$PluginConstants.default = module$src$shared$util$GlobalUtils.default.deepCopy(pluginConstants$$module$src$plugins$PluginConstants);
var module$src$shared$mixins$GlobalMixin = {
    default: function() {
        this.jsify = function(a) {
            return JSON.stringify(a, null, 0)
        };
        return this
    }
};
var module$src$shared$mixins$SettingsMixin = {},
    GlobalUtils$$module$src$shared$mixins$SettingsMixin = module$src$shared$util$GlobalUtils.default;
module$src$shared$mixins$SettingsMixin.default = function(a, b) {
    var c = this,
        d = "function" === typeof c.warn ? c.warn : function() {};
    if (void 0 === a || "object" !== typeof a) a = {};
    if (void 0 === b || "object" !== typeof b) b = {};
    var e = module$src$shared$util$GlobalUtils.default.deepCopy(a);
    module$src$shared$util$GlobalUtils.default.defaults(e, b);
    this.getSettings = function(a) {
        if (void 0 === a || !Array.isArray(a)) return module$src$shared$util$GlobalUtils.default.deepCopy(e);
        var b = {};
        a.forEach(function(a) {
            c.hasSetting(a) && module$src$shared$util$GlobalUtils.default.forceAtPath(b,
                a, c.getSetting(a))
        });
        return b
    };
    this.getSetting = function(a) {
        return module$src$shared$util$GlobalUtils.default.deepCopy(module$src$shared$util$GlobalUtils.default.getAtPath(e, a))
    };
    this.getSettingShallow = function(a) {
        return module$src$shared$util$GlobalUtils.default.getAtPath(e, a)
    };
    this.hasSetting = function(a) {
        return void 0 !== module$src$shared$util$GlobalUtils.default.getAtPath(e, a)
    };
    var f = {},
        g = 0;
    this.registerHook = function(a, b) {
        a || (a = ".*");
        if ("string" === typeof a) a.startsWith("^") || (a = "^" + a), a.endsWith("$") ||
            (a += "$"), a = RegExp(a);
        else if (!(a instanceof RegExp)) return;
        if ("function" === typeof b) {
            var c = g;
            f[g++] = {
                r: a,
                cb: b
            };
            return c
        }
    };
    this.deregisterHook = function(a) {
        if (!f.hasOwnProperty(a)) return !1;
        delete f[a];
        return !0
    };
    var h = {},
        k = 0;
    this.registerNotifier = function(a, b) {
        a || (a = ".*");
        if ("string" === typeof a) a.startsWith("^") || (a = "^" + a), a.endsWith("$") || (a += "$"), a = RegExp(a);
        else if (!(a instanceof RegExp)) return;
        if ("function" === typeof b) {
            var c = k;
            h[k++] = {
                r: a,
                cb: b
            };
            return c
        }
    };
    this.deregisterNotifier = function(a) {
        if (!h.hasOwnProperty(a)) return !1;
        delete h[a];
        return !0
    };
    this.updateSetting = function(a, b) {
        if (!Object.keys(f).every(function(c) {
                c = f[c];
                if (!c.r.test(a)) return !0;
                c = c.cb(b, a);
                c instanceof Promise && d("SettingsMixin.updateSetting", "A hook for " + a + " returned a Promise, which is always a truthy value, use SettingsMixin.updateSettingAsync instead for updates to this key");
                return c
            })) return !1;
        var g = c.getSetting(a);
        module$src$shared$util$GlobalUtils.default.forceAtPath(e, a, module$src$shared$util$GlobalUtils.default.deepCopy(b));
        Object.keys(h).forEach(function(c) {
            c =
                h[c];
            if (c.r.test(a)) try {
                c.cb(a, g, b)
            } catch (r) {
                d("SettingsMixin.updateSetting", "A notifier for setting " + c.r.toString() + " threw an exception", r)
            }
        });
        return !0
    };
    this.updateSettingAsync = function(a, b) {
        var g = [];
        return Object.keys(f).every(function(c) {
            c = f[c];
            if (!c.r.test(a)) return !0;
            c = c.cb(b, a);
            return c instanceof Promise ? (g.push(c), !0) : c
        }) ? Promise.all(g).then(function(f) {
            if (f.every(function(a) {
                    return a
                })) {
                var g = c.getSetting(a);
                module$src$shared$util$GlobalUtils.default.forceAtPath(e, a, module$src$shared$util$GlobalUtils.default.deepCopy(b));
                Object.keys(h).forEach(function(c) {
                    c = h[c];
                    if (c.r.test(a)) try {
                        c.cb(a, g, b)
                    } catch (t) {
                        d("SettingsMixin.updateSettingAsync", "A notifier for setting " + c.r.toString() + " threw an exception", t)
                    }
                });
                return !0
            }
            return !1
        }, function() {
            return !1
        }) : Promise.resolve(!1)
    };
    this.updateSettings = function(a, b) {
        "boolean" !== typeof b && (b = !1);
        var d = !0;
        if (void 0 === a || "object" !== typeof a) return d;
        var e = [];
        module$src$shared$util$GlobalUtils.default.getPaths(a, e);
        e.forEach(function(e) {
            b && c.hasSetting(e) || c.updateSetting(e, module$src$shared$util$GlobalUtils.default.getAtPath(a,
                e)) || (d = !1)
        });
        return d
    };
    this.updateSettingsAsync = function() {
        d("SettingsMixin.updateSettingsAsync", "to be implemented");
        return Promise.reject(Error("SettingsMixin.updateSettingsAsyncto be implemented"))
    };
    this.isSettingPersistent = function() {
        return !1
    };
    this.getSection = function(a) {
        var b = c.getSettingShallow(a);
        return void 0 === b || "object" !== typeof b ? !1 : {
            getSettings: function(b) {
                if (void 0 === b || !Array.isArray(b)) return b = c.getSettings([a]), module$src$shared$util$GlobalUtils.default.getAtPath(b, a);
                b = module$src$shared$util$GlobalUtils.default.deepCopy(b);
                for (var d = 0; d < b.length; d++) b[d] = a + "." + b[d];
                return c.getSettings(b)
            },
            getSetting: function(b) {
                return c.getSetting(a + "." + b)
            },
            getSettingShallow: function(b) {
                return c.getSettingShallow(a + "." + b)
            },
            hasSetting: function(b) {
                return c.hasSetting(a + "." + b)
            },
            registerHook: function(b, d) {
                if ("string" !== typeof b) return !1;
                b.startsWith("^") && (b = b.substring(1));
                var e = a.length + 1;
                return c.registerHook(a + "." + b, function(a, b) {
                    return d(a, b.substring(e))
                })
            },
            deregisterHook: function(a) {
                return c.deregisterHook(a)
            },
            registerNotifier: function(b,
                d) {
                if ("string" !== typeof b) return !1;
                b.startsWith("^") && (b = b.substring(1));
                var e = a.length + 1;
                return c.registerNotifier(a + "." + b, function(a, b, c) {
                    return d(a.substring(e), b, c)
                })
            },
            deregisterNotifier: function(a) {
                return c.deregisterNotifier(a)
            },
            updateSetting: function(b, d) {
                return c.updateSetting(a + "." + b, d)
            },
            updateSettingAsync: function(b, d) {
                return c.updateSettingAsync(a + "." + b, d)
            },
            updateSettings: function(b, d) {
                "boolean" !== typeof d && (d = !1);
                var e = !0;
                if (void 0 === b || "object" !== typeof b) return e;
                var f = [];
                module$src$shared$util$GlobalUtils.default.getPaths(b,
                    f);
                f.forEach(function(f) {
                    var g = a + "." + f;
                    d && c.hasSetting(g) || c.updateSetting(g, module$src$shared$util$GlobalUtils.default.getAtPath(b, f)) || (e = !1)
                });
                return e
            },
            updateSettingsAsync: function() {
                d("SettingsMixin.updateSettingsAsync", "to be implemented");
                return Promise.reject(Error("SettingsMixin.updateSettingsAsyncto be implemented"))
            },
            isSettingPersistent: function(b) {
                return c.isSettingPersistent(a + "." + b)
            },
            getSection: function(b) {
                return c.getSection(a + "." + b)
            }
        }
    };
    return this
};
var module$src$shared$mixins$LoggingMixin = {},
    loggingConstants$$module$src$shared$mixins$LoggingMixin = module$src$shared$constants$LoggingConstants.default;
module$src$shared$mixins$LoggingMixin.default = function() {
    var a = this;
    this.getLoggingLevelName = function(a) {
        var b = a.toString();
        Object.keys(module$src$shared$constants$LoggingConstants.default.loggingLevels).forEach(function(c) {
            module$src$shared$constants$LoggingConstants.default.loggingLevels[c] == a && (b = c)
        });
        return b
    };
    this.logToConsole = function() {
        var a = 1 === arguments.length ? [arguments[0]] : Array.apply(null, arguments),
            c = a[0] & module$src$shared$constants$LoggingConstants.default.loggingLevels.LVLBITS,
            d = a[1];
        a = a.slice(2);
        c === module$src$shared$constants$LoggingConstants.default.loggingLevels.ERROR ? console.error.apply(console, ["ERROR." + d, ":"].concat($jscomp.arrayFromIterable(a))) : c === module$src$shared$constants$LoggingConstants.default.loggingLevels.WARN ? console.warn.apply(console, ["WARN." + d, ":"].concat($jscomp.arrayFromIterable(a))) : c === module$src$shared$constants$LoggingConstants.default.loggingLevels.INFO ? console.log.apply(console, ["INFO." + d, ":"].concat($jscomp.arrayFromIterable(a))) : c === module$src$shared$constants$LoggingConstants.default.loggingLevels.DEBUG ?
            console.log.apply(console, ["DEBUG." + d, ":"].concat($jscomp.arrayFromIterable(a))) : console.log.apply(console, ["UNKNOWN." + d, ":"].concat($jscomp.arrayFromIterable(a)))
    };
    this.log = function() {
        (arguments[0] & module$src$shared$constants$LoggingConstants.default.loggingLevels.LVLBITS) <= a.getLoggingLevel() && a.logToConsole.apply(a, arguments)
    };
    this.error = function() {
        a.log.apply(a, [module$src$shared$constants$LoggingConstants.default.loggingLevels.ERROR].concat($jscomp.arrayFromIterable(arguments)))
    };
    this.warn = function() {
        a.log.apply(a, [module$src$shared$constants$LoggingConstants.default.loggingLevels.WARN].concat($jscomp.arrayFromIterable(arguments)))
    };
    this.info = function() {
        a.log.apply(a, [module$src$shared$constants$LoggingConstants.default.loggingLevels.INFO].concat($jscomp.arrayFromIterable(arguments)))
    };
    this.debug = function() {
        a.log.apply(a, [module$src$shared$constants$LoggingConstants.default.loggingLevels.DEBUG].concat($jscomp.arrayFromIterable(arguments)))
    };
    this.setLoggingLevel = function(b) {
        return a.updateSetting("loggingLevel",
            b)
    };
    this.getLoggingLevel = function() {
        return a.getSetting("loggingLevel")
    };
    return this
};
var module$src$shared$mixins$MessagingMixin = {},
    messagingConstants$$module$src$shared$mixins$MessagingMixin = module$src$shared$constants$MessagingConstants.default,
    loggingConstants$$module$src$shared$mixins$MessagingMixin = module$src$shared$constants$LoggingConstants.default;
module$src$shared$mixins$MessagingMixin.default = function() {
    var a = this;
    this.messageToLog = function(b, c) {
        var d = a.getSetting("messageLoggingLevel");
        d !== module$src$shared$constants$LoggingConstants.default.loggingLevels.NONE && a.log(d, b, c)
    };
    this.messageToPubSub = function(a, c, d, e) {
        e && "string" === typeof e.prefix && (a = e.prefix.concat(".", a));
        e && "string" === typeof e.postfix && (a = a.concat(".", e.postfix));
        d.publish(a, c)
    };
    this.message = function(b, c) {
        a.messageToLog(b, c)
    };
    this.hasSetting("messageLoggingLevel") || a.updateSetting("messageLoggingLevel",
        module$src$shared$constants$MessagingConstants.default.defaultSettings.messageLoggingLevel);
    return this
};
var module$src$shared$messages$MessagePrototype = {},
    GlobalUtils$$module$src$shared$messages$MessagePrototype = module$src$shared$util$GlobalUtils.default;
module$src$shared$messages$MessagePrototype.default = function(a, b, c) {
    var d = this;
    this.origin = {};
    this.parts = [];
    this.addPart = function(a, b) {
        void 0 !== a && d.parts.push({
            type: a,
            data: b
        })
    };
    this.addPart(a, b);
    this.getPartsByType = function(a) {
        return d.parts.filter(function(b) {
            return b.type === a
        })
    };
    this.getUniquePartByType = function(a) {
        a = d.getPartsByType(a);
        if (1 === a.length) return a[0]
    };
    this.token = {};
    "string" === typeof c && 0 < c.length ? this.token = {
            id: c
        } : null !== c && "object" === typeof c && "string" === typeof c.id && 0 < c.id.length ?
        this.token = c : this.token.id = module$src$shared$util$GlobalUtils.default.createRandomId();
    if (void 0 === this.token.serial || "number" !== typeof this.token.serial) this.token.serial = Date.now();
    this.date = Date.now();
    return this
};
var module$src$shared$util$stringChecksum = {
    default: function(a) {
        var b = 0,
            c = a.length,
            d;
        if (0 === c) return b;
        for (d = 0; d < c; d++) {
            var e = a.charCodeAt(d);
            b = (b << 5) - b + e;
            b &= b
        }
        return b
    }
};
var module$src$shared$util$getImageBase64 = {},
    axios$$module$src$shared$util$getImageBase64 = module$src$externals$axios.default,
    _converterEngine$$module$src$shared$util$getImageBase64 = function(a) {
        a = new Uint8Array(a);
        for (var b = a.length, c = []; b--;) c[b] = String.fromCharCode(a[b]);
        return window.btoa(c.join(""))
    };
module$src$shared$util$getImageBase64.default = function(a) {
    return (0, module$src$externals$axios.default)({
        method: "GET",
        url: a,
        responseType: "arraybuffer"
    }).catch(function(a) {
        return Promise.reject(a)
    }).then(function(a) {
        var b = _converterEngine$$module$src$shared$util$getImageBase64(a.data);
        return Promise.resolve({
            data: b,
            contentType: a.headers["content-type"]
        })
    })
};
var module$src$shared$singletons$TextureLoader = {},
    axios$$module$src$shared$singletons$TextureLoader = module$src$externals$axios.default,
    THREE$$module$src$shared$singletons$TextureLoader = module$src$externals$three.default,
    textureCache$$module$src$shared$singletons$TextureLoader = {},
    TextureLoader$$module$src$shared$singletons$TextureLoader = function() {
        var a = this;
        this.log = function() {};
        this.warn = function() {};
        this.error = function() {};
        this.loadTexture = function(a, d) {
            return -1 != navigator.userAgent.indexOf("Safari") &&
                -1 == navigator.userAgent.indexOf("Chrome") ? b(a, d).then(function() {
                    return b(a, d)
                }) : b(a, d)
        };
        var b = function(b, d) {
            d = d || {};
            var c = function(a) {
                a.wrapS = module$src$externals$three.default.RepeatWrapping;
                a.wrapT = module$src$externals$three.default.RepeatWrapping;
                var b = d.offset || [0, 0];
                a.offset = new module$src$externals$three.default.Vector2(b[0], b[1]);
                b = d.repeat || [1, 1];
                a.repeat = new module$src$externals$three.default.Vector2(b[0], b[1]);
                a.rotation = d.rotation || 0;
                b = d.center || [0, 0];
                a.center = new module$src$externals$three.default.Vector2(b[0],
                    b[1]);
                a.uvTransform = new module$src$externals$three.default.Matrix3;
                a.uvTransform.identity().translate(-a.center.x, -a.center.y).rotate(a.rotation).scale(a.repeat.x, a.repeat.y).translate(a.center.x, a.center.y).translate(a.offset.x, a.offset.y);
                a.needsUpdate = !0;
                return a
            };
            if (typeof b && "object" === typeof b && null !== b && 1 === b.nodeType && "string" === typeof b.nodeName && "CANVAS" === b.nodeName.toUpperCase()) {
                var f = new module$src$externals$three.default.Texture(b);
                f.SDCanvasTexture = !0;
                "function" !== typeof b._addTexture &&
                    function() {
                        var a = [];
                        b._addTexture = function(b) {
                            return a.push(b)
                        };
                        Object.defineProperty(b, "needsUpdate", {
                            set: function(b) {
                                return b && a.forEach(function(a) {
                                    return a.needsUpdate = !0
                                })
                            }
                        })
                    }();
                b._addTexture(f);
                return Promise.resolve(c(f))
            }
            if ("string" !== typeof b) return Promise.reject(Error("Input is not a string"));
            f = "_" + (0, module$src$shared$util$stringChecksum.default)(b);
            if (textureCache$$module$src$shared$singletons$TextureLoader.hasOwnProperty(f)) return textureCache$$module$src$shared$singletons$TextureLoader[f].then(function(a) {
                return c(a.clone())
            });
            var g = null,
                h = null,
                k = null,
                l = null,
                p = null,
                m = null;
            textureCache$$module$src$shared$singletons$TextureLoader[f] = (new Promise(function(a, c) {
                "data:" == b.substring(0, 5) ? (l = !0, g = b.substring(b.indexOf(":") + 1, b.indexOf(";")), k = -1 !== b.indexOf("base64"), h = b.substring(b.indexOf(",") + 1), a()) : (l = !1, module$src$externals$axios.default.get(b).then(function(b) {
                    g = b.headers["content-type"]; - 1 < g.indexOf(";") && (g = g.substr(0, g.indexOf(";")));
                    h = b.data;
                    k = !1;
                    a()
                }).catch(function(a) {
                    a.response ? c(Error("Loading texture failed with error code " +
                        a.response.status)) : a.request ? c(Error("Loading texture failed, no response from the server.")) : c(Error("Loading texture failed, unknown error."))
                }))
            })).then(function() {
                var a, c;
                p = -1 < ["image/jpeg", "image/png", "image/gif", "image/bmp"].indexOf(g);
                m = "image/svg+xml" == g;
                if (p) return new Promise(function(a, c) {
                    (new module$src$externals$three.default.TextureLoader).load(b, function(b) {
                        a(b)
                    }.bind(this), function() {
                        c(Error("Texture file loading failed."))
                    })
                });
                if (m) {
                    if (0 < window.navigator.userAgent.indexOf("Trident/")) return Promise.reject(Error("SVG textures not supported by Internet Explorer 11. Skipping the texture."));
                    var d = null;
                    l ? (d = k ? window.atob(h) : h, d = (" " + d).slice(1)) : d = h;
                    var e = document.createElement("DIV");
                    e.id = "svgc";
                    e.innerHTML = d;
                    var f = e.getElementsByTagName("svg"),
                        w = [],
                        v = [];
                    for (e = 0; e < f.length; ++e) {
                        for (a = 0; 2 > a; ++a) {
                            var y = f[e].getElementsByTagName(["image", "img"][a]);
                            for (c = 0; c < y.length; ++c) "data:" != y[c].href.baseVal.substring(0, 5) && w.push(y[c].href.baseVal)
                        }
                        c = f[e].getElementsByTagName("style");
                        for (a = 0; a < c.length; ++a) {
                            y = /@import\x20url\(\s*(.*?)\s*\);/g;
                            for (var A = void 0; null !== (A = y.exec(c[a].innerHTML));) v.push(A[1]);
                            v = v.filter(function(a, b, c) {
                                return c.indexOf(a) === b
                            })
                        }
                    }
                    f = [];
                    y = function(a) {
                        return new Promise(function(b, c) {
                            0 < w[a].length ? (0, module$src$shared$util$getImageBase64.default)(w[a]).then(function(c) {
                                d = d.replace(w[a], "data:" + c.contentType + ";base64," + c.data);
                                b()
                            }).catch(function(a) {
                                c(a)
                            }) : b()
                        })
                    };
                    for (e = 0; e < w.length; ++e) c = y(e), f.push(c);
                    y = function(c) {
                        return new Promise(function(e, f) {
                            module$src$externals$axios.default.get(c).then(function(a) {
                                return a.data
                            }).then(function(g) {
                                for (var h = [], k = /url\(\s*(.*?)\s*\)/g,
                                        l; null !== (l = k.exec(g));) h.push(l[1]);
                                k = [];
                                l = function(a) {
                                    return new Promise(function(b, c) {
                                        (0, module$src$shared$util$getImageBase64.default)(a).then(function(c) {
                                            c = "data:" + c.contentType + ";base64," + c.data;
                                            0 < a.length && (g = g.replace(a, c));
                                            b()
                                        }).catch(function() {
                                            c(Error("Error converting " + a + " to base64"))
                                        })
                                    })
                                };
                                for (a = 0; a < h.length; ++a) k.push(l(h[a]));
                                return Promise.all(k).then(function() {
                                    return g
                                }).then(function(a) {
                                    0 < b.length && (d = d.replace("@import url(" + c + ");", a));
                                    e()
                                }).catch(function() {
                                    f(Error("Error converting CSS string."))
                                })
                            })
                        })
                    };
                    for (e = 0; e < v.length; ++e) c = y(v[e]), f.push(c);
                    return Promise.all(f).then(function() {
                        return new Promise(function(a, b) {
                            var c = "data:image/svg+xml," + encodeURIComponent(d),
                                e = document.createElement("canvas");
                            e.width = 2048;
                            e.height = 2048;
                            var f = e.getContext("2d"),
                                g = new Image;
                            g.onload = function() {
                                f.drawImage(g, 0, 0, 2048, 2048);
                                var b = new module$src$externals$three.default.Texture(e);
                                a(b)
                            };
                            g.onerror = function(a) {
                                b(a)
                            };
                            g.crossOrigin = "Anonymous";
                            g.src = c
                        })
                    })
                }
            }).catch(function(b) {
                b && a.warn(b)
            });
            return textureCache$$module$src$shared$singletons$TextureLoader[f].then(function(a) {
                return c(a.clone())
            })
        }
    };
module$src$shared$singletons$TextureLoader.default = new TextureLoader$$module$src$shared$singletons$TextureLoader;
var module$src$plugins$PluginPrototype = {},
    pluginConstants$$module$src$plugins$PluginPrototype = module$src$plugins$PluginConstants.default,
    GlobalUtils$$module$src$plugins$PluginPrototype = module$src$shared$util$GlobalUtils.default,
    GlobalMixin$$module$src$plugins$PluginPrototype = module$src$shared$mixins$GlobalMixin.default,
    SettingsMixin$$module$src$plugins$PluginPrototype = module$src$shared$mixins$SettingsMixin.default,
    LoggingMixin$$module$src$plugins$PluginPrototype = module$src$shared$mixins$LoggingMixin.default,
    MessagingMixin$$module$src$plugins$PluginPrototype = module$src$shared$mixins$MessagingMixin.default,
    MessagePrototype$$module$src$plugins$PluginPrototype = module$src$shared$messages$MessagePrototype.default,
    TextureLoader$$module$src$plugins$PluginPrototype = module$src$shared$singletons$TextureLoader.default,
    THREE$$module$src$plugins$PluginPrototype = module$src$externals$three.default;
module$src$plugins$PluginPrototype.default = function(a) {
    var b = this;
    this.pluginConstants = module$src$plugins$PluginConstants.default;
    this.GlobalUtils = module$src$shared$util$GlobalUtils.default;
    this.MessagePrototype = module$src$shared$messages$MessagePrototype.default;
    b.TextureLoader = module$src$shared$singletons$TextureLoader.default;
    b.THREE = module$src$externals$three.default;
    module$src$shared$mixins$GlobalMixin.default.call(this);
    if (void 0 === a.runtimeId || "string" !== typeof a.runtimeId) a.runtimeId = module$src$shared$util$GlobalUtils.default.createRandomId();
    module$src$shared$mixins$SettingsMixin.default.call(this, a, b.pluginConstants.defaultSettings);
    this.registerHook("runtimeId", function() {
        return !1
    });
    module$src$shared$mixins$LoggingMixin.default.call(this);
    module$src$shared$mixins$MessagingMixin.default.call(this);
    this.getRuntimeId = function() {
        return b.getSetting("runtimeId")
    };
    this.load = function(a) {
        b.updateSettings(a);
        return !0
    };
    this.getStatus = function() {};
    this.setStatus = function() {};
    (function() {
        var a = b.pluginConstants.pluginStatuses.READY;
        b.getStatus =
            function() {
                return module$src$shared$util$GlobalUtils.default.deepCopy(a)
            };
        b.setStatus = function(c) {
            if (a !== c) {
                var d = b.pluginConstants.messageTopics.PLUGIN_FAILED;
                c === b.pluginConstants.pluginStatuses.FAILED ? d = b.pluginConstants.messageTopics.PLUGIN_FAILED : c === b.pluginConstants.pluginStatuses.LOADED ? d = b.pluginConstants.messageTopics.PLUGIN_LOADED : c === b.pluginConstants.pluginStatuses.ACTIVE ? d = b.pluginConstants.messageTopics.PLUGIN_ACTIVE : c === b.pluginConstants.pluginStatuses.UNLOADED && (d = b.pluginConstants.messageTopics.PLUGIN_UNLOADED);
                var f = new module$src$shared$messages$MessagePrototype.default(b.pluginConstants.messageDataTypes.PLUGIN_RUNTIME_ID, b.getRuntimeId());
                b.message(d, f);
                a = c
            }
        }
    }).call(this);
    this.getStatusDescription = function() {
        return {
            id: b.getRuntimeId(),
            status: b.getStatus(),
            name: b.getName(),
            shortName: b.getShortName()
        }
    };
    return this
};
var module$src$plugins$comm$CommPlugin = {},
    axios$$module$src$plugins$comm$CommPlugin = module$src$externals$axios.default,
    commPluginConstants$$module$src$plugins$comm$CommPlugin = module$src$plugins$comm$CommPluginConstants.default,
    pluginConstantsGlobal$$module$src$plugins$comm$CommPlugin = module$src$shared$constants$PluginConstantsGlobal.default,
    pluginPrototype$$module$src$plugins$comm$CommPlugin = module$src$plugins$PluginPrototype.default,
    messagingConstants$$module$src$plugins$comm$CommPlugin = module$src$shared$constants$MessagingConstants.default,
    loggingConstants$$module$src$plugins$comm$CommPlugin = module$src$shared$constants$LoggingConstants.default,
    GlobalUtils$$module$src$plugins$comm$CommPlugin = module$src$shared$util$GlobalUtils.default,
    MessagePrototype$$module$src$plugins$comm$CommPlugin = module$src$shared$messages$MessagePrototype.default;
module$src$plugins$comm$CommPlugin.default = function(a) {
    var b = this;
    module$src$plugins$PluginPrototype.default.call(this, module$src$shared$util$GlobalUtils.default.inject(module$src$plugins$comm$CommPluginConstants.default.defaultSettings, module$src$shared$util$GlobalUtils.default.deepCopy(a), !1));
    if (this.hasSetting("ticket")) {
        var c = {},
            d = [module$src$shared$constants$PluginConstantsGlobal.default.pluginCapabilities.SHAPEDIVER_MODEL_VIEW],
            e = function(a, c) {
                return (new q(a)).then(function(a) {
                    if (!a.hasOwnProperty("outputs")) return Promise.reject("Reply to customization request did not contain output member.");
                    var d = Object.keys(a.outputs),
                        e = [],
                        f = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.SUBSCENE_INIT, d.length, c);
                    b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.SCENE_SUBSCENE_INIT, f);
                    f = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_STATUS, {
                        state: module$src$shared$constants$MessagingConstants.default.messageTopics.SCENE_SUBSCENE_INIT,
                        progress: .25
                    }, c);
                    b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS, f);
                    f = {};
                    d = $jscomp.makeIterator(d);
                    for (var g = d.next(); !g.done; f = {
                            outputId: f.outputId
                        }, g = d.next()) f.outputId = g.value, g = (new Promise(function(b) {
                        return function(c, d) {
                            var e = a.outputs[b.outputId];
                            if (e.hasOwnProperty("content")) c(e);
                            else {
                                var f = e.version,
                                    g = function() {
                                        return p(b.outputId, f).then(function(a) {
                                            a.hasOwnProperty("outputs") && a.outputs.hasOwnProperty(b.outputId) ? (a = a.outputs[b.outputId], a.hasOwnProperty("version") &&
                                                a.version === f ? (a.hasOwnProperty("delay") && setTimeout(function() {
                                                    g()
                                                }, Math.max(100, parseInt(a.delay))), a.hasOwnProperty("content") && (a.id = b.outputId, c(a))) : d(Error("Invalid reply to cache request."))) : d(Error("Invalid reply to cache request."))
                                        })
                                    };
                                g()
                            }
                        }
                    }(f))).then(function(a) {
                        return function(d) {
                            d.id = a.outputId;
                            var e = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.SUBSCENE_OUTPUTVERSION_JSON, d, c);
                            b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.SCENE_SUBSCENE_OUTPUTVERSION,
                                e);
                            return d
                        }
                    }(f)), e.push(g);
                    return Promise.all(e)
                })
            },
            f = function(a, c, d) {
                var e = function() {
                    return (new m(a, c)).then(function(c) {
                        if (!c.hasOwnProperty("exports") || !c.exports.hasOwnProperty(a)) return Promise.reject("Unexpected reply to export request");
                        var f = c.exports[a];
                        return f.hasOwnProperty("delay") ? (c = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_STATUS, {
                            data: f
                        }, d), b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS,
                            c), c = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.EXPORT_STATUS, f, d), b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.EXPORT_STATUS, c), new Promise(function(a) {
                            setTimeout(function() {
                                a(e())
                            }, Math.max(1E3, parseInt(f.delay)))
                        })) : f
                    })
                };
                return e()
            },
            g = function() {
                return l().then(function(a) {
                    b.debug("CommPlugin.initSession", "Received session init reply", a);
                    if (a.hasOwnProperty("config")) {
                        var c = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.APP_SETTINGS,
                            a.config);
                        b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.SETTINGS_REGISTER, c)
                    }
                    a.hasOwnProperty("parameters") && (c = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PARAMETER_DEFINITION, a.parameters), a.hasOwnProperty("config") && c.addPart(module$src$shared$constants$MessagingConstants.default.messageDataTypes.APP_SETTINGS, a.config), b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.PARAMETER_REGISTER,
                        c));
                    a.hasOwnProperty("exports") && (a = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.EXPORT_DEFINITION, a.exports), b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.EXPORT_REGISTER, a));
                    b.getStatus() !== module$src$shared$constants$PluginConstantsGlobal.default.pluginStatuses.ACTIVE && b.setStatus(module$src$shared$constants$PluginConstantsGlobal.default.pluginStatuses.ACTIVE)
                }).catch(function(a) {
                    b.error("CommPlugin.initSession",
                        "Session init failed", a, b.getSetting("ticket"));
                    b.setStatus(module$src$shared$constants$PluginConstantsGlobal.default.pluginStatuses.FAILED)
                })
            },
            h = null,
            k = function(a, d, e, f) {
                var g = {
                    method: d,
                    url: a,
                    headers: {},
                    withCredentials: !1,
                    timeout: b.getSetting("ajaxTimeout")
                };
                e && (g.data = e);
                f && (g.headers["Content-Type"] = f);
                return (0, module$src$externals$axios.default)(g).then(function(a) {
                    a = a.data;
                    a.hasOwnProperty("msg") && delete a.msg;
                    if (a.hasOwnProperty("actions")) {
                        a.actions.forEach(function(a) {
                            a.hasOwnProperty("method") &&
                                a.hasOwnProperty("href") && a.hasOwnProperty("name") && (c[a.name] = a)
                        });
                        if (c.hasOwnProperty("default")) {
                            var d = c.default.href.replace("/default", "");
                            d !== h && (h = d, b.debug("CommPlugin.modelViewAjax", "Setting base URL to", h))
                        }
                        delete a.actions
                    }
                    a.hasOwnProperty("templates") && delete a.templates;
                    return a
                }, function(c) {
                    if (c.response) {
                        var g = !1,
                            m = "",
                            n = "";
                        switch (c.response.status) {
                            case 400:
                                g = !0;
                                m = "Invalid request";
                                break;
                            case 403:
                                g = !0;
                                m = "Invalid model identification";
                                break;
                            case 410:
                                return n = module$src$shared$util$GlobalUtils.default.deepCopy(h),
                                    l().then(function() {
                                        var b = a.replace(n, h);
                                        return k(b, d, e, f)
                                    }, function() {
                                        return Promise.reject(Error("Session expired and a new one could not be opened."))
                                    });
                            case 500:
                                g = !1;
                                m = "Internal server error";
                                break;
                            default:
                                g = !1, m = "Communication failed with HTTP status"
                        }
                        m += " (" + c.response.status + ")";
                        g ? (b.error("CommPlugin.modelViewAjax", "Fatal ajax request error: " + m, c), b.setStatus(module$src$shared$constants$PluginConstantsGlobal.default.pluginStatuses.FAILED)) : b.warn("CommPlugin.modelViewAjax", "Ajax request error: " +
                            m, c);
                        return Promise.reject(Error(m))
                    }
                    return c.request ? Promise.reject(Error("No response from model view interface.")) : Promise.reject(Error("Unknown error during AJAX request."))
                })
            },
            l = function() {
                var a = b.getSetting("modelViewUrl");
                return a ? k(a + "/ticket/" + b.getSetting("ticket"), "POST") : Promise.reject(Error("Base url not defined."))
            },
            p = function(a, b) {
                return new Promise(function(d, e) {
                    c.hasOwnProperty("cache") && c.cache.hasOwnProperty("method") && c.cache.hasOwnProperty("href") ? (e = {}, e[a] = b, d(k(c.cache.href,
                        c.cache.method, e, "application/json"))) : e(Error('Action "cache" is missing'))
                })
            },
            m = function(a, b) {
                return new Promise(function(d, e) {
                    c.hasOwnProperty("export") && c.customize.hasOwnProperty("method") && c.customize.hasOwnProperty("href") || e(Error('Action "export" is missing'));
                    d(k(c.export.href, c.export.method, {
                        exports: {
                            id: a
                        },
                        parameters: b
                    }, "application/json"))
                })
            },
            q = function(a) {
                return new Promise(function(b, d) {
                    c.hasOwnProperty("customize") && c.customize.hasOwnProperty("method") && c.customize.hasOwnProperty("href") ||
                        d(Error('Action "customize" is missing'));
                    b(k(c.customize.href, c.customize.method, a, "application/json"))
                })
            };
        this.getName = function() {
            return "ShapeDiver Communications Plugin"
        };
        this.getShortName = function() {
            return "CommPlugin"
        };
        this.getCapabilities = function() {
            var a = module$src$shared$util$GlobalUtils.default.deepCopy(d);
            c.hasOwnProperty("log") && a.push(module$src$shared$constants$PluginConstantsGlobal.default.pluginCapabilities.LOGGING);
            c.hasOwnProperty("configure") && a.push(module$src$shared$constants$PluginConstantsGlobal.default.pluginCapabilities.SETTINGS);
            c.hasOwnProperty("defaultparam") && a.push(module$src$shared$constants$PluginConstantsGlobal.default.pluginCapabilities.DEFAULTPARAM);
            return a
        };
        this.getMessageCallbacks = function() {
            return {}
        };
        this.load = function(a) {
            b.updateSettings(a);
            g();
            b.debug("CommPlugin.load", 'Loaded plugin "' + b.getName() + '" with capabilities ' + JSON.stringify(b.getCapabilities()) + " and runtime id " + b.getRuntimeId());
            b.setStatus(module$src$shared$constants$PluginConstantsGlobal.default.pluginStatuses.LOADED);
            return !0
        };
        this.logToServer =
            function() {
                var a = 1 === arguments.length ? [arguments[0]] : Array.apply(null, arguments),
                    d = a[0] & module$src$shared$constants$LoggingConstants.default.loggingLevels.LVLBITS,
                    e = a[1],
                    f = a.slice(2);
                0 < f.length && "string" === typeof f[0] && (e += ": " + f[0], f = f.slice(1));
                return new Promise(function(a, g) {
                    c.hasOwnProperty("log") && c.log.hasOwnProperty("method") && c.log.hasOwnProperty("href") || g(Error("CommPlugin.logToServer: Session did not provide log action"));
                    var h = {
                        level: 2 - Math.min(Math.max(d, 2), 0),
                        message: e
                    };
                    1 === f.length ?
                        h.err = f[0] : 1 < f.length && (h.err = {
                            messages: f
                        });
                    k(c.log.href, c.log.method, h, "application/json").then(function(b) {
                        a(b)
                    }, function(a) {
                        a = "CommPlugin.logToServer: Log message rejected by server " + b.jsify(a);
                        g(Error(a))
                    })
                })
            };
        this.setParameterValue = function() {
            b.warn("CommPlugin.setParameterValue", "Not supported");
            return module$src$shared$constants$PluginConstantsGlobal.default.setParameterResults.ERROR
        };
        this.setMultipleParameterValues = function() {
            b.warn("CommPlugin.setMultipleParameterValues", "Not supported");
            return module$src$shared$constants$PluginConstantsGlobal.default.setParameterResults.ERROR
        };
        this.setAllParameterValues = function(a, c) {
            if (b.getStatus() !== module$src$shared$constants$PluginConstantsGlobal.default.pluginStatuses.ACTIVE) return a = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_ERROR, "Plugin not active", c), b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS, a), module$src$shared$constants$PluginConstantsGlobal.default.setParameterResults.ERROR;
            e(a, c).catch(function(a) {
                a = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_ERROR, a, c);
                b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS, a)
            });
            return module$src$shared$constants$PluginConstantsGlobal.default.setParameterResults.LOAD
        };
        this.requestExport = function(a, c, d) {
            if (b.getStatus() !== module$src$shared$constants$PluginConstantsGlobal.default.pluginStatuses.ACTIVE) return a = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_ERROR,
                "Plugin not active", d), b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS, a), module$src$shared$constants$PluginConstantsGlobal.default.setParameterResults.ERROR;
            f(a, c, d).then(function(a) {
                var c = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.EXPORT_RESULT, a, d);
                b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.EXPORT_AVAILABLE, c);
                c = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_SUCCESS,
                    "Export available", d);
                c.addPart(module$src$shared$constants$MessagingConstants.default.messageDataTypes.EXPORT_RESULT, a);
                b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS, c)
            }, function(a) {
                a = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_ERROR, a, d);
                b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS, a)
            });
            b.debug("CommPlugin.requestExport", "Called with export " +
                a + ", kvps " + b.jsify(c) + ", token " + b.jsify(d));
            return b.pluginConstants.requestExportResults.LOAD
        };
        this.registerHook("modelViewUrl", function() {
            return !1
        });
        this.registerHook("ticket", function() {
            return !1
        });
        this.setStatus(module$src$shared$constants$PluginConstantsGlobal.default.pluginStatuses.READY)
    } else b.error("CommPlugin.CommPlugin", "Plugin was initialized without a ticket."), b.setStatus(module$src$shared$constants$PluginConstantsGlobal.default.pluginStatuses.FAILED)
};
var module$node_modules$pubsub_js$src$pubsub = {
        default: {}
    },
    root$$module$node_modules$pubsub_js$src$pubsub = "object" === typeof window && window || this,
    factory$$module$node_modules$pubsub_js$src$pubsub = function(a) {
        function b(a) {
            for (var b in a)
                if (a.hasOwnProperty(b)) return !0;
            return !1
        }

        function c(a) {
            return function() {
                throw a;
            }
        }

        function d(a, b, d) {
            try {
                a(b, d)
            } catch (r) {
                setTimeout(c(r), 0)
            }
        }

        function e(a, b, c) {
            a(b, c)
        }

        function f(a, b, c, f) {
            var g = k[b];
            f = f ? e : d;
            var h;
            if (k.hasOwnProperty(b))
                for (h in g) g.hasOwnProperty(h) &&
                    f(g[h], a, c)
        }

        function g(a, b, c) {
            return function() {
                var d = String(a),
                    e = d.lastIndexOf(".");
                for (f(a, a, b, c); - 1 !== e;) d = d.substr(0, e), e = d.lastIndexOf("."), f(a, d, b, c)
            }
        }

        function h(a, c, d, e) {
            c = g(a, c, e);
            a = String(a);
            e = !(!k.hasOwnProperty(a) || !b(k[a]));
            for (var f = a.lastIndexOf("."); !e && -1 !== f;) a = a.substr(0, f), f = a.lastIndexOf("."), e = !(!k.hasOwnProperty(a) || !b(k[a]));
            if (!e) return !1;
            !0 === d ? c() : setTimeout(c, 0);
            return !0
        }
        var k = {},
            l = -1;
        a.publish = function(b, c) {
            return h(b, c, !1, a.immediateExceptions)
        };
        a.publishSync = function(b,
            c) {
            return h(b, c, !0, a.immediateExceptions)
        };
        a.subscribe = function(a, b) {
            if ("function" !== typeof b) return !1;
            k.hasOwnProperty(a) || (k[a] = {});
            var c = "uid_" + String(++l);
            k[a][c] = b;
            return c
        };
        a.subscribeOnce = function(b, c) {
            var d = a.subscribe(b, function() {
                a.unsubscribe(d);
                c.apply(this, arguments)
            });
            return a
        };
        a.clearAllSubscriptions = function() {
            k = {}
        };
        a.clearSubscriptions = function(a) {
            for (var b in k) k.hasOwnProperty(b) && 0 === b.indexOf(a) && delete k[b]
        };
        a.unsubscribe = function(b) {
            var c;
            if ((c = "string" === typeof b) && !(c = k.hasOwnProperty(b))) a: {
                for (var d in k)
                    if (k.hasOwnProperty(d) &&
                        0 === d.indexOf(b)) {
                        c = !0;
                        break a
                    }
                c = !1
            }
            var e = c;
            d = !e && "string" === typeof b;
            c = "function" === typeof b;
            var f = !1,
                g, h;
            if (e) a.clearSubscriptions(b);
            else {
                for (g in k)
                    if (k.hasOwnProperty(g)) {
                        e = k[g];
                        if (d && e[b]) {
                            delete e[b];
                            f = b;
                            break
                        }
                        if (c)
                            for (h in e) e.hasOwnProperty(h) && e[h] === b && (delete e[h], f = !0)
                    }
                return f
            }
        }
    },
    PubSub$$module$node_modules$pubsub_js$src$pubsub = {};
root$$module$node_modules$pubsub_js$src$pubsub.PubSub = PubSub$$module$node_modules$pubsub_js$src$pubsub;
var define$$module$node_modules$pubsub_js$src$pubsub = root$$module$node_modules$pubsub_js$src$pubsub.define;
factory$$module$node_modules$pubsub_js$src$pubsub(PubSub$$module$node_modules$pubsub_js$src$pubsub);
module$node_modules$pubsub_js$src$pubsub.default && (module$node_modules$pubsub_js$src$pubsub.default = PubSub$$module$node_modules$pubsub_js$src$pubsub);
module$node_modules$pubsub_js$src$pubsub.default.PubSub = PubSub$$module$node_modules$pubsub_js$src$pubsub;
module$node_modules$pubsub_js$src$pubsub.default = exports = PubSub$$module$node_modules$pubsub_js$src$pubsub;
var module$src$app$partials$ViewerAppLoggingPartial = {},
    viewerAppConstants$$module$src$app$partials$ViewerAppLoggingPartial = module$src$app$ViewerAppConstants.default;
module$src$app$partials$ViewerAppLoggingPartial.default = function() {
    var a = this;
    this.subscribeToLogStream = function(a, b, c) {
        if (!Array.isArray(a)) {
            for (var d = [], e = 0; e <= a; e++) d.push(e);
            a = d
        }
        Array.isArray(b) || (b = [b]);
        var f = [];
        a.forEach(function(a) {
            b.forEach(function(b) {
                var d = a.toString();
                0 < b.length && (d += "." + b);
                f.push(module$node_modules$pubsub_js$src$pubsub.default.subscribe(d, c))
            })
        });
        return f
    };
    this.unsubscribeFromLogStream = function(a) {
        a.forEach(function(a) {
            module$node_modules$pubsub_js$src$pubsub.default.unsubscribe(a)
        })
    };
    var b = function(b, c) {
            var d = Number(b.slice(0, 1));
            b = b.slice(2);
            a.logToConsole.apply(a, [d, b].concat($jscomp.arrayFromIterable(c)))
        },
        c = this.subscribeToLogStream(a.getSetting("loggingLevel"), "", b);
    this.log = function() {
        var a = 1 === arguments.length ? [arguments[0]] : Array.apply(null, arguments),
            b = a[0],
            c = a[1];
        a = a.slice(2);
        b = b.toString();
        "string" === typeof c && 0 < c.length && (b += "." + c);
        module$node_modules$pubsub_js$src$pubsub.default.publish(b, [].concat($jscomp.arrayFromIterable(a)))
    };
    this.registerHook("loggingLevel",
        function(d) {
            a.unsubscribeFromLogStream(c);
            c = a.subscribeToLogStream(d, "", b);
            a.log(module$src$app$ViewerAppConstants.default.loggingLevels.DEBUG, "ViewerApp.loggingLevelUpdateHook", "loggingLevel set from " + a.getLoggingLevelName(a.getSetting("loggingLevel")) + " to " + a.getLoggingLevelName(d));
            return !0
        })
};
var module$src$app$partials$ViewerAppMessagingPartial = {},
    GlobalUtils$$module$src$app$partials$ViewerAppMessagingPartial = module$src$shared$util$GlobalUtils.default,
    messagingConstants$$module$src$app$partials$ViewerAppMessagingPartial = module$src$shared$constants$MessagingConstants.default;
module$src$app$partials$ViewerAppMessagingPartial.default = function() {
    var a = this;
    this.message = function(b, c) {
        b = b === module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS && c.token && c.token.id ? b + "." + c.token.id : b;
        a.messageToPubSub(b, c, module$node_modules$pubsub_js$src$pubsub.default, {});
        a.messageToLog(b, c)
    };
    this.subscribeToMessageStream = function(a, c) {
        Array.isArray(a) || (a = [a]);
        var b = [];
        a.forEach(function(a) {
            b.push(module$node_modules$pubsub_js$src$pubsub.default.subscribe(a, c))
        });
        return b
    };
    this.unsubscribeFromMessageStream = function(a) {
        Array.isArray(a) || (a = [a]);
        var b = !0;
        a.forEach(function(a) {
            module$node_modules$pubsub_js$src$pubsub.default.unsubscribe(a) || (b = !1)
        });
        return b
    };
    this.setupDispatching = function(b) {
        var c = [];
        Object.keys(b).forEach(function(d) {
            var e = b[d].partListeners;
            d = a.subscribeToMessageStream(d, function(b, c) {
                Array.isArray(c.parts) || (c.parts = [], a.warn("ViewerAppMessagingPartial.setupDispatching", "Message without data parts: " + JSON.stringify(c, null, 0)));
                c.parts.forEach(function(d) {
                    e.forEach(function(e) {
                        if (d.type ===
                            e.type && "string" === typeof e.cb && 0 < e.cb.length) {
                            var f = module$src$shared$util$GlobalUtils.default.getAt(a, e.cb.split("."));
                            if ("function" === typeof f) {
                                var g = [];
                                g = Array.isArray(e.params) ? e.params.map(function(a) {
                                    if ("type" === a) return d.type;
                                    if ("data" === a) return d.data;
                                    if ("token" === a) return c.token;
                                    if ("origin" === a) return c.origin;
                                    if ("topic" === a) return b;
                                    if ("plugin" === a) return c.origin.plugin
                                }) : [c.token, d.data, d.type, c.origin];
                                f = Promise.resolve(f.apply(a, g));
                                f.then(function(b) {
                                    !1 === b && a.debug("ViewerAppMessagingPartial.setupDispatching",
                                        "Message callback returned false", e, g)
                                });
                                f.catch(function(b) {
                                    a.error("ViewerAppMessagingPartial.setupDispatching", "Error in message callback: " + b.message, b, e, g)
                                })
                            }
                        }
                    })
                })
            });
            c = c.concat(d)
        });
        return c
    }
};
var module$src$app$partials$ViewerAppPluginManager = {},
    pluginConstants$$module$src$app$partials$ViewerAppPluginManager = module$src$plugins$PluginConstants.default,
    MessagePrototype$$module$src$app$partials$ViewerAppPluginManager = module$src$shared$messages$MessagePrototype.default;
module$src$app$partials$ViewerAppPluginManager.default = function() {
    var a = this,
        b = {},
        c = [],
        d = [];
    b.getStatusDescription = function() {
        var a = [];
        c.forEach(function(b) {
            a.push(b.getStatusDescription())
        });
        return a
    };
    b.registerPlugin = function(e) {
        if (e.getStatus() !== module$src$plugins$PluginConstants.default.pluginStatuses.READY) a.error("ViewerAppPluginManager.registerPlugin", "Unexpected plugin status before loading: " + e.getStatus());
        else {
            var f = e.getRuntimeId();
            if (void 0 !== b.getPluginByRuntimeId(f)) a.error("ViewerAppPluginManager.registerPlugin",
                "Plugin with runtime id " + f + " already loaded");
            else {
                e.log = function() {
                    var b = 1 === arguments.length ? [arguments[0]] : Array.apply(null, arguments),
                        c = b[0],
                        d = b[1];
                    b = b.slice(2);
                    d = e.getShortName() + "." + f + "." + d;
                    a.log.apply(a, [c, d].concat($jscomp.arrayFromIterable(b)))
                };
                e.message = function(b, c) {
                    if (void 0 === c.origin || "object" !== typeof c.origin) c.origin = {};
                    c.origin.plugin = f;
                    void 0 !== c.token && "object" === typeof c.token && void 0 === c.token.creator && (c.token.creator = {
                        plugin: f
                    });
                    a.message(b, c)
                };
                e.app = {
                    api: a.api
                };
                var g = e.getCapabilities();
                g.includes(module$src$plugins$PluginConstants.default.pluginCapabilities.INTERACTIVE) && (e.app.threeDManager = a.threeDManager);
                g.includes(module$src$plugins$PluginConstants.default.pluginCapabilities.DRAGANDDROP) && (e.app.threeDManager = a.threeDManager);
                var l = [];
                if (g.includes(module$src$plugins$PluginConstants.default.pluginCapabilities.MESSAGECALLBACKS) && a.subscribeToMessageStream) {
                    g = e.getMessageCallbacks();
                    for (var p in g) {
                        var m = a.subscribeToMessageStream(p, g[p]);
                        l = l.concat(m)
                    }
                }
                if (e.load({
                        loggingLevel: a.getSetting("loggingLevel")
                    }))
                    if (e.getStatus() !==
                        module$src$plugins$PluginConstants.default.pluginStatuses.LOADED && e.getStatus() !== module$src$plugins$PluginConstants.default.pluginStatuses.ACTIVE) a.error("ViewerAppPluginManager.registerPlugin", "Unexpected plugin status after loading: " + e.getStatus());
                    else return a.message(module$src$plugins$PluginConstants.default.messageTopics.PLUGIN_REGISTERED, new module$src$shared$messages$MessagePrototype.default(module$src$plugins$PluginConstants.default.messageDataTypes.PLUGIN_RUNTIME_ID, f)), a.info("ViewerAppPluginManager.registerPlugin",
                        'Registered plugin "' + e.getName() + '" with capabilities ' + JSON.stringify(e.getCapabilities()) + " and runtime id " + e.getRuntimeId()), c.push(e), d.push(l), f;
                else a.error("ViewerAppPluginManager.registerPlugin", 'Failed to load plugin "' + e.getName() + '" with runtime id ' + f)
            }
        }
    };
    b.deregisterPlugin = function(b) {
        var e = c.findIndex(function(a) {
            return a.getRuntimeId() === b
        });
        if (-1 === e) return a.error("ViewerAppPluginManager.deregisterPlugin", "Plugin with runtimeId " + b + " not found"), !1;
        a.unsubscribeFromMessageStream &&
            a.unsubscribeFromMessageStream(d[e]);
        var f = c.splice(e, 1)[0];
        d.splice(e, 1);
        a.info("ViewerAppPluginManager.deregisterPlugin", 'Deregistered plugin "' + f.getName() + '" with capabilities ' + JSON.stringify(f.getCapabilities()) + " and runtime id " + f.getRuntimeId());
        return !0
    };
    b.getPluginByRuntimeId = function(a) {
        return c.find(function(b) {
            return b.getRuntimeId() === a
        })
    };
    b.getPluginByName = function(a) {
        return c.find(function(b) {
            return b.getName() === a
        })
    };
    b.getPluginByShortName = function(a) {
        return c.find(function(b) {
            return b.getShortName() ===
                a
        })
    };
    var e = 999,
        f = function(b, d) {
            var g = b.indexOf("."),
                h = Number(b.slice(0, g)) & module$src$plugins$PluginConstants.default.loggingLevels.LVLBITS;
            g = b.slice(g + 1);
            var p = c.find(function(a) {
                return a.getCapabilities().includes(module$src$plugins$PluginConstants.default.pluginCapabilities.LOGGING)
            });
            p ? (a.debug("ViewerAppPluginManager._logToServer", "Logging to server", a.jsify({
                loggingLevel: h,
                scope: g,
                data: d
            })), Array.isArray(d) || (d = [d]), p.logToServer.apply(p, [h, g].concat($jscomp.arrayFromIterable(d))).catch(function(b) {
                a.warn("ViewerAppPluginManager._logToServer",
                    b)
            }), e = 999) : (a.debug("ViewerAppPluginManager._logToServer", "Delaying logging to server by " + e + "msec", a.jsify({
                loggingLevel: h,
                scope: g,
                data: d
            })), setTimeout(f, e, b, d), e *= 2)
        };
    "function" === typeof a.subscribeToLogStream && a.subscribeToLogStream([module$src$plugins$PluginConstants.default.loggingLevels.ERROR_S, module$src$plugins$PluginConstants.default.loggingLevels.WARN_S, module$src$plugins$PluginConstants.default.loggingLevels.INFO_S, module$src$plugins$PluginConstants.default.loggingLevels.DEBUG_S], "", f);
    return b
};
var module$src$shared$exceptions$MissingImplementationException = {
    default: function() {}
};
module$src$shared$exceptions$MissingImplementationException.default.prototype.toString = function() {
    return "Missing implementation"
};
var module$src$shared$interfaces$ParameterInterface = {},
    MissingImplementationException$$module$src$shared$interfaces$ParameterInterface = module$src$shared$exceptions$MissingImplementationException.default;
module$src$shared$interfaces$ParameterInterface.default = function() {
    this.setValue = function() {
        throw new module$src$shared$exceptions$MissingImplementationException.default;
    };
    this.parseValue = function() {
        throw new module$src$shared$exceptions$MissingImplementationException.default;
    };
    this.getValue = function() {
        throw new module$src$shared$exceptions$MissingImplementationException.default;
    };
    this.getValueString = function() {
        throw new module$src$shared$exceptions$MissingImplementationException.default;
    };
    this.checkValue =
        function() {
            throw new module$src$shared$exceptions$MissingImplementationException.default;
        };
    this.isValid = function() {
        throw new module$src$shared$exceptions$MissingImplementationException.default;
    };
    this.getDefinition = function() {
        throw new module$src$shared$exceptions$MissingImplementationException.default;
    }
};
var module$src$shared$types$ShapeDiverParameters = {
        default: {}
    },
    GlobalUtils$$module$src$shared$types$ShapeDiverParameters = module$src$shared$util$GlobalUtils.default,
    toTinyColor$$module$src$shared$types$ShapeDiverParameters = module$src$shared$util$toTinyColor.default,
    defaultSettings$$module$src$shared$types$ShapeDiverParameters = {
        strictMode: !0
    },
    CommonParameter$$module$src$shared$types$ShapeDiverParameters = function(a) {
        var b = this;
        module$src$shared$mixins$GlobalMixin.default.call(this);
        module$src$shared$interfaces$ParameterInterface.default.call(this);
        var c = function(a, b) {
            return Array.isArray(a) && "array" === b || typeof a === b ? !0 : !1
        };
        void 0 === a || "object" !== typeof a ? a = defaultSettings$$module$src$shared$types$ShapeDiverParameters : (a = module$src$shared$util$GlobalUtils.default.deepCopy(a), module$src$shared$util$GlobalUtils.default.defaults(a, defaultSettings$$module$src$shared$types$ShapeDiverParameters));
        void 0 === a.isValid && (a.isValid = !0);
        if (void 0 === a.name || "string" !== typeof a.name || 0 === a.name.length) a.name = "Generic parameter";
        if (void 0 === a.valuetype ||
            "string" !== typeof a.valuetype || 0 === a.valuetype.length) void 0 !== a.defval ? Array.isArray(a.defval) ? a.valuetype = "array" : a.valuetype = typeof a.defval : (a.valuetype = "number", a.isValid = !1);
        void 0 !== a.defval && c(a.defval, a.valuetype) || (a.defval = 0, a.isValid = !1);
        void 0 === a.value ? a.value = a.defval : c(a.value, a.valuetype) || (a.isValid = !1);
        module$src$shared$mixins$SettingsMixin.default.call(this, a);
        this.registerHook("valuetype", function() {
            return !1
        });
        this.registerHook("defval", function(a) {
            return b.checkValue(a)
        });
        this.registerHook("value",
            function(a) {
                return b.checkValue(a)
            });
        this.registerHook("isValid", function() {
            return !1
        });
        module$src$shared$mixins$LoggingMixin.default.call(this);
        this.isValid = function() {
            return b.getSetting("isValid")
        };
        this.checkValue = function(a) {
            return c(a, b.getSettingShallow("valuetype"))
        };
        this.setValue = function(a) {
            return b.updateSetting("value", a)
        };
        this.getValue = function() {
            return b.getSetting("value")
        };
        this.getValueString = function() {
            return b.getValue().toString()
        };
        this.parseValue = function(a) {
            if ("string" !== typeof a) return !1;
            var c = b.getSettingShallow("valuetype");
            if ("string" === c) return b.setValue(a);
            if ("number" === c) return b.setValue(parseFloat(a));
            if ("boolean" === c) return "false" === a.toLowerCase() ? b.setValue(!1) : b.setValue(!!a);
            if ("object" === c || "array" === c) try {
                return b.setValue(JSON.Parse(a))
            } catch (f) {
                return b.debug("CommonParameter.parseValue", f), !1
            } else return !1
        };
        this.isValueDifferent = function(a) {
            var c = b.getSettingShallow("valuetype"),
                d = b.getSettingShallow("value");
            return "array" === c || "object" === c ? (c = JSON.stringify(d,
                null, 0), a = JSON.stringify(a, null, 0), c !== a) : d !== a
        };
        b.toString = function() {
            var a = 'Parameter "' + b.getSetting("name") + '"';
            return a += "\n\tsettings: " + JSON.stringify(b.getSettings(), null, 0)
        };
        return this
    };
module$src$shared$types$ShapeDiverParameters.default.CommonParameter = CommonParameter$$module$src$shared$types$ShapeDiverParameters;
var FloatParameter$$module$src$shared$types$ShapeDiverParameters = function(a) {
    var b = this;
    void 0 === a || "object" !== typeof a ? a = defaultSettings$$module$src$shared$types$ShapeDiverParameters : (a = module$src$shared$util$GlobalUtils.default.deepCopy(a), module$src$shared$util$GlobalUtils.default.defaults(a, defaultSettings$$module$src$shared$types$ShapeDiverParameters));
    void 0 === a.isValid && (a.isValid = !0);
    "boolean" !== typeof a.strictMode || a.strictMode || (["decimalplaces"].forEach(function(b) {
        "string" === typeof a[b] &&
            (a[b] = parseInt(a[b]))
    }), ["min", "max", "defval", "value"].forEach(function(b) {
        "string" === typeof a[b] && (a[b] = parseFloat(a[b]))
    }));
    if (void 0 === a.name || "string" !== typeof a.name || 0 === a.name.length) a.name = "Float parameter";
    a.valuetype = "number";
    if (void 0 === a.decimalplaces || "number" !== typeof a.decimalplaces || 0 > a.decimalplaces) a.decimalplaces = 20;
    if (void 0 === a.min || "number" !== typeof a.min) a.min = -Number.MAX_VALUE;
    if (void 0 === a.max || "number" !== typeof a.max) a.max = Number.MAX_VALUE;
    a.min > a.max && (a.min = a.max, a.isValid = !1);
    if (void 0 === a.defval || "number" !== typeof a.defval || a.defval < a.min || a.defval > a.max) a.defval = a.min, a.isValid = !1;
    if (void 0 === a.value || "number" !== typeof a.value || a.value < a.min || a.value > a.max) a.value = a.defval;
    CommonParameter$$module$src$shared$types$ShapeDiverParameters.call(this, a);
    this.registerHook("decimalplaces", function() {
        return !1
    });
    this.registerHook("min", function(a) {
        return b.getSettingShallow("value") >= a ? !0 : !1
    });
    this.registerHook("max", function(a) {
        return b.getSettingShallow("value") <= a ? !0 : !1
    });
    var c = this.setValue;
    this.setValue = function(a) {
        "string" !== typeof a || b.getSettingShallow("strictMode") || (a = parseFloat(a));
        if ("number" !== typeof a) return !1;
        var d = a,
            e = b.getSettingShallow("decimalplaces");
        e < Number.MAX_SAFE_INTEGER && (d = parseFloat(a.toFixed(e)));
        return c(d)
    };
    this.getValueString = function() {
        var a = b.getSettingShallow("decimalplaces");
        return a < Number.MAX_SAFE_INTEGER ? b.getValue().toFixed(a) : b.getValue()
    };
    var d = this.checkValue;
    this.checkValue = function(a) {
        "string" !== typeof a || b.getSettingShallow("strictMode") ||
            (a = parseFloat(a));
        return d(a) ? a >= b.getSettingShallow("min") && a <= b.getSettingShallow("max") : !1
    };
    this.getDefinition = function() {
        return b.getSettings("id name plugin note type decimalplaces defval group max min visualization _name order hidden".split(" "))
    };
    return this
};
module$src$shared$types$ShapeDiverParameters.default.FloatParameter = FloatParameter$$module$src$shared$types$ShapeDiverParameters;
var IntegerParameter$$module$src$shared$types$ShapeDiverParameters = function(a) {
    void 0 === a || "object" !== typeof a ? a = defaultSettings$$module$src$shared$types$ShapeDiverParameters : (a = module$src$shared$util$GlobalUtils.default.deepCopy(a), module$src$shared$util$GlobalUtils.default.defaults(a, defaultSettings$$module$src$shared$types$ShapeDiverParameters));
    void 0 === a.isValid && (a.isValid = !0);
    "boolean" !== typeof a.strictMode || a.strictMode || ["decimalplaces", "min", "max", "defval", "value"].forEach(function(b) {
        "string" ===
        typeof a[b] && (a[b] = parseInt(a[b]))
    });
    if (void 0 === a.name || "string" !== typeof a.name || 0 === a.name.length) a.name = "Integer parameter";
    void 0 === a.decimalplaces && (a.decimalplaces = 0);
    if ("number" !== typeof a.decimalplaces || 0 !== a.decimalplaces) a.decimalplaces = 0, a.isValid = !1;
    if (void 0 === a.min || "number" !== typeof a.min) a.min = Number.MIN_SAFE_INTEGER;
    if (void 0 === a.max || "number" !== typeof a.max) a.max = Number.MAX_SAFE_INTEGER;
    a.min > a.max && (a.min = a.max, a.isValid = !1);
    if (void 0 === a.defval || "number" !== typeof a.defval || a.defval <
        a.min || a.defval > a.max || Math.round(a.defval) !== a.defval) a.defval = a.min, a.isValid = !1;
    if (void 0 === a.value || "number" !== typeof a.value || a.value < a.min || a.value > a.max || Math.round(a.value) !== a.value) a.value = a.defval;
    FloatParameter$$module$src$shared$types$ShapeDiverParameters.call(this, a);
    return this
};
module$src$shared$types$ShapeDiverParameters.default.IntegerParameter = IntegerParameter$$module$src$shared$types$ShapeDiverParameters;
var EvenIntegerParameter$$module$src$shared$types$ShapeDiverParameters = function(a) {
    void 0 === a || "object" !== typeof a ? a = defaultSettings$$module$src$shared$types$ShapeDiverParameters : (a = module$src$shared$util$GlobalUtils.default.deepCopy(a), module$src$shared$util$GlobalUtils.default.defaults(a, defaultSettings$$module$src$shared$types$ShapeDiverParameters));
    void 0 === a.isValid && (a.isValid = !0);
    "boolean" !== typeof a.strictMode || a.strictMode || ["decimalplaces", "min", "max", "defval", "value"].forEach(function(b) {
        "string" ===
        typeof a[b] && (a[b] = parseInt(a[b]))
    });
    if (void 0 === a.name || "string" !== typeof a.name || 0 === a.name.length) a.name = "Even integer parameter";
    if (void 0 === a.min || "number" !== typeof a.min) a.min = Number.MIN_SAFE_INTEGER;
    if (void 0 === a.max || "number" !== typeof a.max) a.max = Number.MAX_SAFE_INTEGER;
    a.min > a.max && (a.min = a.max, a.isValid = !1);
    if (void 0 === a.defval || "number" !== typeof a.defval || a.defval < a.min || a.defval > a.max || 0 !== a.defval % 2) a.defval = a.min, a.isValid = !1;
    if (void 0 === a.value || "number" !== typeof a.value || a.value < a.min ||
        a.value > a.max || 0 !== a.value % 2) a.value = a.defval;
    IntegerParameter$$module$src$shared$types$ShapeDiverParameters.call(this, a);
    var b = this.checkValue;
    this.checkValue = function(a) {
        return b(a) ? 0 === a % 2 : !1
    };
    return this
};
module$src$shared$types$ShapeDiverParameters.default.EvenIntegerParameter = EvenIntegerParameter$$module$src$shared$types$ShapeDiverParameters;
var OddIntegerParameter$$module$src$shared$types$ShapeDiverParameters = function(a) {
    void 0 === a || "object" !== typeof a ? a = defaultSettings$$module$src$shared$types$ShapeDiverParameters : (a = module$src$shared$util$GlobalUtils.default.deepCopy(a), module$src$shared$util$GlobalUtils.default.defaults(a, defaultSettings$$module$src$shared$types$ShapeDiverParameters));
    void 0 === a.isValid && (a.isValid = !0);
    "boolean" !== typeof a.strictMode || a.strictMode || ["decimalplaces", "min", "max", "defval", "value"].forEach(function(b) {
        "string" ===
        typeof a[b] && (a[b] = parseInt(a[b]))
    });
    if (void 0 === a.name || "string" !== typeof a.name || 0 === a.name.length) a.name = "Even integer parameter";
    if (void 0 === a.min || "number" !== typeof a.min) a.min = Number.MIN_SAFE_INTEGER;
    if (void 0 === a.max || "number" !== typeof a.max) a.max = Number.MAX_SAFE_INTEGER;
    a.min > a.max && (a.min = a.max, a.isValid = !1);
    if (void 0 === a.defval || "number" !== typeof a.defval || a.defval < a.min || a.defval > a.max || 1 !== Math.abs(a.defval % 2)) a.defval = a.min, a.isValid = !1;
    if (void 0 === a.value || "number" !== typeof a.value ||
        a.value < a.min || a.value > a.max || 1 !== Math.abs(a.value % 2)) a.value = a.defval;
    IntegerParameter$$module$src$shared$types$ShapeDiverParameters.call(this, a);
    var b = this.checkValue;
    this.checkValue = function(a) {
        return b(a) ? 1 === Math.abs(a % 2) : !1
    };
    return this
};
module$src$shared$types$ShapeDiverParameters.default.OddIntegerParameter = OddIntegerParameter$$module$src$shared$types$ShapeDiverParameters;
var ValueListParameter$$module$src$shared$types$ShapeDiverParameters = function(a) {
    var b = this;
    void 0 === a || "object" !== typeof a ? a = defaultSettings$$module$src$shared$types$ShapeDiverParameters : (a = module$src$shared$util$GlobalUtils.default.deepCopy(a), module$src$shared$util$GlobalUtils.default.defaults(a, defaultSettings$$module$src$shared$types$ShapeDiverParameters));
    void 0 === a.isValid && (a.isValid = !0);
    "boolean" !== typeof a.strictMode || a.strictMode || ["defval"].forEach(function(b) {
        "string" === typeof a[b] &&
            (a[b] = parseInt(a[b]))
    });
    if (void 0 === a.name || "string" !== typeof a.name || 0 === a.name.length) a.name = "Value list parameter";
    void 0 !== a.choices && Array.isArray(a.choices) || (a.choices = [], a.isValid = !1);
    a.min = 0;
    a.max = a.choices.length - 1;
    if (void 0 === a.defval || "number" !== typeof a.defval || a.defval < a.min || a.defval > a.max) a.defval = a.min, a.isValid = !1;
    IntegerParameter$$module$src$shared$types$ShapeDiverParameters.call(this, a);
    this.registerHook("min", function() {
        return !1
    });
    this.registerHook("max", function() {
        return !1
    });
    this.registerHook("choices", function() {
        return !1
    });
    this.getChoices = function() {
        return b.getSetting("choices")
    };
    this.getSelectedChoice = function() {
        return b.getSetting("choices")[b.getSettingShallow("value")]
    };
    this.getDefinition = function() {
        return b.getSettings("id name plugin note type choices defval group visualization".split(" "))
    };
    return this
};
module$src$shared$types$ShapeDiverParameters.default.ValueListParameter = ValueListParameter$$module$src$shared$types$ShapeDiverParameters;
var MultipleChoiceParameter$$module$src$shared$types$ShapeDiverParameters = function(a) {
    var b = this,
        c = function(a, c, d) {
            void 0 === d && (d = !0);
            if ("string" === typeof a && !d)
                if (!a.startsWith("[") && a.includes(",")) try {
                    a = JSON.parse("[" + a + "]")
                } catch (l) {
                    b.debug("MultipleChoiceParameter._checkValue", l);
                    return
                } else if (a = parseInt(a), isNaN(a)) return;
            if ("number" === typeof a) {
                if (0 <= a && a <= c) return [a]
            } else if (Array.isArray(a)) {
                var e = [];
                if (a.every(function(b, f) {
                        if ("string" === typeof b && !d) {
                            b = parseInt(b);
                            if (!isNaN(b)) return !1;
                            a[f] = b
                        }
                        return "number" === typeof b && 0 <= b && b <= c && -1 === e.indexOf(b) ? (e.push(b), !0) : !1
                    })) return e
            }
        };
    void 0 === a || "object" !== typeof a ? a = defaultSettings$$module$src$shared$types$ShapeDiverParameters : (a = module$src$shared$util$GlobalUtils.default.deepCopy(a), module$src$shared$util$GlobalUtils.default.defaults(a, defaultSettings$$module$src$shared$types$ShapeDiverParameters));
    void 0 === a.isValid && (a.isValid = !0);
    var d = !0;
    "boolean" !== typeof a.strictMode || a.strictMode || (d = !1);
    if (void 0 === a.name || "string" !== typeof a.name ||
        0 === a.name.length) a.name = "Multiple value list parameter";
    void 0 !== a.choices && Array.isArray(a.choices) || (a.choices = [], a.isValid = !1);
    a.min = 0;
    a.max = a.choices.length - 1;
    "string" === typeof a.defval && !d || void 0 !== a.defval && ("number" === typeof a.defval || Array.isArray(a.defval)) ? (a.defval = c(a.defval, a.max, d), void 0 === a.defval && (a.defval = [], a.isValid = !1)) : (a.defval = [], a.isValid = !1);
    void 0 === a.value && (a.value = a.defval);
    "number" === typeof a.value || Array.isArray(a.value) ? (a.value = c(a.value, a.max, d), void 0 === a.value &&
        (a.value = a.defval, a.isValid = !1)) : (a.value = a.defval, a.isValid = !1);
    CommonParameter$$module$src$shared$types$ShapeDiverParameters.call(this, a);
    this.registerHook("min", function() {
        return !1
    });
    this.registerHook("max", function() {
        return !1
    });
    this.registerHook("choices", function() {
        return !1
    });
    this.getChoices = function() {
        return b.getSetting("choices")
    };
    this.getSelectedChoices = function() {
        var a = b.getSetting("choices"),
            c = [];
        b.getSettingShallow("value").forEach(function(b) {
            c.push(a[b])
        });
        return c
    };
    this.checkValue =
        function(a) {
            return void 0 !== c(a, b.getSettingShallow("max"), b.getSettingShallow("strictMode"))
        };
    this.getValueString = function() {
        var a = JSON.stringify(b.getValue(), null, 0);
        a = a.replace("[", "");
        return a = a.replace("]", "")
    };
    var e = this.setValue;
    this.setValue = function(a) {
        a = c(a, b.getSettingShallow("max"), b.getSettingShallow("strictMode"));
        return void 0 === a ? !1 : e(a)
    };
    this.parseValue = function(a) {
        a = c(a, b.getSettingShallow("max"), !1);
        return b.setValue(a)
    };
    this.getDefinition = function() {
        return b.getSettings("id name plugin note type choices defval group visualization".split(" "))
    };
    return this
};
module$src$shared$types$ShapeDiverParameters.default.MultipleChoiceParameter = MultipleChoiceParameter$$module$src$shared$types$ShapeDiverParameters;
var StringParameter$$module$src$shared$types$ShapeDiverParameters = function(a) {
    var b = this;
    void 0 === a || "object" !== typeof a ? a = defaultSettings$$module$src$shared$types$ShapeDiverParameters : (a = module$src$shared$util$GlobalUtils.default.deepCopy(a), module$src$shared$util$GlobalUtils.default.defaults(a, defaultSettings$$module$src$shared$types$ShapeDiverParameters));
    a.valuetype = "string";
    void 0 === a.isValid && (a.isValid = !0);
    "boolean" !== typeof a.strictMode || a.strictMode || ["max"].forEach(function(b) {
        "string" ===
        typeof a[b] && (a[b] = parseInt(a[b]))
    });
    if (void 0 === a.name || "string" !== typeof a.name || 0 === a.name.length) a.name = "String parameter";
    if (void 0 === a.max || "number" !== typeof a.max) a.max = Number.MAX_SAFE_INTEGER, a.isValid = !1;
    if (void 0 === a.defval || "string" !== typeof a.defval) a.defval = "", a.isValid = !1;
    a.defval.length > a.max && (a.defval = a.defval.slice(0, a.max), a.isValid = !1);
    void 0 !== a.value && "string" !== typeof a.value && (a.value = a.defval, a.isValid = !1);
    void 0 !== a.value && a.value.length > a.max && (a.value = a.value.slice(0, a.max),
        a.isValid = !1);
    CommonParameter$$module$src$shared$types$ShapeDiverParameters.call(this, a);
    var c = this.checkValue;
    this.checkValue = function(a) {
        return c(a) ? a.length <= b.getSettingShallow("max") : !1
    };
    this.getDefinition = function() {
        return b.getSettings("id name plugin note type defval group max".split(" "))
    };
    return this
};
module$src$shared$types$ShapeDiverParameters.default.StringParameter = StringParameter$$module$src$shared$types$ShapeDiverParameters;
var BooleanParameter$$module$src$shared$types$ShapeDiverParameters = function(a) {
    var b = this;
    void 0 === a || "object" !== typeof a ? a = defaultSettings$$module$src$shared$types$ShapeDiverParameters : (a = module$src$shared$util$GlobalUtils.default.deepCopy(a), module$src$shared$util$GlobalUtils.default.defaults(a, defaultSettings$$module$src$shared$types$ShapeDiverParameters));
    a.valuetype = "boolean";
    void 0 === a.isValid && (a.isValid = !0);
    "boolean" !== typeof a.strictMode || a.strictMode || "string" !== typeof a.defval || ("false" ===
        a.defval.toLowerCase() ? a.defval = !1 : "true" === a.defval.toLowerCase() ? a.defval = !0 : 0 >= parseInt(a.defval) ? a.defval = !1 : 0 < parseInt(a.defval) && (a.defval = !0));
    if (void 0 === a.name || "string" !== typeof a.name || 0 === a.name.length) a.name = "Boolean parameter";
    if (void 0 === a.defval || "boolean" !== typeof a.defval) a.defval = !1, a.isValid = !1;
    CommonParameter$$module$src$shared$types$ShapeDiverParameters.call(this, a);
    var c = this.checkValue;
    this.checkValue = function(a) {
        if ("string" === typeof a && !b.getSettingShallow("strictMode"))
            if ("true" ===
                a.toLowerCase()) a = !0;
            else if ("false" === a.toLowerCase()) a = !1;
        else return !1;
        return c(a)
    };
    var d = this.setValue;
    this.setValue = function(a) {
        if ("string" === typeof a && !b.getSettingShallow("strictMode"))
            if ("true" === a.toLowerCase()) a = !0;
            else if ("false" === a.toLowerCase()) a = !1;
        else return !1;
        return d(a)
    };
    this.getDefinition = function() {
        return b.getSettings("id name plugin note type defval group".split(" "))
    };
    return this
};
module$src$shared$types$ShapeDiverParameters.default.BooleanParameter = BooleanParameter$$module$src$shared$types$ShapeDiverParameters;
var ColorParameter$$module$src$shared$types$ShapeDiverParameters = function(a) {
    var b = this,
        c = function(a) {
            return a.toString("hex8").replace("#", "0x")
        };
    void 0 === a || "object" !== typeof a ? a = defaultSettings$$module$src$shared$types$ShapeDiverParameters : (a = module$src$shared$util$GlobalUtils.default.deepCopy(a), module$src$shared$util$GlobalUtils.default.defaults(a, defaultSettings$$module$src$shared$types$ShapeDiverParameters));
    a.max = Number.MAX_SAFE_INTEGER;
    void 0 === a.isValid && (a.isValid = !0);
    if (void 0 === a.name ||
        "string" !== typeof a.name || 0 === a.name.length) a.name = "Color parameter";
    void 0 === a.defval && (a.defval = "white");
    var d = (0, module$src$shared$util$toTinyColor.default)(a.defval);
    null === d ? (a.defval = (0, module$src$shared$util$toTinyColor.default)("white"), a.isValid = !1) : a.defval = d;
    a.defval = c(a.defval);
    void 0 === a.value ? a.value = a.defval : (d = (0, module$src$shared$util$toTinyColor.default)(a.defval), null === d ? (a.value = (0, module$src$shared$util$toTinyColor.default)("white"), a.isValid = !1) : a.value = d);
    a.value = c(a.value);
    StringParameter$$module$src$shared$types$ShapeDiverParameters.call(this, a);
    var e = this.setValue;
    this.setValue = function(a) {
        a = (0, module$src$shared$util$toTinyColor.default)(a);
        return null === a ? !1 : e(c(a))
    };
    this.getValue = function() {
        return c((0, module$src$shared$util$toTinyColor.default)(b.getSettingShallow("value")))
    };
    this.getValueTinyColor = function() {
        return (0, module$src$shared$util$toTinyColor.default)(b.getSettingShallow("value"))
    };
    this.getValueString = function() {
        return b.getValue()
    };
    this.parseValue = function(a) {
        return b.setValue(a)
    };
    this.getDefinition = function() {
        return b.getSettings("id name plugin note type defval group".split(" "))
    };
    return this
};
module$src$shared$types$ShapeDiverParameters.default.ColorParameter = ColorParameter$$module$src$shared$types$ShapeDiverParameters;
var ParameterFactory$$module$src$shared$types$ShapeDiverParameters = function(a) {
    var b = this;
    module$src$shared$mixins$GlobalMixin.default.call(this);
    module$src$shared$mixins$SettingsMixin.default.call(this, a);
    module$src$shared$mixins$LoggingMixin.default.call(this);
    var c = module$src$shared$util$GlobalUtils.default.deepCopy(a),
        d = {
            "float": FloatParameter$$module$src$shared$types$ShapeDiverParameters,
            "int": IntegerParameter$$module$src$shared$types$ShapeDiverParameters,
            even: EvenIntegerParameter$$module$src$shared$types$ShapeDiverParameters,
            odd: OddIntegerParameter$$module$src$shared$types$ShapeDiverParameters,
            string: StringParameter$$module$src$shared$types$ShapeDiverParameters,
            color: ColorParameter$$module$src$shared$types$ShapeDiverParameters,
            "stringlist:sequence": ValueListParameter$$module$src$shared$types$ShapeDiverParameters,
            "stringlist:cycle": ValueListParameter$$module$src$shared$types$ShapeDiverParameters,
            "stringlist:dropdown": ValueListParameter$$module$src$shared$types$ShapeDiverParameters,
            "stringlist:checklist": MultipleChoiceParameter$$module$src$shared$types$ShapeDiverParameters,
            bool: BooleanParameter$$module$src$shared$types$ShapeDiverParameters
        };
    this.produce = function(a) {
        a = module$src$shared$util$GlobalUtils.default.deepCopy(a);
        if (void 0 === a.type || "string" !== typeof a.type) b.debug("ShapeDiverParameters~factory", "type not defined");
        else {
            var e = d[(a.type + ":" + a.visualization).toLowerCase()];
            if (void 0 === e && (e = d[a.type.toLowerCase()], void 0 === e)) {
                b.debug("ShapeDiverParameters~factory", "type not known: " + a.type.toLowerCase());
                return
            }
            try {
                module$src$shared$util$GlobalUtils.default.inject(c,
                    a);
                var g = new e(a);
                if (g.isValid()) return g;
                b.debug("ShapeDiverParameters~factory", "created parameter not valid for " + b.jsify(a) + ": " + b.jsify(g.getSettings()) + ", try to set strictMode to false")
            } catch (h) {
                b.debug("ShapeDiverParameters~factory", "exception creating parameter", a, h)
            }
        }
    };
    return this
};
module$src$shared$types$ShapeDiverParameters.default.ParameterFactory = ParameterFactory$$module$src$shared$types$ShapeDiverParameters;
var module$src$app$partials$ViewerAppParameterManager = {},
    GlobalUtils$$module$src$app$partials$ViewerAppParameterManager = module$src$shared$util$GlobalUtils.default,
    pluginConstants$$module$src$app$partials$ViewerAppParameterManager = module$src$shared$constants$PluginConstantsGlobal.default,
    messagingConstants$$module$src$app$partials$ViewerAppParameterManager = module$src$shared$constants$MessagingConstants.default,
    MessagePrototype$$module$src$app$partials$ViewerAppParameterManager = module$src$shared$messages$MessagePrototype.default;
module$src$app$partials$ViewerAppParameterManager.default = function(a) {
    var b = this,
        c = {},
        d = [],
        e = new module$src$shared$types$ShapeDiverParameters.default.ParameterFactory(b.getSettings()),
        f = {};
    if (a && a.hasOwnProperty("pluginManager") && a.pluginManager.hasOwnProperty("getPluginByRuntimeId")) var g = a.pluginManager;
    var h = [],
        k = [],
        l = function(a) {
            if (h.length !== k.length) {
                for (var b = [], d = [], e = k.length, f = Math.max(0, e - 50), g = f; g < e; g++) b.push(h[k[g]]), d.push(g - f);
                k = d;
                h = b
            }
            a || (a = c.getParameterState());
            h.push(a);
            k.push(h.length -
                1)
        };
    c.canGoBackInHistory = function() {
        return 0 >= h.length || 0 >= k[k.length - 1] ? !1 : !0
    };
    c.canGoForwardInHistory = function() {
        return 0 >= h.length || k[k.length - 1] >= h.length - 1 ? !1 : !0
    };
    c.goBackInHistory = function(a) {
        if (!c.canGoBackInHistory()) return !1;
        var b = k[k.length - 1] - 1;
        k.push(b);
        c.setMultipleParameterValues(h[b], a, !1, !0);
        return !0
    };
    c.goForwardInHistory = function(a) {
        if (!c.canGoForwardInHistory()) return !1;
        var b = k[k.length - 1] + 1;
        k.push(b);
        c.setMultipleParameterValues(h[b], a, !1, !0);
        return !0
    };
    c.registerMultipleParameters =
        function(a, b) {
            var d = [];
            Object.keys(a).forEach(function(e) {
                var f = module$src$shared$util$GlobalUtils.default.deepCopy(a[e]);
                f.id = e;
                "time" !== f.type.toLowerCase() && (e = c.registerParameter(f, b), void 0 !== e && d.push(e))
            });
            return d
        };
    c.registerParameter = function(a, f) {
        if (void 0 === f || "string" !== typeof f) b.debug("ViewerAppParameterManager.registerParameter", "No plugin specified");
        else if (void 0 === a || "object" !== typeof a) b.debug("ViewerAppParameterManager.registerParameter", "Definition of parameter missing");
        else {
            a.plugin =
                f;
            if (void 0 === a.id || "string" !== typeof a.id) a.id = module$src$shared$util$GlobalUtils.default.createRandomId(), b.debug("ViewerAppParameterManager.registerParameter", "No id was specified, using " + a.id);
            if (void 0 !== c.getUniqueParameterBySettings({
                    id: a.id,
                    plugin: f
                })) b.debug("ViewerAppParameterManager.registerParameter", "Parameter with id " + a.id + " and plugin " + f + " already exists");
            else if (f = e.produce(a), void 0 === f) b.debug("ViewerAppParameterManager.registerParameter", "Parameter factory failed for definition",
                a);
            else return d.push(f), b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.PARAMETER_REGISTERED, new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PARAMETER_DEFINITION, a)), a.id
        }
    };
    c.registerConfig = function(a, b) {
        if (void 0 !== a.controlNames && "object" === typeof a.controlNames) {
            var d = a.controlNames;
            Object.keys(d).forEach(function(a) {
                var e = c.getUniqueParameterBySettings({
                    id: a,
                    plugin: b
                });
                e && (e.updateSetting("_name",
                    e.getSetting("name")), e.updateSetting("name", d[a]))
            })
        }
        if (void 0 !== a.controlOrder && Array.isArray(a.controlOrder))
            for (var e = a.controlOrder, f = 0; f < e.length; f++) {
                var g = c.getUniqueParameterBySettings({
                    id: e[f],
                    plugin: b
                });
                g && g.updateSetting("order", f)
            }
        if (void 0 !== a.parametersHidden && Array.isArray(a.parametersHidden))
            for (a = a.parametersHidden, e = 0; e < a.length; e++)(f = c.getUniqueParameterBySettings({
                id: a[e],
                plugin: b
            })) && f.updateSetting("hidden", !0);
        return !0
    };
    c.deregisterParameter = function(a, c) {
        var e = {};
        e.id = a;
        void 0 !== c && (e.plugin = c);
        e = m(e);
        if (void 0 === e) return b.error("ViewerAppParameterManager.deregisterParameter", "Parameter with id " + a + " and plugin " + c + " not found"), !1;
        c = d.splice(e, 1)[0];
        b.info("ViewerAppParameterManager.deregisterParameter", 'Deregistered parameter "' + c.getSetting("name") + '" with id ' + a);
        return !0
    };
    c.getParameterById = function(a, b) {
        var d = {};
        d.id = a;
        void 0 !== b && (d.plugin = b);
        return c.getUniqueParameterBySettings(d)
    };
    c.getParameterByName = function(a, b) {
        var d = {};
        d.name = a;
        void 0 !== b && (d.plugin =
            b);
        return c.getUniqueParameterBySettings(d)
    };
    c.getParameterByIdOrName = function(a, b) {
        var d = {};
        d.id = a;
        void 0 !== b && (d.plugin = b);
        b = c.getUniqueParameterBySettings(d);
        if (void 0 !== b) return b;
        delete d.id;
        d.name = a;
        return c.getUniqueParameterBySettings(d)
    };
    c.getParametersBySettings = function(a) {
        return d.filter(function(b) {
            return Object.keys(a).every(function(c) {
                return b.hasSetting(c) && b.getSettingShallow(c) === a[c] ? !0 : !1
            })
        })
    };
    c.idsUnique = function() {
        var a = [];
        return d.every(function(b) {
            b = b.getSetting("id");
            if (a.includes(b)) return !1;
            a.push(b);
            return !0
        })
    };
    c.namesUnique = function() {
        var a = [];
        return d.every(function(b) {
            b = b.getSetting("name");
            if (a.includes(b)) return !1;
            a.push(b);
            return !0
        })
    };
    var p = function(a) {
            var b = [];
            d.forEach(function(c, d) {
                Object.keys(a).every(function(b) {
                    return c.hasSetting(b) && c.getSettingShallow(b) === a[b] ? !0 : !1
                }) && b.push(d)
            });
            return b
        },
        m = function(a) {
            a = p(a);
            if (1 === a.length) return a[0]
        };
    c.getUniqueParameterBySettings = function(a) {
        a = c.getParametersBySettings(a);
        if (1 === a.length) return a[0]
    };
    c.getParameterDefinitions =
        function(a) {
            var e = {};
            (void 0 !== a && "object" === typeof a ? c.getParametersBySettings(a) : d).forEach(function(a, d) {
                var f = a.getDefinition();
                void 0 === f || "object" !== typeof f ? b.debug("ViewerAppParameterManager.getParameterDefinitions", "Could not get definition of parameter " + d) : (d = a.getSetting("id"), 1 < c.getParametersBySettings({
                    id: d
                }).length && (d = d + "__" + a.getSetting("plugin")), e[d] = f)
            });
            return e
        };
    c.getParameterDefinitionsAndValues = function(a) {
        a = void 0 !== a && "object" === typeof a ? c.getParametersBySettings(a) : d;
        var e = [];
        a.forEach(function(a, c) {
            var d = a.getDefinition();
            void 0 === d || "object" !== typeof d ? b.debug("ViewerAppParameterManager.getParameterDefinitionsAndValues", "Could not get definition of parameter " + c) : (d.value = a.getValue(), e.push(d))
        });
        e.sort(function(a, b) {
            var c = a.plugin;
            c = "number" === typeof a.order ? c + a.order.toString().padStart(3, "0") : c + a.name;
            a = b.plugin;
            a = "number" === typeof b.order ? a + b.order.toString().padStart(3, "0") : a + b.name;
            return c < a ? -1 : c > a ? 1 : 0
        });
        return e
    };
    var q = function(a) {
        if (void 0 !== a && "object" ===
            typeof a) {
            var b = {};
            void 0 !== a.plugin && "string" === typeof a.plugin && (b.plugin = a.plugin);
            if (void 0 !== a.id && "string" === typeof a.id) {
                b.id = a.id;
                var c = m(b);
                if (void 0 !== c) return c;
                delete b.id
            }
            if (void 0 !== a.idOrName && "string" === typeof a.idOrName) {
                b.id = a.idOrName;
                c = m(b);
                if (void 0 !== c) return c;
                delete b.id;
                b.name = a.idOrName;
                c = m(b);
                if (void 0 !== c) return c;
                delete b.name
            }
            if (void 0 !== a.name && "string" === typeof a.name && (b.name = a.name, c = m(b), void 0 !== c)) return c
        }
    };
    c.setParameterValue = function(a, b) {
        return c.setMultipleParameterValues([a],
            b)
    };
    c.setMultipleParameterValues = function(a, e, h, m) {
        void 0 === h && (h = !1);
        var n = c.getParameterState(),
            p = {
                params: [],
                plugins: {}
            };
        e = module$src$shared$constants$MessagingConstants.default.makeMessageToken(e);
        p.token = e;
        var r = function(a, b, c) {
                p.err || (p.err = []);
                p.err.push({
                    code: a,
                    msg: b,
                    data: c
                })
            },
            t = function(a, b, c) {
                p.warn || (p.warn = []);
                p.warn.push({
                    code: a,
                    msg: b,
                    data: c
                })
            },
            x = [];
        a.forEach(function(a) {
            var c = q(a);
            void 0 === c ? (r(module$src$shared$constants$PluginConstantsGlobal.default.setParameterResults.PARAM_NOT_FOUND,
                "Could not find parameter", a), b.warn("ViewerAppParameterManager.setMultipleParameterValues", "Could not find parameter", a)) : (a.idx = c, c = d[c], a.id = c.getSetting("id"), a.plugin = c.getSetting("plugin"), x.includes(a.plugin) || x.push(a.plugin), void 0 === a.value ? (r(module$src$shared$constants$PluginConstantsGlobal.default.setParameterResults.NO_VALUE, "Parameter value not set", a.value), p.params.push({
                    id: a.id,
                    plugin: a.plugin,
                    result: module$src$shared$constants$PluginConstantsGlobal.default.setParameterResults.NO_VALUE
                }),
                b.info("ViewerAppParameterManager.setMultipleParameterValues", "Parameter value not set")) : c.checkValue(a.value) || (r(module$src$shared$constants$PluginConstantsGlobal.default.setParameterResults.VALUE_REJECT, "Parameter value rejected", a.value), p.params.push({
                id: a.id,
                plugin: a.plugin,
                result: module$src$shared$constants$PluginConstantsGlobal.default.setParameterResults.VALUE_REJECT
            }), b.info("ViewerAppParameterManager.setMultipleParameterValues", "Parameter value rejected: " + a.value)))
        });
        if (p.err || p.warn) return p;
        var z = !0,
            u = [];
        a.forEach(function(a) {
            var c = d[a.idx];
            c.isValueDifferent(a.value) ? (u.includes(a.plugin) || u.push(a.plugin), z = !1, c.setValue(a.value) ? p.params.push({
                id: a.id,
                plugin: a.plugin,
                result: module$src$shared$constants$PluginConstantsGlobal.default.setParameterResults.VALUE_OK
            }) : (r(module$src$shared$constants$PluginConstantsGlobal.default.setParameterResults.VALUE_REJECT, "Parameter value rejected", a.value), p.params.push({
                    id: a.id,
                    plugin: a.plugin,
                    result: module$src$shared$constants$PluginConstantsGlobal.default.setParameterResults.VALUE_REJECT
                }),
                b.info("ViewerAppParameterManager.setMultipleParameterValues", "Parameter value rejected: " + a.value))) : p.params.push({
                id: a.id,
                plugin: a.plugin,
                result: module$src$shared$constants$PluginConstantsGlobal.default.setParameterResults.VALUE_EXISTS
            })
        });
        if (p.err) return h = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_ERROR, p.err, e), b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS, h),
            p;
        h && (u = x);
        u.forEach(function(a) {
            if (!f[a]) {
                var c = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_INITIAL, {}, e);
                b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS, c);
                f[a] = !0
            }
        });
        if (z && !h) return h = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_SUCCESS, "All parameter values up to date", e), b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS,
            h), p;
        0 === k.length && l(n);
        m || z || l();
        h = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_STATUS, {
            busy: !0,
            progress: 0
        }, e);
        b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS, h);
        var N = {};
        if (1 < u.length) {
            h = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_FORK, [], e);
            m = (u.length + "").length;
            for (n = 0; n < u.length; n++) {
                var K =
                    module$src$shared$util$GlobalUtils.default.deepCopy(e);
                K.id = e.id + "." + (Array(m).join("0") + n).slice(-m);
                N[u[n]] = K;
                h.parts[0].data.push(K.id)
            }
            b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS, h)
        } else u.forEach(function(a) {
            N[a] = module$src$shared$util$GlobalUtils.default.deepCopy(e)
        });
        var H = {};
        u.forEach(function(c) {
            var e = a.filter(function(a) {
                return a.plugin === c
            });
            H[c] = {};
            var f = H[c];
            e.forEach(function(a) {
                f[a.id] = d[a.idx].getValue()
            });
            var h;
            if (void 0 === g) t(module$src$shared$constants$PluginConstantsGlobal.default.setParameterResults.PLUGIN_NOT_FOUND,
                "Plugin functionality not found", c), b.warn("ViewerAppParameterManager.setMultipleParameterValues", "Plugin functionality not found"), p.plugins[c] = module$src$shared$constants$PluginConstantsGlobal.default.setParameterResults.PLUGIN_NOT_FOUND;
            else if (h = g.getPluginByRuntimeId(c)) {
                var k = {};
                h.getCapabilities().includes(module$src$shared$constants$PluginConstantsGlobal.default.pluginCapabilities.PARTIAL_UPDATES) ? (e.forEach(function(a) {
                    k[a.id] = d[a.idx].getValueString()
                }), e = h.setMultipleParameterValues(k,
                    N[c]), p.plugins[c] = e) : (e.forEach(function(a) {
                    k[a.id] = d[a.idx].getValueString()
                }), d.forEach(function(a) {
                    var b = a.getSetting("id");
                    c !== a.getSetting("plugin") || k.hasOwnProperty(b) || (k[b] = a.getValueString())
                }), e = h.setAllParameterValues(k, N[c]), p.plugins[c] = e)
            } else r(module$src$shared$constants$PluginConstantsGlobal.default.setParameterResults.PLUGIN_NOT_FOUND, "Plugin not found", c), b.error("ViewerAppParameterManager.setMultipleParameterValues", "Plugin " + c + " not found"), p.plugins[c] = module$src$shared$constants$PluginConstantsGlobal.default.setParameterResults.PLUGIN_NOT_FOUND
        });
        h = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PARAMETER_UPDATE, H, e);
        b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.PARAMETER_VALUE_UPDATE, h);
        if (p.err || p.warn) h = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_ERROR, p.err, e), b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS,
            h);
        return p
    };
    c.getParameterValuesForPlugin = function(a, b) {
        var d = {};
        c.getParametersBySettings({
            plugin: a
        }).forEach(function(a) {
            b ? d[a.getSetting("id")] = a.getValueString() : d[a.getSetting("id")] = a.getSetting("value")
        });
        return d
    };
    c.refreshPluginInitial = function(a, d) {
        var e = {
            plugins: {}
        };
        d = module$src$shared$constants$MessagingConstants.default.makeMessageToken(d);
        e.token = d;
        var f = function(a, b, c) {
            e.err || (e.err = []);
            e.err.push({
                code: a,
                msg: b,
                data: c
            })
        };
        if (void 0 === g) return f(module$src$shared$constants$PluginConstantsGlobal.default.setParameterResults.PLUGIN_NOT_FOUND,
            "Plugin functionality not found", a), d = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_ERROR, e.err, d), b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS, d), e.plugins[a] = module$src$shared$constants$PluginConstantsGlobal.default.setParameterResults.PLUGIN_NOT_FOUND, e;
        var h = g.getPluginByRuntimeId(a);
        return h ? h.hasSetting("deferGeometryLoading") && h.getSettingShallow("deferGeometryLoading") ?
            (d = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_SUCCESS, "Geometry loading deferred", d), b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS, d), e.plugins[a] = module$src$shared$constants$PluginConstantsGlobal.default.setParameterResults.ABORT, e) : c.refreshPlugin(a, d) : (f(module$src$shared$constants$PluginConstantsGlobal.default.setParameterResults.PLUGIN_NOT_FOUND, "Plugin not found",
                a), d = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_ERROR, e.err, d), b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS, d), e.plugins[a] = module$src$shared$constants$PluginConstantsGlobal.default.setParameterResults.PLUGIN_NOT_FOUND, e)
    };
    c.refreshPlugin = function(a, d) {
        var e = {
            plugins: {}
        };
        d = module$src$shared$constants$MessagingConstants.default.makeMessageToken(d);
        e.token = d;
        var h = function(a,
                b, c) {
                e.err || (e.err = []);
                e.err.push({
                    code: a,
                    msg: b,
                    data: c
                })
            },
            k = [];
        c.getParametersBySettings({
            plugin: a
        }).forEach(function(b) {
            k.push({
                id: b.getSetting("id"),
                value: b.getSetting("value"),
                plugin: a
            })
        });
        if (0 >= k.length && g) {
            var l = g.getPluginByRuntimeId(a);
            if (!l) return h(module$src$shared$constants$PluginConstantsGlobal.default.setParameterResults.PLUGIN_NOT_FOUND, "Plugin not found", a), d = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_ERROR,
                e.err, d), b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS, d), e.plugins[a] = module$src$shared$constants$PluginConstantsGlobal.default.setParameterResults.PLUGIN_NOT_FOUND, e;
            h = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_STATUS, {
                busy: !0,
                progress: 0
            }, d);
            b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS, h);
            f[a] || (h = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_INITIAL, {}, d), b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS, h), f[a] = !0);
            e.plugins[a] = l.setAllParameterValues({}, d);
            return e
        }
        return c.setMultipleParameterValues(k, d, !0)
    };
    c.getParameterValuesCompat = function() {
        var a = {};
        d.forEach(function(b) {
            a[b.getSettingShallow("id")] = b.getSetting("value")
        });
        return a
    };
    c.getParameterState = function() {
        var a = [];
        d.forEach(function(b) {
            a.push({
                id: b.getSettingShallow("id"),
                plugin: b.getSettingShallow("plugin"),
                value: b.getSettingShallow("value")
            })
        });
        return a
    };
    return c
};
var module$src$app$partials$ViewerAppExportManager = {},
    GlobalUtils$$module$src$app$partials$ViewerAppExportManager = module$src$shared$util$GlobalUtils.default,
    pluginConstants$$module$src$app$partials$ViewerAppExportManager = module$src$shared$constants$PluginConstantsGlobal.default,
    messagingConstants$$module$src$app$partials$ViewerAppExportManager = module$src$shared$constants$MessagingConstants.default,
    MessagePrototype$$module$src$app$partials$ViewerAppExportManager = module$src$shared$messages$MessagePrototype.default;
module$src$app$partials$ViewerAppExportManager.default = function(a) {
    var b = this,
        c = a.pluginManager,
        d = a.parameterManager,
        e = {},
        f = [];
    e.registerMultipleExports = function(a, b) {
        Object.keys(a).forEach(function(c) {
            var d = module$src$shared$util$GlobalUtils.default.deepCopy(a[c]);
            d.id = c;
            e.registerExport(d, b)
        });
        return []
    };
    e.registerExport = function(a, c) {
        if (void 0 !== c && module$src$shared$util$GlobalUtils.default.typeCheck(c, "string"))
            if (void 0 === a || "object" !== typeof a) b.debug("ViewerAppExportManager.registerExport",
                "Definition of export missing");
            else if (a.plugin = c, void 0 !== a.id && module$src$shared$util$GlobalUtils.default.typeCheck(a.id, "string") || (a.id = module$src$shared$util$GlobalUtils.default.createRandomId(), b.debug("ViewerAppExportManager.registerExport", "No id was specified, using " + a.id)), void 0 !== e.getUniqueExportByProperties({
                id: a.id,
                plugin: c
            })) b.debug("ViewerAppExportManager.registerExport", "Export with id " + a.id + " and plugin " + c + " already exists");
        else return void 0 === a.name && b.warn("ViewerAppExportManager.registerExport",
            "Export without name:", a), f.push(a), b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.EXPORT_REGISTERED, new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.EXPORT_DEFINITION, a)), a.id;
        else b.debug("ViewerAppExportManager.registerExport", "No plugin specified")
    };
    e.deregisterExport = function(a, c) {
        var d = {};
        d.id = a;
        void 0 !== c && (d.plugin = c);
        d = h(d);
        if (void 0 === d) return b.error("ViewerAppExportManager.deregisterExport",
            "Export with id " + a + " and plugin " + c + " not found"), !1;
        c = f.splice(d, 1)[0];
        b.info("ViewerAppExportManager.deregisterExport", 'Deregistered export "' + c.name + '" with id ' + a);
        return !0
    };
    e.getExportById = function(a, b) {
        var c = {};
        c.id = a;
        void 0 !== b && (c.plugin = b);
        return e.getUniqueExportByProperties(c)
    };
    e.getExportByName = function(a, b) {
        var c = {};
        c.name = a;
        void 0 !== b && (c.plugin = b);
        return e.getUniqueExportByProperties(c)
    };
    e.getExportByIdOrName = function(a, b) {
        var c = {};
        c.id = a;
        void 0 !== b && (c.plugin = b);
        b = e.getUniqueExportByProperties(c);
        if (void 0 !== b) return b;
        delete c.id;
        c.name = a;
        return e.getUniqueExportByProperties(c)
    };
    e.getExportsByProperties = function(a) {
        return f.filter(function(b) {
            return Object.keys(a).every(function(c) {
                return b.hasOwnProperty(c) && b[c] === a[c] ? !0 : !1
            })
        })
    };
    var g = function(a) {
            var b = [];
            f.forEach(function(c, d) {
                Object.keys(a).every(function(b) {
                    return c.hasOwnProperty(b) && c[b] === a[b] ? !0 : !1
                }) && b.push(d)
            });
            return b
        },
        h = function(a) {
            a = g(a);
            if (1 === a.length) return a[0]
        };
    e.getUniqueExportByProperties = function(a) {
        a = e.getExportsByProperties(a);
        if (1 === a.length) return a[0]
    };
    e.getExportDefinitions = function() {
        var a = [];
        f.forEach(function(b) {
            b = module$src$shared$util$GlobalUtils.default.deepCopy({
                id: b.id,
                name: b.name,
                type: b.type,
                plugin: b.plugin,
                group: b.group
            });
            a.push(b)
        });
        return a
    };
    var k = function(a) {
        if (void 0 !== a && "object" === typeof a) {
            var b = {};
            void 0 !== a.plugin && "string" === typeof a.plugin && (b.plugin = a.plugin);
            if (void 0 !== a.id && "string" === typeof a.id) {
                b.id = a.id;
                var c = h(b);
                if (void 0 !== c) return c;
                delete b.id
            }
            if (void 0 !== a.idOrName && "string" === typeof a.idOrName) {
                b.id =
                    a.idOrName;
                c = h(b);
                if (void 0 !== c) return c;
                delete b.id;
                b.name = a.idOrName;
                c = h(b);
                if (void 0 !== c) return c;
                delete b.name
            }
            if (void 0 !== a.name && "string" === typeof a.name && (b.name = a.name, c = h(b), void 0 !== c)) return c
        }
    };
    e.getUniqueExportByRequestObject = function(a) {
        a = k(a);
        if (void 0 !== a) return module$src$shared$util$GlobalUtils.default.deepCopy(f[a])
    };
    e.requestExport = function(a, e) {
        e = module$src$shared$constants$MessagingConstants.default.makeMessageToken(e);
        var g = function(a, c) {
                e && (c = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_ERROR,
                    c, e), b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS, c));
                return a
            },
            h = k(a);
        if (void 0 === h) return b.error("ViewerAppExportManager.requestExport", "Export not found", a), g(module$src$shared$constants$PluginConstantsGlobal.default.requestExportResults.EXPORT_NOT_FOUND, "Export not found");
        a = f[h];
        h = d.getParameterValuesForPlugin(a.plugin, !0);
        if (void 0 === c || void 0 === c.getPluginByRuntimeId) return b.error("ViewerAppExportManager.requestExport", "Plugin manager not found"),
            g(module$src$shared$constants$PluginConstantsGlobal.default.requestExportResults.PLUGIN_NOT_FOUND, "Plugin manager not found");
        var l = c.getPluginByRuntimeId(a.plugin);
        if (!l) return a = "Plugin " + a.plugin + " not found", b.error("ViewerAppExportManager.requestExport", a), g(module$src$shared$constants$PluginConstantsGlobal.default.requestExportResults.PLUGIN_NOT_FOUND, a);
        e && (g = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_STATUS, {
            progress: 0
        }, e), b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS, g), g = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.EXPORT_STATUS, a, e), b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.EXPORT_STATUS, g));
        return l.requestExport(a.id, h, e)
    };
    return e
};
var module$src$app$handlers$ContainerHandler = {},
    viewerAppConstants$$module$src$app$handlers$ContainerHandler = module$src$app$ViewerAppConstants.default,
    MessagePrototype$$module$src$app$handlers$ContainerHandler = module$src$shared$messages$MessagePrototype.default,
    GlobalUtils$$module$src$app$handlers$ContainerHandler = module$src$shared$util$GlobalUtils.default;
module$src$app$handlers$ContainerHandler.default = function(a) {
    var b = this,
        c = a && a.container,
        d = !1,
        e = {
            isVisible: function() {
                return b.getSettingShallow("showScene")
            },
            showScene: function(a) {
                c && (!1 === a ? (c.style.opacity = 0, e.isVisible() && (a = new module$src$shared$messages$MessagePrototype.default(module$src$app$ViewerAppConstants.default.messageDataTypes.GENERIC, {
                    shownBefore: d
                }), b.message(module$src$app$ViewerAppConstants.default.messageTopics.SCENE_VISIBILITY_OFF, a))) : (c.style.opacity = 1, e.isVisible() || (a = new module$src$shared$messages$MessagePrototype.default(module$src$app$ViewerAppConstants.default.messageDataTypes.GENERIC, {
                    shownBefore: d
                }), b.message(module$src$app$ViewerAppConstants.default.messageTopics.SCENE_VISIBILITY_ON, a)), d = !0))
            },
            hideScene: function() {
                b.updateSetting("showScene", !1)
            }
        };
    this.registerHook("showSceneTransition", function(a) {
        if (!module$src$shared$util$GlobalUtils.default.typeCheck(a, "string")) return !1;
        c && (c.style.transition = 0 < a.length ? "opacity " + a : "none");
        return !0
    });
    this.registerHook("showScene", function(a) {
        if (!module$src$shared$util$GlobalUtils.default.typeCheck(a, "boolean")) return !1;
        e.showScene(a);
        return !0
    });
    var f = {};
    e.messageReceiver = function(a, c, e) {
        d || (e === module$src$app$ViewerAppConstants.default.messageDataTypes.PROCESS_INITIAL ? f[a.id] = a : e === module$src$app$ViewerAppConstants.default.messageDataTypes.PROCESS_SUCCESS ? f.hasOwnProperty(a.id) && (delete f[a.id], a = b.getSettingShallow("showSceneMode"), (a === module$src$app$ViewerAppConstants.default.showSceneModes.ON_FIRST_PLUGIN || 0 === Object.keys(f).length && a === module$src$app$ViewerAppConstants.default.showSceneModes.ON_ALL_PLUGINS) && b.updateSetting("showScene", !0)) : e === module$src$app$ViewerAppConstants.default.messageDataTypes.PROCESS_ERROR && b.warn("ContainerHandler.messageReceiver", "Received error message for initial geometry loading process, not showing 3D scene"))
    };
    e.init = function() {
        b.getSetting("showSceneMode") === module$src$app$ViewerAppConstants.default.showSceneModes.INSTANT ? b.updateSetting("showScene", !0) : b.updateSetting("showScene", !1);
        setTimeout(function() {
            b.updateSetting("showSceneTransition", b.getSetting("showSceneTransition"))
        }, 0)
    };
    return e
};
var module$node_modules$$tweenjs$tween_js$src$Tween = {},
    _Group$$module$node_modules$$tweenjs$tween_js$src$Tween = function() {
        this._tweens = {};
        this._tweensAddedDuringUpdate = {}
    };
_Group$$module$node_modules$$tweenjs$tween_js$src$Tween.prototype = {
    getAll: function() {
        return Object.keys(this._tweens).map(function(a) {
            return this._tweens[a]
        }.bind(this))
    },
    removeAll: function() {
        this._tweens = {}
    },
    add: function(a) {
        this._tweens[a.getId()] = a;
        this._tweensAddedDuringUpdate[a.getId()] = a
    },
    remove: function(a) {
        delete this._tweens[a.getId()];
        delete this._tweensAddedDuringUpdate[a.getId()]
    },
    update: function(a, b) {
        var c = Object.keys(this._tweens);
        if (0 === c.length) return !1;
        for (a = void 0 !== a ? a : module$node_modules$$tweenjs$tween_js$src$Tween.default.now(); 0 <
            c.length;) {
            this._tweensAddedDuringUpdate = {};
            for (var d = 0; d < c.length; d++) {
                var e = this._tweens[c[d]];
                e && !1 === e.update(a) && (e._isPlaying = !1, b || delete this._tweens[c[d]])
            }
            c = Object.keys(this._tweensAddedDuringUpdate)
        }
        return !0
    }
};
module$node_modules$$tweenjs$tween_js$src$Tween.default = new _Group$$module$node_modules$$tweenjs$tween_js$src$Tween;
module$node_modules$$tweenjs$tween_js$src$Tween.default.Group = _Group$$module$node_modules$$tweenjs$tween_js$src$Tween;
module$node_modules$$tweenjs$tween_js$src$Tween.default._nextId = 0;
module$node_modules$$tweenjs$tween_js$src$Tween.default.nextId = function() {
    return module$node_modules$$tweenjs$tween_js$src$Tween.default._nextId++
};
module$node_modules$$tweenjs$tween_js$src$Tween.default.now = "undefined" === typeof window && "undefined" !== typeof process ? function() {
    var a = process.hrtime();
    return 1E3 * a[0] + a[1] / 1E6
} : "undefined" !== typeof window && void 0 !== window.performance && void 0 !== window.performance.now ? window.performance.now.bind(window.performance) : void 0 !== Date.now ? Date.now : function() {
    return (new Date).getTime()
};
module$node_modules$$tweenjs$tween_js$src$Tween.default.Tween = function(a, b) {
    this._object = a;
    this._valuesStart = {};
    this._valuesEnd = {};
    this._valuesStartRepeat = {};
    this._duration = 1E3;
    this._repeat = 0;
    this._repeatDelayTime = void 0;
    this._reversed = this._isPlaying = this._yoyo = !1;
    this._delayTime = 0;
    this._startTime = null;
    this._easingFunction = module$node_modules$$tweenjs$tween_js$src$Tween.default.Easing.Linear.None;
    this._interpolationFunction = module$node_modules$$tweenjs$tween_js$src$Tween.default.Interpolation.Linear;
    this._chainedTweens = [];
    this._onStartCallback = null;
    this._onStartCallbackFired = !1;
    this._onStopCallback = this._onCompleteCallback = this._onUpdateCallback = null;
    this._group = b || module$node_modules$$tweenjs$tween_js$src$Tween.default;
    this._id = module$node_modules$$tweenjs$tween_js$src$Tween.default.nextId()
};
module$node_modules$$tweenjs$tween_js$src$Tween.default.Tween.prototype = {
    getId: function() {
        return this._id
    },
    isPlaying: function() {
        return this._isPlaying
    },
    to: function(a, b) {
        this._valuesEnd = a;
        void 0 !== b && (this._duration = b);
        return this
    },
    start: function(a) {
        this._group.add(this);
        this._isPlaying = !0;
        this._onStartCallbackFired = !1;
        this._startTime = void 0 !== a ? "string" === typeof a ? module$node_modules$$tweenjs$tween_js$src$Tween.default.now() + parseFloat(a) : a : module$node_modules$$tweenjs$tween_js$src$Tween.default.now();
        this._startTime += this._delayTime;
        for (var b in this._valuesEnd) {
            if (this._valuesEnd[b] instanceof Array) {
                if (0 === this._valuesEnd[b].length) continue;
                this._valuesEnd[b] = [this._object[b]].concat(this._valuesEnd[b])
            }
            void 0 !== this._object[b] && (this._valuesStart[b] = this._object[b], !1 === this._valuesStart[b] instanceof Array && (this._valuesStart[b] *= 1), this._valuesStartRepeat[b] = this._valuesStart[b] || 0)
        }
        return this
    },
    stop: function() {
        if (!this._isPlaying) return this;
        this._group.remove(this);
        this._isPlaying = !1;
        null !==
            this._onStopCallback && this._onStopCallback(this._object);
        this.stopChainedTweens();
        return this
    },
    end: function() {
        this.update(this._startTime + this._duration);
        return this
    },
    stopChainedTweens: function() {
        for (var a = 0, b = this._chainedTweens.length; a < b; a++) this._chainedTweens[a].stop()
    },
    group: function a(a) {
        this._group = a;
        return this
    },
    delay: function(a) {
        this._delayTime = a;
        return this
    },
    repeat: function(a) {
        this._repeat = a;
        return this
    },
    repeatDelay: function(a) {
        this._repeatDelayTime = a;
        return this
    },
    yoyo: function(a) {
        this._yoyo =
            a;
        return this
    },
    easing: function(a) {
        this._easingFunction = a;
        return this
    },
    interpolation: function(a) {
        this._interpolationFunction = a;
        return this
    },
    chain: function() {
        this._chainedTweens = arguments;
        return this
    },
    onStart: function(a) {
        this._onStartCallback = a;
        return this
    },
    onUpdate: function(a) {
        this._onUpdateCallback = a;
        return this
    },
    onComplete: function(a) {
        this._onCompleteCallback = a;
        return this
    },
    onStop: function(a) {
        this._onStopCallback = a;
        return this
    },
    update: function(a) {
        var b;
        if (a < this._startTime) return !0;
        !1 === this._onStartCallbackFired &&
            (null !== this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0);
        var c = (a - this._startTime) / this._duration;
        c = 0 === this._duration || 1 < c ? 1 : c;
        var d = this._easingFunction(c);
        for (b in this._valuesEnd)
            if (void 0 !== this._valuesStart[b]) {
                var e = this._valuesStart[b] || 0,
                    f = this._valuesEnd[b];
                f instanceof Array ? this._object[b] = this._interpolationFunction(f, d) : ("string" === typeof f && (f = "+" === f.charAt(0) || "-" === f.charAt(0) ? e + parseFloat(f) : parseFloat(f)), "number" === typeof f && (this._object[b] =
                    e + (f - e) * d))
            }
        null !== this._onUpdateCallback && this._onUpdateCallback(this._object);
        if (1 === c)
            if (0 < this._repeat) {
                isFinite(this._repeat) && this._repeat--;
                for (b in this._valuesStartRepeat) "string" === typeof this._valuesEnd[b] && (this._valuesStartRepeat[b] += parseFloat(this._valuesEnd[b])), this._yoyo && (c = this._valuesStartRepeat[b], this._valuesStartRepeat[b] = this._valuesEnd[b], this._valuesEnd[b] = c), this._valuesStart[b] = this._valuesStartRepeat[b];
                this._yoyo && (this._reversed = !this._reversed);
                this._startTime = void 0 !==
                    this._repeatDelayTime ? a + this._repeatDelayTime : a + this._delayTime
            } else {
                null !== this._onCompleteCallback && this._onCompleteCallback(this._object);
                a = 0;
                for (b = this._chainedTweens.length; a < b; a++) this._chainedTweens[a].start(this._startTime + this._duration);
                return !1
            }
        return !0
    }
};
module$node_modules$$tweenjs$tween_js$src$Tween.default.Easing = {
    Linear: {
        None: function(a) {
            return a
        }
    },
    Quadratic: {
        In: function(a) {
            return a * a
        },
        Out: function(a) {
            return a * (2 - a)
        },
        InOut: function(a) {
            return 1 > (a *= 2) ? .5 * a * a : -.5 * (--a * (a - 2) - 1)
        }
    },
    Cubic: {
        In: function(a) {
            return a * a * a
        },
        Out: function(a) {
            return --a * a * a + 1
        },
        InOut: function(a) {
            return 1 > (a *= 2) ? .5 * a * a * a : .5 * ((a -= 2) * a * a + 2)
        }
    },
    Quartic: {
        In: function(a) {
            return a * a * a * a
        },
        Out: function(a) {
            return 1 - --a * a * a * a
        },
        InOut: function(a) {
            return 1 > (a *= 2) ? .5 * a * a * a * a : -.5 * ((a -= 2) * a * a *
                a - 2)
        }
    },
    Quintic: {
        In: function(a) {
            return a * a * a * a * a
        },
        Out: function(a) {
            return --a * a * a * a * a + 1
        },
        InOut: function(a) {
            return 1 > (a *= 2) ? .5 * a * a * a * a * a : .5 * ((a -= 2) * a * a * a * a + 2)
        }
    },
    Sinusoidal: {
        In: function(a) {
            return 1 - Math.cos(a * Math.PI / 2)
        },
        Out: function(a) {
            return Math.sin(a * Math.PI / 2)
        },
        InOut: function(a) {
            return .5 * (1 - Math.cos(Math.PI * a))
        }
    },
    Exponential: {
        In: function(a) {
            return 0 === a ? 0 : Math.pow(1024, a - 1)
        },
        Out: function(a) {
            return 1 === a ? 1 : 1 - Math.pow(2, -10 * a)
        },
        InOut: function(a) {
            return 0 === a ? 0 : 1 === a ? 1 : 1 > (a *= 2) ? .5 * Math.pow(1024, a - 1) :
                .5 * (-Math.pow(2, -10 * (a - 1)) + 2)
        }
    },
    Circular: {
        In: function(a) {
            return 1 - Math.sqrt(1 - a * a)
        },
        Out: function(a) {
            return Math.sqrt(1 - --a * a)
        },
        InOut: function(a) {
            return 1 > (a *= 2) ? -.5 * (Math.sqrt(1 - a * a) - 1) : .5 * (Math.sqrt(1 - (a -= 2) * a) + 1)
        }
    },
    Elastic: {
        In: function(a) {
            return 0 === a ? 0 : 1 === a ? 1 : -Math.pow(2, 10 * (a - 1)) * Math.sin(5 * (a - 1.1) * Math.PI)
        },
        Out: function(a) {
            return 0 === a ? 0 : 1 === a ? 1 : Math.pow(2, -10 * a) * Math.sin(5 * (a - .1) * Math.PI) + 1
        },
        InOut: function(a) {
            if (0 === a) return 0;
            if (1 === a) return 1;
            a *= 2;
            return 1 > a ? -.5 * Math.pow(2, 10 * (a - 1)) * Math.sin(5 *
                (a - 1.1) * Math.PI) : .5 * Math.pow(2, -10 * (a - 1)) * Math.sin(5 * (a - 1.1) * Math.PI) + 1
        }
    },
    Back: {
        In: function(a) {
            return a * a * (2.70158 * a - 1.70158)
        },
        Out: function(a) {
            return --a * a * (2.70158 * a + 1.70158) + 1
        },
        InOut: function(a) {
            return 1 > (a *= 2) ? .5 * a * a * (3.5949095 * a - 2.5949095) : .5 * ((a -= 2) * a * (3.5949095 * a + 2.5949095) + 2)
        }
    },
    Bounce: {
        In: function(a) {
            return 1 - module$node_modules$$tweenjs$tween_js$src$Tween.default.Easing.Bounce.Out(1 - a)
        },
        Out: function(a) {
            return a < 1 / 2.75 ? 7.5625 * a * a : a < 2 / 2.75 ? 7.5625 * (a -= 1.5 / 2.75) * a + .75 : a < 2.5 / 2.75 ? 7.5625 * (a -= 2.25 /
                2.75) * a + .9375 : 7.5625 * (a -= 2.625 / 2.75) * a + .984375
        },
        InOut: function(a) {
            return .5 > a ? .5 * module$node_modules$$tweenjs$tween_js$src$Tween.default.Easing.Bounce.In(2 * a) : .5 * module$node_modules$$tweenjs$tween_js$src$Tween.default.Easing.Bounce.Out(2 * a - 1) + .5
        }
    }
};
module$node_modules$$tweenjs$tween_js$src$Tween.default.Interpolation = {
    Linear: function(a, b) {
        var c = a.length - 1,
            d = c * b,
            e = Math.floor(d),
            f = module$node_modules$$tweenjs$tween_js$src$Tween.default.Interpolation.Utils.Linear;
        return 0 > b ? f(a[0], a[1], d) : 1 < b ? f(a[c], a[c - 1], c - d) : f(a[e], a[e + 1 > c ? c : e + 1], d - e)
    },
    Bezier: function(a, b) {
        for (var c = 0, d = a.length - 1, e = Math.pow, f = module$node_modules$$tweenjs$tween_js$src$Tween.default.Interpolation.Utils.Bernstein, g = 0; g <= d; g++) c += e(1 - b, d - g) * e(b, g) * a[g] * f(d, g);
        return c
    },
    CatmullRom: function(a,
        b) {
        var c = a.length - 1,
            d = c * b,
            e = Math.floor(d),
            f = module$node_modules$$tweenjs$tween_js$src$Tween.default.Interpolation.Utils.CatmullRom;
        return a[0] === a[c] ? (0 > b && (e = Math.floor(d = c * (1 + b))), f(a[(e - 1 + c) % c], a[e], a[(e + 1) % c], a[(e + 2) % c], d - e)) : 0 > b ? a[0] - (f(a[0], a[0], a[1], a[1], -d) - a[0]) : 1 < b ? a[c] - (f(a[c], a[c], a[c - 1], a[c - 1], d - c) - a[c]) : f(a[e ? e - 1 : 0], a[e], a[c < e + 1 ? c : e + 1], a[c < e + 2 ? c : e + 2], d - e)
    },
    Utils: {
        Linear: function(a, b, c) {
            return (b - a) * c + a
        },
        Bernstein: function(a, b) {
            var c = module$node_modules$$tweenjs$tween_js$src$Tween.default.Interpolation.Utils.Factorial;
            return c(a) / c(b) / c(a - b)
        },
        Factorial: function() {
            var a = [1];
            return function(b) {
                var c = 1;
                if (a[b]) return a[b];
                for (var d = b; 1 < d; d--) c *= d;
                return a[b] = c
            }
        }(),
        CatmullRom: function(a, b, c, d, e) {
            a = .5 * (c - a);
            d = .5 * (d - b);
            var f = e * e;
            return (2 * b - 2 * c + a + d) * e * f + (-3 * b + 3 * c - 2 * a - d) * f + a * e + b
        }
    }
};
var module$src$3d$shaders$ShaderFile = {
    default: {}
};
module$src$3d$shaders$ShaderFile.default.basic_vert = "\nvarying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n\n";
module$src$3d$shaders$ShaderFile.default.blend_frag = "\nuniform sampler2D tStandard;\nuniform sampler2D tBeauty;\t\t\nuniform vec2 size;\nuniform float amount;\n\nvarying vec2 vUv;\n\nvoid main() {\n\tgl_FragColor =  texture2D(tStandard, vUv) * (1.0-amount) + texture2D(tBeauty, vUv) * amount;\n}\n\n";
module$src$3d$shaders$ShaderFile.default.blur_frag = "\n#include <common>\n#include <packing>\n\nuniform sampler2D tAO;\nuniform sampler2D tDiffuse;\n\nuniform sampler2D tDepth;\n\nuniform float cameraNear;\nuniform float cameraFar;\nuniform vec2 size;\nuniform int orientation;\n\nuniform float sampleWeights[ KERNEL_RADIUS + 1 ];\n\nvarying vec2 vUv;\n\t\t\nconst float depthCutoff = 1.0;\n\nvoid main() {\n\tfloat depth = unpackRGBAToDepth( texture2D( tDepth, vUv ) );\n\tif( depth >= ( 1.0 - EPSILON ) ) {\n\t\tgl_FragColor = texture2D(tDiffuse, vUv);\n\t\treturn;\n\t}\n\n\tfloat centerViewZ = -perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n\tvec2 size = 1.0 / size;\n\n\tfloat weightSum = sampleWeights[0];\n\tvec4 sum = texture2D(tAO, vUv) * sampleWeights[0];\n\n\tvec2 position;\n\tfor(int i = 1; i <= KERNEL_RADIUS; i++){\n\t\tif(orientation == 0){\n\t\t\tposition = vec2(vUv.x - size.x*float(i), vUv.y);\n\t\t}else if(orientation == 1){\n\t\t\tposition = vec2(vUv.x, vUv.y - size.y*float(i));\n\t\t}\n\t\tfloat positionDepth = unpackRGBAToDepth( texture2D( tDepth, position ) );\n\t\tfloat viewZ = -perspectiveDepthToViewZ( positionDepth, cameraNear, cameraFar );\n\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) break;\n\t\tfloat weight = sampleWeights[i];\n\t\tsum += texture2D( tAO, position ) * weight;\n\t\tweightSum += weight;\n\t}\n\n\tfor(int i = 1; i <= KERNEL_RADIUS; i++){\n\t\tif(orientation == 0){\n\t\t\tposition = vec2(vUv.x + size.x*float(i), vUv.y);\n\t\t}else if(orientation == 1){\n\t\t\tposition = vec2(vUv.x, vUv.y + size.y*float(i));\n\t\t}\n\t\tfloat positionDepth = unpackRGBAToDepth( texture2D( tDepth, position ) );\n\t\tfloat viewZ = -perspectiveDepthToViewZ( positionDepth, cameraNear, cameraFar );\n\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) break;\n\t\tfloat weight = sampleWeights[i];\n\t\tsum += texture2D( tAO, position ) * weight;\n\t\tweightSum += weight;\n\t}\n\n\tif(orientation == 1){\n\t\tvec4 texel = texture2D(tDiffuse, vUv);\n\t\tgl_FragColor = (sum / weightSum) * texel;\n\t}else{\n\t\tgl_FragColor = (sum / weightSum);\n\t}\n}\n\n";
module$src$3d$shaders$ShaderFile.default.copy_frag = "\nuniform float opacity;\nuniform sampler2D tDiffuse;\n\nvarying vec2 vUv;\n\nvoid main() {\nvec4 texel = texture2D( tDiffuse, vUv );\ngl_FragColor = opacity * texel;\n}\n\n";
module$src$3d$shaders$ShaderFile.default.refl_frag = "uniform vec3 color;\nuniform sampler2D tDiffuse;\nuniform sampler2D tDepth;\nuniform vec3 worldPosition;\nuniform float far;\nuniform mat4 viewMatrixInv;\nvarying vec4 vUv;\nuniform float threshold;\n\nfloat blendOverlay( float base, float blend ) {\nreturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n}\n\nvec3 blendOverlay( vec3 base, vec3 blend ) {\nreturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n}\n\nfloat decompress(float a){\nreturn a < .5 ? -a * (far * 2.0) : (a-.5) * (far * 2.0);\n}\n\nvoid main() {\nfloat depth = ((decompress(texture2DProj(tDepth, vUv).a) - worldPosition.z) / far) * (1.0/threshold);\ngl_FragColor = vec4( blendOverlay( texture2DProj( tDiffuse, vUv ).rgb, color ), 1.0 - max(0.0, min(1.0, depth)) );\n}\n\n";
module$src$3d$shaders$ShaderFile.default.refl_vert = "uniform mat4 textureMatrix;\nvarying vec4 vUv;\n\nvoid main() {\n\tvUv = textureMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n\n";
module$src$3d$shaders$ShaderFile.default.sao_frag = "\n#include <common>\n#include <packing>\n\nvarying vec2 vUv;\n\nuniform sampler2D tDepth;\nuniform sampler2D tNormal;\n\nuniform float cameraNear;\nuniform float cameraFar;\nuniform mat4 cameraProjectionMatrix;\nuniform mat4 cameraInverseProjectionMatrix;\n\nuniform vec2 size;\nuniform float intensity;\nuniform float scale;\nuniform float kernelRadius;\n\nvec3 getViewPosition(const in vec2 screenPosition, const in float depth, const in float viewZ) {\n\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\n\tvec4 clipPosition = vec4((vec3(screenPosition, depth) - 0.5) * 2.0, 1.0);\n\tclipPosition *= clipW; // unprojection\n\n\treturn (cameraInverseProjectionMatrix * clipPosition).xyz;\n}\n\nfloat getOcclusion(const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition) {\n\tvec3 viewDelta = sampleViewPosition - centerViewPosition;\n\tfloat viewDistance = length(viewDelta);\n\tfloat scaledScreenDistance = scale * viewDistance;\n\treturn max(0.0, (dot(centerViewNormal, viewDelta))/scaledScreenDistance)/(1.0 + pow2(scaledScreenDistance));\n}\n\nfloat getAmbientOcclusion(const in vec3 centerViewPosition) {\n\tvec3 centerViewNormal = unpackRGBToNormal(texture2D(tNormal, vUv).xyz);\n\n\tfloat angle = rand(vUv) * PI2;\n\tvec2 radius = vec2(kernelRadius * (1.0/float(SAMPLES)))/size;\n\tvec2 radiusStep = radius;\n\tfloat occlusionSum = 0.0;\n\tfloat weightSum = 0.0;\n\tfloat angleStep = PI2 * 3.0/float(SAMPLES);\n\n\tfor(int i = 0; i < SAMPLES; i ++) {\n\t\tvec2 sampleUv = vUv + vec2(cos(angle), sin(angle)) * radius;\n\t\tradius += radiusStep;\n\t\tangle += PI2 * 3.0/float(SAMPLES);\n\n\t\tfloat sampleDepth = unpackRGBAToDepth(texture2D(tDepth, sampleUv));\n\t\tif(sampleDepth >= (1.0 - EPSILON)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tfloat sampleViewZ = perspectiveDepthToViewZ(sampleDepth, cameraNear, cameraFar);\n\t\tvec3 sampleViewPosition = getViewPosition(sampleUv, sampleDepth, sampleViewZ);\n\t\tocclusionSum += getOcclusion(centerViewPosition, centerViewNormal, sampleViewPosition);\n\t\tweightSum += 1.0;\n\t}\n\n\tif(weightSum == 0.0) discard;\n\n\treturn occlusionSum * (intensity/weightSum);\n}\n\nvoid main() {\n\tfloat centerDepth = unpackRGBAToDepth(texture2D(tDepth, vUv));\n\tif(centerDepth >= (1.0 - EPSILON)) {\n\t\tdiscard;\n\t}\n\tfloat centerViewZ = perspectiveDepthToViewZ(centerDepth, cameraNear, cameraFar);\n\tvec3 viewPosition = getViewPosition(vUv, centerDepth, centerViewZ);\n\tfloat ao = 1.0 - getAmbientOcclusion(viewPosition);\n\tgl_FragColor = vec4(ao, ao, ao, 1);\n}\n\n";
module$src$3d$shaders$ShaderFile.default.simple_blur_frag = "\nuniform sampler2D tDiffuse;\nuniform sampler2D tAO;\t\t\nuniform vec2 size;\nuniform int orientation;\n\nvarying vec2 vUv;\n\nvoid main() {\n\tvec4 sum = vec4( 0.0 );\n\tvec2 or = vec2(0,0);\n\n\tif(orientation==0){\n\t\tor = vec2(1,0);\n\t}else{\n\t\tor = vec2(0,1);\n\t}\n\tvec2 off = vec2(3.2307692308) * or;\n\tsum += texture2D(tAO, vUv) * 0.29411764705882354;\n\tsum += texture2D(tAO, vUv + (off / size)) * 0.35294117647058826;\n\tsum += texture2D(tAO, vUv - (off / size)) * 0.35294117647058826;\n\t\n\tif(orientation == 1){\n\t\tgl_FragColor =  texture2D( tDiffuse, vUv );\n\t\tgl_FragColor.xyz *= sum.x;\n\t}else{\n\t\tgl_FragColor = sum;\n\t}\n}\n\n";
module$src$3d$shaders$ShaderFile.default.standard_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\nuniform float clearCoat;\nuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#endif\nvarying vec4 worldPos;\n\nuniform float shadowOpacity;\nuniform float lightReflectivity;\n\nuniform float threeDNoiseScale;\nuniform float threeDNoiseDistanceFade;\nuniform float threeDNoiseOpacity;\nfloat threeDAmbient = 1.0;\n\n#ifdef USE_ADDITIONAL_MAPS\n#define MAPCOUNT 5\nuniform int mapsSize;\nuniform sampler2D additionalMaps0;\nuniform sampler2D additionalMaps1;\nuniform sampler2D additionalMaps2;\nuniform sampler2D additionalMaps3;\nuniform sampler2D additionalMaps4;\nuniform int mapPropertyType[MAPCOUNT];\nuniform vec3 mapPropertyColor[MAPCOUNT];\nvarying vec2 vUvAddMap[MAPCOUNT];\n#endif\n\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#if defined( USE_MAP )\nvarying vec2 vUvMap;\n#endif\n#if defined( USE_BUMPMAP )\nvarying vec2 vUvBumpMap;\n#endif\n#if defined( USE_NORMALMAP )\nvarying vec2 vUvNormalMap;\n#endif\n#if defined( USE_SPECULARMAP )\nvarying vec2 vUvSpecularMap;\n#endif\n#if defined( USE_ALPHAMAP )\nvarying vec2 vUvAlphaMap;\n#endif\n#if defined( USE_EMISSIVEMAP )\nvarying vec2 vUvEmissiveMap;\n#endif\n#if defined( USE_ROUGHNESSMAP )\nvarying vec2 vUvRoughnessMap;\n#endif\n#if defined( USE_METALNESSMAP )\nvarying vec2 vUvMetalnessMap;\n#endif\n\n\n\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#ifdef USE_3D_NOISE\n\tvec3 random3(vec3 c) {\n\t\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\t\tvec3 r;\n\t\tr.z = fract(512.0*j);\n\t\tj *= .125;\n\t\tr.x = fract(512.0*j);\n\t\tj *= .125;\n\t\tr.y = fract(512.0*j);\n\t\treturn r-0.5;\n\t}\n\n\tconst float F3 =  0.3333333;\n\tconst float G3 =  0.1666667;\n\tfloat snoise(vec3 p) {\n\t\tvec3 s = floor(p + dot(p, vec3(F3)));\n\t\tvec3 x = p - s + dot(s, vec3(G3));\n\t\t\n\t\tvec3 e = step(vec3(0.0), x - x.yzx);\n\t\tvec3 i1 = e*(1.0 - e.zxy);\n\t\tvec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t\t\t\n\t\tvec3 x1 = x - i1 + G3;\n\t\tvec3 x2 = x - i2 + 2.0*G3;\n\t\tvec3 x3 = x - 1.0 + 3.0*G3;\n\n\t\tvec4 w = vec4(dot(x, x), dot(x1, x1), dot(x2, x2), dot(x3, x3));\t\t\n\t\tw = max(0.6 - w, 0.0);\n\t\tw = w*w*w;\n\n\t\tvec4 d = vec4(dot(random3(s), x), dot(random3(s + i1), x1), dot(random3(s + i2), x2), dot(random3(s + 1.0), x3)) * w;\n\t\treturn dot(d, vec4(52.0));\n\t}\n#endif\n\n#ifdef USE_3D_NOISE_F999\n\tvec3 noise(vec3 m) { return vec3(0); }\n#endif\n\n#ifdef USE_3D_NOISE_F0\n\tvec3 noise(vec3 m) {\n\t\tvec3 i, n;\n\t\ti = m.xzx + m.y;\n\t\tn.x = snoise(i);\n\t\ti = m.yzy + m.x;\n\t\tn.y = snoise(i);\n\t\ti = m.zxy;\n\t\tn.z = snoise(i);\n\t\treturn normalize(n);\n\t}\n#endif\n\n#ifdef USE_3D_NOISE_F1\n\tvec3 noise(vec3 m) {\n\t\tvec3 i = m;\n\t\tm.x = snoise(i);\n\t\ti = vec3(m.yzx);\n\t\tm.y = snoise(i);\n\t\tm.z = cos(m.z*5.0);\n\t\treturn normalize(m);\n\t}\n#endif\n\n#ifdef USE_3D_NOISE_F2\n\tvec3 noise(vec3 m) {\n\t\tm.x = 0.3333333* cos(m.z);\n\t\tm.y = 0.3333333* sin(m.z)+snoise(vec3(m.z));\n\t\tm.z = 0.3333333* cos(m.z*5.0);\n\t\treturn normalize(m);\n\t}\n#endif\n\n#ifdef USE_3D_NOISE_F3\n\tvec3 noise(vec3 m) {\n\t\tvec3 i = vec3( m.z);\n\t\tm.x = 0.1333333* snoise(4.0*i);\n\t\ti = vec3(m.yzx);\n\t\tm.y = 0.05333333* snoise(4.0*i);\n\t\ti = vec3(m.zxy);\n\t\tm.z = 0.1333333* snoise(4.0*i);\n\t\treturn normalize(m);\n\t}\n#endif\n\n\n#include <lights_pars_begin>\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\nvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\nvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n#ifdef ENVMAP_TYPE_CUBE\nvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n#ifdef LOD_BLACK_LIST\nvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n#else\n#ifdef TEXTURE_LOD_EXT\nvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n#else\nvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n#endif\n#endif\nenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\nvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\nvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n#else\nvec4 envMapColor = vec4( 0.0 );\n#endif\nreturn PI * envMapColor.rgb * envMapIntensity;\n}\nfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\nfloat maxMIPLevelScalar = float( maxMIPLevel );\nfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\nreturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n}\nvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n#ifdef ENVMAP_MODE_REFLECTION\nvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n#else\nvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n#endif\nreflectVec = inverseTransformDirection( reflectVec, viewMatrix );\nfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n#ifdef ENVMAP_TYPE_CUBE\nvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n#ifdef LOD_BLACK_LIST\nvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n#else\n#ifdef TEXTURE_LOD_EXT\nvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n#else\nvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n#endif\n#endif\nenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\nvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\nvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n#elif defined( ENVMAP_TYPE_EQUIREC )\nvec2 sampleUV;\nsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\nsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n#ifdef LOD_BLACK_LIST\nvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n#else\n#ifdef TEXTURE_LOD_EXT\nvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n#else\nvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n#endif\n#endif\n\nenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n#elif defined( ENVMAP_TYPE_SPHERE )\nvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n#ifdef LOD_BLACK_LIST\nvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n#else\n#ifdef TEXTURE_LOD_EXT\nvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n#else\nvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n#endif\n#endif\nenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n#endif\nreturn envMapColor.rgb * envMapIntensity;\n}\n#endif\n\n\n#include <lights_physical_pars_fragment>\nuniform float lightWorldSize;\nuniform float lightFrustum;\n\n#ifdef USE_SHADOWMAP\n#ifdef USE_PCSS_SHADOW\n#define softShadowSamples 20\n#define near 25.0\nvec2 poissonDisk[softShadowSamples];\n\nvoid initPoissonSamples(const in vec2 randomSeed) {\nfloat angleStep = PI2 * 11.0/float(softShadowSamples);\nfloat angle = rand(randomSeed) * PI2;\nfloat radius = 1.0/float(softShadowSamples);\n\nfor(int i = 0; i < softShadowSamples; i ++) {\npoissonDisk[i] = vec2(cos(angle), sin(angle)) * pow(radius, 0.75);\nradius += 1.0/float(softShadowSamples);\nangle += angleStep;\n}\n}\n\nfloat penumbraSize(const in float zReceiver, const in float zBlocker) {\nreturn (zReceiver - zBlocker)/zBlocker;\n}\n\nfloat findBlocker(sampler2D shadowMap, const in vec2 uv, const in float zReceiver) {\nfloat searchRadius = (lightWorldSize/lightFrustum) * (zReceiver - near)/zReceiver;\nfloat blockerDepthSum = 0.0;\nint numBlockers = 0;\n\nfor(int i = 0; i < softShadowSamples; i++) {\nfloat shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\nif (shadowMapDepth < zReceiver) {\nblockerDepthSum += shadowMapDepth;\nnumBlockers ++;\n}\n}\n\nif(numBlockers == 0) return -1.0;\nreturn blockerDepthSum/float(numBlockers);\n}\n\nfloat PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius) {\nfloat sum = 0.0;\nfor(int i = 0; i < softShadowSamples; i ++) {\nfloat depth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[ i ] * filterRadius));\nif(zReceiver <= depth) sum += 1.0;\n}\nfor(int i = 0; i < softShadowSamples; i ++) {\nfloat depth = unpackRGBAToDepth(texture2D(shadowMap, uv + -poissonDisk[ i ].yx * filterRadius));\nif(zReceiver <= depth) sum += 1.0;\n}\nreturn sum/(2.0 * float(softShadowSamples));\n}\n\nfloat PCSS (sampler2D shadowMap, vec4 coords) {\nvec2 uv = coords.xy;\nfloat zReceiver = coords.z;\n\ninitPoissonSamples(uv);\nfloat avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver);\n\nif(avgBlockerDepth == -1.0) return 1.0;\n\nfloat penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);\nfloat filterRadius = penumbraRatio * (lightWorldSize/lightFrustum) * near/zReceiver;\n\nreturn PCF_Filter(shadowMap, uv, zReceiver, filterRadius);\n}\n#endif\n\n#if NUM_DIR_LIGHTS > 0\nuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\nvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n#endif\n#if NUM_SPOT_LIGHTS > 0\nuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\nvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n#endif\n#if NUM_POINT_LIGHTS > 0\nuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\nvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n#endif\nfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\nreturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n}\nfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\nconst vec2 offset = vec2( 0.0, 1.0 );\nvec2 texelSize = vec2( 1.0 ) / size;\nvec2 centroidUV = floor( uv * size + 0.5 ) / size;\nfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\nfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\nfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\nfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\nvec2 f = fract( uv * size + 0.5 );\nfloat a = mix( lb, lt, f.y );\nfloat b = mix( rb, rt, f.y );\nfloat c = mix( a, b, f.x );\nreturn c;\n}\nfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\nshadowCoord.xyz /= shadowCoord.w;\nshadowCoord.z += shadowBias;\nbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\nbool inFrustum = all( inFrustumVec );\nbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\nbool frustumTest = all( frustumTestVec );\nif ( frustumTest ) {\n#if defined(USE_PCSS_SHADOW)\nreturn PCSS(shadowMap, shadowCoord);\n#elif defined( SHADOWMAP_TYPE_PCF )\nvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\nfloat dx0 = - texelSize.x * shadowRadius;\nfloat dy0 = - texelSize.y * shadowRadius;\nfloat dx1 = + texelSize.x * shadowRadius;\nfloat dy1 = + texelSize.y * shadowRadius;\nreturn (\ntexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\ntexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\ntexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\ntexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\ntexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\ntexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\ntexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\ntexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\ntexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n) * ( 1.0 / 9.0 );\n#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\nvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\nfloat dx0 = - texelSize.x * shadowRadius;\nfloat dy0 = - texelSize.y * shadowRadius;\nfloat dx1 = + texelSize.x * shadowRadius;\nfloat dy1 = + texelSize.y * shadowRadius;\nreturn (\ntexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\ntexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\ntexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\ntexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\ntexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\ntexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\ntexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\ntexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\ntexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n) * ( 1.0 / 9.0 );\n#else\nreturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n#endif\n}\nreturn 1.0;\n}\nvec2 cubeToUV( vec3 v, float texelSizeY ) {\nvec3 absV = abs( v );\nfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\nabsV *= scaleToCube;\nv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\nvec2 planar = v.xy;\nfloat almostATexel = 1.5 * texelSizeY;\nfloat almostOne = 1.0 - almostATexel;\nif ( absV.z >= almostOne ) {\nif ( v.z > 0.0 )\nplanar.x = 4.0 - v.x;\n} else if ( absV.x >= almostOne ) {\nfloat signX = sign( v.x );\nplanar.x = v.z * signX + 2.0 * signX;\n} else if ( absV.y >= almostOne ) {\nfloat signY = sign( v.y );\nplanar.x = v.x + 2.0 * signY + 2.0;\nplanar.y = v.z * signY - 2.0;\n}\nreturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n}\nfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\nvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\nvec3 lightToPosition = shadowCoord.xyz;\nvec3 bd3D = normalize( lightToPosition );\nfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\nvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\nreturn (\ntexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\ntexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\ntexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\ntexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\ntexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\ntexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\ntexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\ntexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\ntexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n) * ( 1.0 / 9.0 );\n#else\nreturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n#endif\n}\n#endif\n\n\n#ifdef USE_BUMPMAP\nuniform sampler2D bumpMap;\nuniform float bumpScale;\nvec2 dHdxy_fwd() {\nvec2 dSTdx = dFdx( vUvBumpMap );\nvec2 dSTdy = dFdy( vUvBumpMap );\nfloat Hll = bumpScale * texture2D( bumpMap, vUvBumpMap ).x;\nfloat dBx = bumpScale * texture2D( bumpMap, vUvBumpMap + dSTdx ).x - Hll;\nfloat dBy = bumpScale * texture2D( bumpMap, vUvBumpMap + dSTdy ).x - Hll;\nreturn vec2( dBx, dBy );\n}\nvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\nvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\nvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\nvec3 vN = surf_norm;\nvec3 R1 = cross( vSigmaY, vN );\nvec3 R2 = cross( vN, vSigmaX );\nfloat fDet = dot( vSigmaX, R1 );\nvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\nreturn normalize( abs( fDet ) * surf_norm - vGrad );\n}\n#endif\n\n\n#ifdef USE_NORMALMAP\nuniform sampler2D normalMap;\nuniform vec2 normalScale;\nvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\nvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\nvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\nvec2 st0 = dFdx( vUvNormalMap.st );\nvec2 st1 = dFdy( vUvNormalMap.st );\nvec3 S = normalize( q0 * st1.t - q1 * st0.t );\nvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\nvec3 N = normalize( surf_norm );\nvec3 mapN = texture2D( normalMap, vUvNormalMap ).xyz * 2.0 - 1.0;\nmapN.xy = normalScale * mapN.xy;\nmat3 tsn = mat3( S, T, N );\nreturn normalize( tsn * mapN );\n}\n#endif\n\n\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4(diffuse, opacity);\n\tReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n\tvec3 totalEmissiveRadiance = emissive;\n#include <logdepthbuf_fragment>\n#ifdef USE_COLOR\ndiffuseColor.rgb = vColor;\n#endif\n\n\n#ifdef USE_ADDITIONAL_MAPS\nfor(int i = 0; i < MAPCOUNT; i++){\nif(i >= mapsSize) break;\n\nvec4 texelColorAdd;\nif(i == 0){\ntexelColorAdd = texture2D( additionalMaps0, vUvAddMap[i]);\n}else if(i == 1){\ntexelColorAdd = texture2D( additionalMaps1, vUvAddMap[i]);\n}else if(i == 2){\ntexelColorAdd = texture2D( additionalMaps2, vUvAddMap[i]);\n}else if(i == 3){\ntexelColorAdd = texture2D( additionalMaps3, vUvAddMap[i]);\n}else if(i == 4){\ntexelColorAdd = texture2D( additionalMaps4, vUvAddMap[i]);\n}\n\ntexelColorAdd = mapTexelToLinear( texelColorAdd );\n\nif(mapPropertyType[i] == 0){\ndiffuseColor = texelColorAdd.a * vec4(texelColorAdd.rgb, 1.0) + (1.0 - texelColorAdd.a) * diffuseColor;\n}else if(mapPropertyType[i] == 1){\ndiffuseColor = texelColorAdd.a * vec4(mapPropertyColor[i], 1.0) + (1.0 - texelColorAdd.a) * diffuseColor;\n}\n}\n#endif\n\n#ifdef USE_MAP\nvec4 texelColor = texture2D( map, vUvMap );\ntexelColor = mapTexelToLinear( texelColor );\n\ndiffuseColor *= texelColor;\n#endif\n\n\n#ifdef USE_ALPHAMAP\ndiffuseColor.a *= texture2D( alphaMap, vUvAlphaMap ).g;\n#endif\n\n\n#include <alphatest_fragment>\nfloat roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\nvec4 texelRoughness = texture2D( roughnessMap, vUvRoughnessMap );\nroughnessFactor *= texelRoughness.g;\n#endif\n\n\nfloat metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\nvec4 texelMetalness = texture2D( metalnessMap, vUvMetalnessMap );\nmetalnessFactor *= texelMetalness.b;\n#endif\n\n\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\n#ifdef USE_3D_NOISE\nvec3 threeDNoise = noise(worldPos.xyz / threeDNoiseScale);\nfloat op = threeDNoiseOpacity * (1.0 / (1.0 + vViewPosition.z * threeDNoiseDistanceFade));\nfloat dotP = dot(normal, threeDNoise);\nif(dotP < 0.0) threeDNoise *= -1.0;\n\ndotP = abs(dotP);\n\nnormal = (1.0 - op) * normal + op * threeDNoise;\nroughnessFactor += ((1.0 - roughnessFactor) * (1.0 - dotP)) * op;\nmetalnessFactor *= (1.0 - dotP * op);\n\nthreeDAmbient = min(1.0, (1.0 - op) + dotP * op);\ndiffuseColor.rgb *= min(1.0, (1.0 - op) + dotP * op);\n#endif\n\n\n#include <lights_physical_fragment>\nGeometricContext geometry;\ngeometry.position = -vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize(vViewPosition);\nIncidentLight directLight;\nfloat invShadowAmount;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\nPointLight pointLight;\nfor (int i = 0; i < NUM_POINT_LIGHTS; i++) {\n\tpointLight = pointLights[i];\n\tgetPointDirectLightIrradiance(pointLight, geometry, directLight);\n#ifdef USE_SHADOWMAP\n\tdirectLight.color *= all(bvec2(pointLight.shadow, directLight.visible)) ? getPointShadow(pointShadowMap[i], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[i]) : 1.0;\n#endif\n\tRE_Direct(directLight, geometry, material, reflectedLight);\n}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\nSpotLight spotLight;\nfor (int i = 0; i < NUM_SPOT_LIGHTS; i++) {\n\tspotLight = spotLights[i];\n\tgetSpotDirectLightIrradiance(spotLight, geometry, directLight);\n#ifdef USE_SHADOWMAP\n\tinvShadowAmount = all(bvec2(spotLight.shadow, directLight.visible)) ? getShadow(spotShadowMap[i], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[i]) : 1.0;\n\tdirectLight.color *= min((invShadowAmount + (1.0 - shadowOpacity)), 1.0);\n#endif\n\tRE_Direct(directLight, geometry, material, reflectedLight);\n}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\nDirectionalLight directionalLight;\nfor (int i = 0; i < NUM_DIR_LIGHTS; i++) {\n\tdirectionalLight = directionalLights[i];\n\tgetDirectionalDirectLightIrradiance(directionalLight, geometry, directLight);\n#ifdef USE_SHADOWMAP\n\tinvShadowAmount = all(bvec2(directionalLight.shadow, directLight.visible)) ? getShadow(directionalShadowMap[i], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[i]) : 1.0;\n\tdirectLight.color *= min((invShadowAmount + (1.0 - shadowOpacity)), 1.0);\n#endif\n\tRE_Direct(directLight, geometry, material, reflectedLight);\n}\n#endif\n#if (NUM_RECT_AREA_LIGHTS > 0) && defined(RE_Direct_RectArea)\nRectAreaLight rectAreaLight;\nfor (int i = 0; i < NUM_RECT_AREA_LIGHTS; i++) {\n\trectAreaLight = rectAreaLights[i];\n\tRE_Direct_RectArea(rectAreaLight, geometry, material, reflectedLight);\n}\n#endif\n#if defined(RE_IndirectDiffuse)\nvec3 irradiance = getAmbientLightIrradiance(ambientLightColor);\n#if (NUM_HEMI_LIGHTS > 0)\nfor (int i = 0; i < NUM_HEMI_LIGHTS; i++) {\n\tirradiance += getHemisphereLightIrradiance(hemisphereLights[i], geometry);\n}\n#endif\n#endif\n#if defined(RE_IndirectSpecular)\nvec3 radiance = vec3(0.0);\nvec3 clearCoatRadiance = vec3(0.0);\n#endif\n\n\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#include <aomap_fragment>\n\n#ifdef USE_3D_NOISE\n\treflectedLight.indirectDiffuse *= threeDAmbient;\n#endif\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular * lightReflectivity + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4(outgoingLight, diffuseColor.a);\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <dithering_fragment>\n}\n\n";
module$src$3d$shaders$ShaderFile.default.standard_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nvarying vec4 worldPos;\n#include <common>\n#if defined( USE_MAP )\nvarying vec2 vUvMap;\nuniform mat3 uvTransformMap;\n#endif\n#if defined( USE_BUMPMAP )\nvarying vec2 vUvBumpMap;\nuniform mat3 uvTransformBumpMap;\n#endif\n#if defined( USE_NORMALMAP )\nvarying vec2 vUvNormalMap;\nuniform mat3 uvTransformNormalMap;\n#endif\n#if defined( USE_SPECULARMAP )\nvarying vec2 vUvSpecularMap;\nuniform mat3 uvTransformSpecularMap;\n#endif\n#if defined( USE_ALPHAMAP )\nvarying vec2 vUvAlphaMap;\nuniform mat3 uvTransformAlphaMap;\n#endif\n#if defined( USE_EMISSIVEMAP )\nvarying vec2 vUvEmissiveMap;\nuniform mat3 uvTransformEmissiveMap;\n#endif\n#if defined( USE_ROUGHNESSMAP )\nvarying vec2 vUvRoughnessMap;\nuniform mat3 uvTransformRoughnessMap;\n#endif\n#if defined( USE_METALNESSMAP )\nvarying vec2 vUvMetalnessMap;\nuniform mat3 uvTransformMetalnessMap;\n#endif\n\n#ifdef USE_ADDITIONAL_MAPS\n#define MAPCOUNT 5\nuniform int mapsSize;\nuniform mat3 uvTransformAddMap[MAPCOUNT];\nvarying vec2 vUvAddMap[MAPCOUNT];\n#endif\n\n\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n#if defined( USE_MAP )\n\tvUvMap = (uvTransformMap * vec3(uv, 1)).xy;\n#endif\n#if defined( USE_BUMPMAP )\nvUvBumpMap = (uvTransformBumpMap * vec3(uv, 1)).xy;\n#endif\n#if defined( USE_NORMALMAP )\nvUvNormalMap = (uvTransformNormalMap * vec3(uv, 1)).xy;\n#endif\n#if defined( USE_SPECULARMAP )\n\tvUvSpecularMap = (uvTransformSpecularMap * vec3(uv, 1)).xy;\n#endif\n#if defined( USE_ALPHAMAP )\n\tvUvAlphaMap = (uvTransformAlphaMap * vec3(uv, 1)).xy;\n#endif\n#if defined( USE_EMISSIVEMAP )\n\tvUvEmissiveMap = (uvTransformEmissiveMap * vec3(uv, 1)).xy;\n#endif\n#if defined( USE_ROUGHNESSMAP )\n\tvUvRoughnessMap = (uvTransformRoughnessMap * vec3(uv, 1)).xy;\n#endif\n#if defined( USE_METALNESSMAP )\n\tvUvMetalnessMap = (uvTransformMetalnessMap * vec3(uv, 1)).xy;\n#endif\n\n#ifdef USE_ADDITIONAL_MAPS\n\tfor(int i = 0; i < MAPCOUNT; i++){\n\t\tif(i >= mapsSize) break;\n\t\tvUvAddMap[i] = (uvTransformAddMap[i] * vec3(uv, 1)).xy;\n\t}\n#endif\n\n\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#include <shadowmap_vertex>\n\tworldPos = worldPosition;\n}\n\n";
module$src$3d$shaders$ShaderFile.default.world_z_frag = "varying vec4 position_VS;\nuniform float far;\n\nfloat compress(float a){\nreturn a < 0.0 ? -a / (2.0 * far) : a / (2.0 * far) + .5;\n}\n\nvoid main() {\n\tgl_FragColor = vec4(1,1,1, compress(position_VS.z));\n}\n\n";
module$src$3d$shaders$ShaderFile.default.world_z_vert = "varying vec4 position_VS;\n\nvoid main() {\nposition_VS = modelMatrix * vec4( position, 1.0 );\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n\n";
var module$node_modules$three$build$three = {
    default: {}
};
module$node_modules$three$build$three.default.EventDispatcher = function() {};
module$node_modules$three$build$three.default.Vector2 = function(a, b) {
    this.x = a || 0;
    this.y = b || 0
};
module$node_modules$three$build$three.default.Matrix4 = function() {
    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
};
module$node_modules$three$build$three.default.Quaternion = function(a, b, c, d) {
    this._x = a || 0;
    this._y = b || 0;
    this._z = c || 0;
    this._w = void 0 !== d ? d : 1
};
module$node_modules$three$build$three.default.Vector3 = function(a, b, c) {
    this.x = a || 0;
    this.y = b || 0;
    this.z = c || 0
};
module$node_modules$three$build$three.default.Matrix3 = function() {
    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
};
module$node_modules$three$build$three.default.Texture = function(a, b, c, d, e, f, g, h, k, l) {
    Object.defineProperty(this, "id", {
        value: textureId$$module$node_modules$three$build$three++
    });
    this.uuid = module$node_modules$three$build$three.default.Math.generateUUID();
    this.name = "";
    this.image = void 0 !== a ? a : module$node_modules$three$build$three.default.Texture.DEFAULT_IMAGE;
    this.mipmaps = [];
    this.mapping = void 0 !== b ? b : module$node_modules$three$build$three.default.Texture.DEFAULT_MAPPING;
    this.wrapS = void 0 !== c ? c : module$node_modules$three$build$three.default.ClampToEdgeWrapping;
    this.wrapT = void 0 !== d ? d : module$node_modules$three$build$three.default.ClampToEdgeWrapping;
    this.magFilter = void 0 !== e ? e : module$node_modules$three$build$three.default.LinearFilter;
    this.minFilter = void 0 !== f ? f : module$node_modules$three$build$three.default.LinearMipMapLinearFilter;
    this.anisotropy = void 0 !== k ? k : 1;
    this.format = void 0 !== g ? g : module$node_modules$three$build$three.default.RGBAFormat;
    this.type = void 0 !== h ? h : module$node_modules$three$build$three.default.UnsignedByteType;
    this.offset = new module$node_modules$three$build$three.default.Vector2(0,
        0);
    this.repeat = new module$node_modules$three$build$three.default.Vector2(1, 1);
    this.center = new module$node_modules$three$build$three.default.Vector2(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = !0;
    this.matrix = new module$node_modules$three$build$three.default.Matrix3;
    this.generateMipmaps = !0;
    this.premultiplyAlpha = !1;
    this.flipY = !0;
    this.unpackAlignment = 4;
    this.encoding = void 0 !== l ? l : module$node_modules$three$build$three.default.LinearEncoding;
    this.version = 0;
    this.onUpdate = null
};
module$node_modules$three$build$three.default.Vector4 = function(a, b, c, d) {
    this.x = a || 0;
    this.y = b || 0;
    this.z = c || 0;
    this.w = void 0 !== d ? d : 1
};
module$node_modules$three$build$three.default.WebGLRenderTarget = function(a, b, c) {
    this.width = a;
    this.height = b;
    this.scissor = new module$node_modules$three$build$three.default.Vector4(0, 0, a, b);
    this.scissorTest = !1;
    this.viewport = new module$node_modules$three$build$three.default.Vector4(0, 0, a, b);
    c = c || {};
    void 0 === c.minFilter && (c.minFilter = module$node_modules$three$build$three.default.LinearFilter);
    this.texture = new module$node_modules$three$build$three.default.Texture(void 0, void 0, c.wrapS, c.wrapT, c.magFilter,
        c.minFilter, c.format, c.type, c.anisotropy, c.encoding);
    this.texture.generateMipmaps = void 0 !== c.generateMipmaps ? c.generateMipmaps : !0;
    this.depthBuffer = void 0 !== c.depthBuffer ? c.depthBuffer : !0;
    this.stencilBuffer = void 0 !== c.stencilBuffer ? c.stencilBuffer : !0;
    this.depthTexture = void 0 !== c.depthTexture ? c.depthTexture : null
};
module$node_modules$three$build$three.default.WebGLRenderTargetCube = function(a, b, c) {
    module$node_modules$three$build$three.default.WebGLRenderTarget.call(this, a, b, c);
    this.activeMipMapLevel = this.activeCubeFace = 0
};
module$node_modules$three$build$three.default.DataTexture = function(a, b, c, d, e, f, g, h, k, l, p, m) {
    module$node_modules$three$build$three.default.Texture.call(this, null, f, g, h, k, l, d, e, p, m);
    this.image = {
        data: a,
        width: b,
        height: c
    };
    this.magFilter = void 0 !== k ? k : module$node_modules$three$build$three.default.NearestFilter;
    this.minFilter = void 0 !== l ? l : module$node_modules$three$build$three.default.NearestFilter;
    this.flipY = this.generateMipmaps = !1;
    this.unpackAlignment = 1
};
module$node_modules$three$build$three.default.Box3 = function(a, b) {
    this.min = void 0 !== a ? a : new module$node_modules$three$build$three.default.Vector3(Infinity, Infinity, Infinity);
    this.max = void 0 !== b ? b : new module$node_modules$three$build$three.default.Vector3(-Infinity, -Infinity, -Infinity)
};
module$node_modules$three$build$three.default.Sphere = function(a, b) {
    this.center = void 0 !== a ? a : new module$node_modules$three$build$three.default.Vector3;
    this.radius = void 0 !== b ? b : 0
};
module$node_modules$three$build$three.default.Plane = function(a, b) {
    this.normal = void 0 !== a ? a : new module$node_modules$three$build$three.default.Vector3(1, 0, 0);
    this.constant = void 0 !== b ? b : 0
};
module$node_modules$three$build$three.default.Frustum = function(a, b, c, d, e, f) {
    this.planes = [void 0 !== a ? a : new module$node_modules$three$build$three.default.Plane, void 0 !== b ? b : new module$node_modules$three$build$three.default.Plane, void 0 !== c ? c : new module$node_modules$three$build$three.default.Plane, void 0 !== d ? d : new module$node_modules$three$build$three.default.Plane, void 0 !== e ? e : new module$node_modules$three$build$three.default.Plane, void 0 !== f ? f : new module$node_modules$three$build$three.default.Plane]
};
module$node_modules$three$build$three.default.Color = function(a, b, c) {
    return void 0 === b && void 0 === c ? this.set(a) : this.setRGB(a, b, c)
};
module$node_modules$three$build$three.default.Euler = function(a, b, c, d) {
    this._x = a || 0;
    this._y = b || 0;
    this._z = c || 0;
    this._order = d || module$node_modules$three$build$three.default.Euler.DefaultOrder
};
module$node_modules$three$build$three.default.Layers = function() {
    this.mask = 1
};
module$node_modules$three$build$three.default.Object3D = function() {
    Object.defineProperty(this, "id", {
        value: object3DId$$module$node_modules$three$build$three++
    });
    this.uuid = module$node_modules$three$build$three.default.Math.generateUUID();
    this.name = "";
    this.type = "Object3D";
    this.parent = null;
    this.children = [];
    this.up = module$node_modules$three$build$three.default.Object3D.DefaultUp.clone();
    var a = new module$node_modules$three$build$three.default.Vector3,
        b = new module$node_modules$three$build$three.default.Euler,
        c = new module$node_modules$three$build$three.default.Quaternion,
        d = new module$node_modules$three$build$three.default.Vector3(1, 1, 1);
    b.onChange(function() {
        c.setFromEuler(b, !1)
    });
    c.onChange(function() {
        b.setFromQuaternion(c, void 0, !1)
    });
    Object.defineProperties(this, {
        position: {
            enumerable: !0,
            value: a
        },
        rotation: {
            enumerable: !0,
            value: b
        },
        quaternion: {
            enumerable: !0,
            value: c
        },
        scale: {
            enumerable: !0,
            value: d
        },
        modelViewMatrix: {
            value: new module$node_modules$three$build$three.default.Matrix4
        },
        normalMatrix: {
            value: new module$node_modules$three$build$three.default.Matrix3
        }
    });
    this.matrix = new module$node_modules$three$build$three.default.Matrix4;
    this.matrixWorld = new module$node_modules$three$build$three.default.Matrix4;
    this.matrixAutoUpdate = module$node_modules$three$build$three.default.Object3D.DefaultMatrixAutoUpdate;
    this.matrixWorldNeedsUpdate = !1;
    this.layers = new module$node_modules$three$build$three.default.Layers;
    this.visible = !0;
    this.receiveShadow = this.castShadow = !1;
    this.frustumCulled = !0;
    this.renderOrder = 0;
    this.userData = {}
};
module$node_modules$three$build$three.default.Camera = function() {
    module$node_modules$three$build$three.default.Object3D.call(this);
    this.type = "Camera";
    this.matrixWorldInverse = new module$node_modules$three$build$three.default.Matrix4;
    this.projectionMatrix = new module$node_modules$three$build$three.default.Matrix4
};
module$node_modules$three$build$three.default.OrthographicCamera = function(a, b, c, d, e, f) {
    module$node_modules$three$build$three.default.Camera.call(this);
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.view = null;
    this.left = a;
    this.right = b;
    this.top = c;
    this.bottom = d;
    this.near = void 0 !== e ? e : .1;
    this.far = void 0 !== f ? f : 2E3;
    this.updateProjectionMatrix()
};
module$node_modules$three$build$three.default.Face3 = function(a, b, c, d, e, f) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.normal = d && d.isVector3 ? d : new module$node_modules$three$build$three.default.Vector3;
    this.vertexNormals = Array.isArray(d) ? d : [];
    this.color = e && e.isColor ? e : new module$node_modules$three$build$three.default.Color;
    this.vertexColors = Array.isArray(e) ? e : [];
    this.materialIndex = void 0 !== f ? f : 0
};
module$node_modules$three$build$three.default.Geometry = function() {
    Object.defineProperty(this, "id", {
        value: geometryId$$module$node_modules$three$build$three += 2
    });
    this.uuid = module$node_modules$three$build$three.default.Math.generateUUID();
    this.name = "";
    this.type = "Geometry";
    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [
        []
    ];
    this.morphTargets = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingSphere = this.boundingBox = null;
    this.groupsNeedUpdate =
        this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = !1
};
module$node_modules$three$build$three.default.BufferAttribute = function(a, b, c) {
    if (Array.isArray(a)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.name = "";
    this.array = a;
    this.itemSize = b;
    this.count = void 0 !== a ? a.length / b : 0;
    this.normalized = !0 === c;
    this.dynamic = !1;
    this.updateRange = {
        offset: 0,
        count: -1
    };
    this.version = 0
};
module$node_modules$three$build$three.default.Int8BufferAttribute = function(a, b, c) {
    module$node_modules$three$build$three.default.BufferAttribute.call(this, new Int8Array(a), b, c)
};
module$node_modules$three$build$three.default.Uint8BufferAttribute = function(a, b, c) {
    module$node_modules$three$build$three.default.BufferAttribute.call(this, new Uint8Array(a), b, c)
};
module$node_modules$three$build$three.default.Uint8ClampedBufferAttribute = function(a, b, c) {
    module$node_modules$three$build$three.default.BufferAttribute.call(this, new Uint8ClampedArray(a), b, c)
};
module$node_modules$three$build$three.default.Int16BufferAttribute = function(a, b, c) {
    module$node_modules$three$build$three.default.BufferAttribute.call(this, new Int16Array(a), b, c)
};
module$node_modules$three$build$three.default.Uint16BufferAttribute = function(a, b, c) {
    module$node_modules$three$build$three.default.BufferAttribute.call(this, new Uint16Array(a), b, c)
};
module$node_modules$three$build$three.default.Int32BufferAttribute = function(a, b, c) {
    module$node_modules$three$build$three.default.BufferAttribute.call(this, new Int32Array(a), b, c)
};
module$node_modules$three$build$three.default.Uint32BufferAttribute = function(a, b, c) {
    module$node_modules$three$build$three.default.BufferAttribute.call(this, new Uint32Array(a), b, c)
};
module$node_modules$three$build$three.default.Float32BufferAttribute = function(a, b, c) {
    module$node_modules$three$build$three.default.BufferAttribute.call(this, new Float32Array(a), b, c)
};
module$node_modules$three$build$three.default.Float64BufferAttribute = function(a, b, c) {
    module$node_modules$three$build$three.default.BufferAttribute.call(this, new Float64Array(a), b, c)
};
module$node_modules$three$build$three.default.BufferGeometry = function() {
    Object.defineProperty(this, "id", {
        value: bufferGeometryId$$module$node_modules$three$build$three += 2
    });
    this.uuid = module$node_modules$three$build$three.default.Math.generateUUID();
    this.name = "";
    this.type = "BufferGeometry";
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingSphere = this.boundingBox = null;
    this.drawRange = {
        start: 0,
        count: Infinity
    };
    this.userData = {}
};
module$node_modules$three$build$three.default.BoxGeometry = function(a, b, c, d, e, f) {
    module$node_modules$three$build$three.default.Geometry.call(this);
    this.type = "BoxGeometry";
    this.parameters = {
        width: a,
        height: b,
        depth: c,
        widthSegments: d,
        heightSegments: e,
        depthSegments: f
    };
    this.fromBufferGeometry(new module$node_modules$three$build$three.default.BoxBufferGeometry(a, b, c, d, e, f));
    this.mergeVertices()
};
module$node_modules$three$build$three.default.BoxBufferGeometry = function(a, b, c, d, e, f) {
    function g(a, b, c, d, e, f, g, x, z, B, N) {
        var n = f / z,
            A = g / B,
            u = f / 2,
            t = g / 2,
            y = x / 2;
        g = z + 1;
        var v = B + 1,
            w = f = 0,
            F, M, J = new module$node_modules$three$build$three.default.Vector3;
        for (M = 0; M < v; M++) {
            var R = M * A - t;
            for (F = 0; F < g; F++) J[a] = (F * n - u) * d, J[b] = R * e, J[c] = y, l.push(J.x, J.y, J.z), J[a] = 0, J[b] = 0, J[c] = 0 < x ? 1 : -1, p.push(J.x, J.y, J.z), m.push(F / z), m.push(1 - M / B), f += 1
        }
        for (M = 0; M < B; M++)
            for (F = 0; F < z; F++) a = q + F + g * (M + 1), b = q + (F + 1) + g * (M + 1), c = q + (F + 1) + g * M, k.push(q +
                F + g * M, a, c), k.push(a, b, c), w += 6;
        h.addGroup(r, w, N);
        r += w;
        q += f
    }
    module$node_modules$three$build$three.default.BufferGeometry.call(this);
    this.type = "BoxBufferGeometry";
    this.parameters = {
        width: a,
        height: b,
        depth: c,
        widthSegments: d,
        heightSegments: e,
        depthSegments: f
    };
    var h = this;
    a = a || 1;
    b = b || 1;
    c = c || 1;
    d = Math.floor(d) || 1;
    e = Math.floor(e) || 1;
    f = Math.floor(f) || 1;
    var k = [],
        l = [],
        p = [],
        m = [],
        q = 0,
        r = 0;
    g("z", "y", "x", -1, -1, c, b, a, f, e, 0);
    g("z", "y", "x", 1, -1, c, b, -a, f, e, 1);
    g("x", "z", "y", 1, 1, a, c, b, d, f, 2);
    g("x", "z", "y", 1, -1, a, c, -b, d, f, 3);
    g("x", "y", "z", 1, -1, a, b, c, d, e, 4);
    g("x", "y", "z", -1, -1, a, b, -c, d, e, 5);
    this.setIndex(k);
    this.addAttribute("position", new module$node_modules$three$build$three.default.Float32BufferAttribute(l, 3));
    this.addAttribute("normal", new module$node_modules$three$build$three.default.Float32BufferAttribute(p, 3));
    this.addAttribute("uv", new module$node_modules$three$build$three.default.Float32BufferAttribute(m, 2))
};
module$node_modules$three$build$three.default.PlaneGeometry = function(a, b, c, d) {
    module$node_modules$three$build$three.default.Geometry.call(this);
    this.type = "PlaneGeometry";
    this.parameters = {
        width: a,
        height: b,
        widthSegments: c,
        heightSegments: d
    };
    this.fromBufferGeometry(new module$node_modules$three$build$three.default.PlaneBufferGeometry(a, b, c, d));
    this.mergeVertices()
};
module$node_modules$three$build$three.default.PlaneBufferGeometry = function(a, b, c, d) {
    module$node_modules$three$build$three.default.BufferGeometry.call(this);
    this.type = "PlaneBufferGeometry";
    this.parameters = {
        width: a,
        height: b,
        widthSegments: c,
        heightSegments: d
    };
    a = a || 1;
    b = b || 1;
    var e = a / 2,
        f = b / 2;
    c = Math.floor(c) || 1;
    d = Math.floor(d) || 1;
    var g = c + 1,
        h = d + 1,
        k = a / c,
        l = b / d,
        p = [],
        m = [],
        q = [],
        r = [];
    for (a = 0; a < h; a++) {
        var n = a * l - f;
        for (b = 0; b < g; b++) m.push(b * k - e, -n, 0), q.push(0, 0, 1), r.push(b / c), r.push(1 - a / d)
    }
    for (a = 0; a < d; a++)
        for (b = 0; b <
            c; b++) e = b + g * (a + 1), f = b + 1 + g * (a + 1), h = b + 1 + g * a, p.push(b + g * a, e, h), p.push(e, f, h);
    this.setIndex(p);
    this.addAttribute("position", new module$node_modules$three$build$three.default.Float32BufferAttribute(m, 3));
    this.addAttribute("normal", new module$node_modules$three$build$three.default.Float32BufferAttribute(q, 3));
    this.addAttribute("uv", new module$node_modules$three$build$three.default.Float32BufferAttribute(r, 2))
};
module$node_modules$three$build$three.default.Material = function() {
    Object.defineProperty(this, "id", {
        value: materialId$$module$node_modules$three$build$three++
    });
    this.uuid = module$node_modules$three$build$three.default.Math.generateUUID();
    this.name = "";
    this.type = "Material";
    this.lights = this.fog = !0;
    this.blending = module$node_modules$three$build$three.default.NormalBlending;
    this.side = module$node_modules$three$build$three.default.FrontSide;
    this.flatShading = !1;
    this.vertexColors = module$node_modules$three$build$three.default.NoColors;
    this.opacity = 1;
    this.transparent = !1;
    this.blendSrc = module$node_modules$three$build$three.default.SrcAlphaFactor;
    this.blendDst = module$node_modules$three$build$three.default.OneMinusSrcAlphaFactor;
    this.blendEquation = module$node_modules$three$build$three.default.AddEquation;
    this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null;
    this.depthFunc = module$node_modules$three$build$three.default.LessEqualDepth;
    this.depthWrite = this.depthTest = !0;
    this.clippingPlanes = null;
    this.clipShadows = this.clipIntersection = !1;
    this.shadowSide = null;
    this.colorWrite = !0;
    this.precision = null;
    this.polygonOffset = !1;
    this.polygonOffsetUnits = this.polygonOffsetFactor = 0;
    this.dithering = !1;
    this.alphaTest = 0;
    this.premultipliedAlpha = !1;
    this.overdraw = 0;
    this.visible = !0;
    this.userData = {};
    this.needsUpdate = !0
};
module$node_modules$three$build$three.default.MeshBasicMaterial = function(a) {
    module$node_modules$three$build$three.default.Material.call(this);
    this.type = "MeshBasicMaterial";
    this.color = new module$node_modules$three$build$three.default.Color(16777215);
    this.lightMap = this.map = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.envMap = this.alphaMap = this.specularMap = null;
    this.combine = module$node_modules$three$build$three.default.MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio =
        .98;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.wireframeLinejoin = this.wireframeLinecap = "round";
    this.lights = this.morphTargets = this.skinning = !1;
    this.setValues(a)
};
module$node_modules$three$build$three.default.ShaderMaterial = function(a) {
    module$node_modules$three$build$three.default.Material.call(this);
    this.type = "ShaderMaterial";
    this.defines = {};
    this.uniforms = {};
    this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
    this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
    this.linewidth = 1;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.morphNormals = this.morphTargets = this.skinning =
        this.clipping = this.lights = this.fog = !1;
    this.extensions = {
        derivatives: !1,
        fragDepth: !1,
        drawBuffers: !1,
        shaderTextureLOD: !1
    };
    this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv2: [0, 0]
    };
    this.index0AttributeName = void 0;
    this.uniformsNeedUpdate = !1;
    void 0 !== a && (void 0 !== a.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(a))
};
module$node_modules$three$build$three.default.Ray = function(a, b) {
    this.origin = void 0 !== a ? a : new module$node_modules$three$build$three.default.Vector3;
    this.direction = void 0 !== b ? b : new module$node_modules$three$build$three.default.Vector3
};
module$node_modules$three$build$three.default.Triangle = function(a, b, c) {
    this.a = void 0 !== a ? a : new module$node_modules$three$build$three.default.Vector3;
    this.b = void 0 !== b ? b : new module$node_modules$three$build$three.default.Vector3;
    this.c = void 0 !== c ? c : new module$node_modules$three$build$three.default.Vector3
};
module$node_modules$three$build$three.default.Mesh = function(a, b) {
    module$node_modules$three$build$three.default.Object3D.call(this);
    this.type = "Mesh";
    this.geometry = void 0 !== a ? a : new module$node_modules$three$build$three.default.BufferGeometry;
    this.material = void 0 !== b ? b : new module$node_modules$three$build$three.default.MeshBasicMaterial({
        color: 16777215 * Math.random()
    });
    this.drawMode = module$node_modules$three$build$three.default.TrianglesDrawMode;
    this.updateMorphTargets()
};
module$node_modules$three$build$three.default.CubeTexture = function(a, b, c, d, e, f, g, h, k, l) {
    a = void 0 !== a ? a : [];
    b = void 0 !== b ? b : module$node_modules$three$build$three.default.CubeReflectionMapping;
    module$node_modules$three$build$three.default.Texture.call(this, a, b, c, d, e, f, g, h, k, l);
    this.flipY = !1
};
module$node_modules$three$build$three.default.MeshDepthMaterial = function(a) {
    module$node_modules$three$build$three.default.Material.call(this);
    this.type = "MeshDepthMaterial";
    this.depthPacking = module$node_modules$three$build$three.default.BasicDepthPacking;
    this.morphTargets = this.skinning = !1;
    this.displacementMap = this.alphaMap = this.map = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.lights = this.fog = !1;
    this.setValues(a)
};
module$node_modules$three$build$three.default.MeshDistanceMaterial = function(a) {
    module$node_modules$three$build$three.default.Material.call(this);
    this.type = "MeshDistanceMaterial";
    this.referencePosition = new module$node_modules$three$build$three.default.Vector3;
    this.nearDistance = 1;
    this.farDistance = 1E3;
    this.morphTargets = this.skinning = !1;
    this.displacementMap = this.alphaMap = this.map = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.lights = this.fog = !1;
    this.setValues(a)
};
module$node_modules$three$build$three.default.WebGLUtils = function(a, b, c) {
    return {
        convert: function(d) {
            if (d === module$node_modules$three$build$three.default.RepeatWrapping) return a.REPEAT;
            if (d === module$node_modules$three$build$three.default.ClampToEdgeWrapping) return a.CLAMP_TO_EDGE;
            if (d === module$node_modules$three$build$three.default.MirroredRepeatWrapping) return a.MIRRORED_REPEAT;
            if (d === module$node_modules$three$build$three.default.NearestFilter) return a.NEAREST;
            if (d === module$node_modules$three$build$three.default.NearestMipMapNearestFilter) return a.NEAREST_MIPMAP_NEAREST;
            if (d === module$node_modules$three$build$three.default.NearestMipMapLinearFilter) return a.NEAREST_MIPMAP_LINEAR;
            if (d === module$node_modules$three$build$three.default.LinearFilter) return a.LINEAR;
            if (d === module$node_modules$three$build$three.default.LinearMipMapNearestFilter) return a.LINEAR_MIPMAP_NEAREST;
            if (d === module$node_modules$three$build$three.default.LinearMipMapLinearFilter) return a.LINEAR_MIPMAP_LINEAR;
            if (d === module$node_modules$three$build$three.default.UnsignedByteType) return a.UNSIGNED_BYTE;
            if (d === module$node_modules$three$build$three.default.UnsignedShort4444Type) return a.UNSIGNED_SHORT_4_4_4_4;
            if (d === module$node_modules$three$build$three.default.UnsignedShort5551Type) return a.UNSIGNED_SHORT_5_5_5_1;
            if (d === module$node_modules$three$build$three.default.UnsignedShort565Type) return a.UNSIGNED_SHORT_5_6_5;
            if (d === module$node_modules$three$build$three.default.ByteType) return a.BYTE;
            if (d === module$node_modules$three$build$three.default.ShortType) return a.SHORT;
            if (d === module$node_modules$three$build$three.default.UnsignedShortType) return a.UNSIGNED_SHORT;
            if (d === module$node_modules$three$build$three.default.IntType) return a.INT;
            if (d === module$node_modules$three$build$three.default.UnsignedIntType) return a.UNSIGNED_INT;
            if (d === module$node_modules$three$build$three.default.FloatType) return a.FLOAT;
            if (d === module$node_modules$three$build$three.default.HalfFloatType) {
                if (c.isWebGL2) return a.HALF_FLOAT;
                var e = b.get("OES_texture_half_float");
                if (null !== e) return e.HALF_FLOAT_OES
            }
            if (d === module$node_modules$three$build$three.default.AlphaFormat) return a.ALPHA;
            if (d ===
                module$node_modules$three$build$three.default.RGBFormat) return a.RGB;
            if (d === module$node_modules$three$build$three.default.RGBAFormat) return a.RGBA;
            if (d === module$node_modules$three$build$three.default.LuminanceFormat) return a.LUMINANCE;
            if (d === module$node_modules$three$build$three.default.LuminanceAlphaFormat) return a.LUMINANCE_ALPHA;
            if (d === module$node_modules$three$build$three.default.DepthFormat) return a.DEPTH_COMPONENT;
            if (d === module$node_modules$three$build$three.default.DepthStencilFormat) return a.DEPTH_STENCIL;
            if (d === module$node_modules$three$build$three.default.AddEquation) return a.FUNC_ADD;
            if (d === module$node_modules$three$build$three.default.SubtractEquation) return a.FUNC_SUBTRACT;
            if (d === module$node_modules$three$build$three.default.ReverseSubtractEquation) return a.FUNC_REVERSE_SUBTRACT;
            if (d === module$node_modules$three$build$three.default.ZeroFactor) return a.ZERO;
            if (d === module$node_modules$three$build$three.default.OneFactor) return a.ONE;
            if (d === module$node_modules$three$build$three.default.SrcColorFactor) return a.SRC_COLOR;
            if (d === module$node_modules$three$build$three.default.OneMinusSrcColorFactor) return a.ONE_MINUS_SRC_COLOR;
            if (d === module$node_modules$three$build$three.default.SrcAlphaFactor) return a.SRC_ALPHA;
            if (d === module$node_modules$three$build$three.default.OneMinusSrcAlphaFactor) return a.ONE_MINUS_SRC_ALPHA;
            if (d === module$node_modules$three$build$three.default.DstAlphaFactor) return a.DST_ALPHA;
            if (d === module$node_modules$three$build$three.default.OneMinusDstAlphaFactor) return a.ONE_MINUS_DST_ALPHA;
            if (d === module$node_modules$three$build$three.default.DstColorFactor) return a.DST_COLOR;
            if (d === module$node_modules$three$build$three.default.OneMinusDstColorFactor) return a.ONE_MINUS_DST_COLOR;
            if (d === module$node_modules$three$build$three.default.SrcAlphaSaturateFactor) return a.SRC_ALPHA_SATURATE;
            if (d === module$node_modules$three$build$three.default.RGB_S3TC_DXT1_Format || d === module$node_modules$three$build$three.default.RGBA_S3TC_DXT1_Format || d === module$node_modules$three$build$three.default.RGBA_S3TC_DXT3_Format || d === module$node_modules$three$build$three.default.RGBA_S3TC_DXT5_Format)
                if (e =
                    b.get("WEBGL_compressed_texture_s3tc"), null !== e) {
                    if (d === module$node_modules$three$build$three.default.RGB_S3TC_DXT1_Format) return e.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (d === module$node_modules$three$build$three.default.RGBA_S3TC_DXT1_Format) return e.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (d === module$node_modules$three$build$three.default.RGBA_S3TC_DXT3_Format) return e.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (d === module$node_modules$three$build$three.default.RGBA_S3TC_DXT5_Format) return e.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
            if (d ===
                module$node_modules$three$build$three.default.RGB_PVRTC_4BPPV1_Format || d === module$node_modules$three$build$three.default.RGB_PVRTC_2BPPV1_Format || d === module$node_modules$three$build$three.default.RGBA_PVRTC_4BPPV1_Format || d === module$node_modules$three$build$three.default.RGBA_PVRTC_2BPPV1_Format)
                if (e = b.get("WEBGL_compressed_texture_pvrtc"), null !== e) {
                    if (d === module$node_modules$three$build$three.default.RGB_PVRTC_4BPPV1_Format) return e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (d === module$node_modules$three$build$three.default.RGB_PVRTC_2BPPV1_Format) return e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (d === module$node_modules$three$build$three.default.RGBA_PVRTC_4BPPV1_Format) return e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (d === module$node_modules$three$build$three.default.RGBA_PVRTC_2BPPV1_Format) return e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
            if (d === module$node_modules$three$build$three.default.RGB_ETC1_Format && (e = b.get("WEBGL_compressed_texture_etc1"), null !== e)) return e.COMPRESSED_RGB_ETC1_WEBGL;
            if (d === module$node_modules$three$build$three.default.RGBA_ASTC_4x4_Format || d === module$node_modules$three$build$three.default.RGBA_ASTC_5x4_Format ||
                d === module$node_modules$three$build$three.default.RGBA_ASTC_5x5_Format || d === module$node_modules$three$build$three.default.RGBA_ASTC_6x5_Format || d === module$node_modules$three$build$three.default.RGBA_ASTC_6x6_Format || d === module$node_modules$three$build$three.default.RGBA_ASTC_8x5_Format || d === module$node_modules$three$build$three.default.RGBA_ASTC_8x6_Format || d === module$node_modules$three$build$three.default.RGBA_ASTC_8x8_Format || d === module$node_modules$three$build$three.default.RGBA_ASTC_10x5_Format ||
                d === module$node_modules$three$build$three.default.RGBA_ASTC_10x6_Format || d === module$node_modules$three$build$three.default.RGBA_ASTC_10x8_Format || d === module$node_modules$three$build$three.default.RGBA_ASTC_10x10_Format || d === module$node_modules$three$build$three.default.RGBA_ASTC_12x10_Format || d === module$node_modules$three$build$three.default.RGBA_ASTC_12x12_Format)
                if (e = b.get("WEBGL_compressed_texture_astc"), null !== e) return d;
            if (d === module$node_modules$three$build$three.default.MinEquation || d === module$node_modules$three$build$three.default.MaxEquation) {
                if (c.isWebGL2) {
                    if (d ===
                        module$node_modules$three$build$three.default.MinEquation) return a.MIN;
                    if (d === module$node_modules$three$build$three.default.MaxEquation) return a.MAX
                }
                e = b.get("EXT_blend_minmax");
                if (null !== e) {
                    if (d === module$node_modules$three$build$three.default.MinEquation) return e.MIN_EXT;
                    if (d === module$node_modules$three$build$three.default.MaxEquation) return e.MAX_EXT
                }
            }
            if (d === module$node_modules$three$build$three.default.UnsignedInt248Type) {
                if (c.isWebGL2) return a.UNSIGNED_INT_24_8;
                e = b.get("WEBGL_depth_texture");
                if (null !==
                    e) return e.UNSIGNED_INT_24_8_WEBGL
            }
            return 0
        }
    }
};
module$node_modules$three$build$three.default.Group = function() {
    module$node_modules$three$build$three.default.Object3D.call(this);
    this.type = "Group"
};
module$node_modules$three$build$three.default.PerspectiveCamera = function(a, b, c, d) {
    module$node_modules$three$build$three.default.Camera.call(this);
    this.type = "PerspectiveCamera";
    this.fov = void 0 !== a ? a : 50;
    this.zoom = 1;
    this.near = void 0 !== c ? c : .1;
    this.far = void 0 !== d ? d : 2E3;
    this.focus = 10;
    this.aspect = void 0 !== b ? b : 1;
    this.view = null;
    this.filmGauge = 35;
    this.filmOffset = 0;
    this.updateProjectionMatrix()
};
module$node_modules$three$build$three.default.ArrayCamera = function(a) {
    module$node_modules$three$build$three.default.PerspectiveCamera.call(this);
    this.cameras = a || []
};
module$node_modules$three$build$three.default.WebGLRenderer = function(a) {
    var b;

    function c() {
        W = new WebGLExtensions$$module$node_modules$three$build$three(C);
        aa = new WebGLCapabilities$$module$node_modules$three$build$three(C, W, a);
        aa.isWebGL2 || (W.get("WEBGL_depth_texture"), W.get("OES_texture_float"), W.get("OES_texture_half_float"), W.get("OES_texture_half_float_linear"), W.get("OES_standard_derivatives"), W.get("OES_element_index_uint"), W.get("ANGLE_instanced_arrays"));
        W.get("OES_texture_float_linear");
        ra =
            new module$node_modules$three$build$three.default.WebGLUtils(C, W, aa);
        U = new WebGLState$$module$node_modules$three$build$three(C, W, ra, aa);
        U.scissor(O.copy(sa).multiplyScalar(P));
        U.viewport(S.copy(Y).multiplyScalar(P));
        va = new WebGLInfo$$module$node_modules$three$build$three(C);
        fa = new WebGLProperties$$module$node_modules$three$build$three;
        ya = new WebGLTextures$$module$node_modules$three$build$three(C, W, U, fa, aa, ra, va);
        Fa = new WebGLAttributes$$module$node_modules$three$build$three(C);
        Na = new WebGLGeometries$$module$node_modules$three$build$three(C,
            Fa, va);
        Ca = new WebGLObjects$$module$node_modules$three$build$three(Na, va);
        $a = new WebGLMorphtargets$$module$node_modules$three$build$three(C);
        da = new WebGLPrograms$$module$node_modules$three$build$three(D, W, aa);
        Ga = new WebGLRenderLists$$module$node_modules$three$build$three;
        Da = new WebGLRenderStates$$module$node_modules$three$build$three;
        ma = new WebGLBackground$$module$node_modules$three$build$three(D, U, Ca, z);
        Va = new WebGLBufferRenderer$$module$node_modules$three$build$three(C, W, va, aa);
        Ka = new WebGLIndexedBufferRenderer$$module$node_modules$three$build$three(C,
            W, va, aa);
        va.programs = da.programs;
        D.context = C;
        D.capabilities = aa;
        D.extensions = W;
        D.properties = fa;
        D.renderLists = Ga;
        D.state = U;
        D.info = va
    }

    function d(a) {
        a.preventDefault();
        console.log("THREE.WebGLRenderer: Context Lost.");
        I = !0
    }

    function e() {
        console.log("THREE.WebGLRenderer: Context Restored.");
        I = !1;
        c()
    }

    function f(a) {
        a = a.target;
        a.removeEventListener("dispose", f);
        g(a);
        fa.remove(a)
    }

    function g(a) {
        var b = fa.get(a).program;
        a.program = void 0;
        void 0 !== b && da.releaseProgram(b)
    }

    function h(a, b) {
        a.render(function(a) {
            D.renderBufferImmediate(a,
                b)
        })
    }

    function k(a, b, c) {
        if (!1 !== a.visible) {
            if (a.layers.test(b.layers))
                if (a.isLight) H.pushLight(a), a.castShadow && H.pushShadow(a);
                else if (a.isSprite) {
                if (!a.frustumCulled || na.intersectsSprite(a)) {
                    c && wa.setFromMatrixPosition(a.matrixWorld).applyMatrix4(Ha);
                    var d = Ca.update(a),
                        e = a.material;
                    K.push(a, d, e, wa.z, null)
                }
            } else if (a.isImmediateRenderObject) c && wa.setFromMatrixPosition(a.matrixWorld).applyMatrix4(Ha), K.push(a, null, a.material, wa.z, null);
            else if (a.isMesh || a.isLine || a.isPoints)
                if (a.isSkinnedMesh && a.skeleton.update(), !a.frustumCulled || na.intersectsObject(a))
                    if (c && wa.setFromMatrixPosition(a.matrixWorld).applyMatrix4(Ha), d = Ca.update(a), e = a.material, Array.isArray(e))
                        for (var f = d.groups, g = 0, h = f.length; g < h; g++) {
                            var l = f[g],
                                m = e[l.materialIndex];
                            m && m.visible && K.push(a, d, m, wa.z, l)
                        } else e.visible && K.push(a, d, e, wa.z, null);
            a = a.children;
            g = 0;
            for (h = a.length; g < h; g++) k(a[g], b, c)
        }
    }

    function l(a, b, c, d) {
        for (var e = 0, f = a.length; e < f; e++) {
            var g = a[e],
                h = g.object,
                k = g.geometry,
                l = void 0 === d ? g.material : d;
            g = g.group;
            if (c.isArrayCamera) {
                V = c;
                for (var m =
                        c.cameras, x = 0, n = m.length; x < n; x++) {
                    var q = m[x];
                    if (h.layers.test(q.layers)) {
                        if ("viewport" in q) U.viewport(S.copy(q.viewport));
                        else {
                            var r = q.bounds;
                            U.viewport(S.set(r.x * ca, r.y * E, r.z * ca, r.w * E).multiplyScalar(P))
                        }
                        p(h, b, q, k, l, g)
                    }
                }
            } else V = null, p(h, b, c, k, l, g)
        }
    }

    function p(a, c, d, e, f, g) {
        a.onBeforeRender(D, c, d, e, f, g);
        H = Da.get(c, V || d);
        a.modelViewMatrix.multiplyMatrices(d.matrixWorldInverse, a.matrixWorld);
        a.normalMatrix.getNormalMatrix(a.modelViewMatrix);
        if (a.isImmediateRenderObject) {
            U.setMaterial(f);
            var k = q(d, c.fog,
                f, a);
            M = b = null;
            J = !1;
            h(a, k)
        } else D.renderBufferDirect(d, c.fog, e, f, a, g);
        a.onAfterRender(D, c, d, e, f, g);
        H = Da.get(c, V || d)
    }

    function m(a, b, c) {
        var d = fa.get(a),
            e = H.state.lights,
            h = d.lightsHash,
            k = e.state.hash;
        c = da.getParameters(a, e.state, H.state.shadowsArray, b, Q.numPlanes, Q.numIntersection, c);
        var l = da.getProgramCode(a, c),
            m = d.program,
            x = !0;
        if (void 0 === m) a.addEventListener("dispose", f);
        else if (m.code !== l) g(a);
        else {
            if (h.stateID !== k.stateID || h.directionalLength !== k.directionalLength || h.pointLength !== k.pointLength ||
                h.spotLength !== k.spotLength || h.rectAreaLength !== k.rectAreaLength || h.hemiLength !== k.hemiLength || h.shadowsLength !== k.shadowsLength) h.stateID = k.stateID, h.directionalLength = k.directionalLength, h.pointLength = k.pointLength, h.spotLength = k.spotLength, h.rectAreaLength = k.rectAreaLength, h.hemiLength = k.hemiLength, h.shadowsLength = k.shadowsLength;
            else if (void 0 !== c.shaderID) return;
            x = !1
        }
        x && (c.shaderID ? (l = module$node_modules$three$build$three.default.ShaderLib[c.shaderID], d.shader = {
            name: a.type,
            uniforms: module$node_modules$three$build$three.default.UniformsUtils.clone(l.uniforms),
            vertexShader: l.vertexShader,
            fragmentShader: l.fragmentShader
        }) : d.shader = {
            name: a.type,
            uniforms: a.uniforms,
            vertexShader: a.vertexShader,
            fragmentShader: a.fragmentShader
        }, a.onBeforeCompile(d.shader, D), l = da.getProgramCode(a, c), m = da.acquireProgram(a, d.shader, c, l), d.program = m, a.program = m);
        c = m.getAttributes();
        if (a.morphTargets)
            for (l = a.numSupportedMorphTargets = 0; l < D.maxMorphTargets; l++) 0 <= c["morphTarget" + l] && a.numSupportedMorphTargets++;
        if (a.morphNormals)
            for (l = a.numSupportedMorphNormals = 0; l < D.maxMorphNormals; l++) 0 <=
                c["morphNormal" + l] && a.numSupportedMorphNormals++;
        c = d.shader.uniforms;
        if (!a.isShaderMaterial && !a.isRawShaderMaterial || !0 === a.clipping) d.numClippingPlanes = Q.numPlanes, d.numIntersection = Q.numIntersection, c.clippingPlanes = Q.uniform;
        d.fog = b;
        void 0 === h && (d.lightsHash = h = {});
        h.stateID = k.stateID;
        h.directionalLength = k.directionalLength;
        h.pointLength = k.pointLength;
        h.spotLength = k.spotLength;
        h.rectAreaLength = k.rectAreaLength;
        h.hemiLength = k.hemiLength;
        h.shadowsLength = k.shadowsLength;
        a.lights && (c.ambientLightColor.value =
            e.state.ambient, c.directionalLights.value = e.state.directional, c.spotLights.value = e.state.spot, c.rectAreaLights.value = e.state.rectArea, c.pointLights.value = e.state.point, c.hemisphereLights.value = e.state.hemi, c.directionalShadowMap.value = e.state.directionalShadowMap, c.directionalShadowMatrix.value = e.state.directionalShadowMatrix, c.spotShadowMap.value = e.state.spotShadowMap, c.spotShadowMatrix.value = e.state.spotShadowMatrix, c.pointShadowMap.value = e.state.pointShadowMap, c.pointShadowMatrix.value = e.state.pointShadowMatrix);
        a = d.program.getUniforms();
        a = WebGLUniforms$$module$node_modules$three$build$three.seqWithValue(a.seq, c);
        d.uniformsList = a
    }

    function q(a, b, c, d) {
        X = 0;
        var e = fa.get(c),
            f = e.lightsHash,
            g = H.state.lights.state.hash;
        ta && (Oa || a !== R) && Q.setState(c.clippingPlanes, c.clipIntersection, c.clipShadows, a, e, a === R && c.id === F);
        !1 === c.needsUpdate && (void 0 === e.program ? c.needsUpdate = !0 : c.fog && e.fog !== b ? c.needsUpdate = !0 : !c.lights || f.stateID === g.stateID && f.directionalLength === g.directionalLength && f.pointLength === g.pointLength &&
            f.spotLength === g.spotLength && f.rectAreaLength === g.rectAreaLength && f.hemiLength === g.hemiLength && f.shadowsLength === g.shadowsLength ? void 0 === e.numClippingPlanes || e.numClippingPlanes === Q.numPlanes && e.numIntersection === Q.numIntersection || (c.needsUpdate = !0) : c.needsUpdate = !0);
        c.needsUpdate && (m(c, b, d), c.needsUpdate = !1);
        var h = !1,
            k = !1,
            l = !1;
        f = e.program;
        g = f.getUniforms();
        var x = e.shader.uniforms;
        U.useProgram(f.program) && (l = k = h = !0);
        c.id !== F && (F = c.id, k = !0);
        if (h || a !== R) {
            g.setValue(C, "projectionMatrix", a.projectionMatrix);
            aa.logarithmicDepthBuffer && g.setValue(C, "logDepthBufFC", 2 / (Math.log(a.far + 1) / Math.LN2));
            R !== (V || a) && (R = V || a, l = k = !0);
            if (c.isShaderMaterial || c.isMeshPhongMaterial || c.isMeshStandardMaterial || c.envMap) h = g.map.cameraPosition, void 0 !== h && h.setValue(C, wa.setFromMatrixPosition(a.matrixWorld));
            (c.isMeshPhongMaterial || c.isMeshLambertMaterial || c.isMeshBasicMaterial || c.isMeshStandardMaterial || c.isShaderMaterial || c.skinning) && g.setValue(C, "viewMatrix", a.matrixWorldInverse)
        }
        if (c.skinning && (g.setOptional(C, d, "bindMatrix"),
                g.setOptional(C, d, "bindMatrixInverse"), a = d.skeleton))
            if (h = a.bones, aa.floatVertexTextures) {
                if (void 0 === a.boneTexture) {
                    h = Math.sqrt(4 * h.length);
                    h = module$node_modules$three$build$three.default.Math.ceilPowerOfTwo(h);
                    h = Math.max(h, 4);
                    var q = new Float32Array(h * h * 4);
                    q.set(a.boneMatrices);
                    var p = new module$node_modules$three$build$three.default.DataTexture(q, h, h, module$node_modules$three$build$three.default.RGBAFormat, module$node_modules$three$build$three.default.FloatType);
                    p.needsUpdate = !0;
                    a.boneMatrices = q;
                    a.boneTexture = p;
                    a.boneTextureSize = h
                }
                g.setValue(C, "boneTexture", a.boneTexture);
                g.setValue(C, "boneTextureSize", a.boneTextureSize)
            } else g.setOptional(C, a, "boneMatrices");
        k && (g.setValue(C, "toneMappingExposure", D.toneMappingExposure), g.setValue(C, "toneMappingWhitePoint", D.toneMappingWhitePoint), c.lights && (k = l, x.ambientLightColor.needsUpdate = k, x.directionalLights.needsUpdate = k, x.pointLights.needsUpdate = k, x.spotLights.needsUpdate = k, x.rectAreaLights.needsUpdate = k, x.hemisphereLights.needsUpdate = k), b && c.fog &&
            (x.fogColor.value = b.color, b.isFog ? (x.fogNear.value = b.near, x.fogFar.value = b.far) : b.isFogExp2 && (x.fogDensity.value = b.density)), c.isMeshBasicMaterial ? r(x, c) : c.isMeshLambertMaterial ? (r(x, c), c.emissiveMap && (x.emissiveMap.value = c.emissiveMap)) : c.isMeshPhongMaterial ? (r(x, c), c.isMeshToonMaterial ? (n(x, c), c.gradientMap && (x.gradientMap.value = c.gradientMap)) : n(x, c)) : c.isMeshStandardMaterial ? (r(x, c), c.isMeshPhysicalMaterial ? (t(x, c), x.reflectivity.value = c.reflectivity, x.clearCoat.value = c.clearCoat, x.clearCoatRoughness.value =
                c.clearCoatRoughness) : t(x, c)) : c.isMeshDepthMaterial ? (r(x, c), c.displacementMap && (x.displacementMap.value = c.displacementMap, x.displacementScale.value = c.displacementScale, x.displacementBias.value = c.displacementBias)) : c.isMeshDistanceMaterial ? (r(x, c), c.displacementMap && (x.displacementMap.value = c.displacementMap, x.displacementScale.value = c.displacementScale, x.displacementBias.value = c.displacementBias), x.referencePosition.value.copy(c.referencePosition), x.nearDistance.value = c.nearDistance, x.farDistance.value =
                c.farDistance) : c.isMeshNormalMaterial ? (r(x, c), c.bumpMap && (x.bumpMap.value = c.bumpMap, x.bumpScale.value = c.bumpScale, c.side === module$node_modules$three$build$three.default.BackSide && (x.bumpScale.value *= -1)), c.normalMap && (x.normalMap.value = c.normalMap, x.normalScale.value.copy(c.normalScale), c.side === module$node_modules$three$build$three.default.BackSide && x.normalScale.value.negate()), c.displacementMap && (x.displacementMap.value = c.displacementMap, x.displacementScale.value = c.displacementScale, x.displacementBias.value =
                c.displacementBias)) : c.isLineBasicMaterial ? (x.diffuse.value = c.color, x.opacity.value = c.opacity, c.isLineDashedMaterial && (x.dashSize.value = c.dashSize, x.totalSize.value = c.dashSize + c.gapSize, x.scale.value = c.scale)) : c.isPointsMaterial ? (x.diffuse.value = c.color, x.opacity.value = c.opacity, x.size.value = c.size * P, x.scale.value = .5 * E, x.map.value = c.map, null !== c.map && (!0 === c.map.matrixAutoUpdate && c.map.updateMatrix(), x.uvTransform.value.copy(c.map.matrix))) : c.isSpriteMaterial ? (x.diffuse.value = c.color, x.opacity.value =
                c.opacity, x.rotation.value = c.rotation, x.map.value = c.map, null !== c.map && (!0 === c.map.matrixAutoUpdate && c.map.updateMatrix(), x.uvTransform.value.copy(c.map.matrix))) : c.isShadowMaterial && (x.color.value = c.color, x.opacity.value = c.opacity), void 0 !== x.ltc_1 && (x.ltc_1.value = module$node_modules$three$build$three.default.UniformsLib.LTC_1), void 0 !== x.ltc_2 && (x.ltc_2.value = module$node_modules$three$build$three.default.UniformsLib.LTC_2), WebGLUniforms$$module$node_modules$three$build$three.upload(C, e.uniformsList,
                x, D));
        c.isShaderMaterial && !0 === c.uniformsNeedUpdate && (WebGLUniforms$$module$node_modules$three$build$three.upload(C, e.uniformsList, x, D), c.uniformsNeedUpdate = !1);
        c.isSpriteMaterial && g.setValue(C, "center", d.center);
        g.setValue(C, "modelViewMatrix", d.modelViewMatrix);
        g.setValue(C, "normalMatrix", d.normalMatrix);
        g.setValue(C, "modelMatrix", d.matrixWorld);
        return f
    }

    function r(a, b) {
        a.opacity.value = b.opacity;
        b.color && (a.diffuse.value = b.color);
        b.emissive && a.emissive.value.copy(b.emissive).multiplyScalar(b.emissiveIntensity);
        b.map && (a.map.value = b.map);
        b.alphaMap && (a.alphaMap.value = b.alphaMap);
        b.specularMap && (a.specularMap.value = b.specularMap);
        b.envMap && (a.envMap.value = b.envMap, a.flipEnvMap.value = b.envMap && b.envMap.isCubeTexture ? -1 : 1, a.reflectivity.value = b.reflectivity, a.refractionRatio.value = b.refractionRatio, a.maxMipLevel.value = fa.get(b.envMap).__maxMipLevel);
        b.lightMap && (a.lightMap.value = b.lightMap, a.lightMapIntensity.value = b.lightMapIntensity);
        b.aoMap && (a.aoMap.value = b.aoMap, a.aoMapIntensity.value = b.aoMapIntensity);
        if (b.map) var c = b.map;
        else b.specularMap ? c = b.specularMap : b.displacementMap ? c = b.displacementMap : b.normalMap ? c = b.normalMap : b.bumpMap ? c = b.bumpMap : b.roughnessMap ? c = b.roughnessMap : b.metalnessMap ? c = b.metalnessMap : b.alphaMap ? c = b.alphaMap : b.emissiveMap && (c = b.emissiveMap);
        void 0 !== c && (c.isWebGLRenderTarget && (c = c.texture), !0 === c.matrixAutoUpdate && c.updateMatrix(), a.uvTransform.value.copy(c.matrix))
    }

    function n(a, b) {
        a.specular.value = b.specular;
        a.shininess.value = Math.max(b.shininess, 1E-4);
        b.emissiveMap && (a.emissiveMap.value =
            b.emissiveMap);
        b.bumpMap && (a.bumpMap.value = b.bumpMap, a.bumpScale.value = b.bumpScale, b.side === module$node_modules$three$build$three.default.BackSide && (a.bumpScale.value *= -1));
        b.normalMap && (a.normalMap.value = b.normalMap, a.normalScale.value.copy(b.normalScale), b.side === module$node_modules$three$build$three.default.BackSide && a.normalScale.value.negate());
        b.displacementMap && (a.displacementMap.value = b.displacementMap, a.displacementScale.value = b.displacementScale, a.displacementBias.value = b.displacementBias)
    }

    function t(a, b) {
        a.roughness.value = b.roughness;
        a.metalness.value = b.metalness;
        b.roughnessMap && (a.roughnessMap.value = b.roughnessMap);
        b.metalnessMap && (a.metalnessMap.value = b.metalnessMap);
        b.emissiveMap && (a.emissiveMap.value = b.emissiveMap);
        b.bumpMap && (a.bumpMap.value = b.bumpMap, a.bumpScale.value = b.bumpScale, b.side === module$node_modules$three$build$three.default.BackSide && (a.bumpScale.value *= -1));
        b.normalMap && (a.normalMap.value = b.normalMap, a.normalScale.value.copy(b.normalScale), b.side === module$node_modules$three$build$three.default.BackSide &&
            a.normalScale.value.negate());
        b.displacementMap && (a.displacementMap.value = b.displacementMap, a.displacementScale.value = b.displacementScale, a.displacementBias.value = b.displacementBias);
        b.envMap && (a.envMapIntensity.value = b.envMapIntensity)
    }
    console.log("THREE.WebGLRenderer", module$node_modules$three$build$three.default.REVISION);
    a = a || {};
    var u = void 0 !== a.canvas ? a.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
        w = void 0 !== a.context ? a.context : null,
        v = void 0 !== a.alpha ? a.alpha : !1,
        y =
        void 0 !== a.depth ? a.depth : !0,
        A = void 0 !== a.stencil ? a.stencil : !0,
        x = void 0 !== a.antialias ? a.antialias : !1,
        z = void 0 !== a.premultipliedAlpha ? a.premultipliedAlpha : !0,
        B = void 0 !== a.preserveDrawingBuffer ? a.preserveDrawingBuffer : !1,
        N = void 0 !== a.powerPreference ? a.powerPreference : "default",
        K = null,
        H = null;
    this.domElement = u;
    this.context = null;
    this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0;
    this.clippingPlanes = [];
    this.localClippingEnabled = !1;
    this.gammaFactor = 2;
    this.physicallyCorrectLights =
        this.gammaOutput = this.gammaInput = !1;
    this.toneMapping = module$node_modules$three$build$three.default.LinearToneMapping;
    this.toneMappingWhitePoint = this.toneMappingExposure = 1;
    this.maxMorphTargets = 8;
    this.maxMorphNormals = 4;
    var D = this,
        I = !1,
        G = null,
        T = null,
        L = null,
        F = -1;
    var M = b = null;
    var J = !1;
    var R = null,
        V = null,
        S = new module$node_modules$three$build$three.default.Vector4,
        O = new module$node_modules$three$build$three.default.Vector4,
        ba = null,
        X = 0,
        ca = u.width,
        E = u.height,
        P = 1,
        Y = new module$node_modules$three$build$three.default.Vector4(0,
            0, ca, E),
        sa = new module$node_modules$three$build$three.default.Vector4(0, 0, ca, E),
        ka = !1,
        na = new module$node_modules$three$build$three.default.Frustum,
        Q = new WebGLClipping$$module$node_modules$three$build$three,
        ta = !1,
        Oa = !1,
        Ha = new module$node_modules$three$build$three.default.Matrix4,
        wa = new module$node_modules$three$build$three.default.Vector3;
    try {
        v = {
            alpha: v,
            depth: y,
            stencil: A,
            antialias: x,
            premultipliedAlpha: z,
            preserveDrawingBuffer: B,
            powerPreference: N
        };
        u.addEventListener("webglcontextlost", d, !1);
        u.addEventListener("webglcontextrestored",
            e, !1);
        var C = w || u.getContext("webgl", v) || u.getContext("experimental-webgl", v);
        if (null === C) {
            if (null !== u.getContext("webgl")) throw Error("Error creating WebGL context with your selected attributes.");
            throw Error("Error creating WebGL context.");
        }
        void 0 === C.getShaderPrecisionFormat && (C.getShaderPrecisionFormat = function() {
            return {
                rangeMin: 1,
                rangeMax: 1,
                precision: 1
            }
        })
    } catch (sb) {
        console.error("THREE.WebGLRenderer: " + sb.message)
    }
    var W, aa, U, va, fa, ya, Fa, Na, Ca, da, Ga, Da, ma, $a, Va, Ka, ra;
    c();
    var ua = "xr" in navigator ?
        new WebXRManager$$module$node_modules$three$build$three(D) : new WebVRManager$$module$node_modules$three$build$three(D);
    this.vr = ua;
    var bb = new WebGLShadowMap$$module$node_modules$three$build$three(D, Ca, aa.maxTextureSize);
    this.shadowMap = bb;
    this.getContext = function() {
        return C
    };
    this.getContextAttributes = function() {
        return C.getContextAttributes()
    };
    this.forceContextLoss = function() {
        var a = W.get("WEBGL_lose_context");
        a && a.loseContext()
    };
    this.forceContextRestore = function() {
        var a = W.get("WEBGL_lose_context");
        a &&
            a.restoreContext()
    };
    this.getPixelRatio = function() {
        return P
    };
    this.setPixelRatio = function(a) {
        void 0 !== a && (P = a, this.setSize(ca, E, !1))
    };
    this.getSize = function() {
        return {
            width: ca,
            height: E
        }
    };
    this.setSize = function(a, b, c) {
        ua.isPresenting() ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (ca = a, E = b, u.width = a * P, u.height = b * P, !1 !== c && (u.style.width = a + "px", u.style.height = b + "px"), this.setViewport(0, 0, a, b))
    };
    this.getDrawingBufferSize = function() {
        return {
            width: ca * P,
            height: E * P
        }
    };
    this.setDrawingBufferSize =
        function(a, b, c) {
            ca = a;
            E = b;
            P = c;
            u.width = a * c;
            u.height = b * c;
            this.setViewport(0, 0, a, b)
        };
    this.getCurrentViewport = function() {
        return S
    };
    this.setViewport = function(a, b, c, d) {
        Y.set(a, E - b - d, c, d);
        U.viewport(S.copy(Y).multiplyScalar(P))
    };
    this.setScissor = function(a, b, c, d) {
        sa.set(a, E - b - d, c, d);
        U.scissor(O.copy(sa).multiplyScalar(P))
    };
    this.setScissorTest = function(a) {
        U.setScissorTest(ka = a)
    };
    this.getClearColor = function() {
        return ma.getClearColor()
    };
    this.setClearColor = function() {
        ma.setClearColor.apply(ma, arguments)
    };
    this.getClearAlpha =
        function() {
            return ma.getClearAlpha()
        };
    this.setClearAlpha = function() {
        ma.setClearAlpha.apply(ma, arguments)
    };
    this.clear = function(a, b, c) {
        var d = 0;
        if (void 0 === a || a) d |= C.COLOR_BUFFER_BIT;
        if (void 0 === b || b) d |= C.DEPTH_BUFFER_BIT;
        if (void 0 === c || c) d |= C.STENCIL_BUFFER_BIT;
        C.clear(d)
    };
    this.clearColor = function() {
        this.clear(!0, !1, !1)
    };
    this.clearDepth = function() {
        this.clear(!1, !0, !1)
    };
    this.clearStencil = function() {
        this.clear(!1, !1, !0)
    };
    this.clearTarget = function(a, b, c, d) {
        this.setRenderTarget(a);
        this.clear(b, c, d)
    };
    this.dispose =
        function() {
            u.removeEventListener("webglcontextlost", d, !1);
            u.removeEventListener("webglcontextrestored", e, !1);
            Ga.dispose();
            Da.dispose();
            fa.dispose();
            Ca.dispose();
            ua.dispose();
            ha.stop()
        };
    this.renderBufferImmediate = function(a, b) {
        U.initAttributes();
        var c = fa.get(a);
        a.hasPositions && !c.position && (c.position = C.createBuffer());
        a.hasNormals && !c.normal && (c.normal = C.createBuffer());
        a.hasUvs && !c.uv && (c.uv = C.createBuffer());
        a.hasColors && !c.color && (c.color = C.createBuffer());
        b = b.getAttributes();
        a.hasPositions && (C.bindBuffer(C.ARRAY_BUFFER,
            c.position), C.bufferData(C.ARRAY_BUFFER, a.positionArray, C.DYNAMIC_DRAW), U.enableAttribute(b.position), C.vertexAttribPointer(b.position, 3, C.FLOAT, !1, 0, 0));
        a.hasNormals && (C.bindBuffer(C.ARRAY_BUFFER, c.normal), C.bufferData(C.ARRAY_BUFFER, a.normalArray, C.DYNAMIC_DRAW), U.enableAttribute(b.normal), C.vertexAttribPointer(b.normal, 3, C.FLOAT, !1, 0, 0));
        a.hasUvs && (C.bindBuffer(C.ARRAY_BUFFER, c.uv), C.bufferData(C.ARRAY_BUFFER, a.uvArray, C.DYNAMIC_DRAW), U.enableAttribute(b.uv), C.vertexAttribPointer(b.uv, 2, C.FLOAT, !1, 0, 0));
        a.hasColors && (C.bindBuffer(C.ARRAY_BUFFER, c.color), C.bufferData(C.ARRAY_BUFFER, a.colorArray, C.DYNAMIC_DRAW), U.enableAttribute(b.color), C.vertexAttribPointer(b.color, 3, C.FLOAT, !1, 0, 0));
        U.disableUnusedAttributes();
        C.drawArrays(C.TRIANGLES, 0, a.count);
        a.count = 0
    };
    this.renderBufferDirect = function(a, c, d, e, f, g) {
        var h = f.isMesh && 0 > f.normalMatrix.determinant();
        U.setMaterial(e, h);
        var k = q(a, c, e, f),
            l = !1;
        if (b !== d.id || M !== k.id || J !== (!0 === e.wireframe)) b = d.id, M = k.id, J = !0 === e.wireframe, l = !0;
        f.morphTargetInfluences &&
            ($a.update(f, d, e, k), l = !0);
        h = d.index;
        var m = d.attributes.position;
        c = 1;
        !0 === e.wireframe && (h = Na.getWireframeAttribute(d), c = 2);
        a = Va;
        if (null !== h) {
            var x = Fa.get(h);
            a = Ka;
            a.setIndex(x)
        }
        if (l) {
            if (d && d.isInstancedBufferGeometry & !aa.isWebGL2 && null === W.get("ANGLE_instanced_arrays")) console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            else {
                U.initAttributes();
                l = d.attributes;
                k = k.getAttributes();
                var n = e.defaultAttributeValues;
                for (w in k) {
                    var p = k[w];
                    if (0 <= p) {
                        var r = l[w];
                        if (void 0 !== r) {
                            var z = r.normalized,
                                A = r.itemSize,
                                u = Fa.get(r);
                            if (void 0 !== u) {
                                var t = u.buffer,
                                    y = u.type;
                                u = u.bytesPerElement;
                                if (r.isInterleavedBufferAttribute) {
                                    var B = r.data,
                                        v = B.stride;
                                    r = r.offset;
                                    B && B.isInstancedInterleavedBuffer ? (U.enableAttributeAndDivisor(p, B.meshPerAttribute), void 0 === d.maxInstancedCount && (d.maxInstancedCount = B.meshPerAttribute * B.count)) : U.enableAttribute(p);
                                    C.bindBuffer(C.ARRAY_BUFFER, t);
                                    C.vertexAttribPointer(p, A, y, z, v * u, r * u)
                                } else r.isInstancedBufferAttribute ?
                                    (U.enableAttributeAndDivisor(p, r.meshPerAttribute), void 0 === d.maxInstancedCount && (d.maxInstancedCount = r.meshPerAttribute * r.count)) : U.enableAttribute(p), C.bindBuffer(C.ARRAY_BUFFER, t), C.vertexAttribPointer(p, A, y, z, 0, 0)
                            }
                        } else if (void 0 !== n && (z = n[w], void 0 !== z)) switch (z.length) {
                            case 2:
                                C.vertexAttrib2fv(p, z);
                                break;
                            case 3:
                                C.vertexAttrib3fv(p, z);
                                break;
                            case 4:
                                C.vertexAttrib4fv(p, z);
                                break;
                            default:
                                C.vertexAttrib1fv(p, z)
                        }
                    }
                }
                U.disableUnusedAttributes()
            }
            null !== h && C.bindBuffer(C.ELEMENT_ARRAY_BUFFER, x.buffer)
        }
        x =
            Infinity;
        null !== h ? x = h.count : void 0 !== m && (x = m.count);
        h = d.drawRange.start * c;
        m = null !== g ? g.start * c : 0;
        var w = Math.max(h, m);
        g = Math.max(0, Math.min(x, h + d.drawRange.count * c, m + (null !== g ? g.count * c : Infinity)) - 1 - w + 1);
        if (0 !== g) {
            if (f.isMesh)
                if (!0 === e.wireframe) U.setLineWidth(e.wireframeLinewidth * (null === T ? P : 1)), a.setMode(C.LINES);
                else switch (f.drawMode) {
                    case module$node_modules$three$build$three.default.TrianglesDrawMode:
                        a.setMode(C.TRIANGLES);
                        break;
                    case module$node_modules$three$build$three.default.TriangleStripDrawMode:
                        a.setMode(C.TRIANGLE_STRIP);
                        break;
                    case module$node_modules$three$build$three.default.TriangleFanDrawMode:
                        a.setMode(C.TRIANGLE_FAN)
                } else f.isLine ? (e = e.linewidth, void 0 === e && (e = 1), U.setLineWidth(e * (null === T ? P : 1)), f.isLineSegments ? a.setMode(C.LINES) : f.isLineLoop ? a.setMode(C.LINE_LOOP) : a.setMode(C.LINE_STRIP)) : f.isPoints ? a.setMode(C.POINTS) : f.isSprite && a.setMode(C.TRIANGLES);
            d && d.isInstancedBufferGeometry ? 0 < d.maxInstancedCount && a.renderInstances(d, w, g) : a.render(w, g)
        }
    };
    this.compile = function(a, b) {
        H = Da.get(a, b);
        H.init();
        a.traverse(function(a) {
            a.isLight &&
                (H.pushLight(a), a.castShadow && H.pushShadow(a))
        });
        H.setupLights(b);
        a.traverse(function(b) {
            if (b.material)
                if (Array.isArray(b.material))
                    for (var c = 0; c < b.material.length; c++) m(b.material[c], a.fog, b);
                else m(b.material, a.fog, b)
        })
    };
    var ia = null,
        ha = new WebGLAnimation$$module$node_modules$three$build$three;
    ha.setAnimationLoop(function(a) {
        ua.isPresenting() || ia && ia(a)
    });
    "undefined" !== typeof window && ha.setContext(window);
    this.setAnimationLoop = function(a) {
        ia = a;
        ua.setAnimationLoop(a);
        ha.start()
    };
    this.render = function(a,
        c, d, e) {
        if (!c || !c.isCamera) console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        else if (!I) {
            M = b = null;
            J = !1;
            F = -1;
            R = null;
            !0 === a.autoUpdate && a.updateMatrixWorld();
            null === c.parent && c.updateMatrixWorld();
            ua.enabled && (c = ua.getCamera(c));
            H = Da.get(a, c);
            H.init();
            a.onBeforeRender(D, a, c, d);
            Ha.multiplyMatrices(c.projectionMatrix, c.matrixWorldInverse);
            na.setFromMatrix(Ha);
            Oa = this.localClippingEnabled;
            ta = Q.init(this.clippingPlanes, Oa, c);
            K = Ga.get(a, c);
            K.init();
            k(a, c, D.sortObjects);
            !0 === D.sortObjects && K.sort();
            ta && Q.beginShadows();
            bb.render(H.state.shadowsArray, a, c);
            H.setupLights(c);
            ta && Q.endShadows();
            this.info.autoReset && this.info.reset();
            void 0 === d && (d = null);
            this.setRenderTarget(d);
            ma.render(K, a, c, e);
            e = K.opaque;
            var f = K.transparent;
            if (a.overrideMaterial) {
                var g = a.overrideMaterial;
                e.length && l(e, a, c, g);
                f.length && l(f, a, c, g)
            } else e.length && l(e, a, c), f.length && l(f, a, c);
            d && ya.updateRenderTargetMipmap(d);
            U.buffers.depth.setTest(!0);
            U.buffers.depth.setMask(!0);
            U.buffers.color.setMask(!0);
            U.setPolygonOffset(!1);
            a.onAfterRender(D, a, c);
            ua.enabled && ua.submitFrame();
            H = K = null
        }
    };
    this.allocTextureUnit = function() {
        var a = X;
        a >= aa.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + a + " texture units while this GPU supports only " + aa.maxTextures);
        X += 1;
        return a
    };
    this.setTexture2D = function() {
        var a = !1;
        return function(b, c) {
            b && b.isWebGLRenderTarget && (a || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), a = !0), b = b.texture);
            ya.setTexture2D(b, c)
        }
    }();
    this.setTexture = function() {
        var a = !1;
        return function(b, c) {
            a || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), a = !0);
            ya.setTexture2D(b, c)
        }
    }();
    this.setTextureCube = function() {
        var a = !1;
        return function(b, c) {
            b && b.isWebGLRenderTargetCube && (a || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), a = !0), b = b.texture);
            b && b.isCubeTexture || Array.isArray(b.image) && 6 ===
                b.image.length ? ya.setTextureCube(b, c) : ya.setTextureCubeDynamic(b, c)
        }
    }();
    this.setFramebuffer = function(a) {
        G = a
    };
    this.getRenderTarget = function() {
        return T
    };
    this.setRenderTarget = function(a) {
        (T = a) && void 0 === fa.get(a).__webglFramebuffer && ya.setupRenderTarget(a);
        var b = G,
            c = !1;
        a ? (b = fa.get(a).__webglFramebuffer, a.isWebGLRenderTargetCube && (b = b[a.activeCubeFace], c = !0), S.copy(a.viewport), O.copy(a.scissor), ba = a.scissorTest) : (S.copy(Y).multiplyScalar(P), O.copy(sa).multiplyScalar(P), ba = ka);
        L !== b && (C.bindFramebuffer(C.FRAMEBUFFER,
            b), L = b);
        U.viewport(S);
        U.scissor(O);
        U.setScissorTest(ba);
        c && (c = fa.get(a.texture), C.framebufferTexture2D(C.FRAMEBUFFER, C.COLOR_ATTACHMENT0, C.TEXTURE_CUBE_MAP_POSITIVE_X + a.activeCubeFace, c.__webglTexture, a.activeMipMapLevel))
    };
    this.readRenderTargetPixels = function(a, b, c, d, e, f) {
        if (a && a.isWebGLRenderTarget) {
            var g = fa.get(a).__webglFramebuffer;
            if (g) {
                var h = !1;
                g !== L && (C.bindFramebuffer(C.FRAMEBUFFER, g), h = !0);
                try {
                    var k = a.texture,
                        l = k.format,
                        m = k.type;
                    l !== module$node_modules$three$build$three.default.RGBAFormat &&
                        ra.convert(l) !== C.getParameter(C.IMPLEMENTATION_COLOR_READ_FORMAT) ? console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") : m === module$node_modules$three$build$three.default.UnsignedByteType || ra.convert(m) === C.getParameter(C.IMPLEMENTATION_COLOR_READ_TYPE) || m === module$node_modules$three$build$three.default.FloatType && (aa.isWebGL2 || W.get("OES_texture_float") || W.get("WEBGL_color_buffer_float")) || m === module$node_modules$three$build$three.default.HalfFloatType &&
                        (aa.isWebGL2 ? W.get("EXT_color_buffer_float") : W.get("EXT_color_buffer_half_float")) ? C.checkFramebufferStatus(C.FRAMEBUFFER) === C.FRAMEBUFFER_COMPLETE ? 0 <= b && b <= a.width - d && 0 <= c && c <= a.height - e && C.readPixels(b, c, d, e, ra.convert(l), ra.convert(m), f) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") : console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.")
                } finally {
                    h &&
                        C.bindFramebuffer(C.FRAMEBUFFER, L)
                }
            }
        } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
    };
    this.copyFramebufferToTexture = function(a, b, c) {
        var d = b.image.width,
            e = b.image.height,
            f = ra.convert(b.format);
        this.setTexture2D(b, 0);
        C.copyTexImage2D(C.TEXTURE_2D, c || 0, f, a.x, a.y, d, e, 0)
    };
    this.copyTextureToTexture = function(a, b, c, d) {
        var e = b.image.width,
            f = b.image.height,
            g = ra.convert(c.format),
            h = ra.convert(c.type);
        this.setTexture2D(c, 0);
        b.isDataTexture ? C.texSubImage2D(C.TEXTURE_2D,
            d || 0, a.x, a.y, e, f, g, h, b.image.data) : C.texSubImage2D(C.TEXTURE_2D, d || 0, a.x, a.y, g, h, b.image)
    }
};
module$node_modules$three$build$three.default.FogExp2 = function(a, b) {
    this.name = "";
    this.color = new module$node_modules$three$build$three.default.Color(a);
    this.density = void 0 !== b ? b : 2.5E-4
};
module$node_modules$three$build$three.default.Fog = function(a, b, c) {
    this.name = "";
    this.color = new module$node_modules$three$build$three.default.Color(a);
    this.near = void 0 !== b ? b : 1;
    this.far = void 0 !== c ? c : 1E3
};
module$node_modules$three$build$three.default.Scene = function() {
    module$node_modules$three$build$three.default.Object3D.call(this);
    this.type = "Scene";
    this.overrideMaterial = this.fog = this.background = null;
    this.autoUpdate = !0
};
module$node_modules$three$build$three.default.InterleavedBuffer = function(a, b) {
    this.array = a;
    this.stride = b;
    this.count = void 0 !== a ? a.length / b : 0;
    this.dynamic = !1;
    this.updateRange = {
        offset: 0,
        count: -1
    };
    this.version = 0
};
module$node_modules$three$build$three.default.InterleavedBufferAttribute = function(a, b, c, d) {
    this.data = a;
    this.itemSize = b;
    this.offset = c;
    this.normalized = !0 === d
};
module$node_modules$three$build$three.default.SpriteMaterial = function(a) {
    module$node_modules$three$build$three.default.Material.call(this);
    this.type = "SpriteMaterial";
    this.color = new module$node_modules$three$build$three.default.Color(16777215);
    this.map = null;
    this.rotation = 0;
    this.lights = !1;
    this.transparent = !0;
    this.setValues(a)
};
module$node_modules$three$build$three.default.Sprite = function(a) {
    module$node_modules$three$build$three.default.Object3D.call(this);
    this.type = "Sprite";
    if (void 0 === geometry$$module$node_modules$three$build$three) {
        geometry$$module$node_modules$three$build$three = new module$node_modules$three$build$three.default.BufferGeometry;
        var b = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]);
        b = new module$node_modules$three$build$three.default.InterleavedBuffer(b, 5);
        geometry$$module$node_modules$three$build$three.setIndex([0,
            1, 2, 0, 2, 3
        ]);
        geometry$$module$node_modules$three$build$three.addAttribute("position", new module$node_modules$three$build$three.default.InterleavedBufferAttribute(b, 3, 0, !1));
        geometry$$module$node_modules$three$build$three.addAttribute("uv", new module$node_modules$three$build$three.default.InterleavedBufferAttribute(b, 2, 3, !1))
    }
    this.geometry = geometry$$module$node_modules$three$build$three;
    this.material = void 0 !== a ? a : new module$node_modules$three$build$three.default.SpriteMaterial;
    this.center = new module$node_modules$three$build$three.default.Vector2(.5,
        .5)
};
module$node_modules$three$build$three.default.LOD = function() {
    module$node_modules$three$build$three.default.Object3D.call(this);
    this.type = "LOD";
    Object.defineProperties(this, {
        levels: {
            enumerable: !0,
            value: []
        }
    })
};
module$node_modules$three$build$three.default.Skeleton = function(a, b) {
    a = a || [];
    this.bones = a.slice(0);
    this.boneMatrices = new Float32Array(16 * this.bones.length);
    if (void 0 === b) this.calculateInverses();
    else if (this.bones.length === b.length) this.boneInverses = b.slice(0);
    else
        for (console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [], a = 0, b = this.bones.length; a < b; a++) this.boneInverses.push(new module$node_modules$three$build$three.default.Matrix4)
};
module$node_modules$three$build$three.default.Bone = function() {
    module$node_modules$three$build$three.default.Object3D.call(this);
    this.type = "Bone"
};
module$node_modules$three$build$three.default.SkinnedMesh = function(a, b) {
    module$node_modules$three$build$three.default.Mesh.call(this, a, b);
    this.type = "SkinnedMesh";
    this.bindMode = "attached";
    this.bindMatrix = new module$node_modules$three$build$three.default.Matrix4;
    this.bindMatrixInverse = new module$node_modules$three$build$three.default.Matrix4;
    a = this.initBones();
    a = new module$node_modules$three$build$three.default.Skeleton(a);
    this.bind(a, this.matrixWorld);
    this.normalizeSkinWeights()
};
module$node_modules$three$build$three.default.LineBasicMaterial = function(a) {
    module$node_modules$three$build$three.default.Material.call(this);
    this.type = "LineBasicMaterial";
    this.color = new module$node_modules$three$build$three.default.Color(16777215);
    this.linewidth = 1;
    this.linejoin = this.linecap = "round";
    this.lights = !1;
    this.setValues(a)
};
module$node_modules$three$build$three.default.Line = function(a, b, c) {
    1 === c && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.");
    module$node_modules$three$build$three.default.Object3D.call(this);
    this.type = "Line";
    this.geometry = void 0 !== a ? a : new module$node_modules$three$build$three.default.BufferGeometry;
    this.material = void 0 !== b ? b : new module$node_modules$three$build$three.default.LineBasicMaterial({
        color: 16777215 * Math.random()
    })
};
module$node_modules$three$build$three.default.LineSegments = function(a, b) {
    module$node_modules$three$build$three.default.Line.call(this, a, b);
    this.type = "LineSegments"
};
module$node_modules$three$build$three.default.LineLoop = function(a, b) {
    module$node_modules$three$build$three.default.Line.call(this, a, b);
    this.type = "LineLoop"
};
module$node_modules$three$build$three.default.PointsMaterial = function(a) {
    module$node_modules$three$build$three.default.Material.call(this);
    this.type = "PointsMaterial";
    this.color = new module$node_modules$three$build$three.default.Color(16777215);
    this.map = null;
    this.size = 1;
    this.sizeAttenuation = !0;
    this.lights = this.morphTargets = !1;
    this.setValues(a)
};
module$node_modules$three$build$three.default.Points = function(a, b) {
    module$node_modules$three$build$three.default.Object3D.call(this);
    this.type = "Points";
    this.geometry = void 0 !== a ? a : new module$node_modules$three$build$three.default.BufferGeometry;
    this.material = void 0 !== b ? b : new module$node_modules$three$build$three.default.PointsMaterial({
        color: 16777215 * Math.random()
    })
};
module$node_modules$three$build$three.default.VideoTexture = function(a, b, c, d, e, f, g, h, k) {
    module$node_modules$three$build$three.default.Texture.call(this, a, b, c, d, e, f, g, h, k);
    this.generateMipmaps = !1
};
module$node_modules$three$build$three.default.CompressedTexture = function(a, b, c, d, e, f, g, h, k, l, p, m) {
    module$node_modules$three$build$three.default.Texture.call(this, null, f, g, h, k, l, d, e, p, m);
    this.image = {
        width: b,
        height: c
    };
    this.mipmaps = a;
    this.generateMipmaps = this.flipY = !1
};
module$node_modules$three$build$three.default.CanvasTexture = function(a, b, c, d, e, f, g, h, k) {
    module$node_modules$three$build$three.default.Texture.call(this, a, b, c, d, e, f, g, h, k);
    this.needsUpdate = !0
};
module$node_modules$three$build$three.default.DepthTexture = function(a, b, c, d, e, f, g, h, k, l) {
    l = void 0 !== l ? l : module$node_modules$three$build$three.default.DepthFormat;
    if (l !== module$node_modules$three$build$three.default.DepthFormat && l !== module$node_modules$three$build$three.default.DepthStencilFormat) throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    void 0 === c && l === module$node_modules$three$build$three.default.DepthFormat && (c = module$node_modules$three$build$three.default.UnsignedShortType);
    void 0 === c && l === module$node_modules$three$build$three.default.DepthStencilFormat && (c = module$node_modules$three$build$three.default.UnsignedInt248Type);
    module$node_modules$three$build$three.default.Texture.call(this, null, d, e, f, g, h, l, c, k);
    this.image = {
        width: a,
        height: b
    };
    this.magFilter = void 0 !== g ? g : module$node_modules$three$build$three.default.NearestFilter;
    this.minFilter = void 0 !== h ? h : module$node_modules$three$build$three.default.NearestFilter;
    this.generateMipmaps = this.flipY = !1
};
module$node_modules$three$build$three.default.WireframeGeometry = function(a) {
    module$node_modules$three$build$three.default.BufferGeometry.call(this);
    this.type = "WireframeGeometry";
    var b = [],
        c, d, e, f = [0, 0],
        g = {},
        h = ["a", "b", "c"];
    if (a && a.isGeometry) {
        var k = a.faces;
        var l = 0;
        for (d = k.length; l < d; l++) {
            var p = k[l];
            for (c = 0; 3 > c; c++) {
                var m = p[h[c]];
                var q = p[h[(c + 1) % 3]];
                f[0] = Math.min(m, q);
                f[1] = Math.max(m, q);
                m = f[0] + "," + f[1];
                void 0 === g[m] && (g[m] = {
                    index1: f[0],
                    index2: f[1]
                })
            }
        }
        for (m in g) l = g[m], h = a.vertices[l.index1], b.push(h.x,
            h.y, h.z), h = a.vertices[l.index2], b.push(h.x, h.y, h.z)
    } else if (a && a.isBufferGeometry)
        if (h = new module$node_modules$three$build$three.default.Vector3, null !== a.index) {
            k = a.attributes.position;
            p = a.index;
            var r = a.groups;
            0 === r.length && (r = [{
                start: 0,
                count: p.count,
                materialIndex: 0
            }]);
            a = 0;
            for (e = r.length; a < e; ++a)
                for (l = r[a], c = l.start, d = l.count, l = c, d = c + d; l < d; l += 3)
                    for (c = 0; 3 > c; c++) m = p.getX(l + c), q = p.getX(l + (c + 1) % 3), f[0] = Math.min(m, q), f[1] = Math.max(m, q), m = f[0] + "," + f[1], void 0 === g[m] && (g[m] = {
                        index1: f[0],
                        index2: f[1]
                    });
            for (m in g) l =
                g[m], h.fromBufferAttribute(k, l.index1), b.push(h.x, h.y, h.z), h.fromBufferAttribute(k, l.index2), b.push(h.x, h.y, h.z)
        } else
            for (k = a.attributes.position, l = 0, d = k.count / 3; l < d; l++)
                for (c = 0; 3 > c; c++) g = 3 * l + c, h.fromBufferAttribute(k, g), b.push(h.x, h.y, h.z), g = 3 * l + (c + 1) % 3, h.fromBufferAttribute(k, g), b.push(h.x, h.y, h.z);
    this.addAttribute("position", new module$node_modules$three$build$three.default.Float32BufferAttribute(b, 3))
};
module$node_modules$three$build$three.default.ParametricGeometry = function(a, b, c) {
    module$node_modules$three$build$three.default.Geometry.call(this);
    this.type = "ParametricGeometry";
    this.parameters = {
        func: a,
        slices: b,
        stacks: c
    };
    this.fromBufferGeometry(new module$node_modules$three$build$three.default.ParametricBufferGeometry(a, b, c));
    this.mergeVertices()
};
module$node_modules$three$build$three.default.ParametricBufferGeometry = function(a, b, c) {
    module$node_modules$three$build$three.default.BufferGeometry.call(this);
    this.type = "ParametricBufferGeometry";
    this.parameters = {
        func: a,
        slices: b,
        stacks: c
    };
    var d = [],
        e = [],
        f = [],
        g = [],
        h = new module$node_modules$three$build$three.default.Vector3,
        k = new module$node_modules$three$build$three.default.Vector3,
        l = new module$node_modules$three$build$three.default.Vector3,
        p = new module$node_modules$three$build$three.default.Vector3,
        m = new module$node_modules$three$build$three.default.Vector3,
        q, r;
    3 > a.length && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
    var n = b + 1;
    for (q = 0; q <= c; q++) {
        var t = q / c;
        for (r = 0; r <= b; r++) {
            var u = r / b;
            a(u, t, k);
            e.push(k.x, k.y, k.z);
            0 <= u - 1E-5 ? (a(u - 1E-5, t, l), p.subVectors(k, l)) : (a(u + 1E-5, t, l), p.subVectors(l, k));
            0 <= t - 1E-5 ? (a(u, t - 1E-5, l), m.subVectors(k, l)) : (a(u, t + 1E-5, l), m.subVectors(l, k));
            h.crossVectors(p, m).normalize();
            f.push(h.x, h.y, h.z);
            g.push(u, t)
        }
    }
    for (q = 0; q < c; q++)
        for (r =
            0; r < b; r++) a = q * n + r + 1, h = (q + 1) * n + r + 1, k = (q + 1) * n + r, d.push(q * n + r, a, k), d.push(a, h, k);
    this.setIndex(d);
    this.addAttribute("position", new module$node_modules$three$build$three.default.Float32BufferAttribute(e, 3));
    this.addAttribute("normal", new module$node_modules$three$build$three.default.Float32BufferAttribute(f, 3));
    this.addAttribute("uv", new module$node_modules$three$build$three.default.Float32BufferAttribute(g, 2))
};
module$node_modules$three$build$three.default.PolyhedronGeometry = function(a, b, c, d) {
    module$node_modules$three$build$three.default.Geometry.call(this);
    this.type = "PolyhedronGeometry";
    this.parameters = {
        vertices: a,
        indices: b,
        radius: c,
        detail: d
    };
    this.fromBufferGeometry(new module$node_modules$three$build$three.default.PolyhedronBufferGeometry(a, b, c, d));
    this.mergeVertices()
};
module$node_modules$three$build$three.default.PolyhedronBufferGeometry = function(a, b, c, d) {
    function e(a) {
        h.push(a.x, a.y, a.z)
    }

    function f(b, c) {
        b *= 3;
        c.x = a[b + 0];
        c.y = a[b + 1];
        c.z = a[b + 2]
    }

    function g(a, b, c, d) {
        0 > d && 1 === a.x && (k[b] = a.x - 1);
        0 === c.x && 0 === c.z && (k[b] = d / 2 / Math.PI + .5)
    }
    module$node_modules$three$build$three.default.BufferGeometry.call(this);
    this.type = "PolyhedronBufferGeometry";
    this.parameters = {
        vertices: a,
        indices: b,
        radius: c,
        detail: d
    };
    c = c || 1;
    d = d || 0;
    var h = [],
        k = [];
    (function(a) {
        for (var c = new module$node_modules$three$build$three.default.Vector3,
                d = new module$node_modules$three$build$three.default.Vector3, g = new module$node_modules$three$build$three.default.Vector3, h = 0; h < b.length; h += 3) {
            f(b[h + 0], c);
            f(b[h + 1], d);
            f(b[h + 2], g);
            var k, l, u = c,
                w = d,
                v = g,
                y = Math.pow(2, a),
                A = [];
            for (l = 0; l <= y; l++) {
                A[l] = [];
                var x = u.clone().lerp(v, l / y),
                    z = w.clone().lerp(v, l / y),
                    B = y - l;
                for (k = 0; k <= B; k++) A[l][k] = 0 === k && l === y ? x : x.clone().lerp(z, k / B)
            }
            for (l = 0; l < y; l++)
                for (k = 0; k < 2 * (y - l) - 1; k++) u = Math.floor(k / 2), 0 === k % 2 ? (e(A[l][u + 1]), e(A[l + 1][u]), e(A[l][u])) : (e(A[l][u + 1]), e(A[l + 1][u + 1]), e(A[l +
                    1][u]))
        }
    })(d);
    (function(a) {
        for (var b = new module$node_modules$three$build$three.default.Vector3, c = 0; c < h.length; c += 3) b.x = h[c + 0], b.y = h[c + 1], b.z = h[c + 2], b.normalize().multiplyScalar(a), h[c + 0] = b.x, h[c + 1] = b.y, h[c + 2] = b.z
    })(c);
    (function() {
        for (var a = new module$node_modules$three$build$three.default.Vector3, b = 0; b < h.length; b += 3) a.x = h[b + 0], a.y = h[b + 1], a.z = h[b + 2], k.push(Math.atan2(a.z, -a.x) / 2 / Math.PI + .5, 1 - (Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + .5));
        a = new module$node_modules$three$build$three.default.Vector3;
        b = new module$node_modules$three$build$three.default.Vector3;
        for (var c = new module$node_modules$three$build$three.default.Vector3, d = new module$node_modules$three$build$three.default.Vector3, e = new module$node_modules$three$build$three.default.Vector2, f = new module$node_modules$three$build$three.default.Vector2, t = new module$node_modules$three$build$three.default.Vector2, u = 0, w = 0; u < h.length; u += 9, w += 6) {
            a.set(h[u + 0], h[u + 1], h[u + 2]);
            b.set(h[u + 3], h[u + 4], h[u + 5]);
            c.set(h[u + 6], h[u + 7], h[u + 8]);
            e.set(k[w + 0], k[w + 1]);
            f.set(k[w + 2], k[w + 3]);
            t.set(k[w + 4], k[w + 5]);
            d.copy(a).add(b).add(c).divideScalar(3);
            var v = Math.atan2(d.z, -d.x);
            g(e, w + 0, a, v);
            g(f, w + 2, b, v);
            g(t, w + 4, c, v)
        }
        for (a = 0; a < k.length; a += 6) b = k[a + 0], c = k[a + 2], d = k[a + 4], e = Math.min(b, c, d), .9 < Math.max(b, c, d) && .1 > e && (.2 > b && (k[a + 0] += 1), .2 > c && (k[a + 2] += 1), .2 > d && (k[a + 4] += 1))
    })();
    this.addAttribute("position", new module$node_modules$three$build$three.default.Float32BufferAttribute(h, 3));
    this.addAttribute("normal", new module$node_modules$three$build$three.default.Float32BufferAttribute(h.slice(),
        3));
    this.addAttribute("uv", new module$node_modules$three$build$three.default.Float32BufferAttribute(k, 2));
    0 === d ? this.computeVertexNormals() : this.normalizeNormals()
};
module$node_modules$three$build$three.default.TetrahedronGeometry = function(a, b) {
    module$node_modules$three$build$three.default.Geometry.call(this);
    this.type = "TetrahedronGeometry";
    this.parameters = {
        radius: a,
        detail: b
    };
    this.fromBufferGeometry(new module$node_modules$three$build$three.default.TetrahedronBufferGeometry(a, b));
    this.mergeVertices()
};
module$node_modules$three$build$three.default.TetrahedronBufferGeometry = function(a, b) {
    module$node_modules$three$build$three.default.PolyhedronBufferGeometry.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], a, b);
    this.type = "TetrahedronBufferGeometry";
    this.parameters = {
        radius: a,
        detail: b
    }
};
module$node_modules$three$build$three.default.OctahedronGeometry = function(a, b) {
    module$node_modules$three$build$three.default.Geometry.call(this);
    this.type = "OctahedronGeometry";
    this.parameters = {
        radius: a,
        detail: b
    };
    this.fromBufferGeometry(new module$node_modules$three$build$three.default.OctahedronBufferGeometry(a, b));
    this.mergeVertices()
};
module$node_modules$three$build$three.default.OctahedronBufferGeometry = function(a, b) {
    module$node_modules$three$build$three.default.PolyhedronBufferGeometry.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], a, b);
    this.type = "OctahedronBufferGeometry";
    this.parameters = {
        radius: a,
        detail: b
    }
};
module$node_modules$three$build$three.default.IcosahedronGeometry = function(a, b) {
    module$node_modules$three$build$three.default.Geometry.call(this);
    this.type = "IcosahedronGeometry";
    this.parameters = {
        radius: a,
        detail: b
    };
    this.fromBufferGeometry(new module$node_modules$three$build$three.default.IcosahedronBufferGeometry(a, b));
    this.mergeVertices()
};
module$node_modules$three$build$three.default.IcosahedronBufferGeometry = function(a, b) {
    var c = (1 + Math.sqrt(5)) / 2;
    module$node_modules$three$build$three.default.PolyhedronBufferGeometry.call(this, [-1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, 0, 0, -1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, c, 0, -1, c, 0, 1, -c, 0, -1, -c, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], a, b);
    this.type = "IcosahedronBufferGeometry";
    this.parameters = {
        radius: a,
        detail: b
    }
};
module$node_modules$three$build$three.default.DodecahedronGeometry = function(a, b) {
    module$node_modules$three$build$three.default.Geometry.call(this);
    this.type = "DodecahedronGeometry";
    this.parameters = {
        radius: a,
        detail: b
    };
    this.fromBufferGeometry(new module$node_modules$three$build$three.default.DodecahedronBufferGeometry(a, b));
    this.mergeVertices()
};
module$node_modules$three$build$three.default.DodecahedronBufferGeometry = function(a, b) {
    var c = (1 + Math.sqrt(5)) / 2,
        d = 1 / c;
    module$node_modules$three$build$three.default.PolyhedronBufferGeometry.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, 0, -c, 0, -d, c, 0, -d, -c, 0, d, c, 0, d], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18,
        1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9
    ], a, b);
    this.type = "DodecahedronBufferGeometry";
    this.parameters = {
        radius: a,
        detail: b
    }
};
module$node_modules$three$build$three.default.TubeGeometry = function(a, b, c, d, e, f) {
    module$node_modules$three$build$three.default.Geometry.call(this);
    this.type = "TubeGeometry";
    this.parameters = {
        path: a,
        tubularSegments: b,
        radius: c,
        radialSegments: d,
        closed: e
    };
    void 0 !== f && console.warn("THREE.TubeGeometry: taper has been removed.");
    a = new module$node_modules$three$build$three.default.TubeBufferGeometry(a, b, c, d, e);
    this.tangents = a.tangents;
    this.normals = a.normals;
    this.binormals = a.binormals;
    this.fromBufferGeometry(a);
    this.mergeVertices()
};
module$node_modules$three$build$three.default.TubeBufferGeometry = function(a, b, c, d, e) {
    function f(e) {
        p = a.getPointAt(e / b, p);
        var f = g.normals[e];
        e = g.binormals[e];
        for (q = 0; q <= d; q++) {
            var l = q / d * Math.PI * 2,
                m = Math.sin(l);
            l = -Math.cos(l);
            k.x = l * f.x + m * e.x;
            k.y = l * f.y + m * e.y;
            k.z = l * f.z + m * e.z;
            k.normalize();
            n.push(k.x, k.y, k.z);
            h.x = p.x + c * k.x;
            h.y = p.y + c * k.y;
            h.z = p.z + c * k.z;
            r.push(h.x, h.y, h.z)
        }
    }
    module$node_modules$three$build$three.default.BufferGeometry.call(this);
    this.type = "TubeBufferGeometry";
    this.parameters = {
        path: a,
        tubularSegments: b,
        radius: c,
        radialSegments: d,
        closed: e
    };
    b = b || 64;
    c = c || 1;
    d = d || 8;
    e = e || !1;
    var g = a.computeFrenetFrames(b, e);
    this.tangents = g.tangents;
    this.normals = g.normals;
    this.binormals = g.binormals;
    var h = new module$node_modules$three$build$three.default.Vector3,
        k = new module$node_modules$three$build$three.default.Vector3,
        l = new module$node_modules$three$build$three.default.Vector2,
        p = new module$node_modules$three$build$three.default.Vector3,
        m, q, r = [],
        n = [],
        t = [],
        u = [];
    for (m = 0; m < b; m++) f(m);
    f(!1 === e ? b : 0);
    for (m = 0; m <= b; m++)
        for (q = 0; q <=
            d; q++) l.x = m / b, l.y = q / d, t.push(l.x, l.y);
    (function() {
        for (q = 1; q <= b; q++)
            for (m = 1; m <= d; m++) {
                var a = (d + 1) * q + (m - 1),
                    c = (d + 1) * q + m,
                    e = (d + 1) * (q - 1) + m;
                u.push((d + 1) * (q - 1) + (m - 1), a, e);
                u.push(a, c, e)
            }
    })();
    this.setIndex(u);
    this.addAttribute("position", new module$node_modules$three$build$three.default.Float32BufferAttribute(r, 3));
    this.addAttribute("normal", new module$node_modules$three$build$three.default.Float32BufferAttribute(n, 3));
    this.addAttribute("uv", new module$node_modules$three$build$three.default.Float32BufferAttribute(t,
        2))
};
module$node_modules$three$build$three.default.TorusKnotGeometry = function(a, b, c, d, e, f, g) {
    module$node_modules$three$build$three.default.Geometry.call(this);
    this.type = "TorusKnotGeometry";
    this.parameters = {
        radius: a,
        tube: b,
        tubularSegments: c,
        radialSegments: d,
        p: e,
        q: f
    };
    void 0 !== g && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.");
    this.fromBufferGeometry(new module$node_modules$three$build$three.default.TorusKnotBufferGeometry(a, b, c, d, e, f));
    this.mergeVertices()
};
module$node_modules$three$build$three.default.TorusKnotBufferGeometry = function(a, b, c, d, e, f) {
    function g(a, b, c, d, e) {
        var f = Math.sin(a);
        b = c / b * a;
        c = Math.cos(b);
        e.x = d * (2 + c) * .5 * Math.cos(a);
        e.y = d * (2 + c) * f * .5;
        e.z = d * Math.sin(b) * .5
    }
    module$node_modules$three$build$three.default.BufferGeometry.call(this);
    this.type = "TorusKnotBufferGeometry";
    this.parameters = {
        radius: a,
        tube: b,
        tubularSegments: c,
        radialSegments: d,
        p: e,
        q: f
    };
    a = a || 1;
    b = b || .4;
    c = Math.floor(c) || 64;
    d = Math.floor(d) || 8;
    e = e || 2;
    f = f || 3;
    var h = [],
        k = [],
        l = [],
        p = [],
        m, q = new module$node_modules$three$build$three.default.Vector3,
        r = new module$node_modules$three$build$three.default.Vector3,
        n = new module$node_modules$three$build$three.default.Vector3,
        t = new module$node_modules$three$build$three.default.Vector3,
        u = new module$node_modules$three$build$three.default.Vector3,
        w = new module$node_modules$three$build$three.default.Vector3,
        v = new module$node_modules$three$build$three.default.Vector3;
    for (m = 0; m <= c; ++m) {
        var y = m / c * e * Math.PI * 2;
        g(y, e, f, a, n);
        g(y + .01, e, f, a, t);
        w.subVectors(t, n);
        v.addVectors(t, n);
        u.crossVectors(w, v);
        v.crossVectors(u,
            w);
        u.normalize();
        v.normalize();
        for (y = 0; y <= d; ++y) {
            var A = y / d * Math.PI * 2,
                x = -b * Math.cos(A);
            A = b * Math.sin(A);
            q.x = n.x + (x * v.x + A * u.x);
            q.y = n.y + (x * v.y + A * u.y);
            q.z = n.z + (x * v.z + A * u.z);
            k.push(q.x, q.y, q.z);
            r.subVectors(q, n).normalize();
            l.push(r.x, r.y, r.z);
            p.push(m / c);
            p.push(y / d)
        }
    }
    for (y = 1; y <= c; y++)
        for (m = 1; m <= d; m++) a = (d + 1) * y + (m - 1), b = (d + 1) * y + m, e = (d + 1) * (y - 1) + m, h.push((d + 1) * (y - 1) + (m - 1), a, e), h.push(a, b, e);
    this.setIndex(h);
    this.addAttribute("position", new module$node_modules$three$build$three.default.Float32BufferAttribute(k,
        3));
    this.addAttribute("normal", new module$node_modules$three$build$three.default.Float32BufferAttribute(l, 3));
    this.addAttribute("uv", new module$node_modules$three$build$three.default.Float32BufferAttribute(p, 2))
};
module$node_modules$three$build$three.default.TorusGeometry = function(a, b, c, d, e) {
    module$node_modules$three$build$three.default.Geometry.call(this);
    this.type = "TorusGeometry";
    this.parameters = {
        radius: a,
        tube: b,
        radialSegments: c,
        tubularSegments: d,
        arc: e
    };
    this.fromBufferGeometry(new module$node_modules$three$build$three.default.TorusBufferGeometry(a, b, c, d, e));
    this.mergeVertices()
};
module$node_modules$three$build$three.default.TorusBufferGeometry = function(a, b, c, d, e) {
    module$node_modules$three$build$three.default.BufferGeometry.call(this);
    this.type = "TorusBufferGeometry";
    this.parameters = {
        radius: a,
        tube: b,
        radialSegments: c,
        tubularSegments: d,
        arc: e
    };
    a = a || 1;
    b = b || .4;
    c = Math.floor(c) || 8;
    d = Math.floor(d) || 6;
    e = e || 2 * Math.PI;
    var f = [],
        g = [],
        h = [],
        k = [],
        l = new module$node_modules$three$build$three.default.Vector3,
        p = new module$node_modules$three$build$three.default.Vector3,
        m = new module$node_modules$three$build$three.default.Vector3,
        q, r;
    for (q = 0; q <= c; q++)
        for (r = 0; r <= d; r++) {
            var n = r / d * e,
                t = q / c * Math.PI * 2;
            p.x = (a + b * Math.cos(t)) * Math.cos(n);
            p.y = (a + b * Math.cos(t)) * Math.sin(n);
            p.z = b * Math.sin(t);
            g.push(p.x, p.y, p.z);
            l.x = a * Math.cos(n);
            l.y = a * Math.sin(n);
            m.subVectors(p, l).normalize();
            h.push(m.x, m.y, m.z);
            k.push(r / d);
            k.push(q / c)
        }
    for (q = 1; q <= c; q++)
        for (r = 1; r <= d; r++) a = (d + 1) * (q - 1) + r - 1, b = (d + 1) * (q - 1) + r, e = (d + 1) * q + r, f.push((d + 1) * q + r - 1, a, e), f.push(a, b, e);
    this.setIndex(f);
    this.addAttribute("position", new module$node_modules$three$build$three.default.Float32BufferAttribute(g,
        3));
    this.addAttribute("normal", new module$node_modules$three$build$three.default.Float32BufferAttribute(h, 3));
    this.addAttribute("uv", new module$node_modules$three$build$three.default.Float32BufferAttribute(k, 2))
};
module$node_modules$three$build$three.default.ExtrudeGeometry = function(a, b) {
    module$node_modules$three$build$three.default.Geometry.call(this);
    this.type = "ExtrudeGeometry";
    this.parameters = {
        shapes: a,
        options: b
    };
    this.fromBufferGeometry(new module$node_modules$three$build$three.default.ExtrudeBufferGeometry(a, b));
    this.mergeVertices()
};
module$node_modules$three$build$three.default.ExtrudeBufferGeometry = function(a, b) {
    function c(a) {
        function c(a, b, c) {
            b || console.error("THREE.ExtrudeGeometry: vec does not exist");
            return b.clone().multiplyScalar(c).add(a)
        }

        function g(a, b, c) {
            var d = a.x - b.x;
            var e = a.y - b.y;
            var f = c.x - a.x;
            var g = c.y - a.y,
                h = d * d + e * e;
            if (Math.abs(d * g - e * f) > Number.EPSILON) {
                var k = Math.sqrt(h),
                    l = Math.sqrt(f * f + g * g);
                h = b.x - e / k;
                b = b.y + d / k;
                g = ((c.x - g / l - h) * g - (c.y + f / l - b) * f) / (d * g - e * f);
                f = h + d * g - a.x;
                d = b + e * g - a.y;
                e = f * f + d * d;
                if (2 >= e) return new module$node_modules$three$build$three.default.Vector2(f,
                    d);
                e = Math.sqrt(e / 2)
            } else a = !1, d > Number.EPSILON ? f > Number.EPSILON && (a = !0) : d < -Number.EPSILON ? f < -Number.EPSILON && (a = !0) : Math.sign(e) === Math.sign(g) && (a = !0), a ? (f = -e, e = Math.sqrt(h)) : (f = d, d = e, e = Math.sqrt(h / 2));
            return new module$node_modules$three$build$three.default.Vector2(f / e, d / e)
        }

        function h(a, b) {
            for (E = a.length; 0 <= --E;) {
                var c = E;
                var f = E - 1;
                0 > f && (f = a.length - 1);
                var g, h = v + 2 * B;
                for (g = 0; g < h; g++) {
                    var k = ba * g,
                        l = ba * (g + 1),
                        x = b + f + k,
                        m = b + f + l;
                    l = b + c + l;
                    n(b + c + k);
                    n(x);
                    n(l);
                    n(x);
                    n(m);
                    n(l);
                    k = e.length / 3;
                    k = K.generateSideWallUV(d,
                        e, k - 6, k - 3, k - 2, k - 1);
                    t(k[0]);
                    t(k[1]);
                    t(k[3]);
                    t(k[1]);
                    t(k[2]);
                    t(k[3])
                }
            }
        }

        function k(a, b, c) {
            u.push(a);
            u.push(b);
            u.push(c)
        }

        function r(a, b, c) {
            n(a);
            n(b);
            n(c);
            a = e.length / 3;
            a = K.generateTopUV(d, e, a - 3, a - 2, a - 1);
            t(a[0]);
            t(a[1]);
            t(a[2])
        }

        function n(a) {
            e.push(u[3 * a]);
            e.push(u[3 * a + 1]);
            e.push(u[3 * a + 2])
        }

        function t(a) {
            f.push(a.x);
            f.push(a.y)
        }
        var u = [],
            w = void 0 !== b.curveSegments ? b.curveSegments : 12,
            v = void 0 !== b.steps ? b.steps : 1,
            y = void 0 !== b.depth ? b.depth : 100,
            A = void 0 !== b.bevelEnabled ? b.bevelEnabled : !0,
            x = void 0 !== b.bevelThickness ?
            b.bevelThickness : 6,
            z = void 0 !== b.bevelSize ? b.bevelSize : x - 2,
            B = void 0 !== b.bevelSegments ? b.bevelSegments : 3,
            N = b.extrudePath,
            K = void 0 !== b.UVGenerator ? b.UVGenerator : WorldUVGenerator$$module$node_modules$three$build$three;
        void 0 !== b.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), y = b.amount);
        var H = !1;
        if (N) {
            var D = N.getSpacedPoints(v);
            H = !0;
            A = !1;
            var I = N.computeFrenetFrames(v, !1);
            var G = new module$node_modules$three$build$three.default.Vector3;
            var T = new module$node_modules$three$build$three.default.Vector3;
            var L = new module$node_modules$three$build$three.default.Vector3
        }
        A || (z = x = B = 0);
        var F;
        w = a.extractPoints(w);
        a = w.shape;
        var M = w.holes;
        if (!module$node_modules$three$build$three.default.ShapeUtils.isClockWise(a)) {
            a = a.reverse();
            var J = 0;
            for (F = M.length; J < F; J++) {
                var R = M[J];
                module$node_modules$three$build$three.default.ShapeUtils.isClockWise(R) && (M[J] = R.reverse())
            }
        }
        var V = module$node_modules$three$build$three.default.ShapeUtils.triangulateShape(a, M),
            S = a;
        J = 0;
        for (F = M.length; J < F; J++) R = M[J], a = a.concat(R);
        var O, ba =
            a.length,
            X, ca = V.length;
        w = [];
        var E = 0;
        var P = S.length;
        var Y = P - 1;
        for (O = E + 1; E < P; E++, Y++, O++) Y === P && (Y = 0), O === P && (O = 0), w[E] = g(S[E], S[Y], S[O]);
        N = [];
        var sa = w.concat();
        J = 0;
        for (F = M.length; J < F; J++) {
            R = M[J];
            var ka = [];
            E = 0;
            P = R.length;
            Y = P - 1;
            for (O = E + 1; E < P; E++, Y++, O++) Y === P && (Y = 0), O === P && (O = 0), ka[E] = g(R[E], R[Y], R[O]);
            N.push(ka);
            sa = sa.concat(ka)
        }
        for (Y = 0; Y < B; Y++) {
            P = Y / B;
            var na = x * Math.cos(P * Math.PI / 2);
            O = z * Math.sin(P * Math.PI / 2);
            E = 0;
            for (P = S.length; E < P; E++) {
                var Q = c(S[E], w[E], O);
                k(Q.x, Q.y, -na)
            }
            J = 0;
            for (F = M.length; J < F; J++)
                for (R =
                    M[J], ka = N[J], E = 0, P = R.length; E < P; E++) Q = c(R[E], ka[E], O), k(Q.x, Q.y, -na)
        }
        O = z;
        for (E = 0; E < ba; E++) Q = A ? c(a[E], sa[E], O) : a[E], H ? (T.copy(I.normals[0]).multiplyScalar(Q.x), G.copy(I.binormals[0]).multiplyScalar(Q.y), L.copy(D[0]).add(T).add(G), k(L.x, L.y, L.z)) : k(Q.x, Q.y, 0);
        for (P = 1; P <= v; P++)
            for (E = 0; E < ba; E++) Q = A ? c(a[E], sa[E], O) : a[E], H ? (T.copy(I.normals[P]).multiplyScalar(Q.x), G.copy(I.binormals[P]).multiplyScalar(Q.y), L.copy(D[P]).add(T).add(G), k(L.x, L.y, L.z)) : k(Q.x, Q.y, y / v * P);
        for (Y = B - 1; 0 <= Y; Y--) {
            P = Y / B;
            na = x * Math.cos(P *
                Math.PI / 2);
            O = z * Math.sin(P * Math.PI / 2);
            E = 0;
            for (P = S.length; E < P; E++) Q = c(S[E], w[E], O), k(Q.x, Q.y, y + na);
            J = 0;
            for (F = M.length; J < F; J++)
                for (R = M[J], ka = N[J], E = 0, P = R.length; E < P; E++) Q = c(R[E], ka[E], O), H ? k(Q.x, Q.y + D[v - 1].y, D[v - 1].x + na) : k(Q.x, Q.y, y + na)
        }(function() {
            var a = e.length / 3;
            if (A) {
                var b = 0 * ba;
                for (E = 0; E < ca; E++) X = V[E], r(X[2] + b, X[1] + b, X[0] + b);
                b = ba * (v + 2 * B);
                for (E = 0; E < ca; E++) X = V[E], r(X[0] + b, X[1] + b, X[2] + b)
            } else {
                for (E = 0; E < ca; E++) X = V[E], r(X[2], X[1], X[0]);
                for (E = 0; E < ca; E++) X = V[E], r(X[0] + ba * v, X[1] + ba * v, X[2] + ba * v)
            }
            d.addGroup(a,
                e.length / 3 - a, 0)
        })();
        (function() {
            var a = e.length / 3,
                b = 0;
            h(S, b);
            b += S.length;
            J = 0;
            for (F = M.length; J < F; J++) R = M[J], h(R, b), b += R.length;
            d.addGroup(a, e.length / 3 - a, 1)
        })()
    }
    module$node_modules$three$build$three.default.BufferGeometry.call(this);
    this.type = "ExtrudeBufferGeometry";
    this.parameters = {
        shapes: a,
        options: b
    };
    a = Array.isArray(a) ? a : [a];
    for (var d = this, e = [], f = [], g = 0, h = a.length; g < h; g++) c(a[g]);
    this.addAttribute("position", new module$node_modules$three$build$three.default.Float32BufferAttribute(e, 3));
    this.addAttribute("uv",
        new module$node_modules$three$build$three.default.Float32BufferAttribute(f, 2));
    this.computeVertexNormals()
};
module$node_modules$three$build$three.default.TextGeometry = function(a, b) {
    module$node_modules$three$build$three.default.Geometry.call(this);
    this.type = "TextGeometry";
    this.parameters = {
        text: a,
        parameters: b
    };
    this.fromBufferGeometry(new module$node_modules$three$build$three.default.TextBufferGeometry(a, b));
    this.mergeVertices()
};
module$node_modules$three$build$three.default.TextBufferGeometry = function(a, b) {
    b = b || {};
    var c = b.font;
    if (!c || !c.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new module$node_modules$three$build$three.default.Geometry;
    a = c.generateShapes(a, b.size);
    b.depth = void 0 !== b.height ? b.height : 50;
    void 0 === b.bevelThickness && (b.bevelThickness = 10);
    void 0 === b.bevelSize && (b.bevelSize = 8);
    void 0 === b.bevelEnabled && (b.bevelEnabled = !1);
    module$node_modules$three$build$three.default.ExtrudeBufferGeometry.call(this,
        a, b);
    this.type = "TextBufferGeometry"
};
module$node_modules$three$build$three.default.SphereGeometry = function(a, b, c, d, e, f, g) {
    module$node_modules$three$build$three.default.Geometry.call(this);
    this.type = "SphereGeometry";
    this.parameters = {
        radius: a,
        widthSegments: b,
        heightSegments: c,
        phiStart: d,
        phiLength: e,
        thetaStart: f,
        thetaLength: g
    };
    this.fromBufferGeometry(new module$node_modules$three$build$three.default.SphereBufferGeometry(a, b, c, d, e, f, g));
    this.mergeVertices()
};
module$node_modules$three$build$three.default.SphereBufferGeometry = function(a, b, c, d, e, f, g) {
    module$node_modules$three$build$three.default.BufferGeometry.call(this);
    this.type = "SphereBufferGeometry";
    this.parameters = {
        radius: a,
        widthSegments: b,
        heightSegments: c,
        phiStart: d,
        phiLength: e,
        thetaStart: f,
        thetaLength: g
    };
    a = a || 1;
    b = Math.max(3, Math.floor(b) || 8);
    c = Math.max(2, Math.floor(c) || 6);
    d = void 0 !== d ? d : 0;
    e = void 0 !== e ? e : 2 * Math.PI;
    f = void 0 !== f ? f : 0;
    g = void 0 !== g ? g : Math.PI;
    var h = f + g,
        k, l, p = 0,
        m = [],
        q = new module$node_modules$three$build$three.default.Vector3,
        r = new module$node_modules$three$build$three.default.Vector3,
        n = [],
        t = [],
        u = [],
        w = [];
    for (l = 0; l <= c; l++) {
        var v = [],
            y = l / c;
        for (k = 0; k <= b; k++) {
            var A = k / b;
            q.x = -a * Math.cos(d + A * e) * Math.sin(f + y * g);
            q.y = a * Math.cos(f + y * g);
            q.z = a * Math.sin(d + A * e) * Math.sin(f + y * g);
            t.push(q.x, q.y, q.z);
            r.set(q.x, q.y, q.z).normalize();
            u.push(r.x, r.y, r.z);
            w.push(A, 1 - y);
            v.push(p++)
        }
        m.push(v)
    }
    for (l = 0; l < c; l++)
        for (k = 0; k < b; k++) a = m[l][k + 1], d = m[l][k], e = m[l + 1][k], g = m[l + 1][k + 1], (0 !== l || 0 < f) && n.push(a, d, g), (l !== c - 1 || h < Math.PI) && n.push(d, e, g);
    this.setIndex(n);
    this.addAttribute("position", new module$node_modules$three$build$three.default.Float32BufferAttribute(t, 3));
    this.addAttribute("normal", new module$node_modules$three$build$three.default.Float32BufferAttribute(u, 3));
    this.addAttribute("uv", new module$node_modules$three$build$three.default.Float32BufferAttribute(w, 2))
};
module$node_modules$three$build$three.default.RingGeometry = function(a, b, c, d, e, f) {
    module$node_modules$three$build$three.default.Geometry.call(this);
    this.type = "RingGeometry";
    this.parameters = {
        innerRadius: a,
        outerRadius: b,
        thetaSegments: c,
        phiSegments: d,
        thetaStart: e,
        thetaLength: f
    };
    this.fromBufferGeometry(new module$node_modules$three$build$three.default.RingBufferGeometry(a, b, c, d, e, f));
    this.mergeVertices()
};
module$node_modules$three$build$three.default.RingBufferGeometry = function(a, b, c, d, e, f) {
    module$node_modules$three$build$three.default.BufferGeometry.call(this);
    this.type = "RingBufferGeometry";
    this.parameters = {
        innerRadius: a,
        outerRadius: b,
        thetaSegments: c,
        phiSegments: d,
        thetaStart: e,
        thetaLength: f
    };
    a = a || .5;
    b = b || 1;
    e = void 0 !== e ? e : 0;
    f = void 0 !== f ? f : 2 * Math.PI;
    c = void 0 !== c ? Math.max(3, c) : 8;
    d = void 0 !== d ? Math.max(1, d) : 1;
    var g = [],
        h = [],
        k = [],
        l = [],
        p = a,
        m = (b - a) / d,
        q = new module$node_modules$three$build$three.default.Vector3,
        r = new module$node_modules$three$build$three.default.Vector2,
        n, t;
    for (n = 0; n <= d; n++) {
        for (t = 0; t <= c; t++) a = e + t / c * f, q.x = p * Math.cos(a), q.y = p * Math.sin(a), h.push(q.x, q.y, q.z), k.push(0, 0, 1), r.x = (q.x / b + 1) / 2, r.y = (q.y / b + 1) / 2, l.push(r.x, r.y);
        p += m
    }
    for (n = 0; n < d; n++)
        for (b = n * (c + 1), t = 0; t < c; t++) a = t + b, e = a + c + 1, f = a + c + 2, p = a + 1, g.push(a, e, p), g.push(e, f, p);
    this.setIndex(g);
    this.addAttribute("position", new module$node_modules$three$build$three.default.Float32BufferAttribute(h, 3));
    this.addAttribute("normal", new module$node_modules$three$build$three.default.Float32BufferAttribute(k,
        3));
    this.addAttribute("uv", new module$node_modules$three$build$three.default.Float32BufferAttribute(l, 2))
};
module$node_modules$three$build$three.default.LatheGeometry = function(a, b, c, d) {
    module$node_modules$three$build$three.default.Geometry.call(this);
    this.type = "LatheGeometry";
    this.parameters = {
        points: a,
        segments: b,
        phiStart: c,
        phiLength: d
    };
    this.fromBufferGeometry(new module$node_modules$three$build$three.default.LatheBufferGeometry(a, b, c, d));
    this.mergeVertices()
};
module$node_modules$three$build$three.default.LatheBufferGeometry = function(a, b, c, d) {
    module$node_modules$three$build$three.default.BufferGeometry.call(this);
    this.type = "LatheBufferGeometry";
    this.parameters = {
        points: a,
        segments: b,
        phiStart: c,
        phiLength: d
    };
    b = Math.floor(b) || 12;
    c = c || 0;
    d = d || 2 * Math.PI;
    d = module$node_modules$three$build$three.default.Math.clamp(d, 0, 2 * Math.PI);
    var e = [],
        f = [],
        g = [],
        h = 1 / b,
        k = new module$node_modules$three$build$three.default.Vector3,
        l = new module$node_modules$three$build$three.default.Vector2,
        p;
    for (p = 0; p <= b; p++) {
        var m = c + p * h * d;
        var q = Math.sin(m),
            r = Math.cos(m);
        for (m = 0; m <= a.length - 1; m++) k.x = a[m].x * q, k.y = a[m].y, k.z = a[m].x * r, f.push(k.x, k.y, k.z), l.x = p / b, l.y = m / (a.length - 1), g.push(l.x, l.y)
    }
    for (p = 0; p < b; p++)
        for (m = 0; m < a.length - 1; m++) c = m + p * a.length, h = c + a.length, k = c + a.length + 1, l = c + 1, e.push(c, h, l), e.push(h, k, l);
    this.setIndex(e);
    this.addAttribute("position", new module$node_modules$three$build$three.default.Float32BufferAttribute(f, 3));
    this.addAttribute("uv", new module$node_modules$three$build$three.default.Float32BufferAttribute(g,
        2));
    this.computeVertexNormals();
    if (d === 2 * Math.PI)
        for (d = this.attributes.normal.array, e = new module$node_modules$three$build$three.default.Vector3, f = new module$node_modules$three$build$three.default.Vector3, g = new module$node_modules$three$build$three.default.Vector3, c = b * a.length * 3, m = p = 0; p < a.length; p++, m += 3) e.x = d[m + 0], e.y = d[m + 1], e.z = d[m + 2], f.x = d[c + m + 0], f.y = d[c + m + 1], f.z = d[c + m + 2], g.addVectors(e, f).normalize(), d[m + 0] = d[c + m + 0] = g.x, d[m + 1] = d[c + m + 1] = g.y, d[m + 2] = d[c + m + 2] = g.z
};
module$node_modules$three$build$three.default.ShapeGeometry = function(a, b) {
    module$node_modules$three$build$three.default.Geometry.call(this);
    this.type = "ShapeGeometry";
    "object" === typeof b && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), b = b.curveSegments);
    this.parameters = {
        shapes: a,
        curveSegments: b
    };
    this.fromBufferGeometry(new module$node_modules$three$build$three.default.ShapeBufferGeometry(a, b));
    this.mergeVertices()
};
module$node_modules$three$build$three.default.ShapeBufferGeometry = function(a, b) {
    function c(a) {
        var c, h = e.length / 3;
        a = a.extractPoints(b);
        var l = a.shape,
            n = a.holes;
        if (!1 === module$node_modules$three$build$three.default.ShapeUtils.isClockWise(l))
            for (l = l.reverse(), a = 0, c = n.length; a < c; a++) {
                var p = n[a];
                !0 === module$node_modules$three$build$three.default.ShapeUtils.isClockWise(p) && (n[a] = p.reverse())
            }
        var u = module$node_modules$three$build$three.default.ShapeUtils.triangulateShape(l, n);
        a = 0;
        for (c = n.length; a < c; a++) p =
            n[a], l = l.concat(p);
        a = 0;
        for (c = l.length; a < c; a++) p = l[a], e.push(p.x, p.y, 0), f.push(0, 0, 1), g.push(p.x, p.y);
        a = 0;
        for (c = u.length; a < c; a++) l = u[a], d.push(l[0] + h, l[1] + h, l[2] + h), k += 3
    }
    module$node_modules$three$build$three.default.BufferGeometry.call(this);
    this.type = "ShapeBufferGeometry";
    this.parameters = {
        shapes: a,
        curveSegments: b
    };
    b = b || 12;
    var d = [],
        e = [],
        f = [],
        g = [],
        h = 0,
        k = 0;
    if (!1 === Array.isArray(a)) c(a);
    else
        for (var l = 0; l < a.length; l++) c(a[l]), this.addGroup(h, k, l), h += k, k = 0;
    this.setIndex(d);
    this.addAttribute("position",
        new module$node_modules$three$build$three.default.Float32BufferAttribute(e, 3));
    this.addAttribute("normal", new module$node_modules$three$build$three.default.Float32BufferAttribute(f, 3));
    this.addAttribute("uv", new module$node_modules$three$build$three.default.Float32BufferAttribute(g, 2))
};
module$node_modules$three$build$three.default.EdgesGeometry = function(a, b) {
    module$node_modules$three$build$three.default.BufferGeometry.call(this);
    this.type = "EdgesGeometry";
    this.parameters = {
        thresholdAngle: b
    };
    var c = [];
    b = Math.cos(module$node_modules$three$build$three.default.Math.DEG2RAD * (void 0 !== b ? b : 1));
    var d = [0, 0],
        e = {},
        f = ["a", "b", "c"];
    if (a.isBufferGeometry) {
        var g = new module$node_modules$three$build$three.default.Geometry;
        g.fromBufferGeometry(a)
    } else g = a.clone();
    g.mergeVertices();
    g.computeFaceNormals();
    a = g.vertices;
    g = g.faces;
    for (var h = 0, k = g.length; h < k; h++)
        for (var l = g[h], p = 0; 3 > p; p++) {
            var m = l[f[p]];
            var q = l[f[(p + 1) % 3]];
            d[0] = Math.min(m, q);
            d[1] = Math.max(m, q);
            m = d[0] + "," + d[1];
            void 0 === e[m] ? e[m] = {
                index1: d[0],
                index2: d[1],
                face1: h,
                face2: void 0
            } : e[m].face2 = h
        }
    for (m in e)
        if (d = e[m], void 0 === d.face2 || g[d.face1].normal.dot(g[d.face2].normal) <= b) f = a[d.index1], c.push(f.x, f.y, f.z), f = a[d.index2], c.push(f.x, f.y, f.z);
    this.addAttribute("position", new module$node_modules$three$build$three.default.Float32BufferAttribute(c,
        3))
};
module$node_modules$three$build$three.default.CylinderGeometry = function(a, b, c, d, e, f, g, h) {
    module$node_modules$three$build$three.default.Geometry.call(this);
    this.type = "CylinderGeometry";
    this.parameters = {
        radiusTop: a,
        radiusBottom: b,
        height: c,
        radialSegments: d,
        heightSegments: e,
        openEnded: f,
        thetaStart: g,
        thetaLength: h
    };
    this.fromBufferGeometry(new module$node_modules$three$build$three.default.CylinderBufferGeometry(a, b, c, d, e, f, g, h));
    this.mergeVertices()
};
module$node_modules$three$build$three.default.CylinderBufferGeometry = function(a, b, c, d, e, f, g, h) {
    function k(c) {
        var e, f = new module$node_modules$three$build$three.default.Vector2,
            k = new module$node_modules$three$build$three.default.Vector3,
            z = 0,
            t = !0 === c ? a : b,
            v = !0 === c ? 1 : -1;
        var K = n;
        for (e = 1; e <= d; e++) m.push(0, u * v, 0), q.push(0, v, 0), r.push(.5, .5), n++;
        var H = n;
        for (e = 0; e <= d; e++) {
            var D = e / d * h + g,
                I = Math.cos(D);
            D = Math.sin(D);
            k.x = t * D;
            k.y = u * v;
            k.z = t * I;
            m.push(k.x, k.y, k.z);
            q.push(0, v, 0);
            f.x = .5 * I + .5;
            f.y = .5 * D * v + .5;
            r.push(f.x,
                f.y);
            n++
        }
        for (e = 0; e < d; e++) f = K + e, k = H + e, !0 === c ? p.push(k, k + 1, f) : p.push(k + 1, k, f), z += 3;
        l.addGroup(w, z, !0 === c ? 1 : 2);
        w += z
    }
    module$node_modules$three$build$three.default.BufferGeometry.call(this);
    this.type = "CylinderBufferGeometry";
    this.parameters = {
        radiusTop: a,
        radiusBottom: b,
        height: c,
        radialSegments: d,
        heightSegments: e,
        openEnded: f,
        thetaStart: g,
        thetaLength: h
    };
    var l = this;
    a = void 0 !== a ? a : 1;
    b = void 0 !== b ? b : 1;
    c = c || 1;
    d = Math.floor(d) || 8;
    e = Math.floor(e) || 1;
    f = void 0 !== f ? f : !1;
    g = void 0 !== g ? g : 0;
    h = void 0 !== h ? h : 2 * Math.PI;
    var p = [],
        m = [],
        q = [],
        r = [],
        n = 0,
        t = [],
        u = c / 2,
        w = 0;
    (function() {
        var f, k, A = new module$node_modules$three$build$three.default.Vector3,
            x = new module$node_modules$three$build$three.default.Vector3,
            z = 0,
            B = (b - a) / c;
        for (k = 0; k <= e; k++) {
            var N = [],
                K = k / e,
                H = K * (b - a) + a;
            for (f = 0; f <= d; f++) {
                var D = f / d,
                    I = D * h + g,
                    G = Math.sin(I);
                I = Math.cos(I);
                x.x = H * G;
                x.y = -K * c + u;
                x.z = H * I;
                m.push(x.x, x.y, x.z);
                A.set(G, B, I).normalize();
                q.push(A.x, A.y, A.z);
                r.push(D, 1 - K);
                N.push(n++)
            }
            t.push(N)
        }
        for (f = 0; f < d; f++)
            for (k = 0; k < e; k++) A = t[k + 1][f], x = t[k + 1][f + 1], B = t[k][f + 1], p.push(t[k][f],
                A, B), p.push(A, x, B), z += 6;
        l.addGroup(w, z, 0);
        w += z
    })();
    !1 === f && (0 < a && k(!0), 0 < b && k(!1));
    this.setIndex(p);
    this.addAttribute("position", new module$node_modules$three$build$three.default.Float32BufferAttribute(m, 3));
    this.addAttribute("normal", new module$node_modules$three$build$three.default.Float32BufferAttribute(q, 3));
    this.addAttribute("uv", new module$node_modules$three$build$three.default.Float32BufferAttribute(r, 2))
};
module$node_modules$three$build$three.default.ConeGeometry = function(a, b, c, d, e, f, g) {
    module$node_modules$three$build$three.default.CylinderGeometry.call(this, 0, a, b, c, d, e, f, g);
    this.type = "ConeGeometry";
    this.parameters = {
        radius: a,
        height: b,
        radialSegments: c,
        heightSegments: d,
        openEnded: e,
        thetaStart: f,
        thetaLength: g
    }
};
module$node_modules$three$build$three.default.ConeBufferGeometry = function(a, b, c, d, e, f, g) {
    module$node_modules$three$build$three.default.CylinderBufferGeometry.call(this, 0, a, b, c, d, e, f, g);
    this.type = "ConeBufferGeometry";
    this.parameters = {
        radius: a,
        height: b,
        radialSegments: c,
        heightSegments: d,
        openEnded: e,
        thetaStart: f,
        thetaLength: g
    }
};
module$node_modules$three$build$three.default.CircleGeometry = function(a, b, c, d) {
    module$node_modules$three$build$three.default.Geometry.call(this);
    this.type = "CircleGeometry";
    this.parameters = {
        radius: a,
        segments: b,
        thetaStart: c,
        thetaLength: d
    };
    this.fromBufferGeometry(new module$node_modules$three$build$three.default.CircleBufferGeometry(a, b, c, d));
    this.mergeVertices()
};
module$node_modules$three$build$three.default.CircleBufferGeometry = function(a, b, c, d) {
    module$node_modules$three$build$three.default.BufferGeometry.call(this);
    this.type = "CircleBufferGeometry";
    this.parameters = {
        radius: a,
        segments: b,
        thetaStart: c,
        thetaLength: d
    };
    a = a || 1;
    b = void 0 !== b ? Math.max(3, b) : 8;
    c = void 0 !== c ? c : 0;
    d = void 0 !== d ? d : 2 * Math.PI;
    var e = [],
        f = [],
        g = [],
        h = [],
        k, l = new module$node_modules$three$build$three.default.Vector3,
        p = new module$node_modules$three$build$three.default.Vector2;
    f.push(0, 0, 0);
    g.push(0,
        0, 1);
    h.push(.5, .5);
    var m = 0;
    for (k = 3; m <= b; m++, k += 3) {
        var q = c + m / b * d;
        l.x = a * Math.cos(q);
        l.y = a * Math.sin(q);
        f.push(l.x, l.y, l.z);
        g.push(0, 0, 1);
        p.x = (f[k] / a + 1) / 2;
        p.y = (f[k + 1] / a + 1) / 2;
        h.push(p.x, p.y)
    }
    for (k = 1; k <= b; k++) e.push(k, k + 1, 0);
    this.setIndex(e);
    this.addAttribute("position", new module$node_modules$three$build$three.default.Float32BufferAttribute(f, 3));
    this.addAttribute("normal", new module$node_modules$three$build$three.default.Float32BufferAttribute(g, 3));
    this.addAttribute("uv", new module$node_modules$three$build$three.default.Float32BufferAttribute(h,
        2))
};
module$node_modules$three$build$three.default.ShadowMaterial = function(a) {
    module$node_modules$three$build$three.default.Material.call(this);
    this.type = "ShadowMaterial";
    this.color = new module$node_modules$three$build$three.default.Color(0);
    this.transparent = !0;
    this.setValues(a)
};
module$node_modules$three$build$three.default.RawShaderMaterial = function(a) {
    module$node_modules$three$build$three.default.ShaderMaterial.call(this, a);
    this.type = "RawShaderMaterial"
};
module$node_modules$three$build$three.default.MeshStandardMaterial = function(a) {
    module$node_modules$three$build$three.default.Material.call(this);
    this.defines = {
        STANDARD: ""
    };
    this.type = "MeshStandardMaterial";
    this.color = new module$node_modules$three$build$three.default.Color(16777215);
    this.metalness = this.roughness = .5;
    this.lightMap = this.map = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new module$node_modules$three$build$three.default.Color(0);
    this.emissiveIntensity =
        1;
    this.bumpMap = this.emissiveMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = module$node_modules$three$build$three.default.TangentSpaceNormalMap;
    this.normalScale = new module$node_modules$three$build$three.default.Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null;
    this.envMapIntensity = 1;
    this.refractionRatio = .98;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.wireframeLinejoin = this.wireframeLinecap =
        "round";
    this.morphNormals = this.morphTargets = this.skinning = !1;
    this.setValues(a)
};
module$node_modules$three$build$three.default.MeshPhysicalMaterial = function(a) {
    module$node_modules$three$build$three.default.MeshStandardMaterial.call(this);
    this.defines = {
        PHYSICAL: ""
    };
    this.type = "MeshPhysicalMaterial";
    this.reflectivity = .5;
    this.clearCoatRoughness = this.clearCoat = 0;
    this.setValues(a)
};
module$node_modules$three$build$three.default.MeshPhongMaterial = function(a) {
    module$node_modules$three$build$three.default.Material.call(this);
    this.type = "MeshPhongMaterial";
    this.color = new module$node_modules$three$build$three.default.Color(16777215);
    this.specular = new module$node_modules$three$build$three.default.Color(1118481);
    this.shininess = 30;
    this.lightMap = this.map = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new module$node_modules$three$build$three.default.Color(0);
    this.emissiveIntensity = 1;
    this.bumpMap = this.emissiveMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = module$node_modules$three$build$three.default.TangentSpaceNormalMap;
    this.normalScale = new module$node_modules$three$build$three.default.Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.envMap = this.alphaMap = this.specularMap = null;
    this.combine = module$node_modules$three$build$three.default.MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio =
        .98;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.wireframeLinejoin = this.wireframeLinecap = "round";
    this.morphNormals = this.morphTargets = this.skinning = !1;
    this.setValues(a)
};
module$node_modules$three$build$three.default.MeshToonMaterial = function(a) {
    module$node_modules$three$build$three.default.MeshPhongMaterial.call(this);
    this.defines = {
        TOON: ""
    };
    this.type = "MeshToonMaterial";
    this.gradientMap = null;
    this.setValues(a)
};
module$node_modules$three$build$three.default.MeshNormalMaterial = function(a) {
    module$node_modules$three$build$three.default.Material.call(this);
    this.type = "MeshNormalMaterial";
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = module$node_modules$three$build$three.default.TangentSpaceNormalMap;
    this.normalScale = new module$node_modules$three$build$three.default.Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = !1;
    this.wireframeLinewidth =
        1;
    this.morphNormals = this.morphTargets = this.skinning = this.lights = this.fog = !1;
    this.setValues(a)
};
module$node_modules$three$build$three.default.MeshLambertMaterial = function(a) {
    module$node_modules$three$build$three.default.Material.call(this);
    this.type = "MeshLambertMaterial";
    this.color = new module$node_modules$three$build$three.default.Color(16777215);
    this.lightMap = this.map = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new module$node_modules$three$build$three.default.Color(0);
    this.emissiveIntensity = 1;
    this.envMap = this.alphaMap = this.specularMap = this.emissiveMap =
        null;
    this.combine = module$node_modules$three$build$three.default.MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = .98;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.wireframeLinejoin = this.wireframeLinecap = "round";
    this.morphNormals = this.morphTargets = this.skinning = !1;
    this.setValues(a)
};
module$node_modules$three$build$three.default.LineDashedMaterial = function(a) {
    module$node_modules$three$build$three.default.LineBasicMaterial.call(this);
    this.type = "LineDashedMaterial";
    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.setValues(a)
};
module$node_modules$three$build$three.default.LoadingManager = function(a, b, c) {
    var d = this,
        e = !1,
        f = 0,
        g = 0,
        h = void 0;
    this.onStart = void 0;
    this.onLoad = a;
    this.onProgress = b;
    this.onError = c;
    this.itemStart = function(a) {
        g++;
        if (!1 === e && void 0 !== d.onStart) d.onStart(a, f, g);
        e = !0
    };
    this.itemEnd = function(a) {
        f++;
        if (void 0 !== d.onProgress) d.onProgress(a, f, g);
        if (f === g && (e = !1, void 0 !== d.onLoad)) d.onLoad()
    };
    this.itemError = function(a) {
        if (void 0 !== d.onError) d.onError(a)
    };
    this.resolveURL = function(a) {
        return h ? h(a) : a
    };
    this.setURLModifier =
        function(a) {
            h = a;
            return this
        }
};
module$node_modules$three$build$three.default.FileLoader = function(a) {
    this.manager = void 0 !== a ? a : module$node_modules$three$build$three.default.DefaultLoadingManager
};
module$node_modules$three$build$three.default.CompressedTextureLoader = function(a) {
    this.manager = void 0 !== a ? a : module$node_modules$three$build$three.default.DefaultLoadingManager;
    this._parser = null
};
module$node_modules$three$build$three.default.DataTextureLoader = function(a) {
    this.manager = void 0 !== a ? a : module$node_modules$three$build$three.default.DefaultLoadingManager;
    this._parser = null
};
module$node_modules$three$build$three.default.ImageLoader = function(a) {
    this.manager = void 0 !== a ? a : module$node_modules$three$build$three.default.DefaultLoadingManager
};
module$node_modules$three$build$three.default.CubeTextureLoader = function(a) {
    this.manager = void 0 !== a ? a : module$node_modules$three$build$three.default.DefaultLoadingManager
};
module$node_modules$three$build$three.default.TextureLoader = function(a) {
    this.manager = void 0 !== a ? a : module$node_modules$three$build$three.default.DefaultLoadingManager
};
module$node_modules$three$build$three.default.Curve = function() {
    this.type = "Curve";
    this.arcLengthDivisions = 200
};
module$node_modules$three$build$three.default.EllipseCurve = function(a, b, c, d, e, f, g, h) {
    module$node_modules$three$build$three.default.Curve.call(this);
    this.type = "EllipseCurve";
    this.aX = a || 0;
    this.aY = b || 0;
    this.xRadius = c || 1;
    this.yRadius = d || 1;
    this.aStartAngle = e || 0;
    this.aEndAngle = f || 2 * Math.PI;
    this.aClockwise = g || !1;
    this.aRotation = h || 0
};
module$node_modules$three$build$three.default.ArcCurve = function(a, b, c, d, e, f) {
    module$node_modules$three$build$three.default.EllipseCurve.call(this, a, b, c, c, d, e, f);
    this.type = "ArcCurve"
};
module$node_modules$three$build$three.default.CatmullRomCurve3 = function(a, b, c, d) {
    module$node_modules$three$build$three.default.Curve.call(this);
    this.type = "CatmullRomCurve3";
    this.points = a || [];
    this.closed = b || !1;
    this.curveType = c || "centripetal";
    this.tension = d || .5
};
module$node_modules$three$build$three.default.CubicBezierCurve = function(a, b, c, d) {
    module$node_modules$three$build$three.default.Curve.call(this);
    this.type = "CubicBezierCurve";
    this.v0 = a || new module$node_modules$three$build$three.default.Vector2;
    this.v1 = b || new module$node_modules$three$build$three.default.Vector2;
    this.v2 = c || new module$node_modules$three$build$three.default.Vector2;
    this.v3 = d || new module$node_modules$three$build$three.default.Vector2
};
module$node_modules$three$build$three.default.CubicBezierCurve3 = function(a, b, c, d) {
    module$node_modules$three$build$three.default.Curve.call(this);
    this.type = "CubicBezierCurve3";
    this.v0 = a || new module$node_modules$three$build$three.default.Vector3;
    this.v1 = b || new module$node_modules$three$build$three.default.Vector3;
    this.v2 = c || new module$node_modules$three$build$three.default.Vector3;
    this.v3 = d || new module$node_modules$three$build$three.default.Vector3
};
module$node_modules$three$build$three.default.LineCurve = function(a, b) {
    module$node_modules$three$build$three.default.Curve.call(this);
    this.type = "LineCurve";
    this.v1 = a || new module$node_modules$three$build$three.default.Vector2;
    this.v2 = b || new module$node_modules$three$build$three.default.Vector2
};
module$node_modules$three$build$three.default.LineCurve3 = function(a, b) {
    module$node_modules$three$build$three.default.Curve.call(this);
    this.type = "LineCurve3";
    this.v1 = a || new module$node_modules$three$build$three.default.Vector3;
    this.v2 = b || new module$node_modules$three$build$three.default.Vector3
};
module$node_modules$three$build$three.default.QuadraticBezierCurve = function(a, b, c) {
    module$node_modules$three$build$three.default.Curve.call(this);
    this.type = "QuadraticBezierCurve";
    this.v0 = a || new module$node_modules$three$build$three.default.Vector2;
    this.v1 = b || new module$node_modules$three$build$three.default.Vector2;
    this.v2 = c || new module$node_modules$three$build$three.default.Vector2
};
module$node_modules$three$build$three.default.QuadraticBezierCurve3 = function(a, b, c) {
    module$node_modules$three$build$three.default.Curve.call(this);
    this.type = "QuadraticBezierCurve3";
    this.v0 = a || new module$node_modules$three$build$three.default.Vector3;
    this.v1 = b || new module$node_modules$three$build$three.default.Vector3;
    this.v2 = c || new module$node_modules$three$build$three.default.Vector3
};
module$node_modules$three$build$three.default.SplineCurve = function(a) {
    module$node_modules$three$build$three.default.Curve.call(this);
    this.type = "SplineCurve";
    this.points = a || []
};
module$node_modules$three$build$three.default.CurvePath = function() {
    module$node_modules$three$build$three.default.Curve.call(this);
    this.type = "CurvePath";
    this.curves = [];
    this.autoClose = !1
};
module$node_modules$three$build$three.default.Path = function(a) {
    module$node_modules$three$build$three.default.CurvePath.call(this);
    this.type = "Path";
    this.currentPoint = new module$node_modules$three$build$three.default.Vector2;
    a && this.setFromPoints(a)
};
module$node_modules$three$build$three.default.Shape = function(a) {
    module$node_modules$three$build$three.default.Path.call(this, a);
    this.uuid = module$node_modules$three$build$three.default.Math.generateUUID();
    this.type = "Shape";
    this.holes = []
};
module$node_modules$three$build$three.default.Light = function(a, b) {
    module$node_modules$three$build$three.default.Object3D.call(this);
    this.type = "Light";
    this.color = new module$node_modules$three$build$three.default.Color(a);
    this.intensity = void 0 !== b ? b : 1;
    this.receiveShadow = void 0
};
module$node_modules$three$build$three.default.HemisphereLight = function(a, b, c) {
    module$node_modules$three$build$three.default.Light.call(this, a, c);
    this.type = "HemisphereLight";
    this.castShadow = void 0;
    this.position.copy(module$node_modules$three$build$three.default.Object3D.DefaultUp);
    this.updateMatrix();
    this.groundColor = new module$node_modules$three$build$three.default.Color(b)
};
module$node_modules$three$build$three.default.LightShadow = function(a) {
    this.camera = a;
    this.bias = 0;
    this.radius = 1;
    this.mapSize = new module$node_modules$three$build$three.default.Vector2(512, 512);
    this.map = null;
    this.matrix = new module$node_modules$three$build$three.default.Matrix4
};
module$node_modules$three$build$three.default.SpotLightShadow = function() {
    module$node_modules$three$build$three.default.LightShadow.call(this, new module$node_modules$three$build$three.default.PerspectiveCamera(50, 1, .5, 500))
};
module$node_modules$three$build$three.default.SpotLight = function(a, b, c, d, e, f) {
    module$node_modules$three$build$three.default.Light.call(this, a, b);
    this.type = "SpotLight";
    this.position.copy(module$node_modules$three$build$three.default.Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new module$node_modules$three$build$three.default.Object3D;
    Object.defineProperty(this, "power", {
        get: function() {
            return this.intensity * Math.PI
        },
        set: function(a) {
            this.intensity = a / Math.PI
        }
    });
    this.distance = void 0 !== c ? c : 0;
    this.angle =
        void 0 !== d ? d : Math.PI / 3;
    this.penumbra = void 0 !== e ? e : 0;
    this.decay = void 0 !== f ? f : 1;
    this.shadow = new module$node_modules$three$build$three.default.SpotLightShadow
};
module$node_modules$three$build$three.default.PointLight = function(a, b, c, d) {
    module$node_modules$three$build$three.default.Light.call(this, a, b);
    this.type = "PointLight";
    Object.defineProperty(this, "power", {
        get: function() {
            return 4 * this.intensity * Math.PI
        },
        set: function(a) {
            this.intensity = a / (4 * Math.PI)
        }
    });
    this.distance = void 0 !== c ? c : 0;
    this.decay = void 0 !== d ? d : 1;
    this.shadow = new module$node_modules$three$build$three.default.LightShadow(new module$node_modules$three$build$three.default.PerspectiveCamera(90, 1, .5,
        500))
};
module$node_modules$three$build$three.default.DirectionalLightShadow = function() {
    module$node_modules$three$build$three.default.LightShadow.call(this, new module$node_modules$three$build$three.default.OrthographicCamera(-5, 5, 5, -5, .5, 500))
};
module$node_modules$three$build$three.default.DirectionalLight = function(a, b) {
    module$node_modules$three$build$three.default.Light.call(this, a, b);
    this.type = "DirectionalLight";
    this.position.copy(module$node_modules$three$build$three.default.Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new module$node_modules$three$build$three.default.Object3D;
    this.shadow = new module$node_modules$three$build$three.default.DirectionalLightShadow
};
module$node_modules$three$build$three.default.AmbientLight = function(a, b) {
    module$node_modules$three$build$three.default.Light.call(this, a, b);
    this.type = "AmbientLight";
    this.castShadow = void 0
};
module$node_modules$three$build$three.default.RectAreaLight = function(a, b, c, d) {
    module$node_modules$three$build$three.default.Light.call(this, a, b);
    this.type = "RectAreaLight";
    this.width = void 0 !== c ? c : 10;
    this.height = void 0 !== d ? d : 10
};
module$node_modules$three$build$three.default.Interpolant = function(a, b, c, d) {
    this.parameterPositions = a;
    this._cachedIndex = 0;
    this.resultBuffer = void 0 !== d ? d : new b.constructor(c);
    this.sampleValues = b;
    this.valueSize = c
};
module$node_modules$three$build$three.default.CubicInterpolant = function(a, b, c, d) {
    module$node_modules$three$build$three.default.Interpolant.call(this, a, b, c, d);
    this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0
};
module$node_modules$three$build$three.default.LinearInterpolant = function(a, b, c, d) {
    module$node_modules$three$build$three.default.Interpolant.call(this, a, b, c, d)
};
module$node_modules$three$build$three.default.DiscreteInterpolant = function(a, b, c, d) {
    module$node_modules$three$build$three.default.Interpolant.call(this, a, b, c, d)
};
module$node_modules$three$build$three.default.KeyframeTrack = function(a, b, c, d) {
    if (void 0 === a) throw Error("THREE.KeyframeTrack: track name is undefined");
    if (void 0 === b || 0 === b.length) throw Error("THREE.KeyframeTrack: no keyframes in track named " + a);
    this.name = a;
    this.times = module$node_modules$three$build$three.default.AnimationUtils.convertArray(b, this.TimeBufferType);
    this.values = module$node_modules$three$build$three.default.AnimationUtils.convertArray(c, this.ValueBufferType);
    this.setInterpolation(d ||
        this.DefaultInterpolation)
};
module$node_modules$three$build$three.default.BooleanKeyframeTrack = function(a, b, c) {
    module$node_modules$three$build$three.default.KeyframeTrack.call(this, a, b, c)
};
module$node_modules$three$build$three.default.ColorKeyframeTrack = function(a, b, c, d) {
    module$node_modules$three$build$three.default.KeyframeTrack.call(this, a, b, c, d)
};
module$node_modules$three$build$three.default.NumberKeyframeTrack = function(a, b, c, d) {
    module$node_modules$three$build$three.default.KeyframeTrack.call(this, a, b, c, d)
};
module$node_modules$three$build$three.default.QuaternionLinearInterpolant = function(a, b, c, d) {
    module$node_modules$three$build$three.default.Interpolant.call(this, a, b, c, d)
};
module$node_modules$three$build$three.default.QuaternionKeyframeTrack = function(a, b, c, d) {
    module$node_modules$three$build$three.default.KeyframeTrack.call(this, a, b, c, d)
};
module$node_modules$three$build$three.default.StringKeyframeTrack = function(a, b, c, d) {
    module$node_modules$three$build$three.default.KeyframeTrack.call(this, a, b, c, d)
};
module$node_modules$three$build$three.default.VectorKeyframeTrack = function(a, b, c, d) {
    module$node_modules$three$build$three.default.KeyframeTrack.call(this, a, b, c, d)
};
module$node_modules$three$build$three.default.AnimationClip = function(a, b, c) {
    this.name = a;
    this.tracks = c;
    this.duration = void 0 !== b ? b : -1;
    this.uuid = module$node_modules$three$build$three.default.Math.generateUUID();
    0 > this.duration && this.resetDuration()
};
module$node_modules$three$build$three.default.MaterialLoader = function(a) {
    this.manager = void 0 !== a ? a : module$node_modules$three$build$three.default.DefaultLoadingManager;
    this.textures = {}
};
module$node_modules$three$build$three.default.BufferGeometryLoader = function(a) {
    this.manager = void 0 !== a ? a : module$node_modules$three$build$three.default.DefaultLoadingManager
};
module$node_modules$three$build$three.default.Loader = function() {};
module$node_modules$three$build$three.default.JSONLoader = function(a) {
    "boolean" === typeof a && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), a = void 0);
    this.manager = void 0 !== a ? a : module$node_modules$three$build$three.default.DefaultLoadingManager;
    this.withCredentials = !1
};
module$node_modules$three$build$three.default.ObjectLoader = function(a) {
    this.manager = void 0 !== a ? a : module$node_modules$three$build$three.default.DefaultLoadingManager;
    this.texturePath = ""
};
module$node_modules$three$build$three.default.ImageBitmapLoader = function(a) {
    "undefined" === typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
    "undefined" === typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
    this.manager = void 0 !== a ? a : module$node_modules$three$build$three.default.DefaultLoadingManager;
    this.options = void 0
};
module$node_modules$three$build$three.default.ShapePath = function() {
    this.type = "ShapePath";
    this.color = new module$node_modules$three$build$three.default.Color;
    this.subPaths = [];
    this.currentPath = null
};
module$node_modules$three$build$three.default.Font = function(a) {
    this.type = "Font";
    this.data = a
};
module$node_modules$three$build$three.default.FontLoader = function(a) {
    this.manager = void 0 !== a ? a : module$node_modules$three$build$three.default.DefaultLoadingManager
};
module$node_modules$three$build$three.default.AudioLoader = function(a) {
    this.manager = void 0 !== a ? a : module$node_modules$three$build$three.default.DefaultLoadingManager
};
module$node_modules$three$build$three.default.StereoCamera = function() {
    this.type = "StereoCamera";
    this.aspect = 1;
    this.eyeSep = .064;
    this.cameraL = new module$node_modules$three$build$three.default.PerspectiveCamera;
    this.cameraL.layers.enable(1);
    this.cameraL.matrixAutoUpdate = !1;
    this.cameraR = new module$node_modules$three$build$three.default.PerspectiveCamera;
    this.cameraR.layers.enable(2);
    this.cameraR.matrixAutoUpdate = !1
};
module$node_modules$three$build$three.default.CubeCamera = function(a, b, c) {
    module$node_modules$three$build$three.default.Object3D.call(this);
    this.type = "CubeCamera";
    var d = new module$node_modules$three$build$three.default.PerspectiveCamera(90, 1, a, b);
    d.up.set(0, -1, 0);
    d.lookAt(new module$node_modules$three$build$three.default.Vector3(1, 0, 0));
    this.add(d);
    var e = new module$node_modules$three$build$three.default.PerspectiveCamera(90, 1, a, b);
    e.up.set(0, -1, 0);
    e.lookAt(new module$node_modules$three$build$three.default.Vector3(-1,
        0, 0));
    this.add(e);
    var f = new module$node_modules$three$build$three.default.PerspectiveCamera(90, 1, a, b);
    f.up.set(0, 0, 1);
    f.lookAt(new module$node_modules$three$build$three.default.Vector3(0, 1, 0));
    this.add(f);
    var g = new module$node_modules$three$build$three.default.PerspectiveCamera(90, 1, a, b);
    g.up.set(0, 0, -1);
    g.lookAt(new module$node_modules$three$build$three.default.Vector3(0, -1, 0));
    this.add(g);
    var h = new module$node_modules$three$build$three.default.PerspectiveCamera(90, 1, a, b);
    h.up.set(0, -1, 0);
    h.lookAt(new module$node_modules$three$build$three.default.Vector3(0,
        0, 1));
    this.add(h);
    var k = new module$node_modules$three$build$three.default.PerspectiveCamera(90, 1, a, b);
    k.up.set(0, -1, 0);
    k.lookAt(new module$node_modules$three$build$three.default.Vector3(0, 0, -1));
    this.add(k);
    this.renderTarget = new module$node_modules$three$build$three.default.WebGLRenderTargetCube(c, c, {
        format: module$node_modules$three$build$three.default.RGBFormat,
        magFilter: module$node_modules$three$build$three.default.LinearFilter,
        minFilter: module$node_modules$three$build$three.default.LinearFilter
    });
    this.renderTarget.texture.name = "CubeCamera";
    this.update = function(a, b) {
        null === this.parent && this.updateMatrixWorld();
        var c = this.renderTarget,
            l = c.texture.generateMipmaps;
        c.texture.generateMipmaps = !1;
        c.activeCubeFace = 0;
        a.render(b, d, c);
        c.activeCubeFace = 1;
        a.render(b, e, c);
        c.activeCubeFace = 2;
        a.render(b, f, c);
        c.activeCubeFace = 3;
        a.render(b, g, c);
        c.activeCubeFace = 4;
        a.render(b, h, c);
        c.texture.generateMipmaps = l;
        c.activeCubeFace = 5;
        a.render(b, k, c);
        a.setRenderTarget(null)
    };
    this.clear = function(a, b, c, d) {
        for (var e = this.renderTarget,
                f = 0; 6 > f; f++) e.activeCubeFace = f, a.setRenderTarget(e), a.clear(b, c, d);
        a.setRenderTarget(null)
    }
};
module$node_modules$three$build$three.default.AudioListener = function() {
    module$node_modules$three$build$three.default.Object3D.call(this);
    this.type = "AudioListener";
    this.context = module$node_modules$three$build$three.default.AudioContext.getContext();
    this.gain = this.context.createGain();
    this.gain.connect(this.context.destination);
    this.filter = null
};
module$node_modules$three$build$three.default.Audio = function(a) {
    module$node_modules$three$build$three.default.Object3D.call(this);
    this.type = "Audio";
    this.context = a.context;
    this.gain = this.context.createGain();
    this.gain.connect(a.getInput());
    this.autoplay = !1;
    this.buffer = null;
    this.loop = !1;
    this.offset = this.startTime = 0;
    this.playbackRate = 1;
    this.isPlaying = !1;
    this.hasPlaybackControl = !0;
    this.sourceType = "empty";
    this.filters = []
};
module$node_modules$three$build$three.default.PositionalAudio = function(a) {
    module$node_modules$three$build$three.default.Audio.call(this, a);
    this.panner = this.context.createPanner();
    this.panner.connect(this.gain)
};
module$node_modules$three$build$three.default.AudioAnalyser = function(a, b) {
    this.analyser = a.context.createAnalyser();
    this.analyser.fftSize = void 0 !== b ? b : 2048;
    this.data = new Uint8Array(this.analyser.frequencyBinCount);
    a.getOutput().connect(this.analyser)
};
module$node_modules$three$build$three.default.PropertyMixer = function(a, b, c) {
    this.binding = a;
    this.valueSize = c;
    a = Float64Array;
    switch (b) {
        case "quaternion":
            b = this._slerp;
            break;
        case "string":
        case "bool":
            a = Array;
            b = this._select;
            break;
        default:
            b = this._lerp
    }
    this.buffer = new a(4 * c);
    this._mixBufferRegion = b;
    this.referenceCount = this.useCount = this.cumulativeWeight = 0
};
module$node_modules$three$build$three.default.PropertyBinding = function(a, b, c) {
    this.path = b;
    this.parsedPath = c || module$node_modules$three$build$three.default.PropertyBinding.parseTrackName(b);
    this.node = module$node_modules$three$build$three.default.PropertyBinding.findNode(a, this.parsedPath.nodeName) || a;
    this.rootNode = a
};
module$node_modules$three$build$three.default.AnimationObjectGroup = function() {
    this.uuid = module$node_modules$three$build$three.default.Math.generateUUID();
    this._objects = Array.prototype.slice.call(arguments);
    this.nCachedObjects_ = 0;
    var a = {};
    this._indicesByUUID = a;
    for (var b = 0, c = arguments.length; b !== c; ++b) a[arguments[b].uuid] = b;
    this._paths = [];
    this._parsedPaths = [];
    this._bindings = [];
    this._bindingsIndicesByPath = {};
    var d = this;
    this.stats = {
        objects: {get total() {
                return d._objects.length
            },
            get inUse() {
                return this.total -
                    d.nCachedObjects_
            }
        },
        get bindingsPerObject() {
            return d._bindings.length
        }
    }
};
module$node_modules$three$build$three.default.AnimationMixer = function(a) {
    this._root = a;
    this._initMemoryManager();
    this.time = this._accuIndex = 0;
    this.timeScale = 1
};
module$node_modules$three$build$three.default.Uniform = function(a, b) {
    "string" === typeof a && (console.warn("THREE.Uniform: Type parameter is no longer needed."), a = b);
    this.value = a
};
module$node_modules$three$build$three.default.InstancedBufferGeometry = function() {
    module$node_modules$three$build$three.default.BufferGeometry.call(this);
    this.type = "InstancedBufferGeometry";
    this.maxInstancedCount = void 0
};
module$node_modules$three$build$three.default.InstancedInterleavedBuffer = function(a, b, c) {
    module$node_modules$three$build$three.default.InterleavedBuffer.call(this, a, b);
    this.meshPerAttribute = c || 1
};
module$node_modules$three$build$three.default.InstancedBufferAttribute = function(a, b, c) {
    module$node_modules$three$build$three.default.BufferAttribute.call(this, a, b);
    this.meshPerAttribute = c || 1
};
module$node_modules$three$build$three.default.Raycaster = function(a, b, c, d) {
    this.ray = new module$node_modules$three$build$three.default.Ray(a, b);
    this.near = c || 0;
    this.far = d || Infinity;
    this.params = {
        Mesh: {},
        Line: {},
        LOD: {},
        Points: {
            threshold: 1
        },
        Sprite: {}
    };
    Object.defineProperties(this.params, {
        PointCloud: {
            get: function() {
                console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points.");
                return this.Points
            }
        }
    })
};
module$node_modules$three$build$three.default.Clock = function(a) {
    this.autoStart = void 0 !== a ? a : !0;
    this.elapsedTime = this.oldTime = this.startTime = 0;
    this.running = !1
};
module$node_modules$three$build$three.default.Spherical = function(a, b, c) {
    this.radius = void 0 !== a ? a : 1;
    this.phi = void 0 !== b ? b : 0;
    this.theta = void 0 !== c ? c : 0;
    return this
};
module$node_modules$three$build$three.default.Cylindrical = function(a, b, c) {
    this.radius = void 0 !== a ? a : 1;
    this.theta = void 0 !== b ? b : 0;
    this.y = void 0 !== c ? c : 0;
    return this
};
module$node_modules$three$build$three.default.Box2 = function(a, b) {
    this.min = void 0 !== a ? a : new module$node_modules$three$build$three.default.Vector2(Infinity, Infinity);
    this.max = void 0 !== b ? b : new module$node_modules$three$build$three.default.Vector2(-Infinity, -Infinity)
};
module$node_modules$three$build$three.default.Line3 = function(a, b) {
    this.start = void 0 !== a ? a : new module$node_modules$three$build$three.default.Vector3;
    this.end = void 0 !== b ? b : new module$node_modules$three$build$three.default.Vector3
};
module$node_modules$three$build$three.default.ImmediateRenderObject = function(a) {
    module$node_modules$three$build$three.default.Object3D.call(this);
    this.material = a;
    this.render = function() {}
};
module$node_modules$three$build$three.default.VertexNormalsHelper = function(a, b, c, d) {
    this.object = a;
    this.size = void 0 !== b ? b : 1;
    a = void 0 !== c ? c : 16711680;
    d = void 0 !== d ? d : 1;
    b = 0;
    (c = this.object.geometry) && c.isGeometry ? b = 3 * c.faces.length : c && c.isBufferGeometry && (b = c.attributes.normal.count);
    c = new module$node_modules$three$build$three.default.BufferGeometry;
    b = new module$node_modules$three$build$three.default.Float32BufferAttribute(6 * b, 3);
    c.addAttribute("position", b);
    module$node_modules$three$build$three.default.LineSegments.call(this,
        c, new module$node_modules$three$build$three.default.LineBasicMaterial({
            color: a,
            linewidth: d
        }));
    this.matrixAutoUpdate = !1;
    this.update()
};
module$node_modules$three$build$three.default.SpotLightHelper = function(a, b) {
    module$node_modules$three$build$three.default.Object3D.call(this);
    this.light = a;
    this.light.updateMatrixWorld();
    this.matrix = a.matrixWorld;
    this.matrixAutoUpdate = !1;
    this.color = b;
    a = new module$node_modules$three$build$three.default.BufferGeometry;
    b = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
    for (var c = 0, d = 1; 32 > c; c++, d++) {
        var e = c / 32 * Math.PI * 2,
            f = d / 32 * Math.PI * 2;
        b.push(Math.cos(e), Math.sin(e), 1, Math.cos(f), Math.sin(f),
            1)
    }
    a.addAttribute("position", new module$node_modules$three$build$three.default.Float32BufferAttribute(b, 3));
    b = new module$node_modules$three$build$three.default.LineBasicMaterial({
        fog: !1
    });
    this.cone = new module$node_modules$three$build$three.default.LineSegments(a, b);
    this.add(this.cone);
    this.update()
};
module$node_modules$three$build$three.default.SkeletonHelper = function(a) {
    for (var b = getBoneList$$module$node_modules$three$build$three(a), c = new module$node_modules$three$build$three.default.BufferGeometry, d = [], e = [], f = new module$node_modules$three$build$three.default.Color(0, 0, 1), g = new module$node_modules$three$build$three.default.Color(0, 1, 0), h = 0; h < b.length; h++) {
        var k = b[h];
        k.parent && k.parent.isBone && (d.push(0, 0, 0), d.push(0, 0, 0), e.push(f.r, f.g, f.b), e.push(g.r, g.g, g.b))
    }
    c.addAttribute("position", new module$node_modules$three$build$three.default.Float32BufferAttribute(d,
        3));
    c.addAttribute("color", new module$node_modules$three$build$three.default.Float32BufferAttribute(e, 3));
    d = new module$node_modules$three$build$three.default.LineBasicMaterial({
        vertexColors: module$node_modules$three$build$three.default.VertexColors,
        depthTest: !1,
        depthWrite: !1,
        transparent: !0
    });
    module$node_modules$three$build$three.default.LineSegments.call(this, c, d);
    this.root = a;
    this.bones = b;
    this.matrix = a.matrixWorld;
    this.matrixAutoUpdate = !1
};
module$node_modules$three$build$three.default.PointLightHelper = function(a, b, c) {
    this.light = a;
    this.light.updateMatrixWorld();
    this.color = c;
    a = new module$node_modules$three$build$three.default.SphereBufferGeometry(b, 4, 2);
    b = new module$node_modules$three$build$three.default.MeshBasicMaterial({
        wireframe: !0,
        fog: !1
    });
    module$node_modules$three$build$three.default.Mesh.call(this, a, b);
    this.matrix = this.light.matrixWorld;
    this.matrixAutoUpdate = !1;
    this.update()
};
module$node_modules$three$build$three.default.RectAreaLightHelper = function(a, b) {
    module$node_modules$three$build$three.default.Object3D.call(this);
    this.light = a;
    this.light.updateMatrixWorld();
    this.matrix = a.matrixWorld;
    this.matrixAutoUpdate = !1;
    this.color = b;
    a = new module$node_modules$three$build$three.default.LineBasicMaterial({
        fog: !1
    });
    b = new module$node_modules$three$build$three.default.BufferGeometry;
    b.addAttribute("position", new module$node_modules$three$build$three.default.BufferAttribute(new Float32Array(15),
        3));
    this.line = new module$node_modules$three$build$three.default.Line(b, a);
    this.add(this.line);
    this.update()
};
module$node_modules$three$build$three.default.HemisphereLightHelper = function(a, b, c) {
    module$node_modules$three$build$three.default.Object3D.call(this);
    this.light = a;
    this.light.updateMatrixWorld();
    this.matrix = a.matrixWorld;
    this.matrixAutoUpdate = !1;
    this.color = c;
    a = new module$node_modules$three$build$three.default.OctahedronBufferGeometry(b);
    a.rotateY(.5 * Math.PI);
    this.material = new module$node_modules$three$build$three.default.MeshBasicMaterial({
        wireframe: !0,
        fog: !1
    });
    void 0 === this.color && (this.material.vertexColors =
        module$node_modules$three$build$three.default.VertexColors);
    b = a.getAttribute("position");
    b = new Float32Array(3 * b.count);
    a.addAttribute("color", new module$node_modules$three$build$three.default.BufferAttribute(b, 3));
    this.add(new module$node_modules$three$build$three.default.Mesh(a, this.material));
    this.update()
};
module$node_modules$three$build$three.default.GridHelper = function(a, b, c, d) {
    a = a || 10;
    b = b || 10;
    c = new module$node_modules$three$build$three.default.Color(void 0 !== c ? c : 4473924);
    d = new module$node_modules$three$build$three.default.Color(void 0 !== d ? d : 8947848);
    var e = b / 2,
        f = a / b,
        g = a / 2;
    a = [];
    for (var h = [], k = 0, l = 0, p = -g; k <= b; k++, p += f) {
        a.push(-g, 0, p, g, 0, p);
        a.push(p, 0, -g, p, 0, g);
        var m = k === e ? c : d;
        m.toArray(h, l);
        l += 3;
        m.toArray(h, l);
        l += 3;
        m.toArray(h, l);
        l += 3;
        m.toArray(h, l);
        l += 3
    }
    b = new module$node_modules$three$build$three.default.BufferGeometry;
    b.addAttribute("position", new module$node_modules$three$build$three.default.Float32BufferAttribute(a, 3));
    b.addAttribute("color", new module$node_modules$three$build$three.default.Float32BufferAttribute(h, 3));
    c = new module$node_modules$three$build$three.default.LineBasicMaterial({
        vertexColors: module$node_modules$three$build$three.default.VertexColors
    });
    module$node_modules$three$build$three.default.LineSegments.call(this, b, c)
};
module$node_modules$three$build$three.default.PolarGridHelper = function(a, b, c, d, e, f) {
    a = a || 10;
    b = b || 16;
    c = c || 8;
    d = d || 64;
    e = new module$node_modules$three$build$three.default.Color(void 0 !== e ? e : 4473924);
    f = new module$node_modules$three$build$three.default.Color(void 0 !== f ? f : 8947848);
    var g = [],
        h = [],
        k;
    for (k = 0; k <= b; k++) {
        var l = k / b * 2 * Math.PI;
        var p = Math.sin(l) * a;
        l = Math.cos(l) * a;
        g.push(0, 0, 0);
        g.push(p, 0, l);
        var m = k & 1 ? e : f;
        h.push(m.r, m.g, m.b);
        h.push(m.r, m.g, m.b)
    }
    for (k = 0; k <= c; k++) {
        m = k & 1 ? e : f;
        var q = a - a / c * k;
        for (b = 0; b < d; b++) l =
            b / d * 2 * Math.PI, p = Math.sin(l) * q, l = Math.cos(l) * q, g.push(p, 0, l), h.push(m.r, m.g, m.b), l = (b + 1) / d * 2 * Math.PI, p = Math.sin(l) * q, l = Math.cos(l) * q, g.push(p, 0, l), h.push(m.r, m.g, m.b)
    }
    a = new module$node_modules$three$build$three.default.BufferGeometry;
    a.addAttribute("position", new module$node_modules$three$build$three.default.Float32BufferAttribute(g, 3));
    a.addAttribute("color", new module$node_modules$three$build$three.default.Float32BufferAttribute(h, 3));
    g = new module$node_modules$three$build$three.default.LineBasicMaterial({
        vertexColors: module$node_modules$three$build$three.default.VertexColors
    });
    module$node_modules$three$build$three.default.LineSegments.call(this, a, g)
};
module$node_modules$three$build$three.default.FaceNormalsHelper = function(a, b, c, d) {
    this.object = a;
    this.size = void 0 !== b ? b : 1;
    a = void 0 !== c ? c : 16776960;
    d = void 0 !== d ? d : 1;
    b = 0;
    (c = this.object.geometry) && c.isGeometry ? b = c.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
    c = new module$node_modules$three$build$three.default.BufferGeometry;
    b = new module$node_modules$three$build$three.default.Float32BufferAttribute(6 * b, 3);
    c.addAttribute("position",
        b);
    module$node_modules$three$build$three.default.LineSegments.call(this, c, new module$node_modules$three$build$three.default.LineBasicMaterial({
        color: a,
        linewidth: d
    }));
    this.matrixAutoUpdate = !1;
    this.update()
};
module$node_modules$three$build$three.default.DirectionalLightHelper = function(a, b, c) {
    module$node_modules$three$build$three.default.Object3D.call(this);
    this.light = a;
    this.light.updateMatrixWorld();
    this.matrix = a.matrixWorld;
    this.matrixAutoUpdate = !1;
    this.color = c;
    void 0 === b && (b = 1);
    a = new module$node_modules$three$build$three.default.BufferGeometry;
    a.addAttribute("position", new module$node_modules$three$build$three.default.Float32BufferAttribute([-b, b, 0, b, b, 0, b, -b, 0, -b, -b, 0, -b, b, 0], 3));
    b = new module$node_modules$three$build$three.default.LineBasicMaterial({
        fog: !1
    });
    this.lightPlane = new module$node_modules$three$build$three.default.Line(a, b);
    this.add(this.lightPlane);
    a = new module$node_modules$three$build$three.default.BufferGeometry;
    a.addAttribute("position", new module$node_modules$three$build$three.default.Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
    this.targetLine = new module$node_modules$three$build$three.default.Line(a, b);
    this.add(this.targetLine);
    this.update()
};
module$node_modules$three$build$three.default.CameraHelper = function(a) {
    function b(a, b, d) {
        c(a, d);
        c(b, d)
    }

    function c(a, b) {
        f.push(0, 0, 0);
        g.push(b.r, b.g, b.b);
        void 0 === h[a] && (h[a] = []);
        h[a].push(f.length / 3 - 1)
    }
    var d = new module$node_modules$three$build$three.default.BufferGeometry,
        e = new module$node_modules$three$build$three.default.LineBasicMaterial({
            color: 16777215,
            vertexColors: module$node_modules$three$build$three.default.FaceColors
        }),
        f = [],
        g = [],
        h = {},
        k = new module$node_modules$three$build$three.default.Color(16755200),
        l = new module$node_modules$three$build$three.default.Color(16711680),
        p = new module$node_modules$three$build$three.default.Color(43775),
        m = new module$node_modules$three$build$three.default.Color(16777215),
        q = new module$node_modules$three$build$three.default.Color(3355443);
    b("n1", "n2", k);
    b("n2", "n4", k);
    b("n4", "n3", k);
    b("n3", "n1", k);
    b("f1", "f2", k);
    b("f2", "f4", k);
    b("f4", "f3", k);
    b("f3", "f1", k);
    b("n1", "f1", k);
    b("n2", "f2", k);
    b("n3", "f3", k);
    b("n4", "f4", k);
    b("p", "n1", l);
    b("p", "n2", l);
    b("p", "n3", l);
    b("p", "n4",
        l);
    b("u1", "u2", p);
    b("u2", "u3", p);
    b("u3", "u1", p);
    b("c", "t", m);
    b("p", "c", q);
    b("cn1", "cn2", q);
    b("cn3", "cn4", q);
    b("cf1", "cf2", q);
    b("cf3", "cf4", q);
    d.addAttribute("position", new module$node_modules$three$build$three.default.Float32BufferAttribute(f, 3));
    d.addAttribute("color", new module$node_modules$three$build$three.default.Float32BufferAttribute(g, 3));
    module$node_modules$three$build$three.default.LineSegments.call(this, d, e);
    this.camera = a;
    this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix();
    this.matrix = a.matrixWorld;
    this.matrixAutoUpdate = !1;
    this.pointMap = h;
    this.update()
};
module$node_modules$three$build$three.default.BoxHelper = function(a, b) {
    this.object = a;
    void 0 === b && (b = 16776960);
    a = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
    var c = new Float32Array(24),
        d = new module$node_modules$three$build$three.default.BufferGeometry;
    d.setIndex(new module$node_modules$three$build$three.default.BufferAttribute(a, 1));
    d.addAttribute("position", new module$node_modules$three$build$three.default.BufferAttribute(c, 3));
    module$node_modules$three$build$three.default.LineSegments.call(this,
        d, new module$node_modules$three$build$three.default.LineBasicMaterial({
            color: b
        }));
    this.matrixAutoUpdate = !1;
    this.update()
};
module$node_modules$three$build$three.default.Box3Helper = function(a, b) {
    this.type = "Box3Helper";
    this.box = a;
    a = void 0 !== b ? b : 16776960;
    b = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
    var c = new module$node_modules$three$build$three.default.BufferGeometry;
    c.setIndex(new module$node_modules$three$build$three.default.BufferAttribute(b, 1));
    c.addAttribute("position", new module$node_modules$three$build$three.default.Float32BufferAttribute([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3));
    module$node_modules$three$build$three.default.LineSegments.call(this, c, new module$node_modules$three$build$three.default.LineBasicMaterial({
        color: a
    }));
    this.geometry.computeBoundingSphere()
};
module$node_modules$three$build$three.default.PlaneHelper = function(a, b, c) {
    this.type = "PlaneHelper";
    this.plane = a;
    this.size = void 0 === b ? 1 : b;
    a = void 0 !== c ? c : 16776960;
    b = new module$node_modules$three$build$three.default.BufferGeometry;
    b.addAttribute("position", new module$node_modules$three$build$three.default.Float32BufferAttribute([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3));
    b.computeBoundingSphere();
    module$node_modules$three$build$three.default.Line.call(this, b, new module$node_modules$three$build$three.default.LineBasicMaterial({
        color: a
    }));
    b = new module$node_modules$three$build$three.default.BufferGeometry;
    b.addAttribute("position", new module$node_modules$three$build$three.default.Float32BufferAttribute([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3));
    b.computeBoundingSphere();
    this.add(new module$node_modules$three$build$three.default.Mesh(b, new module$node_modules$three$build$three.default.MeshBasicMaterial({
        color: a,
        opacity: .2,
        transparent: !0,
        depthWrite: !1
    })))
};
module$node_modules$three$build$three.default.ArrowHelper = function(a, b, c, d, e, f) {
    module$node_modules$three$build$three.default.Object3D.call(this);
    void 0 === d && (d = 16776960);
    void 0 === c && (c = 1);
    void 0 === e && (e = .2 * c);
    void 0 === f && (f = .2 * e);
    void 0 === lineGeometry$$module$node_modules$three$build$three && (lineGeometry$$module$node_modules$three$build$three = new module$node_modules$three$build$three.default.BufferGeometry, lineGeometry$$module$node_modules$three$build$three.addAttribute("position", new module$node_modules$three$build$three.default.Float32BufferAttribute([0,
        0, 0, 0, 1, 0
    ], 3)), coneGeometry$$module$node_modules$three$build$three = new module$node_modules$three$build$three.default.CylinderBufferGeometry(0, .5, 1, 5, 1), coneGeometry$$module$node_modules$three$build$three.translate(0, -.5, 0));
    this.position.copy(b);
    this.line = new module$node_modules$three$build$three.default.Line(lineGeometry$$module$node_modules$three$build$three, new module$node_modules$three$build$three.default.LineBasicMaterial({
        color: d
    }));
    this.line.matrixAutoUpdate = !1;
    this.add(this.line);
    this.cone =
        new module$node_modules$three$build$three.default.Mesh(coneGeometry$$module$node_modules$three$build$three, new module$node_modules$three$build$three.default.MeshBasicMaterial({
            color: d
        }));
    this.cone.matrixAutoUpdate = !1;
    this.add(this.cone);
    this.setDirection(a);
    this.setLength(c, e, f)
};
module$node_modules$three$build$three.default.AxesHelper = function(a) {
    a = a || 1;
    var b = [0, 0, 0, a, 0, 0, 0, 0, 0, 0, a, 0, 0, 0, 0, 0, 0, a];
    a = new module$node_modules$three$build$three.default.BufferGeometry;
    a.addAttribute("position", new module$node_modules$three$build$three.default.Float32BufferAttribute(b, 3));
    a.addAttribute("color", new module$node_modules$three$build$three.default.Float32BufferAttribute([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
    b = new module$node_modules$three$build$three.default.LineBasicMaterial({
        vertexColors: module$node_modules$three$build$three.default.VertexColors
    });
    module$node_modules$three$build$three.default.LineSegments.call(this, a, b)
};
module$node_modules$three$build$three.default.Face4 = function(a, b, c, d, e, f, g) {
    console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead.");
    return new module$node_modules$three$build$three.default.Face3(a, b, c, e, f, g)
};
module$node_modules$three$build$three.default.MeshFaceMaterial = function(a) {
    console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead.");
    return a
};
module$node_modules$three$build$three.default.MultiMaterial = function(a) {
    void 0 === a && (a = []);
    console.warn("THREE.MultiMaterial has been removed. Use an Array instead.");
    a.isMultiMaterial = !0;
    a.materials = a;
    a.clone = function() {
        return a.slice()
    };
    return a
};
module$node_modules$three$build$three.default.PointCloud = function(a, b) {
    console.warn("THREE.PointCloud has been renamed to THREE.Points.");
    return new module$node_modules$three$build$three.default.Points(a, b)
};
module$node_modules$three$build$three.default.Particle = function(a) {
    console.warn("THREE.Particle has been renamed to THREE.Sprite.");
    return new module$node_modules$three$build$three.default.Sprite(a)
};
module$node_modules$three$build$three.default.ParticleSystem = function(a, b) {
    console.warn("THREE.ParticleSystem has been renamed to THREE.Points.");
    return new module$node_modules$three$build$three.default.Points(a, b)
};
module$node_modules$three$build$three.default.PointCloudMaterial = function(a) {
    console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.");
    return new module$node_modules$three$build$three.default.PointsMaterial(a)
};
module$node_modules$three$build$three.default.ParticleBasicMaterial = function(a) {
    console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.");
    return new module$node_modules$three$build$three.default.PointsMaterial(a)
};
module$node_modules$three$build$three.default.ParticleSystemMaterial = function(a) {
    console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.");
    return new module$node_modules$three$build$three.default.PointsMaterial(a)
};
module$node_modules$three$build$three.default.Vertex = function(a, b, c) {
    console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead.");
    return new module$node_modules$three$build$three.default.Vector3(a, b, c)
};
module$node_modules$three$build$three.default.DynamicBufferAttribute = function(a, b) {
    console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.");
    return (new module$node_modules$three$build$three.default.BufferAttribute(a, b)).setDynamic(!0)
};
module$node_modules$three$build$three.default.Int8Attribute = function(a, b) {
    console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.");
    return new module$node_modules$three$build$three.default.Int8BufferAttribute(a, b)
};
module$node_modules$three$build$three.default.Uint8Attribute = function(a, b) {
    console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.");
    return new module$node_modules$three$build$three.default.Uint8BufferAttribute(a, b)
};
module$node_modules$three$build$three.default.Uint8ClampedAttribute = function(a, b) {
    console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.");
    return new module$node_modules$three$build$three.default.Uint8ClampedBufferAttribute(a, b)
};
module$node_modules$three$build$three.default.Int16Attribute = function(a, b) {
    console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.");
    return new module$node_modules$three$build$three.default.Int16BufferAttribute(a, b)
};
module$node_modules$three$build$three.default.Uint16Attribute = function(a, b) {
    console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.");
    return new module$node_modules$three$build$three.default.Uint16BufferAttribute(a, b)
};
module$node_modules$three$build$three.default.Int32Attribute = function(a, b) {
    console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.");
    return new module$node_modules$three$build$three.default.Int32BufferAttribute(a, b)
};
module$node_modules$three$build$three.default.Uint32Attribute = function(a, b) {
    console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.");
    return new module$node_modules$three$build$three.default.Uint32BufferAttribute(a, b)
};
module$node_modules$three$build$three.default.Float32Attribute = function(a, b) {
    console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.");
    return new module$node_modules$three$build$three.default.Float32BufferAttribute(a, b)
};
module$node_modules$three$build$three.default.Float64Attribute = function(a, b) {
    console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.");
    return new module$node_modules$three$build$three.default.Float64BufferAttribute(a, b)
};
module$node_modules$three$build$three.default.ClosedSplineCurve3 = function(a) {
    console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");
    module$node_modules$three$build$three.default.CatmullRomCurve3.call(this, a);
    this.type = "catmullrom";
    this.closed = !0
};
module$node_modules$three$build$three.default.SplineCurve3 = function(a) {
    console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");
    module$node_modules$three$build$three.default.CatmullRomCurve3.call(this, a);
    this.type = "catmullrom"
};
module$node_modules$three$build$three.default.Spline = function(a) {
    console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.");
    module$node_modules$three$build$three.default.CatmullRomCurve3.call(this, a);
    this.type = "catmullrom"
};
module$node_modules$three$build$three.default.AxisHelper = function(a) {
    console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper.");
    return new module$node_modules$three$build$three.default.AxesHelper(a)
};
module$node_modules$three$build$three.default.BoundingBoxHelper = function(a, b) {
    console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.");
    return new module$node_modules$three$build$three.default.BoxHelper(a, b)
};
module$node_modules$three$build$three.default.EdgesHelper = function(a, b) {
    console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.");
    return new module$node_modules$three$build$three.default.LineSegments(new module$node_modules$three$build$three.default.EdgesGeometry(a.geometry), new module$node_modules$three$build$three.default.LineBasicMaterial({
        color: void 0 !== b ? b : 16777215
    }))
};
module$node_modules$three$build$three.default.WireframeHelper = function(a, b) {
    console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.");
    return new module$node_modules$three$build$three.default.LineSegments(new module$node_modules$three$build$three.default.WireframeGeometry(a.geometry), new module$node_modules$three$build$three.default.LineBasicMaterial({
        color: void 0 !== b ? b : 16777215
    }))
};
module$node_modules$three$build$three.default.XHRLoader = function(a) {
    console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader.");
    return new module$node_modules$three$build$three.default.FileLoader(a)
};
module$node_modules$three$build$three.default.BinaryTextureLoader = function(a) {
    console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.");
    return new module$node_modules$three$build$three.default.DataTextureLoader(a)
};
module$node_modules$three$build$three.default.Projector = function() {
    console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js.");
    this.projectVector = function(a, b) {
        console.warn("THREE.Projector: .projectVector() is now vector.project().");
        a.project(b)
    };
    this.unprojectVector = function(a, b) {
        console.warn("THREE.Projector: .unprojectVector() is now vector.unproject().");
        a.unproject(b)
    };
    this.pickingRay = function() {
        console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
    }
};
module$node_modules$three$build$three.default.CanvasRenderer = function() {
    console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js");
    this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
    this.clear = function() {};
    this.render = function() {};
    this.setClearColor = function() {};
    this.setSize = function() {}
};
module$node_modules$three$build$three.default.LensFlare = function() {
    console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js")
};
void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52));
void 0 === Number.isInteger && (Number.isInteger = function(a) {
    return "number" === typeof a && isFinite(a) && Math.floor(a) === a
});
void 0 === Math.sign && (Math.sign = function(a) {
    return 0 > a ? -1 : 0 < a ? 1 : +a
});
!1 === "name" in Function.prototype && Object.defineProperty(Function.prototype, "name", {
    get: function() {
        return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
    }
});
void 0 === Object.assign && function() {
    Object.assign = function(a) {
        if (void 0 === a || null === a) throw new TypeError("Cannot convert undefined or null to object");
        for (var b = Object(a), c = 1; c < arguments.length; c++) {
            var d = arguments[c];
            if (void 0 !== d && null !== d)
                for (var e in d) Object.prototype.hasOwnProperty.call(d, e) && (b[e] = d[e])
        }
        return b
    }
}();
Object.assign(module$node_modules$three$build$three.default.EventDispatcher.prototype, {
    addEventListener: function(a, b) {
        void 0 === this._listeners && (this._listeners = {});
        var c = this._listeners;
        void 0 === c[a] && (c[a] = []); - 1 === c[a].indexOf(b) && c[a].push(b)
    },
    hasEventListener: function(a, b) {
        if (void 0 === this._listeners) return !1;
        var c = this._listeners;
        return void 0 !== c[a] && -1 !== c[a].indexOf(b)
    },
    removeEventListener: function(a, b) {
        void 0 !== this._listeners && (a = this._listeners[a], void 0 !== a && (b = a.indexOf(b), -1 !== b && a.splice(b,
            1)))
    },
    dispatchEvent: function(a) {
        if (void 0 !== this._listeners) {
            var b = this._listeners[a.type];
            if (void 0 !== b) {
                a.target = this;
                b = b.slice(0);
                for (var c = 0, d = b.length; c < d; c++) b[c].call(this, a)
            }
        }
    }
});
module$node_modules$three$build$three.default.REVISION = "95";
module$node_modules$three$build$three.default.MOUSE = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2
};
module$node_modules$three$build$three.default.CullFaceNone = 0;
module$node_modules$three$build$three.default.CullFaceBack = 1;
module$node_modules$three$build$three.default.CullFaceFront = 2;
module$node_modules$three$build$three.default.CullFaceFrontBack = 3;
module$node_modules$three$build$three.default.FrontFaceDirectionCW = 0;
module$node_modules$three$build$three.default.FrontFaceDirectionCCW = 1;
module$node_modules$three$build$three.default.BasicShadowMap = 0;
module$node_modules$three$build$three.default.PCFShadowMap = 1;
module$node_modules$three$build$three.default.PCFSoftShadowMap = 2;
module$node_modules$three$build$three.default.FrontSide = 0;
module$node_modules$three$build$three.default.BackSide = 1;
module$node_modules$three$build$three.default.DoubleSide = 2;
module$node_modules$three$build$three.default.FlatShading = 1;
module$node_modules$three$build$three.default.SmoothShading = 2;
module$node_modules$three$build$three.default.NoColors = 0;
module$node_modules$three$build$three.default.FaceColors = 1;
module$node_modules$three$build$three.default.VertexColors = 2;
module$node_modules$three$build$three.default.NoBlending = 0;
module$node_modules$three$build$three.default.NormalBlending = 1;
module$node_modules$three$build$three.default.AdditiveBlending = 2;
module$node_modules$three$build$three.default.SubtractiveBlending = 3;
module$node_modules$three$build$three.default.MultiplyBlending = 4;
module$node_modules$three$build$three.default.CustomBlending = 5;
module$node_modules$three$build$three.default.AddEquation = 100;
module$node_modules$three$build$three.default.SubtractEquation = 101;
module$node_modules$three$build$three.default.ReverseSubtractEquation = 102;
module$node_modules$three$build$three.default.MinEquation = 103;
module$node_modules$three$build$three.default.MaxEquation = 104;
module$node_modules$three$build$three.default.ZeroFactor = 200;
module$node_modules$three$build$three.default.OneFactor = 201;
module$node_modules$three$build$three.default.SrcColorFactor = 202;
module$node_modules$three$build$three.default.OneMinusSrcColorFactor = 203;
module$node_modules$three$build$three.default.SrcAlphaFactor = 204;
module$node_modules$three$build$three.default.OneMinusSrcAlphaFactor = 205;
module$node_modules$three$build$three.default.DstAlphaFactor = 206;
module$node_modules$three$build$three.default.OneMinusDstAlphaFactor = 207;
module$node_modules$three$build$three.default.DstColorFactor = 208;
module$node_modules$three$build$three.default.OneMinusDstColorFactor = 209;
module$node_modules$three$build$three.default.SrcAlphaSaturateFactor = 210;
module$node_modules$three$build$three.default.NeverDepth = 0;
module$node_modules$three$build$three.default.AlwaysDepth = 1;
module$node_modules$three$build$three.default.LessDepth = 2;
module$node_modules$three$build$three.default.LessEqualDepth = 3;
module$node_modules$three$build$three.default.EqualDepth = 4;
module$node_modules$three$build$three.default.GreaterEqualDepth = 5;
module$node_modules$three$build$three.default.GreaterDepth = 6;
module$node_modules$three$build$three.default.NotEqualDepth = 7;
module$node_modules$three$build$three.default.MultiplyOperation = 0;
module$node_modules$three$build$three.default.MixOperation = 1;
module$node_modules$three$build$three.default.AddOperation = 2;
module$node_modules$three$build$three.default.NoToneMapping = 0;
module$node_modules$three$build$three.default.LinearToneMapping = 1;
module$node_modules$three$build$three.default.ReinhardToneMapping = 2;
module$node_modules$three$build$three.default.Uncharted2ToneMapping = 3;
module$node_modules$three$build$three.default.CineonToneMapping = 4;
module$node_modules$three$build$three.default.UVMapping = 300;
module$node_modules$three$build$three.default.CubeReflectionMapping = 301;
module$node_modules$three$build$three.default.CubeRefractionMapping = 302;
module$node_modules$three$build$three.default.EquirectangularReflectionMapping = 303;
module$node_modules$three$build$three.default.EquirectangularRefractionMapping = 304;
module$node_modules$three$build$three.default.SphericalReflectionMapping = 305;
module$node_modules$three$build$three.default.CubeUVReflectionMapping = 306;
module$node_modules$three$build$three.default.CubeUVRefractionMapping = 307;
module$node_modules$three$build$three.default.RepeatWrapping = 1E3;
module$node_modules$three$build$three.default.ClampToEdgeWrapping = 1001;
module$node_modules$three$build$three.default.MirroredRepeatWrapping = 1002;
module$node_modules$three$build$three.default.NearestFilter = 1003;
module$node_modules$three$build$three.default.NearestMipMapNearestFilter = 1004;
module$node_modules$three$build$three.default.NearestMipMapLinearFilter = 1005;
module$node_modules$three$build$three.default.LinearFilter = 1006;
module$node_modules$three$build$three.default.LinearMipMapNearestFilter = 1007;
module$node_modules$three$build$three.default.LinearMipMapLinearFilter = 1008;
module$node_modules$three$build$three.default.UnsignedByteType = 1009;
module$node_modules$three$build$three.default.ByteType = 1010;
module$node_modules$three$build$three.default.ShortType = 1011;
module$node_modules$three$build$three.default.UnsignedShortType = 1012;
module$node_modules$three$build$three.default.IntType = 1013;
module$node_modules$three$build$three.default.UnsignedIntType = 1014;
module$node_modules$three$build$three.default.FloatType = 1015;
module$node_modules$three$build$three.default.HalfFloatType = 1016;
module$node_modules$three$build$three.default.UnsignedShort4444Type = 1017;
module$node_modules$three$build$three.default.UnsignedShort5551Type = 1018;
module$node_modules$three$build$three.default.UnsignedShort565Type = 1019;
module$node_modules$three$build$three.default.UnsignedInt248Type = 1020;
module$node_modules$three$build$three.default.AlphaFormat = 1021;
module$node_modules$three$build$three.default.RGBFormat = 1022;
module$node_modules$three$build$three.default.RGBAFormat = 1023;
module$node_modules$three$build$three.default.LuminanceFormat = 1024;
module$node_modules$three$build$three.default.LuminanceAlphaFormat = 1025;
module$node_modules$three$build$three.default.RGBEFormat = module$node_modules$three$build$three.default.RGBAFormat;
module$node_modules$three$build$three.default.DepthFormat = 1026;
module$node_modules$three$build$three.default.DepthStencilFormat = 1027;
module$node_modules$three$build$three.default.RGB_S3TC_DXT1_Format = 33776;
module$node_modules$three$build$three.default.RGBA_S3TC_DXT1_Format = 33777;
module$node_modules$three$build$three.default.RGBA_S3TC_DXT3_Format = 33778;
module$node_modules$three$build$three.default.RGBA_S3TC_DXT5_Format = 33779;
module$node_modules$three$build$three.default.RGB_PVRTC_4BPPV1_Format = 35840;
module$node_modules$three$build$three.default.RGB_PVRTC_2BPPV1_Format = 35841;
module$node_modules$three$build$three.default.RGBA_PVRTC_4BPPV1_Format = 35842;
module$node_modules$three$build$three.default.RGBA_PVRTC_2BPPV1_Format = 35843;
module$node_modules$three$build$three.default.RGB_ETC1_Format = 36196;
module$node_modules$three$build$three.default.RGBA_ASTC_4x4_Format = 37808;
module$node_modules$three$build$three.default.RGBA_ASTC_5x4_Format = 37809;
module$node_modules$three$build$three.default.RGBA_ASTC_5x5_Format = 37810;
module$node_modules$three$build$three.default.RGBA_ASTC_6x5_Format = 37811;
module$node_modules$three$build$three.default.RGBA_ASTC_6x6_Format = 37812;
module$node_modules$three$build$three.default.RGBA_ASTC_8x5_Format = 37813;
module$node_modules$three$build$three.default.RGBA_ASTC_8x6_Format = 37814;
module$node_modules$three$build$three.default.RGBA_ASTC_8x8_Format = 37815;
module$node_modules$three$build$three.default.RGBA_ASTC_10x5_Format = 37816;
module$node_modules$three$build$three.default.RGBA_ASTC_10x6_Format = 37817;
module$node_modules$three$build$three.default.RGBA_ASTC_10x8_Format = 37818;
module$node_modules$three$build$three.default.RGBA_ASTC_10x10_Format = 37819;
module$node_modules$three$build$three.default.RGBA_ASTC_12x10_Format = 37820;
module$node_modules$three$build$three.default.RGBA_ASTC_12x12_Format = 37821;
module$node_modules$three$build$three.default.LoopOnce = 2200;
module$node_modules$three$build$three.default.LoopRepeat = 2201;
module$node_modules$three$build$three.default.LoopPingPong = 2202;
module$node_modules$three$build$three.default.InterpolateDiscrete = 2300;
module$node_modules$three$build$three.default.InterpolateLinear = 2301;
module$node_modules$three$build$three.default.InterpolateSmooth = 2302;
module$node_modules$three$build$three.default.ZeroCurvatureEnding = 2400;
module$node_modules$three$build$three.default.ZeroSlopeEnding = 2401;
module$node_modules$three$build$three.default.WrapAroundEnding = 2402;
module$node_modules$three$build$three.default.TrianglesDrawMode = 0;
module$node_modules$three$build$three.default.TriangleStripDrawMode = 1;
module$node_modules$three$build$three.default.TriangleFanDrawMode = 2;
module$node_modules$three$build$three.default.LinearEncoding = 3E3;
module$node_modules$three$build$three.default.sRGBEncoding = 3001;
module$node_modules$three$build$three.default.GammaEncoding = 3007;
module$node_modules$three$build$three.default.RGBEEncoding = 3002;
module$node_modules$three$build$three.default.LogLuvEncoding = 3003;
module$node_modules$three$build$three.default.RGBM7Encoding = 3004;
module$node_modules$three$build$three.default.RGBM16Encoding = 3005;
module$node_modules$three$build$three.default.RGBDEncoding = 3006;
module$node_modules$three$build$three.default.BasicDepthPacking = 3200;
module$node_modules$three$build$three.default.RGBADepthPacking = 3201;
module$node_modules$three$build$three.default.TangentSpaceNormalMap = 0;
module$node_modules$three$build$three.default.ObjectSpaceNormalMap = 1;
module$node_modules$three$build$three.default.Math = {
    DEG2RAD: Math.PI / 180,
    RAD2DEG: 180 / Math.PI,
    generateUUID: function() {
        for (var a = [], b = 0; 256 > b; b++) a[b] = (16 > b ? "0" : "") + b.toString(16);
        return function() {
            var b = 4294967295 * Math.random() | 0,
                d = 4294967295 * Math.random() | 0,
                e = 4294967295 * Math.random() | 0,
                f = 4294967295 * Math.random() | 0;
            return (a[b & 255] + a[b >> 8 & 255] + a[b >> 16 & 255] + a[b >> 24 & 255] + "-" + a[d & 255] + a[d >> 8 & 255] + "-" + a[d >> 16 & 15 | 64] + a[d >> 24 & 255] + "-" + a[e & 63 | 128] + a[e >> 8 & 255] + "-" + a[e >> 16 & 255] + a[e >> 24 & 255] + a[f & 255] + a[f >> 8 & 255] +
                a[f >> 16 & 255] + a[f >> 24 & 255]).toUpperCase()
        }
    }(),
    clamp: function(a, b, c) {
        return Math.max(b, Math.min(c, a))
    },
    euclideanModulo: function(a, b) {
        return (a % b + b) % b
    },
    mapLinear: function(a, b, c, d, e) {
        return d + (a - b) * (e - d) / (c - b)
    },
    lerp: function(a, b, c) {
        return (1 - c) * a + c * b
    },
    smoothstep: function(a, b, c) {
        if (a <= b) return 0;
        if (a >= c) return 1;
        a = (a - b) / (c - b);
        return a * a * (3 - 2 * a)
    },
    smootherstep: function(a, b, c) {
        if (a <= b) return 0;
        if (a >= c) return 1;
        a = (a - b) / (c - b);
        return a * a * a * (a * (6 * a - 15) + 10)
    },
    randInt: function(a, b) {
        return a + Math.floor(Math.random() *
            (b - a + 1))
    },
    randFloat: function(a, b) {
        return a + Math.random() * (b - a)
    },
    randFloatSpread: function(a) {
        return a * (.5 - Math.random())
    },
    degToRad: function(a) {
        return a * module$node_modules$three$build$three.default.Math.DEG2RAD
    },
    radToDeg: function(a) {
        return a * module$node_modules$three$build$three.default.Math.RAD2DEG
    },
    isPowerOfTwo: function(a) {
        return 0 === (a & a - 1) && 0 !== a
    },
    ceilPowerOfTwo: function(a) {
        return Math.pow(2, Math.ceil(Math.log(a) / Math.LN2))
    },
    floorPowerOfTwo: function(a) {
        return Math.pow(2, Math.floor(Math.log(a) /
            Math.LN2))
    }
};
Object.defineProperties(module$node_modules$three$build$three.default.Vector2.prototype, {
    width: {
        get: function() {
            return this.x
        },
        set: function(a) {
            this.x = a
        }
    },
    height: {
        get: function() {
            return this.y
        },
        set: function(a) {
            this.y = a
        }
    }
});
Object.assign(module$node_modules$three$build$three.default.Vector2.prototype, {
    isVector2: !0,
    set: function(a, b) {
        this.x = a;
        this.y = b;
        return this
    },
    setScalar: function(a) {
        this.y = this.x = a;
        return this
    },
    setX: function(a) {
        this.x = a;
        return this
    },
    setY: function(a) {
        this.y = a;
        return this
    },
    setComponent: function(a, b) {
        switch (a) {
            case 0:
                this.x = b;
                break;
            case 1:
                this.y = b;
                break;
            default:
                throw Error("index is out of range: " + a);
        }
        return this
    },
    getComponent: function(a) {
        switch (a) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw Error("index is out of range: " +
                    a);
        }
    },
    clone: function() {
        return new this.constructor(this.x, this.y)
    },
    copy: function(a) {
        this.x = a.x;
        this.y = a.y;
        return this
    },
    add: function(a, b) {
        if (void 0 !== b) return console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
        this.x += a.x;
        this.y += a.y;
        return this
    },
    addScalar: function(a) {
        this.x += a;
        this.y += a;
        return this
    },
    addVectors: function(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        return this
    },
    addScaledVector: function(a, b) {
        this.x += a.x * b;
        this.y += a.y * b;
        return this
    },
    sub: function(a, b) {
        if (void 0 !== b) return console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
        this.x -= a.x;
        this.y -= a.y;
        return this
    },
    subScalar: function(a) {
        this.x -= a;
        this.y -= a;
        return this
    },
    subVectors: function(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        return this
    },
    multiply: function(a) {
        this.x *= a.x;
        this.y *= a.y;
        return this
    },
    multiplyScalar: function(a) {
        this.x *= a;
        this.y *= a;
        return this
    },
    divide: function(a) {
        this.x /= a.x;
        this.y /= a.y;
        return this
    },
    divideScalar: function(a) {
        return this.multiplyScalar(1 /
            a)
    },
    applyMatrix3: function(a) {
        var b = this.x,
            c = this.y;
        a = a.elements;
        this.x = a[0] * b + a[3] * c + a[6];
        this.y = a[1] * b + a[4] * c + a[7];
        return this
    },
    min: function(a) {
        this.x = Math.min(this.x, a.x);
        this.y = Math.min(this.y, a.y);
        return this
    },
    max: function(a) {
        this.x = Math.max(this.x, a.x);
        this.y = Math.max(this.y, a.y);
        return this
    },
    clamp: function(a, b) {
        this.x = Math.max(a.x, Math.min(b.x, this.x));
        this.y = Math.max(a.y, Math.min(b.y, this.y));
        return this
    },
    clampScalar: function() {
        var a = new module$node_modules$three$build$three.default.Vector2,
            b = new module$node_modules$three$build$three.default.Vector2;
        return function(c, d) {
            a.set(c, c);
            b.set(d, d);
            return this.clamp(a, b)
        }
    }(),
    clampLength: function(a, b) {
        var c = this.length();
        return this.divideScalar(c || 1).multiplyScalar(Math.max(a, Math.min(b, c)))
    },
    floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this
    },
    ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this
    },
    round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this
    },
    roundToZero: function() {
        this.x =
            0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
        return this
    },
    negate: function() {
        this.x = -this.x;
        this.y = -this.y;
        return this
    },
    dot: function(a) {
        return this.x * a.x + this.y * a.y
    },
    cross: function(a) {
        return this.x * a.y - this.y * a.x
    },
    lengthSq: function() {
        return this.x * this.x + this.y * this.y
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    },
    manhattanLength: function() {
        return Math.abs(this.x) + Math.abs(this.y)
    },
    normalize: function() {
        return this.divideScalar(this.length() ||
            1)
    },
    angle: function() {
        var a = Math.atan2(this.y, this.x);
        0 > a && (a += 2 * Math.PI);
        return a
    },
    distanceTo: function(a) {
        return Math.sqrt(this.distanceToSquared(a))
    },
    distanceToSquared: function(a) {
        var b = this.x - a.x;
        a = this.y - a.y;
        return b * b + a * a
    },
    manhattanDistanceTo: function(a) {
        return Math.abs(this.x - a.x) + Math.abs(this.y - a.y)
    },
    setLength: function(a) {
        return this.normalize().multiplyScalar(a)
    },
    lerp: function(a, b) {
        this.x += (a.x - this.x) * b;
        this.y += (a.y - this.y) * b;
        return this
    },
    lerpVectors: function(a, b, c) {
        return this.subVectors(b,
            a).multiplyScalar(c).add(a)
    },
    equals: function(a) {
        return a.x === this.x && a.y === this.y
    },
    fromArray: function(a, b) {
        void 0 === b && (b = 0);
        this.x = a[b];
        this.y = a[b + 1];
        return this
    },
    toArray: function(a, b) {
        void 0 === a && (a = []);
        void 0 === b && (b = 0);
        a[b] = this.x;
        a[b + 1] = this.y;
        return a
    },
    fromBufferAttribute: function(a, b, c) {
        void 0 !== c && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
        this.x = a.getX(b);
        this.y = a.getY(b);
        return this
    },
    rotateAround: function(a, b) {
        var c = Math.cos(b);
        b = Math.sin(b);
        var d =
            this.x - a.x,
            e = this.y - a.y;
        this.x = d * c - e * b + a.x;
        this.y = d * b + e * c + a.y;
        return this
    }
});
Object.assign(module$node_modules$three$build$three.default.Matrix4.prototype, {
    isMatrix4: !0,
    set: function(a, b, c, d, e, f, g, h, k, l, p, m, q, r, n, t) {
        var u = this.elements;
        u[0] = a;
        u[4] = b;
        u[8] = c;
        u[12] = d;
        u[1] = e;
        u[5] = f;
        u[9] = g;
        u[13] = h;
        u[2] = k;
        u[6] = l;
        u[10] = p;
        u[14] = m;
        u[3] = q;
        u[7] = r;
        u[11] = n;
        u[15] = t;
        return this
    },
    identity: function() {
        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this
    },
    clone: function() {
        return (new module$node_modules$three$build$three.default.Matrix4).fromArray(this.elements)
    },
    copy: function(a) {
        var b = this.elements;
        a = a.elements;
        b[0] = a[0];
        b[1] = a[1];
        b[2] = a[2];
        b[3] = a[3];
        b[4] = a[4];
        b[5] = a[5];
        b[6] = a[6];
        b[7] = a[7];
        b[8] = a[8];
        b[9] = a[9];
        b[10] = a[10];
        b[11] = a[11];
        b[12] = a[12];
        b[13] = a[13];
        b[14] = a[14];
        b[15] = a[15];
        return this
    },
    copyPosition: function(a) {
        var b = this.elements;
        a = a.elements;
        b[12] = a[12];
        b[13] = a[13];
        b[14] = a[14];
        return this
    },
    extractBasis: function(a, b, c) {
        a.setFromMatrixColumn(this, 0);
        b.setFromMatrixColumn(this, 1);
        c.setFromMatrixColumn(this, 2);
        return this
    },
    makeBasis: function(a, b, c) {
        this.set(a.x, b.x, c.x, 0, a.y, b.y, c.y, 0, a.z,
            b.z, c.z, 0, 0, 0, 0, 1);
        return this
    },
    extractRotation: function() {
        var a = new module$node_modules$three$build$three.default.Vector3;
        return function(b) {
            var c = this.elements,
                d = b.elements,
                e = 1 / a.setFromMatrixColumn(b, 0).length(),
                f = 1 / a.setFromMatrixColumn(b, 1).length();
            b = 1 / a.setFromMatrixColumn(b, 2).length();
            c[0] = d[0] * e;
            c[1] = d[1] * e;
            c[2] = d[2] * e;
            c[3] = 0;
            c[4] = d[4] * f;
            c[5] = d[5] * f;
            c[6] = d[6] * f;
            c[7] = 0;
            c[8] = d[8] * b;
            c[9] = d[9] * b;
            c[10] = d[10] * b;
            c[11] = 0;
            c[12] = 0;
            c[13] = 0;
            c[14] = 0;
            c[15] = 1;
            return this
        }
    }(),
    makeRotationFromEuler: function(a) {
        a &&
            a.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
        var b = this.elements,
            c = a.x,
            d = a.y,
            e = a.z,
            f = Math.cos(c);
        c = Math.sin(c);
        var g = Math.cos(d);
        d = Math.sin(d);
        var h = Math.cos(e);
        e = Math.sin(e);
        if ("XYZ" === a.order) {
            a = f * h;
            var k = f * e,
                l = c * h,
                p = c * e;
            b[0] = g * h;
            b[4] = -g * e;
            b[8] = d;
            b[1] = k + l * d;
            b[5] = a - p * d;
            b[9] = -c * g;
            b[2] = p - a * d;
            b[6] = l + k * d;
            b[10] = f * g
        } else "YXZ" === a.order ? (a = g * h, k = g * e, l = d * h, p = d * e, b[0] = a + p * c, b[4] = l * c - k, b[8] = f * d, b[1] = f * e, b[5] = f * h, b[9] = -c, b[2] =
            k * c - l, b[6] = p + a * c, b[10] = f * g) : "ZXY" === a.order ? (a = g * h, k = g * e, l = d * h, p = d * e, b[0] = a - p * c, b[4] = -f * e, b[8] = l + k * c, b[1] = k + l * c, b[5] = f * h, b[9] = p - a * c, b[2] = -f * d, b[6] = c, b[10] = f * g) : "ZYX" === a.order ? (a = f * h, k = f * e, l = c * h, p = c * e, b[0] = g * h, b[4] = l * d - k, b[8] = a * d + p, b[1] = g * e, b[5] = p * d + a, b[9] = k * d - l, b[2] = -d, b[6] = c * g, b[10] = f * g) : "YZX" === a.order ? (a = f * g, k = f * d, l = c * g, p = c * d, b[0] = g * h, b[4] = p - a * e, b[8] = l * e + k, b[1] = e, b[5] = f * h, b[9] = -c * h, b[2] = -d * h, b[6] = k * e + l, b[10] = a - p * e) : "XZY" === a.order && (a = f * g, k = f * d, l = c * g, p = c * d, b[0] = g * h, b[4] = -e, b[8] = d * h, b[1] = a * e + p,
            b[5] = f * h, b[9] = k * e - l, b[2] = l * e - k, b[6] = c * h, b[10] = p * e + a);
        b[3] = 0;
        b[7] = 0;
        b[11] = 0;
        b[12] = 0;
        b[13] = 0;
        b[14] = 0;
        b[15] = 1;
        return this
    },
    makeRotationFromQuaternion: function() {
        var a = new module$node_modules$three$build$three.default.Vector3(0, 0, 0),
            b = new module$node_modules$three$build$three.default.Vector3(1, 1, 1);
        return function(c) {
            return this.compose(a, c, b)
        }
    }(),
    lookAt: function() {
        var a = new module$node_modules$three$build$three.default.Vector3,
            b = new module$node_modules$three$build$three.default.Vector3,
            c = new module$node_modules$three$build$three.default.Vector3;
        return function(d, e, f) {
            var g = this.elements;
            c.subVectors(d, e);
            0 === c.lengthSq() && (c.z = 1);
            c.normalize();
            a.crossVectors(f, c);
            0 === a.lengthSq() && (1 === Math.abs(f.z) ? c.x += 1E-4 : c.z += 1E-4, c.normalize(), a.crossVectors(f, c));
            a.normalize();
            b.crossVectors(c, a);
            g[0] = a.x;
            g[4] = b.x;
            g[8] = c.x;
            g[1] = a.y;
            g[5] = b.y;
            g[9] = c.y;
            g[2] = a.z;
            g[6] = b.z;
            g[10] = c.z;
            return this
        }
    }(),
    multiply: function(a, b) {
        return void 0 !== b ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(a,
            b)) : this.multiplyMatrices(this, a)
    },
    premultiply: function(a) {
        return this.multiplyMatrices(a, this)
    },
    multiplyMatrices: function(a, b) {
        var c = a.elements,
            d = b.elements;
        b = this.elements;
        a = c[0];
        var e = c[4],
            f = c[8],
            g = c[12],
            h = c[1],
            k = c[5],
            l = c[9],
            p = c[13],
            m = c[2],
            q = c[6],
            r = c[10],
            n = c[14],
            t = c[3],
            u = c[7],
            w = c[11];
        c = c[15];
        var v = d[0],
            y = d[4],
            A = d[8],
            x = d[12],
            z = d[1],
            B = d[5],
            N = d[9],
            K = d[13],
            H = d[2],
            D = d[6],
            I = d[10],
            G = d[14],
            T = d[3],
            L = d[7],
            F = d[11];
        d = d[15];
        b[0] = a * v + e * z + f * H + g * T;
        b[4] = a * y + e * B + f * D + g * L;
        b[8] = a * A + e * N + f * I + g * F;
        b[12] = a * x + e * K + f * G + g *
            d;
        b[1] = h * v + k * z + l * H + p * T;
        b[5] = h * y + k * B + l * D + p * L;
        b[9] = h * A + k * N + l * I + p * F;
        b[13] = h * x + k * K + l * G + p * d;
        b[2] = m * v + q * z + r * H + n * T;
        b[6] = m * y + q * B + r * D + n * L;
        b[10] = m * A + q * N + r * I + n * F;
        b[14] = m * x + q * K + r * G + n * d;
        b[3] = t * v + u * z + w * H + c * T;
        b[7] = t * y + u * B + w * D + c * L;
        b[11] = t * A + u * N + w * I + c * F;
        b[15] = t * x + u * K + w * G + c * d;
        return this
    },
    multiplyScalar: function(a) {
        var b = this.elements;
        b[0] *= a;
        b[4] *= a;
        b[8] *= a;
        b[12] *= a;
        b[1] *= a;
        b[5] *= a;
        b[9] *= a;
        b[13] *= a;
        b[2] *= a;
        b[6] *= a;
        b[10] *= a;
        b[14] *= a;
        b[3] *= a;
        b[7] *= a;
        b[11] *= a;
        b[15] *= a;
        return this
    },
    applyToBufferAttribute: function() {
        var a =
            new module$node_modules$three$build$three.default.Vector3;
        return function(b) {
            for (var c = 0, d = b.count; c < d; c++) a.x = b.getX(c), a.y = b.getY(c), a.z = b.getZ(c), a.applyMatrix4(this), b.setXYZ(c, a.x, a.y, a.z);
            return b
        }
    }(),
    determinant: function() {
        var a = this.elements,
            b = a[0],
            c = a[4],
            d = a[8],
            e = a[12],
            f = a[1],
            g = a[5],
            h = a[9],
            k = a[13],
            l = a[2],
            p = a[6],
            m = a[10],
            q = a[14];
        return a[3] * (+e * h * p - d * k * p - e * g * m + c * k * m + d * g * q - c * h * q) + a[7] * (+b * h * q - b * k * m + e * f * m - d * f * q + d * k * l - e * h * l) + a[11] * (+b * k * p - b * g * q - e * f * p + c * f * q + e * g * l - c * k * l) + a[15] * (-d * g * l - b * h * p + b * g *
            m + d * f * p - c * f * m + c * h * l)
    },
    transpose: function() {
        var a = this.elements;
        var b = a[1];
        a[1] = a[4];
        a[4] = b;
        b = a[2];
        a[2] = a[8];
        a[8] = b;
        b = a[6];
        a[6] = a[9];
        a[9] = b;
        b = a[3];
        a[3] = a[12];
        a[12] = b;
        b = a[7];
        a[7] = a[13];
        a[13] = b;
        b = a[11];
        a[11] = a[14];
        a[14] = b;
        return this
    },
    setPosition: function(a) {
        var b = this.elements;
        b[12] = a.x;
        b[13] = a.y;
        b[14] = a.z;
        return this
    },
    getInverse: function(a, b) {
        var c = this.elements,
            d = a.elements;
        a = d[0];
        var e = d[1],
            f = d[2],
            g = d[3],
            h = d[4],
            k = d[5],
            l = d[6],
            p = d[7],
            m = d[8],
            q = d[9],
            r = d[10],
            n = d[11],
            t = d[12],
            u = d[13],
            w = d[14];
        d = d[15];
        var v =
            q * w * p - u * r * p + u * l * n - k * w * n - q * l * d + k * r * d,
            y = t * r * p - m * w * p - t * l * n + h * w * n + m * l * d - h * r * d,
            A = m * u * p - t * q * p + t * k * n - h * u * n - m * k * d + h * q * d,
            x = t * q * l - m * u * l - t * k * r + h * u * r + m * k * w - h * q * w,
            z = a * v + e * y + f * A + g * x;
        if (0 === z) {
            if (!0 === b) throw Error("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0");
            console.warn("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0");
            return this.identity()
        }
        b = 1 / z;
        c[0] = v * b;
        c[1] = (u * r * g - q * w * g - u * f * n + e * w * n + q * f * d - e * r * d) * b;
        c[2] = (k * w * g - u * l * g + u * f * p - e * w * p - k * f * d + e * l * d) * b;
        c[3] = (q * l * g - k * r * g - q *
            f * p + e * r * p + k * f * n - e * l * n) * b;
        c[4] = y * b;
        c[5] = (m * w * g - t * r * g + t * f * n - a * w * n - m * f * d + a * r * d) * b;
        c[6] = (t * l * g - h * w * g - t * f * p + a * w * p + h * f * d - a * l * d) * b;
        c[7] = (h * r * g - m * l * g + m * f * p - a * r * p - h * f * n + a * l * n) * b;
        c[8] = A * b;
        c[9] = (t * q * g - m * u * g - t * e * n + a * u * n + m * e * d - a * q * d) * b;
        c[10] = (h * u * g - t * k * g + t * e * p - a * u * p - h * e * d + a * k * d) * b;
        c[11] = (m * k * g - h * q * g - m * e * p + a * q * p + h * e * n - a * k * n) * b;
        c[12] = x * b;
        c[13] = (m * u * f - t * q * f + t * e * r - a * u * r - m * e * w + a * q * w) * b;
        c[14] = (t * k * f - h * u * f - t * e * l + a * u * l + h * e * w - a * k * w) * b;
        c[15] = (h * q * f - m * k * f + m * e * l - a * q * l - h * e * r + a * k * r) * b;
        return this
    },
    scale: function(a) {
        var b = this.elements,
            c = a.x,
            d = a.y;
        a = a.z;
        b[0] *= c;
        b[4] *= d;
        b[8] *= a;
        b[1] *= c;
        b[5] *= d;
        b[9] *= a;
        b[2] *= c;
        b[6] *= d;
        b[10] *= a;
        b[3] *= c;
        b[7] *= d;
        b[11] *= a;
        return this
    },
    getMaxScaleOnAxis: function() {
        var a = this.elements;
        return Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], a[4] * a[4] + a[5] * a[5] + a[6] * a[6], a[8] * a[8] + a[9] * a[9] + a[10] * a[10]))
    },
    makeTranslation: function(a, b, c) {
        this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1);
        return this
    },
    makeRotationX: function(a) {
        var b = Math.cos(a);
        a = Math.sin(a);
        this.set(1, 0, 0, 0, 0, b, -a, 0, 0, a, b, 0, 0, 0, 0, 1);
        return this
    },
    makeRotationY: function(a) {
        var b =
            Math.cos(a);
        a = Math.sin(a);
        this.set(b, 0, a, 0, 0, 1, 0, 0, -a, 0, b, 0, 0, 0, 0, 1);
        return this
    },
    makeRotationZ: function(a) {
        var b = Math.cos(a);
        a = Math.sin(a);
        this.set(b, -a, 0, 0, a, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this
    },
    makeRotationAxis: function(a, b) {
        var c = Math.cos(b);
        b = Math.sin(b);
        var d = 1 - c,
            e = a.x,
            f = a.y;
        a = a.z;
        var g = d * e,
            h = d * f;
        this.set(g * e + c, g * f - b * a, g * a + b * f, 0, g * f + b * a, h * f + c, h * a - b * e, 0, g * a - b * f, h * a + b * e, d * a * a + c, 0, 0, 0, 0, 1);
        return this
    },
    makeScale: function(a, b, c) {
        this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1);
        return this
    },
    makeShear: function(a,
        b, c) {
        this.set(1, b, c, 0, a, 1, c, 0, a, b, 1, 0, 0, 0, 0, 1);
        return this
    },
    compose: function(a, b, c) {
        var d = this.elements,
            e = b._x,
            f = b._y,
            g = b._z,
            h = b._w,
            k = e + e,
            l = f + f,
            p = g + g;
        b = e * k;
        var m = e * l;
        e *= p;
        var q = f * l;
        f *= p;
        g *= p;
        k *= h;
        l *= h;
        h *= p;
        p = c.x;
        var r = c.y;
        c = c.z;
        d[0] = (1 - (q + g)) * p;
        d[1] = (m + h) * p;
        d[2] = (e - l) * p;
        d[3] = 0;
        d[4] = (m - h) * r;
        d[5] = (1 - (b + g)) * r;
        d[6] = (f + k) * r;
        d[7] = 0;
        d[8] = (e + l) * c;
        d[9] = (f - k) * c;
        d[10] = (1 - (b + q)) * c;
        d[11] = 0;
        d[12] = a.x;
        d[13] = a.y;
        d[14] = a.z;
        d[15] = 1;
        return this
    },
    decompose: function() {
        var a = new module$node_modules$three$build$three.default.Vector3,
            b = new module$node_modules$three$build$three.default.Matrix4;
        return function(c, d, e) {
            var f = this.elements,
                g = a.set(f[0], f[1], f[2]).length(),
                h = a.set(f[4], f[5], f[6]).length(),
                k = a.set(f[8], f[9], f[10]).length();
            0 > this.determinant() && (g = -g);
            c.x = f[12];
            c.y = f[13];
            c.z = f[14];
            b.copy(this);
            c = 1 / g;
            f = 1 / h;
            var l = 1 / k;
            b.elements[0] *= c;
            b.elements[1] *= c;
            b.elements[2] *= c;
            b.elements[4] *= f;
            b.elements[5] *= f;
            b.elements[6] *= f;
            b.elements[8] *= l;
            b.elements[9] *= l;
            b.elements[10] *= l;
            d.setFromRotationMatrix(b);
            e.x = g;
            e.y = h;
            e.z = k;
            return this
        }
    }(),
    makePerspective: function(a, b, c, d, e, f) {
        void 0 === f && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
        var g = this.elements;
        g[0] = 2 * e / (b - a);
        g[4] = 0;
        g[8] = (b + a) / (b - a);
        g[12] = 0;
        g[1] = 0;
        g[5] = 2 * e / (c - d);
        g[9] = (c + d) / (c - d);
        g[13] = 0;
        g[2] = 0;
        g[6] = 0;
        g[10] = -(f + e) / (f - e);
        g[14] = -2 * f * e / (f - e);
        g[3] = 0;
        g[7] = 0;
        g[11] = -1;
        g[15] = 0;
        return this
    },
    makeOrthographic: function(a, b, c, d, e, f) {
        var g = this.elements,
            h = 1 / (b - a),
            k = 1 / (c - d),
            l = 1 / (f - e);
        g[0] = 2 * h;
        g[4] = 0;
        g[8] = 0;
        g[12] = -((b + a) *
            h);
        g[1] = 0;
        g[5] = 2 * k;
        g[9] = 0;
        g[13] = -((c + d) * k);
        g[2] = 0;
        g[6] = 0;
        g[10] = -2 * l;
        g[14] = -((f + e) * l);
        g[3] = 0;
        g[7] = 0;
        g[11] = 0;
        g[15] = 1;
        return this
    },
    equals: function(a) {
        var b = this.elements;
        a = a.elements;
        for (var c = 0; 16 > c; c++)
            if (b[c] !== a[c]) return !1;
        return !0
    },
    fromArray: function(a, b) {
        void 0 === b && (b = 0);
        for (var c = 0; 16 > c; c++) this.elements[c] = a[c + b];
        return this
    },
    toArray: function(a, b) {
        void 0 === a && (a = []);
        void 0 === b && (b = 0);
        var c = this.elements;
        a[b] = c[0];
        a[b + 1] = c[1];
        a[b + 2] = c[2];
        a[b + 3] = c[3];
        a[b + 4] = c[4];
        a[b + 5] = c[5];
        a[b + 6] = c[6];
        a[b + 7] =
            c[7];
        a[b + 8] = c[8];
        a[b + 9] = c[9];
        a[b + 10] = c[10];
        a[b + 11] = c[11];
        a[b + 12] = c[12];
        a[b + 13] = c[13];
        a[b + 14] = c[14];
        a[b + 15] = c[15];
        return a
    }
});
Object.assign(module$node_modules$three$build$three.default.Quaternion, {
    slerp: function(a, b, c, d) {
        return c.copy(a).slerp(b, d)
    },
    slerpFlat: function(a, b, c, d, e, f, g) {
        var h = c[d + 0],
            k = c[d + 1],
            l = c[d + 2];
        c = c[d + 3];
        d = e[f + 0];
        var p = e[f + 1],
            m = e[f + 2];
        e = e[f + 3];
        if (c !== e || h !== d || k !== p || l !== m) {
            f = 1 - g;
            var q = h * d + k * p + l * m + c * e,
                r = 0 <= q ? 1 : -1,
                n = 1 - q * q;
            n > Number.EPSILON && (n = Math.sqrt(n), q = Math.atan2(n, q * r), f = Math.sin(f * q) / n, g = Math.sin(g * q) / n);
            r *= g;
            h = h * f + d * r;
            k = k * f + p * r;
            l = l * f + m * r;
            c = c * f + e * r;
            f === 1 - g && (g = 1 / Math.sqrt(h * h + k * k + l * l + c * c), h *= g, k *=
                g, l *= g, c *= g)
        }
        a[b] = h;
        a[b + 1] = k;
        a[b + 2] = l;
        a[b + 3] = c
    }
});
Object.defineProperties(module$node_modules$three$build$three.default.Quaternion.prototype, {
    x: {
        get: function() {
            return this._x
        },
        set: function(a) {
            this._x = a;
            this.onChangeCallback()
        }
    },
    y: {
        get: function() {
            return this._y
        },
        set: function(a) {
            this._y = a;
            this.onChangeCallback()
        }
    },
    z: {
        get: function() {
            return this._z
        },
        set: function(a) {
            this._z = a;
            this.onChangeCallback()
        }
    },
    w: {
        get: function() {
            return this._w
        },
        set: function(a) {
            this._w = a;
            this.onChangeCallback()
        }
    }
});
Object.assign(module$node_modules$three$build$three.default.Quaternion.prototype, {
    set: function(a, b, c, d) {
        this._x = a;
        this._y = b;
        this._z = c;
        this._w = d;
        this.onChangeCallback();
        return this
    },
    clone: function() {
        return new this.constructor(this._x, this._y, this._z, this._w)
    },
    copy: function(a) {
        this._x = a.x;
        this._y = a.y;
        this._z = a.z;
        this._w = a.w;
        this.onChangeCallback();
        return this
    },
    setFromEuler: function(a, b) {
        if (!a || !a.isEuler) throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
        var c = a._x,
            d = a._y,
            e = a._z;
        a = a.order;
        var f = Math.cos,
            g = Math.sin,
            h = f(c / 2),
            k = f(d / 2);
        f = f(e / 2);
        c = g(c / 2);
        d = g(d / 2);
        e = g(e / 2);
        "XYZ" === a ? (this._x = c * k * f + h * d * e, this._y = h * d * f - c * k * e, this._z = h * k * e + c * d * f, this._w = h * k * f - c * d * e) : "YXZ" === a ? (this._x = c * k * f + h * d * e, this._y = h * d * f - c * k * e, this._z = h * k * e - c * d * f, this._w = h * k * f + c * d * e) : "ZXY" === a ? (this._x = c * k * f - h * d * e, this._y = h * d * f + c * k * e, this._z = h * k * e + c * d * f, this._w = h * k * f - c * d * e) : "ZYX" === a ? (this._x = c * k * f - h * d * e, this._y = h * d * f + c * k * e, this._z = h * k * e - c * d * f, this._w = h * k * f + c * d * e) : "YZX" === a ? (this._x =
            c * k * f + h * d * e, this._y = h * d * f + c * k * e, this._z = h * k * e - c * d * f, this._w = h * k * f - c * d * e) : "XZY" === a && (this._x = c * k * f - h * d * e, this._y = h * d * f - c * k * e, this._z = h * k * e + c * d * f, this._w = h * k * f + c * d * e);
        if (!1 !== b) this.onChangeCallback();
        return this
    },
    setFromAxisAngle: function(a, b) {
        b /= 2;
        var c = Math.sin(b);
        this._x = a.x * c;
        this._y = a.y * c;
        this._z = a.z * c;
        this._w = Math.cos(b);
        this.onChangeCallback();
        return this
    },
    setFromRotationMatrix: function(a) {
        var b = a.elements,
            c = b[0];
        a = b[4];
        var d = b[8],
            e = b[1],
            f = b[5],
            g = b[9],
            h = b[2],
            k = b[6];
        b = b[10];
        var l = c + f + b;
        0 < l ?
            (c = .5 / Math.sqrt(l + 1), this._w = .25 / c, this._x = (k - g) * c, this._y = (d - h) * c, this._z = (e - a) * c) : c > f && c > b ? (c = 2 * Math.sqrt(1 + c - f - b), this._w = (k - g) / c, this._x = .25 * c, this._y = (a + e) / c, this._z = (d + h) / c) : f > b ? (c = 2 * Math.sqrt(1 + f - c - b), this._w = (d - h) / c, this._x = (a + e) / c, this._y = .25 * c, this._z = (g + k) / c) : (c = 2 * Math.sqrt(1 + b - c - f), this._w = (e - a) / c, this._x = (d + h) / c, this._y = (g + k) / c, this._z = .25 * c);
        this.onChangeCallback();
        return this
    },
    setFromUnitVectors: function() {
        var a = new module$node_modules$three$build$three.default.Vector3,
            b;
        return function(c,
            d) {
            void 0 === a && (a = new module$node_modules$three$build$three.default.Vector3);
            b = c.dot(d) + 1;
            1E-6 > b ? (b = 0, Math.abs(c.x) > Math.abs(c.z) ? a.set(-c.y, c.x, 0) : a.set(0, -c.z, c.y)) : a.crossVectors(c, d);
            this._x = a.x;
            this._y = a.y;
            this._z = a.z;
            this._w = b;
            return this.normalize()
        }
    }(),
    angleTo: function(a) {
        return 2 * Math.acos(Math.abs(module$node_modules$three$build$three.default.Math.clamp(this.dot(a), -1, 1)))
    },
    rotateTowards: function(a, b) {
        var c = this.angleTo(a);
        if (0 === c) return this;
        this.slerp(a, Math.min(1, b / c));
        return this
    },
    inverse: function() {
        return this.conjugate()
    },
    conjugate: function() {
        this._x *= -1;
        this._y *= -1;
        this._z *= -1;
        this.onChangeCallback();
        return this
    },
    dot: function(a) {
        return this._x * a._x + this._y * a._y + this._z * a._z + this._w * a._w
    },
    lengthSq: function() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    },
    length: function() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    },
    normalize: function() {
        var a = this.length();
        0 === a ? (this._z = this._y = this._x = 0, this._w = 1) : (a = 1 / a, this._x *=
            a, this._y *= a, this._z *= a, this._w *= a);
        this.onChangeCallback();
        return this
    },
    multiply: function(a, b) {
        return void 0 !== b ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a)
    },
    premultiply: function(a) {
        return this.multiplyQuaternions(a, this)
    },
    multiplyQuaternions: function(a, b) {
        var c = a._x,
            d = a._y,
            e = a._z;
        a = a._w;
        var f = b._x,
            g = b._y,
            h = b._z;
        b = b._w;
        this._x = c * b + a * f + d * h - e * g;
        this._y = d * b + a * g +
            e * f - c * h;
        this._z = e * b + a * h + c * g - d * f;
        this._w = a * b - c * f - d * g - e * h;
        this.onChangeCallback();
        return this
    },
    slerp: function(a, b) {
        if (0 === b) return this;
        if (1 === b) return this.copy(a);
        var c = this._x,
            d = this._y,
            e = this._z,
            f = this._w,
            g = f * a._w + c * a._x + d * a._y + e * a._z;
        0 > g ? (this._w = -a._w, this._x = -a._x, this._y = -a._y, this._z = -a._z, g = -g) : this.copy(a);
        if (1 <= g) return this._w = f, this._x = c, this._y = d, this._z = e, this;
        a = 1 - g * g;
        if (a <= Number.EPSILON) return g = 1 - b, this._w = g * f + b * this._w, this._x = g * c + b * this._x, this._y = g * d + b * this._y, this._z = g * e + b * this._z,
            this.normalize();
        a = Math.sqrt(a);
        var h = Math.atan2(a, g);
        g = Math.sin((1 - b) * h) / a;
        b = Math.sin(b * h) / a;
        this._w = f * g + this._w * b;
        this._x = c * g + this._x * b;
        this._y = d * g + this._y * b;
        this._z = e * g + this._z * b;
        this.onChangeCallback();
        return this
    },
    equals: function(a) {
        return a._x === this._x && a._y === this._y && a._z === this._z && a._w === this._w
    },
    fromArray: function(a, b) {
        void 0 === b && (b = 0);
        this._x = a[b];
        this._y = a[b + 1];
        this._z = a[b + 2];
        this._w = a[b + 3];
        this.onChangeCallback();
        return this
    },
    toArray: function(a, b) {
        void 0 === a && (a = []);
        void 0 === b && (b =
            0);
        a[b] = this._x;
        a[b + 1] = this._y;
        a[b + 2] = this._z;
        a[b + 3] = this._w;
        return a
    },
    onChange: function(a) {
        this.onChangeCallback = a;
        return this
    },
    onChangeCallback: function() {}
});
Object.assign(module$node_modules$three$build$three.default.Vector3.prototype, {
    isVector3: !0,
    set: function(a, b, c) {
        this.x = a;
        this.y = b;
        this.z = c;
        return this
    },
    setScalar: function(a) {
        this.z = this.y = this.x = a;
        return this
    },
    setX: function(a) {
        this.x = a;
        return this
    },
    setY: function(a) {
        this.y = a;
        return this
    },
    setZ: function(a) {
        this.z = a;
        return this
    },
    setComponent: function(a, b) {
        switch (a) {
            case 0:
                this.x = b;
                break;
            case 1:
                this.y = b;
                break;
            case 2:
                this.z = b;
                break;
            default:
                throw Error("index is out of range: " + a);
        }
        return this
    },
    getComponent: function(a) {
        switch (a) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw Error("index is out of range: " + a);
        }
    },
    clone: function() {
        return new this.constructor(this.x, this.y, this.z)
    },
    copy: function(a) {
        this.x = a.x;
        this.y = a.y;
        this.z = a.z;
        return this
    },
    add: function(a, b) {
        if (void 0 !== b) return console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
        this.x += a.x;
        this.y += a.y;
        this.z += a.z;
        return this
    },
    addScalar: function(a) {
        this.x += a;
        this.y += a;
        this.z += a;
        return this
    },
    addVectors: function(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        return this
    },
    addScaledVector: function(a, b) {
        this.x += a.x * b;
        this.y += a.y * b;
        this.z += a.z * b;
        return this
    },
    sub: function(a, b) {
        if (void 0 !== b) return console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
        this.x -= a.x;
        this.y -= a.y;
        this.z -= a.z;
        return this
    },
    subScalar: function(a) {
        this.x -= a;
        this.y -= a;
        this.z -= a;
        return this
    },
    subVectors: function(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z =
            a.z - b.z;
        return this
    },
    multiply: function(a, b) {
        if (void 0 !== b) return console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(a, b);
        this.x *= a.x;
        this.y *= a.y;
        this.z *= a.z;
        return this
    },
    multiplyScalar: function(a) {
        this.x *= a;
        this.y *= a;
        this.z *= a;
        return this
    },
    multiplyVectors: function(a, b) {
        this.x = a.x * b.x;
        this.y = a.y * b.y;
        this.z = a.z * b.z;
        return this
    },
    applyEuler: function() {
        var a = new module$node_modules$three$build$three.default.Quaternion;
        return function(b) {
            b &&
                b.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
            return this.applyQuaternion(a.setFromEuler(b))
        }
    }(),
    applyAxisAngle: function() {
        var a = new module$node_modules$three$build$three.default.Quaternion;
        return function(b, c) {
            return this.applyQuaternion(a.setFromAxisAngle(b, c))
        }
    }(),
    applyMatrix3: function(a) {
        var b = this.x,
            c = this.y,
            d = this.z;
        a = a.elements;
        this.x = a[0] * b + a[3] * c + a[6] * d;
        this.y = a[1] * b + a[4] * c + a[7] * d;
        this.z = a[2] * b + a[5] * c + a[8] * d;
        return this
    },
    applyMatrix4: function(a) {
        var b = this.x,
            c = this.y,
            d = this.z;
        a = a.elements;
        var e = 1 / (a[3] * b + a[7] * c + a[11] * d + a[15]);
        this.x = (a[0] * b + a[4] * c + a[8] * d + a[12]) * e;
        this.y = (a[1] * b + a[5] * c + a[9] * d + a[13]) * e;
        this.z = (a[2] * b + a[6] * c + a[10] * d + a[14]) * e;
        return this
    },
    applyQuaternion: function(a) {
        var b = this.x,
            c = this.y,
            d = this.z,
            e = a.x,
            f = a.y,
            g = a.z;
        a = a.w;
        var h = a * b + f * d - g * c,
            k = a * c + g * b - e * d,
            l = a * d + e * c - f * b;
        b = -e * b - f * c - g * d;
        this.x = h * a + b * -e + k * -g - l * -f;
        this.y = k * a + b * -f + l * -e - h * -g;
        this.z = l * a + b * -g + h * -f - k * -e;
        return this
    },
    project: function() {
        var a = new module$node_modules$three$build$three.default.Matrix4;
        return function(b) {
            a.multiplyMatrices(b.projectionMatrix, a.getInverse(b.matrixWorld));
            return this.applyMatrix4(a)
        }
    }(),
    unproject: function() {
        var a = new module$node_modules$three$build$three.default.Matrix4;
        return function(b) {
            a.multiplyMatrices(b.matrixWorld, a.getInverse(b.projectionMatrix));
            return this.applyMatrix4(a)
        }
    }(),
    transformDirection: function(a) {
        var b = this.x,
            c = this.y,
            d = this.z;
        a = a.elements;
        this.x = a[0] * b + a[4] * c + a[8] * d;
        this.y = a[1] * b + a[5] * c + a[9] * d;
        this.z = a[2] * b + a[6] * c + a[10] * d;
        return this.normalize()
    },
    divide: function(a) {
        this.x /= a.x;
        this.y /= a.y;
        this.z /= a.z;
        return this
    },
    divideScalar: function(a) {
        return this.multiplyScalar(1 / a)
    },
    min: function(a) {
        this.x = Math.min(this.x, a.x);
        this.y = Math.min(this.y, a.y);
        this.z = Math.min(this.z, a.z);
        return this
    },
    max: function(a) {
        this.x = Math.max(this.x, a.x);
        this.y = Math.max(this.y, a.y);
        this.z = Math.max(this.z, a.z);
        return this
    },
    clamp: function(a, b) {
        this.x = Math.max(a.x, Math.min(b.x, this.x));
        this.y = Math.max(a.y, Math.min(b.y, this.y));
        this.z = Math.max(a.z, Math.min(b.z, this.z));
        return this
    },
    clampScalar: function() {
        var a = new module$node_modules$three$build$three.default.Vector3,
            b = new module$node_modules$three$build$three.default.Vector3;
        return function(c, d) {
            a.set(c, c, c);
            b.set(d, d, d);
            return this.clamp(a, b)
        }
    }(),
    clampLength: function(a, b) {
        var c = this.length();
        return this.divideScalar(c || 1).multiplyScalar(Math.max(a, Math.min(b, c)))
    },
    floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        return this
    },
    ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        return this
    },
    round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        return this
    },
    roundToZero: function() {
        this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
        return this
    },
    negate: function() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this
    },
    dot: function(a) {
        return this.x * a.x + this.y * a.y + this.z * a.z
    },
    lengthSq: function() {
        return this.x *
            this.x + this.y * this.y + this.z * this.z
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    },
    manhattanLength: function() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    },
    normalize: function() {
        return this.divideScalar(this.length() || 1)
    },
    setLength: function(a) {
        return this.normalize().multiplyScalar(a)
    },
    lerp: function(a, b) {
        this.x += (a.x - this.x) * b;
        this.y += (a.y - this.y) * b;
        this.z += (a.z - this.z) * b;
        return this
    },
    lerpVectors: function(a, b, c) {
        return this.subVectors(b, a).multiplyScalar(c).add(a)
    },
    cross: function(a, b) {
        return void 0 !== b ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(a, b)) : this.crossVectors(this, a)
    },
    crossVectors: function(a, b) {
        var c = a.x,
            d = a.y;
        a = a.z;
        var e = b.x,
            f = b.y;
        b = b.z;
        this.x = d * b - a * f;
        this.y = a * e - c * b;
        this.z = c * f - d * e;
        return this
    },
    projectOnVector: function(a) {
        var b = a.dot(this) / a.lengthSq();
        return this.copy(a).multiplyScalar(b)
    },
    projectOnPlane: function() {
        var a = new module$node_modules$three$build$three.default.Vector3;
        return function(b) {
            a.copy(this).projectOnVector(b);
            return this.sub(a)
        }
    }(),
    reflect: function() {
        var a = new module$node_modules$three$build$three.default.Vector3;
        return function(b) {
            return this.sub(a.copy(b).multiplyScalar(2 * this.dot(b)))
        }
    }(),
    angleTo: function(a) {
        a = this.dot(a) / Math.sqrt(this.lengthSq() * a.lengthSq());
        return Math.acos(module$node_modules$three$build$three.default.Math.clamp(a, -1, 1))
    },
    distanceTo: function(a) {
        return Math.sqrt(this.distanceToSquared(a))
    },
    distanceToSquared: function(a) {
        var b = this.x -
            a.x,
            c = this.y - a.y;
        a = this.z - a.z;
        return b * b + c * c + a * a
    },
    manhattanDistanceTo: function(a) {
        return Math.abs(this.x - a.x) + Math.abs(this.y - a.y) + Math.abs(this.z - a.z)
    },
    setFromSpherical: function(a) {
        var b = Math.sin(a.phi) * a.radius;
        this.x = b * Math.sin(a.theta);
        this.y = Math.cos(a.phi) * a.radius;
        this.z = b * Math.cos(a.theta);
        return this
    },
    setFromCylindrical: function(a) {
        this.x = a.radius * Math.sin(a.theta);
        this.y = a.y;
        this.z = a.radius * Math.cos(a.theta);
        return this
    },
    setFromMatrixPosition: function(a) {
        a = a.elements;
        this.x = a[12];
        this.y =
            a[13];
        this.z = a[14];
        return this
    },
    setFromMatrixScale: function(a) {
        var b = this.setFromMatrixColumn(a, 0).length(),
            c = this.setFromMatrixColumn(a, 1).length();
        a = this.setFromMatrixColumn(a, 2).length();
        this.x = b;
        this.y = c;
        this.z = a;
        return this
    },
    setFromMatrixColumn: function(a, b) {
        return this.fromArray(a.elements, 4 * b)
    },
    equals: function(a) {
        return a.x === this.x && a.y === this.y && a.z === this.z
    },
    fromArray: function(a, b) {
        void 0 === b && (b = 0);
        this.x = a[b];
        this.y = a[b + 1];
        this.z = a[b + 2];
        return this
    },
    toArray: function(a, b) {
        void 0 === a && (a = []);
        void 0 === b && (b = 0);
        a[b] = this.x;
        a[b + 1] = this.y;
        a[b + 2] = this.z;
        return a
    },
    fromBufferAttribute: function(a, b, c) {
        void 0 !== c && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
        this.x = a.getX(b);
        this.y = a.getY(b);
        this.z = a.getZ(b);
        return this
    }
});
Object.assign(module$node_modules$three$build$three.default.Matrix3.prototype, {
    isMatrix3: !0,
    set: function(a, b, c, d, e, f, g, h, k) {
        var l = this.elements;
        l[0] = a;
        l[1] = d;
        l[2] = g;
        l[3] = b;
        l[4] = e;
        l[5] = h;
        l[6] = c;
        l[7] = f;
        l[8] = k;
        return this
    },
    identity: function() {
        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
        return this
    },
    clone: function() {
        return (new this.constructor).fromArray(this.elements)
    },
    copy: function(a) {
        var b = this.elements;
        a = a.elements;
        b[0] = a[0];
        b[1] = a[1];
        b[2] = a[2];
        b[3] = a[3];
        b[4] = a[4];
        b[5] = a[5];
        b[6] = a[6];
        b[7] = a[7];
        b[8] = a[8];
        return this
    },
    setFromMatrix4: function(a) {
        a = a.elements;
        this.set(a[0], a[4], a[8], a[1], a[5], a[9], a[2], a[6], a[10]);
        return this
    },
    applyToBufferAttribute: function() {
        var a = new module$node_modules$three$build$three.default.Vector3;
        return function(b) {
            for (var c = 0, d = b.count; c < d; c++) a.x = b.getX(c), a.y = b.getY(c), a.z = b.getZ(c), a.applyMatrix3(this), b.setXYZ(c, a.x, a.y, a.z);
            return b
        }
    }(),
    multiply: function(a) {
        return this.multiplyMatrices(this, a)
    },
    premultiply: function(a) {
        return this.multiplyMatrices(a, this)
    },
    multiplyMatrices: function(a,
        b) {
        var c = a.elements,
            d = b.elements;
        b = this.elements;
        a = c[0];
        var e = c[3],
            f = c[6],
            g = c[1],
            h = c[4],
            k = c[7],
            l = c[2],
            p = c[5];
        c = c[8];
        var m = d[0],
            q = d[3],
            r = d[6],
            n = d[1],
            t = d[4],
            u = d[7],
            w = d[2],
            v = d[5];
        d = d[8];
        b[0] = a * m + e * n + f * w;
        b[3] = a * q + e * t + f * v;
        b[6] = a * r + e * u + f * d;
        b[1] = g * m + h * n + k * w;
        b[4] = g * q + h * t + k * v;
        b[7] = g * r + h * u + k * d;
        b[2] = l * m + p * n + c * w;
        b[5] = l * q + p * t + c * v;
        b[8] = l * r + p * u + c * d;
        return this
    },
    multiplyScalar: function(a) {
        var b = this.elements;
        b[0] *= a;
        b[3] *= a;
        b[6] *= a;
        b[1] *= a;
        b[4] *= a;
        b[7] *= a;
        b[2] *= a;
        b[5] *= a;
        b[8] *= a;
        return this
    },
    determinant: function() {
        var a =
            this.elements,
            b = a[0],
            c = a[1],
            d = a[2],
            e = a[3],
            f = a[4],
            g = a[5],
            h = a[6],
            k = a[7];
        a = a[8];
        return b * f * a - b * g * k - c * e * a + c * g * h + d * e * k - d * f * h
    },
    getInverse: function(a, b) {
        a && a.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
        var c = a.elements;
        a = this.elements;
        var d = c[0],
            e = c[1],
            f = c[2],
            g = c[3],
            h = c[4],
            k = c[5],
            l = c[6],
            p = c[7];
        c = c[8];
        var m = c * h - k * p,
            q = k * l - c * g,
            r = p * g - h * l,
            n = d * m + e * q + f * r;
        if (0 === n) {
            if (!0 === b) throw Error("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0");
            console.warn("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0");
            return this.identity()
        }
        b = 1 / n;
        a[0] = m * b;
        a[1] = (f * p - c * e) * b;
        a[2] = (k * e - f * h) * b;
        a[3] = q * b;
        a[4] = (c * d - f * l) * b;
        a[5] = (f * g - k * d) * b;
        a[6] = r * b;
        a[7] = (e * l - p * d) * b;
        a[8] = (h * d - e * g) * b;
        return this
    },
    transpose: function() {
        var a = this.elements;
        var b = a[1];
        a[1] = a[3];
        a[3] = b;
        b = a[2];
        a[2] = a[6];
        a[6] = b;
        b = a[5];
        a[5] = a[7];
        a[7] = b;
        return this
    },
    getNormalMatrix: function(a) {
        return this.setFromMatrix4(a).getInverse(this).transpose()
    },
    transposeIntoArray: function(a) {
        var b = this.elements;
        a[0] = b[0];
        a[1] = b[3];
        a[2] = b[6];
        a[3] = b[1];
        a[4] = b[4];
        a[5] = b[7];
        a[6] =
            b[2];
        a[7] = b[5];
        a[8] = b[8];
        return this
    },
    setUvTransform: function(a, b, c, d, e, f, g) {
        var h = Math.cos(e);
        e = Math.sin(e);
        this.set(c * h, c * e, -c * (h * f + e * g) + f + a, -d * e, d * h, -d * (-e * f + h * g) + g + b, 0, 0, 1)
    },
    scale: function(a, b) {
        var c = this.elements;
        c[0] *= a;
        c[3] *= a;
        c[6] *= a;
        c[1] *= b;
        c[4] *= b;
        c[7] *= b;
        return this
    },
    rotate: function(a) {
        var b = Math.cos(a);
        a = Math.sin(a);
        var c = this.elements,
            d = c[0],
            e = c[3],
            f = c[6],
            g = c[1],
            h = c[4],
            k = c[7];
        c[0] = b * d + a * g;
        c[3] = b * e + a * h;
        c[6] = b * f + a * k;
        c[1] = -a * d + b * g;
        c[4] = -a * e + b * h;
        c[7] = -a * f + b * k;
        return this
    },
    translate: function(a,
        b) {
        var c = this.elements;
        c[0] += a * c[2];
        c[3] += a * c[5];
        c[6] += a * c[8];
        c[1] += b * c[2];
        c[4] += b * c[5];
        c[7] += b * c[8];
        return this
    },
    equals: function(a) {
        var b = this.elements;
        a = a.elements;
        for (var c = 0; 9 > c; c++)
            if (b[c] !== a[c]) return !1;
        return !0
    },
    fromArray: function(a, b) {
        void 0 === b && (b = 0);
        for (var c = 0; 9 > c; c++) this.elements[c] = a[c + b];
        return this
    },
    toArray: function(a, b) {
        void 0 === a && (a = []);
        void 0 === b && (b = 0);
        var c = this.elements;
        a[b] = c[0];
        a[b + 1] = c[1];
        a[b + 2] = c[2];
        a[b + 3] = c[3];
        a[b + 4] = c[4];
        a[b + 5] = c[5];
        a[b + 6] = c[6];
        a[b + 7] = c[7];
        a[b + 8] = c[8];
        return a
    }
});
module$node_modules$three$build$three.default.ImageUtils = {
    getDataURL: function(a) {
        if (a instanceof HTMLCanvasElement) var b = a;
        else {
            "undefined" !== typeof OffscreenCanvas ? b = new OffscreenCanvas(a.width, a.height) : (b = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), b.width = a.width, b.height = a.height);
            var c = b.getContext("2d");
            a instanceof ImageData ? c.putImageData(a, 0, 0) : c.drawImage(a, 0, 0, a.width, a.height)
        }
        return 2048 < b.width || 2048 < b.height ? b.toDataURL("image/jpeg", .6) : b.toDataURL("image/png")
    }
};
var textureId$$module$node_modules$three$build$three = 0;
module$node_modules$three$build$three.default.Texture.DEFAULT_IMAGE = void 0;
module$node_modules$three$build$three.default.Texture.DEFAULT_MAPPING = module$node_modules$three$build$three.default.UVMapping;
module$node_modules$three$build$three.default.Texture.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.EventDispatcher.prototype), {
    constructor: module$node_modules$three$build$three.default.Texture,
    isTexture: !0,
    updateMatrix: function() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    },
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(a) {
        this.name = a.name;
        this.image = a.image;
        this.mipmaps = a.mipmaps.slice(0);
        this.mapping = a.mapping;
        this.wrapS = a.wrapS;
        this.wrapT = a.wrapT;
        this.magFilter = a.magFilter;
        this.minFilter = a.minFilter;
        this.anisotropy = a.anisotropy;
        this.format = a.format;
        this.type = a.type;
        this.offset.copy(a.offset);
        this.repeat.copy(a.repeat);
        this.center.copy(a.center);
        this.rotation = a.rotation;
        this.matrixAutoUpdate = a.matrixAutoUpdate;
        this.matrix.copy(a.matrix);
        this.generateMipmaps = a.generateMipmaps;
        this.premultiplyAlpha = a.premultiplyAlpha;
        this.flipY = a.flipY;
        this.unpackAlignment =
            a.unpackAlignment;
        this.encoding = a.encoding;
        return this
    },
    toJSON: function(a) {
        var b = void 0 === a || "string" === typeof a;
        if (!b && void 0 !== a.textures[this.uuid]) return a.textures[this.uuid];
        var c = {
            metadata: {
                version: 4.5,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY
        };
        if (void 0 !== this.image) {
            var d = this.image;
            void 0 === d.uuid && (d.uuid = module$node_modules$three$build$three.default.Math.generateUUID());
            if (!b && void 0 === a.images[d.uuid]) {
                if (Array.isArray(d)) {
                    var e = [];
                    for (var f = 0, g = d.length; f < g; f++) e.push(module$node_modules$three$build$three.default.ImageUtils.getDataURL(d[f]))
                } else e = module$node_modules$three$build$three.default.ImageUtils.getDataURL(d);
                a.images[d.uuid] = {
                    uuid: d.uuid,
                    url: e
                }
            }
            c.image =
                d.uuid
        }
        b || (a.textures[this.uuid] = c);
        return c
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        })
    },
    transformUv: function(a) {
        if (this.mapping === module$node_modules$three$build$three.default.UVMapping) {
            a.applyMatrix3(this.matrix);
            if (0 > a.x || 1 < a.x) switch (this.wrapS) {
                case module$node_modules$three$build$three.default.RepeatWrapping:
                    a.x -= Math.floor(a.x);
                    break;
                case module$node_modules$three$build$three.default.ClampToEdgeWrapping:
                    a.x = 0 > a.x ? 0 : 1;
                    break;
                case module$node_modules$three$build$three.default.MirroredRepeatWrapping:
                    a.x =
                        1 === Math.abs(Math.floor(a.x) % 2) ? Math.ceil(a.x) - a.x : a.x - Math.floor(a.x)
            }
            if (0 > a.y || 1 < a.y) switch (this.wrapT) {
                case module$node_modules$three$build$three.default.RepeatWrapping:
                    a.y -= Math.floor(a.y);
                    break;
                case module$node_modules$three$build$three.default.ClampToEdgeWrapping:
                    a.y = 0 > a.y ? 0 : 1;
                    break;
                case module$node_modules$three$build$three.default.MirroredRepeatWrapping:
                    a.y = 1 === Math.abs(Math.floor(a.y) % 2) ? Math.ceil(a.y) - a.y : a.y - Math.floor(a.y)
            }
            this.flipY && (a.y = 1 - a.y)
        }
    }
});
Object.defineProperty(module$node_modules$three$build$three.default.Texture.prototype, "needsUpdate", {
    set: function(a) {
        !0 === a && this.version++
    }
});
Object.assign(module$node_modules$three$build$three.default.Vector4.prototype, {
    isVector4: !0,
    set: function(a, b, c, d) {
        this.x = a;
        this.y = b;
        this.z = c;
        this.w = d;
        return this
    },
    setScalar: function(a) {
        this.w = this.z = this.y = this.x = a;
        return this
    },
    setX: function(a) {
        this.x = a;
        return this
    },
    setY: function(a) {
        this.y = a;
        return this
    },
    setZ: function(a) {
        this.z = a;
        return this
    },
    setW: function(a) {
        this.w = a;
        return this
    },
    setComponent: function(a, b) {
        switch (a) {
            case 0:
                this.x = b;
                break;
            case 1:
                this.y = b;
                break;
            case 2:
                this.z = b;
                break;
            case 3:
                this.w =
                    b;
                break;
            default:
                throw Error("index is out of range: " + a);
        }
        return this
    },
    getComponent: function(a) {
        switch (a) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw Error("index is out of range: " + a);
        }
    },
    clone: function() {
        return new this.constructor(this.x, this.y, this.z, this.w)
    },
    copy: function(a) {
        this.x = a.x;
        this.y = a.y;
        this.z = a.z;
        this.w = void 0 !== a.w ? a.w : 1;
        return this
    },
    add: function(a, b) {
        if (void 0 !== b) return console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(a, b);
        this.x += a.x;
        this.y += a.y;
        this.z += a.z;
        this.w += a.w;
        return this
    },
    addScalar: function(a) {
        this.x += a;
        this.y += a;
        this.z += a;
        this.w += a;
        return this
    },
    addVectors: function(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        this.w = a.w + b.w;
        return this
    },
    addScaledVector: function(a, b) {
        this.x += a.x * b;
        this.y += a.y * b;
        this.z += a.z * b;
        this.w += a.w * b;
        return this
    },
    sub: function(a, b) {
        if (void 0 !== b) return console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a,
            b);
        this.x -= a.x;
        this.y -= a.y;
        this.z -= a.z;
        this.w -= a.w;
        return this
    },
    subScalar: function(a) {
        this.x -= a;
        this.y -= a;
        this.z -= a;
        this.w -= a;
        return this
    },
    subVectors: function(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        this.w = a.w - b.w;
        return this
    },
    multiplyScalar: function(a) {
        this.x *= a;
        this.y *= a;
        this.z *= a;
        this.w *= a;
        return this
    },
    applyMatrix4: function(a) {
        var b = this.x,
            c = this.y,
            d = this.z,
            e = this.w;
        a = a.elements;
        this.x = a[0] * b + a[4] * c + a[8] * d + a[12] * e;
        this.y = a[1] * b + a[5] * c + a[9] * d + a[13] * e;
        this.z = a[2] * b + a[6] * c + a[10] * d + a[14] *
            e;
        this.w = a[3] * b + a[7] * c + a[11] * d + a[15] * e;
        return this
    },
    divideScalar: function(a) {
        return this.multiplyScalar(1 / a)
    },
    setAxisAngleFromQuaternion: function(a) {
        this.w = 2 * Math.acos(a.w);
        var b = Math.sqrt(1 - a.w * a.w);
        1E-4 > b ? (this.x = 1, this.z = this.y = 0) : (this.x = a.x / b, this.y = a.y / b, this.z = a.z / b);
        return this
    },
    setAxisAngleFromRotationMatrix: function(a) {
        a = a.elements;
        var b = a[0];
        var c = a[4];
        var d = a[8],
            e = a[1],
            f = a[5],
            g = a[9];
        var h = a[2];
        var k = a[6];
        var l = a[10];
        if (.01 > Math.abs(c - e) && .01 > Math.abs(d - h) && .01 > Math.abs(g - k)) {
            if (.1 > Math.abs(c +
                    e) && .1 > Math.abs(d + h) && .1 > Math.abs(g + k) && .1 > Math.abs(b + f + l - 3)) return this.set(1, 0, 0, 0), this;
            a = Math.PI;
            b = (b + 1) / 2;
            f = (f + 1) / 2;
            l = (l + 1) / 2;
            c = (c + e) / 4;
            d = (d + h) / 4;
            g = (g + k) / 4;
            b > f && b > l ? .01 > b ? (k = 0, c = h = .707106781) : (k = Math.sqrt(b), h = c / k, c = d / k) : f > l ? .01 > f ? (k = .707106781, h = 0, c = .707106781) : (h = Math.sqrt(f), k = c / h, c = g / h) : .01 > l ? (h = k = .707106781, c = 0) : (c = Math.sqrt(l), k = d / c, h = g / c);
            this.set(k, h, c, a);
            return this
        }
        a = Math.sqrt((k - g) * (k - g) + (d - h) * (d - h) + (e - c) * (e - c));.001 > Math.abs(a) && (a = 1);
        this.x = (k - g) / a;
        this.y = (d - h) / a;
        this.z = (e - c) / a;
        this.w = Math.acos((b + f + l - 1) / 2);
        return this
    },
    min: function(a) {
        this.x = Math.min(this.x, a.x);
        this.y = Math.min(this.y, a.y);
        this.z = Math.min(this.z, a.z);
        this.w = Math.min(this.w, a.w);
        return this
    },
    max: function(a) {
        this.x = Math.max(this.x, a.x);
        this.y = Math.max(this.y, a.y);
        this.z = Math.max(this.z, a.z);
        this.w = Math.max(this.w, a.w);
        return this
    },
    clamp: function(a, b) {
        this.x = Math.max(a.x, Math.min(b.x, this.x));
        this.y = Math.max(a.y, Math.min(b.y, this.y));
        this.z = Math.max(a.z, Math.min(b.z, this.z));
        this.w = Math.max(a.w, Math.min(b.w,
            this.w));
        return this
    },
    clampScalar: function() {
        var a, b;
        return function(c, d) {
            void 0 === a && (a = new module$node_modules$three$build$three.default.Vector4, b = new module$node_modules$three$build$three.default.Vector4);
            a.set(c, c, c, c);
            b.set(d, d, d, d);
            return this.clamp(a, b)
        }
    }(),
    clampLength: function(a, b) {
        var c = this.length();
        return this.divideScalar(c || 1).multiplyScalar(Math.max(a, Math.min(b, c)))
    },
    floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        this.w = Math.floor(this.w);
        return this
    },
    ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        this.w = Math.ceil(this.w);
        return this
    },
    round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        this.w = Math.round(this.w);
        return this
    },
    roundToZero: function() {
        this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
        this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w);
        return this
    },
    negate: function() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;
        return this
    },
    dot: function(a) {
        return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w
    },
    lengthSq: function() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    },
    manhattanLength: function() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    },
    normalize: function() {
        return this.divideScalar(this.length() ||
            1)
    },
    setLength: function(a) {
        return this.normalize().multiplyScalar(a)
    },
    lerp: function(a, b) {
        this.x += (a.x - this.x) * b;
        this.y += (a.y - this.y) * b;
        this.z += (a.z - this.z) * b;
        this.w += (a.w - this.w) * b;
        return this
    },
    lerpVectors: function(a, b, c) {
        return this.subVectors(b, a).multiplyScalar(c).add(a)
    },
    equals: function(a) {
        return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w
    },
    fromArray: function(a, b) {
        void 0 === b && (b = 0);
        this.x = a[b];
        this.y = a[b + 1];
        this.z = a[b + 2];
        this.w = a[b + 3];
        return this
    },
    toArray: function(a, b) {
        void 0 === a && (a = []);
        void 0 === b && (b = 0);
        a[b] = this.x;
        a[b + 1] = this.y;
        a[b + 2] = this.z;
        a[b + 3] = this.w;
        return a
    },
    fromBufferAttribute: function(a, b, c) {
        void 0 !== c && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
        this.x = a.getX(b);
        this.y = a.getY(b);
        this.z = a.getZ(b);
        this.w = a.getW(b);
        return this
    }
});
module$node_modules$three$build$three.default.WebGLRenderTarget.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.EventDispatcher.prototype), {
    constructor: module$node_modules$three$build$three.default.WebGLRenderTarget,
    isWebGLRenderTarget: !0,
    setSize: function(a, b) {
        if (this.width !== a || this.height !== b) this.width = a, this.height = b, this.dispose();
        this.viewport.set(0, 0, a, b);
        this.scissor.set(0, 0, a, b)
    },
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(a) {
        this.width =
            a.width;
        this.height = a.height;
        this.viewport.copy(a.viewport);
        this.texture = a.texture.clone();
        this.depthBuffer = a.depthBuffer;
        this.stencilBuffer = a.stencilBuffer;
        this.depthTexture = a.depthTexture;
        return this
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
});
module$node_modules$three$build$three.default.WebGLRenderTargetCube.prototype = Object.create(module$node_modules$three$build$three.default.WebGLRenderTarget.prototype);
module$node_modules$three$build$three.default.WebGLRenderTargetCube.prototype.constructor = module$node_modules$three$build$three.default.WebGLRenderTargetCube;
module$node_modules$three$build$three.default.WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = !0;
module$node_modules$three$build$three.default.DataTexture.prototype = Object.create(module$node_modules$three$build$three.default.Texture.prototype);
module$node_modules$three$build$three.default.DataTexture.prototype.constructor = module$node_modules$three$build$three.default.DataTexture;
module$node_modules$three$build$three.default.DataTexture.prototype.isDataTexture = !0;
Object.assign(module$node_modules$three$build$three.default.Box3.prototype, {
    isBox3: !0,
    set: function(a, b) {
        this.min.copy(a);
        this.max.copy(b);
        return this
    },
    setFromArray: function(a) {
        for (var b = Infinity, c = Infinity, d = Infinity, e = -Infinity, f = -Infinity, g = -Infinity, h = 0, k = a.length; h < k; h += 3) {
            var l = a[h],
                p = a[h + 1],
                m = a[h + 2];
            l < b && (b = l);
            p < c && (c = p);
            m < d && (d = m);
            l > e && (e = l);
            p > f && (f = p);
            m > g && (g = m)
        }
        this.min.set(b, c, d);
        this.max.set(e, f, g);
        return this
    },
    setFromBufferAttribute: function(a) {
        for (var b = Infinity, c = Infinity, d = Infinity,
                e = -Infinity, f = -Infinity, g = -Infinity, h = 0, k = a.count; h < k; h++) {
            var l = a.getX(h),
                p = a.getY(h),
                m = a.getZ(h);
            l < b && (b = l);
            p < c && (c = p);
            m < d && (d = m);
            l > e && (e = l);
            p > f && (f = p);
            m > g && (g = m)
        }
        this.min.set(b, c, d);
        this.max.set(e, f, g);
        return this
    },
    setFromPoints: function(a) {
        this.makeEmpty();
        for (var b = 0, c = a.length; b < c; b++) this.expandByPoint(a[b]);
        return this
    },
    setFromCenterAndSize: function() {
        var a = new module$node_modules$three$build$three.default.Vector3;
        return function(b, c) {
            c = a.copy(c).multiplyScalar(.5);
            this.min.copy(b).sub(c);
            this.max.copy(b).add(c);
            return this
        }
    }(),
    setFromObject: function(a) {
        this.makeEmpty();
        return this.expandByObject(a)
    },
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(a) {
        this.min.copy(a.min);
        this.max.copy(a.max);
        return this
    },
    makeEmpty: function() {
        this.min.x = this.min.y = this.min.z = Infinity;
        this.max.x = this.max.y = this.max.z = -Infinity;
        return this
    },
    isEmpty: function() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    },
    getCenter: function(a) {
        void 0 === a && (console.warn("THREE.Box3: .getCenter() target is now required"),
            a = new module$node_modules$three$build$three.default.Vector3);
        return this.isEmpty() ? a.set(0, 0, 0) : a.addVectors(this.min, this.max).multiplyScalar(.5)
    },
    getSize: function(a) {
        void 0 === a && (console.warn("THREE.Box3: .getSize() target is now required"), a = new module$node_modules$three$build$three.default.Vector3);
        return this.isEmpty() ? a.set(0, 0, 0) : a.subVectors(this.max, this.min)
    },
    expandByPoint: function(a) {
        this.min.min(a);
        this.max.max(a);
        return this
    },
    expandByVector: function(a) {
        this.min.sub(a);
        this.max.add(a);
        return this
    },
    expandByScalar: function(a) {
        this.min.addScalar(-a);
        this.max.addScalar(a);
        return this
    },
    expandByObject: function() {
        function a(a) {
            var f = a.geometry;
            if (void 0 !== f)
                if (f.isGeometry)
                    for (f = f.vertices, c = 0, d = f.length; c < d; c++) e.copy(f[c]), e.applyMatrix4(a.matrixWorld), b.expandByPoint(e);
                else if (f.isBufferGeometry && (f = f.attributes.position, void 0 !== f))
                for (c = 0, d = f.count; c < d; c++) e.fromBufferAttribute(f, c).applyMatrix4(a.matrixWorld), b.expandByPoint(e)
        }
        var b, c, d, e = new module$node_modules$three$build$three.default.Vector3;
        return function(c) {
            b = this;
            c.updateMatrixWorld(!0);
            c.traverse(a);
            return this
        }
    }(),
    containsPoint: function(a) {
        return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y || a.z < this.min.z || a.z > this.max.z ? !1 : !0
    },
    containsBox: function(a) {
        return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z && a.max.z <= this.max.z
    },
    getParameter: function(a, b) {
        void 0 === b && (console.warn("THREE.Box3: .getParameter() target is now required"), b = new module$node_modules$three$build$three.default.Vector3);
        return b.set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z - this.min.z) / (this.max.z - this.min.z))
    },
    intersectsBox: function(a) {
        return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max.z < this.min.z || a.min.z > this.max.z ? !1 : !0
    },
    intersectsSphere: function() {
        var a = new module$node_modules$three$build$three.default.Vector3;
        return function(b) {
            this.clampPoint(b.center, a);
            return a.distanceToSquared(b.center) <= b.radius * b.radius
        }
    }(),
    intersectsPlane: function(a) {
        if (0 <
            a.normal.x) {
            var b = a.normal.x * this.min.x;
            var c = a.normal.x * this.max.x
        } else b = a.normal.x * this.max.x, c = a.normal.x * this.min.x;
        0 < a.normal.y ? (b += a.normal.y * this.min.y, c += a.normal.y * this.max.y) : (b += a.normal.y * this.max.y, c += a.normal.y * this.min.y);
        0 < a.normal.z ? (b += a.normal.z * this.min.z, c += a.normal.z * this.max.z) : (b += a.normal.z * this.max.z, c += a.normal.z * this.min.z);
        return b <= a.constant && c >= a.constant
    },
    intersectsTriangle: function() {
        function a(a) {
            var e;
            var f = 0;
            for (e = a.length - 3; f <= e; f += 3) {
                h.fromArray(a, f);
                var g =
                    l.x * Math.abs(h.x) + l.y * Math.abs(h.y) + l.z * Math.abs(h.z),
                    k = b.dot(h),
                    m = c.dot(h),
                    p = d.dot(h);
                if (Math.max(-Math.max(k, m, p), Math.min(k, m, p)) > g) return !1
            }
            return !0
        }
        var b = new module$node_modules$three$build$three.default.Vector3,
            c = new module$node_modules$three$build$three.default.Vector3,
            d = new module$node_modules$three$build$three.default.Vector3,
            e = new module$node_modules$three$build$three.default.Vector3,
            f = new module$node_modules$three$build$three.default.Vector3,
            g = new module$node_modules$three$build$three.default.Vector3,
            h = new module$node_modules$three$build$three.default.Vector3,
            k = new module$node_modules$three$build$three.default.Vector3,
            l = new module$node_modules$three$build$three.default.Vector3,
            p = new module$node_modules$three$build$three.default.Vector3;
        return function(h) {
            if (this.isEmpty()) return !1;
            this.getCenter(k);
            l.subVectors(this.max, k);
            b.subVectors(h.a, k);
            c.subVectors(h.b, k);
            d.subVectors(h.c, k);
            e.subVectors(c, b);
            f.subVectors(d, c);
            g.subVectors(b, d);
            h = [0, -e.z, e.y, 0, -f.z, f.y, 0, -g.z, g.y, e.z, 0, -e.x, f.z, 0, -f.x,
                g.z, 0, -g.x, -e.y, e.x, 0, -f.y, f.x, 0, -g.y, g.x, 0
            ];
            if (!a(h)) return !1;
            h = [1, 0, 0, 0, 1, 0, 0, 0, 1];
            if (!a(h)) return !1;
            p.crossVectors(e, f);
            h = [p.x, p.y, p.z];
            return a(h)
        }
    }(),
    clampPoint: function(a, b) {
        void 0 === b && (console.warn("THREE.Box3: .clampPoint() target is now required"), b = new module$node_modules$three$build$three.default.Vector3);
        return b.copy(a).clamp(this.min, this.max)
    },
    distanceToPoint: function() {
        var a = new module$node_modules$three$build$three.default.Vector3;
        return function(b) {
            return a.copy(b).clamp(this.min,
                this.max).sub(b).length()
        }
    }(),
    getBoundingSphere: function() {
        var a = new module$node_modules$three$build$three.default.Vector3;
        return function(b) {
            void 0 === b && (console.warn("THREE.Box3: .getBoundingSphere() target is now required"), b = new module$node_modules$three$build$three.default.Sphere);
            this.getCenter(b.center);
            b.radius = .5 * this.getSize(a).length();
            return b
        }
    }(),
    intersect: function(a) {
        this.min.max(a.min);
        this.max.min(a.max);
        this.isEmpty() && this.makeEmpty();
        return this
    },
    union: function(a) {
        this.min.min(a.min);
        this.max.max(a.max);
        return this
    },
    applyMatrix4: function(a) {
        if (this.isEmpty()) return this;
        a = a.elements;
        var b = a[0] * this.min.x,
            c = a[1] * this.min.x,
            d = a[2] * this.min.x,
            e = a[0] * this.max.x,
            f = a[1] * this.max.x,
            g = a[2] * this.max.x,
            h = a[4] * this.min.y,
            k = a[5] * this.min.y,
            l = a[6] * this.min.y,
            p = a[4] * this.max.y,
            m = a[5] * this.max.y,
            q = a[6] * this.max.y,
            r = a[8] * this.min.z,
            n = a[9] * this.min.z,
            t = a[10] * this.min.z,
            u = a[8] * this.max.z,
            w = a[9] * this.max.z,
            v = a[10] * this.max.z;
        this.min.x = Math.min(b, e) + Math.min(h, p) + Math.min(r, u) + a[12];
        this.min.y =
            Math.min(c, f) + Math.min(k, m) + Math.min(n, w) + a[13];
        this.min.z = Math.min(d, g) + Math.min(l, q) + Math.min(t, v) + a[14];
        this.max.x = Math.max(b, e) + Math.max(h, p) + Math.max(r, u) + a[12];
        this.max.y = Math.max(c, f) + Math.max(k, m) + Math.max(n, w) + a[13];
        this.max.z = Math.max(d, g) + Math.max(l, q) + Math.max(t, v) + a[14];
        return this
    },
    translate: function(a) {
        this.min.add(a);
        this.max.add(a);
        return this
    },
    equals: function(a) {
        return a.min.equals(this.min) && a.max.equals(this.max)
    }
});
Object.assign(module$node_modules$three$build$three.default.Sphere.prototype, {
    set: function(a, b) {
        this.center.copy(a);
        this.radius = b;
        return this
    },
    setFromPoints: function() {
        var a = new module$node_modules$three$build$three.default.Box3;
        return function(b, c) {
            var d = this.center;
            void 0 !== c ? d.copy(c) : a.setFromPoints(b).getCenter(d);
            for (var e = c = 0, f = b.length; e < f; e++) c = Math.max(c, d.distanceToSquared(b[e]));
            this.radius = Math.sqrt(c);
            return this
        }
    }(),
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(a) {
        this.center.copy(a.center);
        this.radius = a.radius;
        return this
    },
    empty: function() {
        return 0 >= this.radius
    },
    containsPoint: function(a) {
        return a.distanceToSquared(this.center) <= this.radius * this.radius
    },
    distanceToPoint: function(a) {
        return a.distanceTo(this.center) - this.radius
    },
    intersectsSphere: function(a) {
        var b = this.radius + a.radius;
        return a.center.distanceToSquared(this.center) <= b * b
    },
    intersectsBox: function(a) {
        return a.intersectsSphere(this)
    },
    intersectsPlane: function(a) {
        return Math.abs(a.distanceToPoint(this.center)) <= this.radius
    },
    clampPoint: function(a,
        b) {
        var c = this.center.distanceToSquared(a);
        void 0 === b && (console.warn("THREE.Sphere: .clampPoint() target is now required"), b = new module$node_modules$three$build$three.default.Vector3);
        b.copy(a);
        c > this.radius * this.radius && (b.sub(this.center).normalize(), b.multiplyScalar(this.radius).add(this.center));
        return b
    },
    getBoundingBox: function(a) {
        void 0 === a && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), a = new module$node_modules$three$build$three.default.Box3);
        a.set(this.center, this.center);
        a.expandByScalar(this.radius);
        return a
    },
    applyMatrix4: function(a) {
        this.center.applyMatrix4(a);
        this.radius *= a.getMaxScaleOnAxis();
        return this
    },
    translate: function(a) {
        this.center.add(a);
        return this
    },
    equals: function(a) {
        return a.center.equals(this.center) && a.radius === this.radius
    }
});
Object.assign(module$node_modules$three$build$three.default.Plane.prototype, {
    set: function(a, b) {
        this.normal.copy(a);
        this.constant = b;
        return this
    },
    setComponents: function(a, b, c, d) {
        this.normal.set(a, b, c);
        this.constant = d;
        return this
    },
    setFromNormalAndCoplanarPoint: function(a, b) {
        this.normal.copy(a);
        this.constant = -b.dot(this.normal);
        return this
    },
    setFromCoplanarPoints: function() {
        var a = new module$node_modules$three$build$three.default.Vector3,
            b = new module$node_modules$three$build$three.default.Vector3;
        return function(c,
            d, e) {
            d = a.subVectors(e, d).cross(b.subVectors(c, d)).normalize();
            this.setFromNormalAndCoplanarPoint(d, c);
            return this
        }
    }(),
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(a) {
        this.normal.copy(a.normal);
        this.constant = a.constant;
        return this
    },
    normalize: function() {
        var a = 1 / this.normal.length();
        this.normal.multiplyScalar(a);
        this.constant *= a;
        return this
    },
    negate: function() {
        this.constant *= -1;
        this.normal.negate();
        return this
    },
    distanceToPoint: function(a) {
        return this.normal.dot(a) + this.constant
    },
    distanceToSphere: function(a) {
        return this.distanceToPoint(a.center) - a.radius
    },
    projectPoint: function(a, b) {
        void 0 === b && (console.warn("THREE.Plane: .projectPoint() target is now required"), b = new module$node_modules$three$build$three.default.Vector3);
        return b.copy(this.normal).multiplyScalar(-this.distanceToPoint(a)).add(a)
    },
    intersectLine: function() {
        var a = new module$node_modules$three$build$three.default.Vector3;
        return function(b, c) {
            void 0 === c && (console.warn("THREE.Plane: .intersectLine() target is now required"),
                c = new module$node_modules$three$build$three.default.Vector3);
            var d = b.delta(a),
                e = this.normal.dot(d);
            if (0 === e) {
                if (0 === this.distanceToPoint(b.start)) return c.copy(b.start)
            } else if (e = -(b.start.dot(this.normal) + this.constant) / e, !(0 > e || 1 < e)) return c.copy(d).multiplyScalar(e).add(b.start)
        }
    }(),
    intersectsLine: function(a) {
        var b = this.distanceToPoint(a.start);
        a = this.distanceToPoint(a.end);
        return 0 > b && 0 < a || 0 > a && 0 < b
    },
    intersectsBox: function(a) {
        return a.intersectsPlane(this)
    },
    intersectsSphere: function(a) {
        return a.intersectsPlane(this)
    },
    coplanarPoint: function(a) {
        void 0 === a && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), a = new module$node_modules$three$build$three.default.Vector3);
        return a.copy(this.normal).multiplyScalar(-this.constant)
    },
    applyMatrix4: function() {
        var a = new module$node_modules$three$build$three.default.Vector3,
            b = new module$node_modules$three$build$three.default.Matrix3;
        return function(c, d) {
            d = d || b.getNormalMatrix(c);
            c = this.coplanarPoint(a).applyMatrix4(c);
            d = this.normal.applyMatrix3(d).normalize();
            this.constant = -c.dot(d);
            return this
        }
    }(),
    translate: function(a) {
        this.constant -= a.dot(this.normal);
        return this
    },
    equals: function(a) {
        return a.normal.equals(this.normal) && a.constant === this.constant
    }
});
Object.assign(module$node_modules$three$build$three.default.Frustum.prototype, {
    set: function(a, b, c, d, e, f) {
        var g = this.planes;
        g[0].copy(a);
        g[1].copy(b);
        g[2].copy(c);
        g[3].copy(d);
        g[4].copy(e);
        g[5].copy(f);
        return this
    },
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(a) {
        for (var b = this.planes, c = 0; 6 > c; c++) b[c].copy(a.planes[c]);
        return this
    },
    setFromMatrix: function(a) {
        var b = this.planes,
            c = a.elements;
        a = c[0];
        var d = c[1],
            e = c[2],
            f = c[3],
            g = c[4],
            h = c[5],
            k = c[6],
            l = c[7],
            p = c[8],
            m = c[9],
            q = c[10],
            r = c[11],
            n = c[12],
            t = c[13],
            u = c[14];
        c = c[15];
        b[0].setComponents(f - a, l - g, r - p, c - n).normalize();
        b[1].setComponents(f + a, l + g, r + p, c + n).normalize();
        b[2].setComponents(f + d, l + h, r + m, c + t).normalize();
        b[3].setComponents(f - d, l - h, r - m, c - t).normalize();
        b[4].setComponents(f - e, l - k, r - q, c - u).normalize();
        b[5].setComponents(f + e, l + k, r + q, c + u).normalize();
        return this
    },
    intersectsObject: function() {
        var a = new module$node_modules$three$build$three.default.Sphere;
        return function(b) {
            var c = b.geometry;
            null === c.boundingSphere && c.computeBoundingSphere();
            a.copy(c.boundingSphere).applyMatrix4(b.matrixWorld);
            return this.intersectsSphere(a)
        }
    }(),
    intersectsSprite: function() {
        var a = new module$node_modules$three$build$three.default.Sphere;
        return function(b) {
            a.center.set(0, 0, 0);
            a.radius = .7071067811865476;
            a.applyMatrix4(b.matrixWorld);
            return this.intersectsSphere(a)
        }
    }(),
    intersectsSphere: function(a) {
        var b = this.planes,
            c = a.center;
        a = -a.radius;
        for (var d = 0; 6 > d; d++)
            if (b[d].distanceToPoint(c) < a) return !1;
        return !0
    },
    intersectsBox: function() {
        var a = new module$node_modules$three$build$three.default.Vector3;
        return function(b) {
            for (var c = this.planes, d = 0; 6 > d; d++) {
                var e = c[d];
                a.x = 0 < e.normal.x ? b.max.x : b.min.x;
                a.y = 0 < e.normal.y ? b.max.y : b.min.y;
                a.z = 0 < e.normal.z ? b.max.z : b.min.z;
                if (0 > e.distanceToPoint(a)) return !1
            }
            return !0
        }
    }(),
    containsPoint: function(a) {
        for (var b = this.planes, c = 0; 6 > c; c++)
            if (0 > b[c].distanceToPoint(a)) return !1;
        return !0
    }
});
var alphamap_fragment$$module$node_modules$three$build$three = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",
    alphamap_pars_fragment$$module$node_modules$three$build$three = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n",
    alphatest_fragment$$module$node_modules$three$build$three = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",
    aomap_fragment$$module$node_modules$three$build$three = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n",
    aomap_pars_fragment$$module$node_modules$three$build$three = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
    begin_vertex$$module$node_modules$three$build$three = "\nvec3 transformed = vec3( position );\n",
    beginnormal_vertex$$module$node_modules$three$build$three = "\nvec3 objectNormal = vec3( normal );\n",
    bsdfs$$module$node_modules$three$build$three = "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",
    bumpmap_pars_fragment$$module$node_modules$three$build$three = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n",
    clipping_planes_fragment$$module$node_modules$three$build$three = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n",
    clipping_planes_pars_fragment$$module$node_modules$three$build$three = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n",
    clipping_planes_pars_vertex$$module$node_modules$three$build$three = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n",
    clipping_planes_vertex$$module$node_modules$three$build$three =
    "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n",
    color_fragment$$module$node_modules$three$build$three = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
    color_pars_fragment$$module$node_modules$three$build$three = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n",
    color_pars_vertex$$module$node_modules$three$build$three = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
    color_vertex$$module$node_modules$three$build$three =
    "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
    common$$module$node_modules$three$build$three = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n",
    cube_uv_reflection_fragment$$module$node_modules$three$build$three = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n",
    defaultnormal_vertex$$module$node_modules$three$build$three = "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n",
    displacementmap_pars_vertex$$module$node_modules$three$build$three = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n",
    displacementmap_vertex$$module$node_modules$three$build$three = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
    emissivemap_fragment$$module$node_modules$three$build$three = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n",
    emissivemap_pars_fragment$$module$node_modules$three$build$three = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n",
    encodings_fragment$$module$node_modules$three$build$three = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n",
    encodings_pars_fragment$$module$node_modules$three$build$three = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n",
    envmap_fragment$$module$node_modules$three$build$three = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n",
    envmap_pars_fragment$$module$node_modules$three$build$three = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n",
    envmap_pars_vertex$$module$node_modules$three$build$three = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n",
    envmap_vertex$$module$node_modules$three$build$three = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n",
    fog_vertex$$module$node_modules$three$build$three = "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif",
    fog_pars_vertex$$module$node_modules$three$build$three = "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n",
    fog_fragment$$module$node_modules$three$build$three = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n",
    fog_pars_fragment$$module$node_modules$three$build$three = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n",
    gradientmap_pars_fragment$$module$node_modules$three$build$three = "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n",
    lightmap_fragment$$module$node_modules$three$build$three = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
    lightmap_pars_fragment$$module$node_modules$three$build$three = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
    lights_lambert_vertex$$module$node_modules$three$build$three = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n",
    lights_pars_begin$$module$node_modules$three$build$three = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n",
    envmap_physical_pars_fragment$$module$node_modules$three$build$three = "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n",
    lights_phong_fragment$$module$node_modules$three$build$three = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
    lights_phong_pars_fragment$$module$node_modules$three$build$three = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n",
    lights_physical_fragment$$module$node_modules$three$build$three = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n",
    lights_physical_pars_fragment$$module$node_modules$three$build$three = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",
    lights_fragment_begin$$module$node_modules$three$build$three = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif\n",
    lights_fragment_maps$$module$node_modules$three$build$three = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif\n",
    lights_fragment_end$$module$node_modules$three$build$three = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n",
    logdepthbuf_fragment$$module$node_modules$three$build$three = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
    logdepthbuf_pars_fragment$$module$node_modules$three$build$three = "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n",
    logdepthbuf_pars_vertex$$module$node_modules$three$build$three = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif",
    logdepthbuf_vertex$$module$node_modules$three$build$three = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n",
    map_fragment$$module$node_modules$three$build$three = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n",
    map_pars_fragment$$module$node_modules$three$build$three = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n",
    map_particle_fragment$$module$node_modules$three$build$three = "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n",
    map_particle_pars_fragment$$module$node_modules$three$build$three = "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n",
    metalnessmap_fragment$$module$node_modules$three$build$three = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n",
    metalnessmap_pars_fragment$$module$node_modules$three$build$three = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
    morphnormal_vertex$$module$node_modules$three$build$three = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
    morphtarget_pars_vertex$$module$node_modules$three$build$three = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
    morphtarget_vertex$$module$node_modules$three$build$three = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n",
    normal_fragment_begin$$module$node_modules$three$build$three = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n",
    normal_fragment_maps$$module$node_modules$three$build$three =
    "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
    normalmap_pars_fragment$$module$node_modules$three$build$three = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif\n",
    packing$$module$node_modules$three$build$three = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
    premultiplied_alpha_fragment$$module$node_modules$three$build$three = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n",
    project_vertex$$module$node_modules$three$build$three = "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n",
    dithering_fragment$$module$node_modules$three$build$three = "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n",
    dithering_pars_fragment$$module$node_modules$three$build$three =
    "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n",
    roughnessmap_fragment$$module$node_modules$three$build$three = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n",
    roughnessmap_pars_fragment$$module$node_modules$three$build$three = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
    shadowmap_pars_fragment$$module$node_modules$three$build$three = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n",
    shadowmap_pars_vertex$$module$node_modules$three$build$three = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n",
    shadowmap_vertex$$module$node_modules$three$build$three = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n",
    shadowmask_pars_fragment$$module$node_modules$three$build$three = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n",
    skinbase_vertex$$module$node_modules$three$build$three = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
    skinning_pars_vertex$$module$node_modules$three$build$three = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n",
    skinning_vertex$$module$node_modules$three$build$three = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n",
    skinnormal_vertex$$module$node_modules$three$build$three = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
    specularmap_fragment$$module$node_modules$three$build$three = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
    specularmap_pars_fragment$$module$node_modules$three$build$three = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
    tonemapping_fragment$$module$node_modules$three$build$three = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n",
    tonemapping_pars_fragment$$module$node_modules$three$build$three = "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",
    uv_pars_fragment$$module$node_modules$three$build$three = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
    uv_pars_vertex$$module$node_modules$three$build$three = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n",
    uv_vertex$$module$node_modules$three$build$three = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
    uv2_pars_fragment$$module$node_modules$three$build$three = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
    uv2_pars_vertex$$module$node_modules$three$build$three =
    "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
    uv2_vertex$$module$node_modules$three$build$three = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
    worldpos_vertex$$module$node_modules$three$build$three = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n",
    cube_frag$$module$node_modules$three$build$three = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n",
    cube_vert$$module$node_modules$three$build$three = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n",
    depth_frag$$module$node_modules$three$build$three = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n",
    depth_vert$$module$node_modules$three$build$three = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
    distanceRGBA_frag$$module$node_modules$three$build$three = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n",
    distanceRGBA_vert$$module$node_modules$three$build$three = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n",
    equirect_frag$$module$node_modules$three$build$three = "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n",
    equirect_vert$$module$node_modules$three$build$three = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
    linedashed_frag$$module$node_modules$three$build$three = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
    linedashed_vert$$module$node_modules$three$build$three = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n",
    meshbasic_frag$$module$node_modules$three$build$three = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
    meshbasic_vert$$module$node_modules$three$build$three = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n",
    meshlambert_frag$$module$node_modules$three$build$three = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
    meshlambert_vert$$module$node_modules$three$build$three = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
    meshphong_frag$$module$node_modules$three$build$three = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
    meshphong_vert$$module$node_modules$three$build$three = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
    meshphysical_frag$$module$node_modules$three$build$three = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
    meshphysical_vert$$module$node_modules$three$build$three = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
    normal_frag$$module$node_modules$three$build$three = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n",
    normal_vert$$module$node_modules$three$build$three = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n",
    points_frag$$module$node_modules$three$build$three = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
    points_vert$$module$node_modules$three$build$three = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}\n",
    shadow_frag$$module$node_modules$three$build$three = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n",
    shadow_vert$$module$node_modules$three$build$three = "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
    sprite_frag$$module$node_modules$three$build$three = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
    sprite_vert$$module$node_modules$three$build$three = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tvec4 mvPosition;\n\tmvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n";
module$node_modules$three$build$three.default.ShaderChunk = {
    alphamap_fragment: alphamap_fragment$$module$node_modules$three$build$three,
    alphamap_pars_fragment: alphamap_pars_fragment$$module$node_modules$three$build$three,
    alphatest_fragment: alphatest_fragment$$module$node_modules$three$build$three,
    aomap_fragment: aomap_fragment$$module$node_modules$three$build$three,
    aomap_pars_fragment: aomap_pars_fragment$$module$node_modules$three$build$three,
    begin_vertex: begin_vertex$$module$node_modules$three$build$three,
    beginnormal_vertex: beginnormal_vertex$$module$node_modules$three$build$three,
    bsdfs: bsdfs$$module$node_modules$three$build$three,
    bumpmap_pars_fragment: bumpmap_pars_fragment$$module$node_modules$three$build$three,
    clipping_planes_fragment: clipping_planes_fragment$$module$node_modules$three$build$three,
    clipping_planes_pars_fragment: clipping_planes_pars_fragment$$module$node_modules$three$build$three,
    clipping_planes_pars_vertex: clipping_planes_pars_vertex$$module$node_modules$three$build$three,
    clipping_planes_vertex: clipping_planes_vertex$$module$node_modules$three$build$three,
    color_fragment: color_fragment$$module$node_modules$three$build$three,
    color_pars_fragment: color_pars_fragment$$module$node_modules$three$build$three,
    color_pars_vertex: color_pars_vertex$$module$node_modules$three$build$three,
    color_vertex: color_vertex$$module$node_modules$three$build$three,
    common: common$$module$node_modules$three$build$three,
    cube_uv_reflection_fragment: cube_uv_reflection_fragment$$module$node_modules$three$build$three,
    defaultnormal_vertex: defaultnormal_vertex$$module$node_modules$three$build$three,
    displacementmap_pars_vertex: displacementmap_pars_vertex$$module$node_modules$three$build$three,
    displacementmap_vertex: displacementmap_vertex$$module$node_modules$three$build$three,
    emissivemap_fragment: emissivemap_fragment$$module$node_modules$three$build$three,
    emissivemap_pars_fragment: emissivemap_pars_fragment$$module$node_modules$three$build$three,
    encodings_fragment: encodings_fragment$$module$node_modules$three$build$three,
    encodings_pars_fragment: encodings_pars_fragment$$module$node_modules$three$build$three,
    envmap_fragment: envmap_fragment$$module$node_modules$three$build$three,
    envmap_pars_fragment: envmap_pars_fragment$$module$node_modules$three$build$three,
    envmap_pars_vertex: envmap_pars_vertex$$module$node_modules$three$build$three,
    envmap_physical_pars_fragment: envmap_physical_pars_fragment$$module$node_modules$three$build$three,
    envmap_vertex: envmap_vertex$$module$node_modules$three$build$three,
    fog_vertex: fog_vertex$$module$node_modules$three$build$three,
    fog_pars_vertex: fog_pars_vertex$$module$node_modules$three$build$three,
    fog_fragment: fog_fragment$$module$node_modules$three$build$three,
    fog_pars_fragment: fog_pars_fragment$$module$node_modules$three$build$three,
    gradientmap_pars_fragment: gradientmap_pars_fragment$$module$node_modules$three$build$three,
    lightmap_fragment: lightmap_fragment$$module$node_modules$three$build$three,
    lightmap_pars_fragment: lightmap_pars_fragment$$module$node_modules$three$build$three,
    lights_lambert_vertex: lights_lambert_vertex$$module$node_modules$three$build$three,
    lights_pars_begin: lights_pars_begin$$module$node_modules$three$build$three,
    lights_phong_fragment: lights_phong_fragment$$module$node_modules$three$build$three,
    lights_phong_pars_fragment: lights_phong_pars_fragment$$module$node_modules$three$build$three,
    lights_physical_fragment: lights_physical_fragment$$module$node_modules$three$build$three,
    lights_physical_pars_fragment: lights_physical_pars_fragment$$module$node_modules$three$build$three,
    lights_fragment_begin: lights_fragment_begin$$module$node_modules$three$build$three,
    lights_fragment_maps: lights_fragment_maps$$module$node_modules$three$build$three,
    lights_fragment_end: lights_fragment_end$$module$node_modules$three$build$three,
    logdepthbuf_fragment: logdepthbuf_fragment$$module$node_modules$three$build$three,
    logdepthbuf_pars_fragment: logdepthbuf_pars_fragment$$module$node_modules$three$build$three,
    logdepthbuf_pars_vertex: logdepthbuf_pars_vertex$$module$node_modules$three$build$three,
    logdepthbuf_vertex: logdepthbuf_vertex$$module$node_modules$three$build$three,
    map_fragment: map_fragment$$module$node_modules$three$build$three,
    map_pars_fragment: map_pars_fragment$$module$node_modules$three$build$three,
    map_particle_fragment: map_particle_fragment$$module$node_modules$three$build$three,
    map_particle_pars_fragment: map_particle_pars_fragment$$module$node_modules$three$build$three,
    metalnessmap_fragment: metalnessmap_fragment$$module$node_modules$three$build$three,
    metalnessmap_pars_fragment: metalnessmap_pars_fragment$$module$node_modules$three$build$three,
    morphnormal_vertex: morphnormal_vertex$$module$node_modules$three$build$three,
    morphtarget_pars_vertex: morphtarget_pars_vertex$$module$node_modules$three$build$three,
    morphtarget_vertex: morphtarget_vertex$$module$node_modules$three$build$three,
    normal_fragment_begin: normal_fragment_begin$$module$node_modules$three$build$three,
    normal_fragment_maps: normal_fragment_maps$$module$node_modules$three$build$three,
    normalmap_pars_fragment: normalmap_pars_fragment$$module$node_modules$three$build$three,
    packing: packing$$module$node_modules$three$build$three,
    premultiplied_alpha_fragment: premultiplied_alpha_fragment$$module$node_modules$three$build$three,
    project_vertex: project_vertex$$module$node_modules$three$build$three,
    dithering_fragment: dithering_fragment$$module$node_modules$three$build$three,
    dithering_pars_fragment: dithering_pars_fragment$$module$node_modules$three$build$three,
    roughnessmap_fragment: roughnessmap_fragment$$module$node_modules$three$build$three,
    roughnessmap_pars_fragment: roughnessmap_pars_fragment$$module$node_modules$three$build$three,
    shadowmap_pars_fragment: shadowmap_pars_fragment$$module$node_modules$three$build$three,
    shadowmap_pars_vertex: shadowmap_pars_vertex$$module$node_modules$three$build$three,
    shadowmap_vertex: shadowmap_vertex$$module$node_modules$three$build$three,
    shadowmask_pars_fragment: shadowmask_pars_fragment$$module$node_modules$three$build$three,
    skinbase_vertex: skinbase_vertex$$module$node_modules$three$build$three,
    skinning_pars_vertex: skinning_pars_vertex$$module$node_modules$three$build$three,
    skinning_vertex: skinning_vertex$$module$node_modules$three$build$three,
    skinnormal_vertex: skinnormal_vertex$$module$node_modules$three$build$three,
    specularmap_fragment: specularmap_fragment$$module$node_modules$three$build$three,
    specularmap_pars_fragment: specularmap_pars_fragment$$module$node_modules$three$build$three,
    tonemapping_fragment: tonemapping_fragment$$module$node_modules$three$build$three,
    tonemapping_pars_fragment: tonemapping_pars_fragment$$module$node_modules$three$build$three,
    uv_pars_fragment: uv_pars_fragment$$module$node_modules$three$build$three,
    uv_pars_vertex: uv_pars_vertex$$module$node_modules$three$build$three,
    uv_vertex: uv_vertex$$module$node_modules$three$build$three,
    uv2_pars_fragment: uv2_pars_fragment$$module$node_modules$three$build$three,
    uv2_pars_vertex: uv2_pars_vertex$$module$node_modules$three$build$three,
    uv2_vertex: uv2_vertex$$module$node_modules$three$build$three,
    worldpos_vertex: worldpos_vertex$$module$node_modules$three$build$three,
    cube_frag: cube_frag$$module$node_modules$three$build$three,
    cube_vert: cube_vert$$module$node_modules$three$build$three,
    depth_frag: depth_frag$$module$node_modules$three$build$three,
    depth_vert: depth_vert$$module$node_modules$three$build$three,
    distanceRGBA_frag: distanceRGBA_frag$$module$node_modules$three$build$three,
    distanceRGBA_vert: distanceRGBA_vert$$module$node_modules$three$build$three,
    equirect_frag: equirect_frag$$module$node_modules$three$build$three,
    equirect_vert: equirect_vert$$module$node_modules$three$build$three,
    linedashed_frag: linedashed_frag$$module$node_modules$three$build$three,
    linedashed_vert: linedashed_vert$$module$node_modules$three$build$three,
    meshbasic_frag: meshbasic_frag$$module$node_modules$three$build$three,
    meshbasic_vert: meshbasic_vert$$module$node_modules$three$build$three,
    meshlambert_frag: meshlambert_frag$$module$node_modules$three$build$three,
    meshlambert_vert: meshlambert_vert$$module$node_modules$three$build$three,
    meshphong_frag: meshphong_frag$$module$node_modules$three$build$three,
    meshphong_vert: meshphong_vert$$module$node_modules$three$build$three,
    meshphysical_frag: meshphysical_frag$$module$node_modules$three$build$three,
    meshphysical_vert: meshphysical_vert$$module$node_modules$three$build$three,
    normal_frag: normal_frag$$module$node_modules$three$build$three,
    normal_vert: normal_vert$$module$node_modules$three$build$three,
    points_frag: points_frag$$module$node_modules$three$build$three,
    points_vert: points_vert$$module$node_modules$three$build$three,
    shadow_frag: shadow_frag$$module$node_modules$three$build$three,
    shadow_vert: shadow_vert$$module$node_modules$three$build$three,
    sprite_frag: sprite_frag$$module$node_modules$three$build$three,
    sprite_vert: sprite_vert$$module$node_modules$three$build$three
};
module$node_modules$three$build$three.default.UniformsUtils = {
    merge: function(a) {
        for (var b = {}, c = 0; c < a.length; c++) {
            var d = this.clone(a[c]),
                e;
            for (e in d) b[e] = d[e]
        }
        return b
    },
    clone: function(a) {
        var b = {},
            c;
        for (c in a) {
            b[c] = {};
            for (var d in a[c]) {
                var e = a[c][d];
                e && (e.isColor || e.isMatrix3 || e.isMatrix4 || e.isVector2 || e.isVector3 || e.isVector4 || e.isTexture) ? b[c][d] = e.clone() : Array.isArray(e) ? b[c][d] = e.slice() : b[c][d] = e
            }
        }
        return b
    }
};
var ColorKeywords$$module$node_modules$three$build$three = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
};
Object.assign(module$node_modules$three$build$three.default.Color.prototype, {
    isColor: !0,
    r: 1,
    g: 1,
    b: 1,
    set: function(a) {
        a && a.isColor ? this.copy(a) : "number" === typeof a ? this.setHex(a) : "string" === typeof a && this.setStyle(a);
        return this
    },
    setScalar: function(a) {
        this.b = this.g = this.r = a;
        return this
    },
    setHex: function(a) {
        a = Math.floor(a);
        this.r = (a >> 16 & 255) / 255;
        this.g = (a >> 8 & 255) / 255;
        this.b = (a & 255) / 255;
        return this
    },
    setRGB: function(a, b, c) {
        this.r = a;
        this.g = b;
        this.b = c;
        return this
    },
    setHSL: function() {
        function a(a, c, d) {
            0 > d &&
                (d += 1);
            1 < d && --d;
            return d < 1 / 6 ? a + 6 * (c - a) * d : .5 > d ? c : d < 2 / 3 ? a + 6 * (c - a) * (2 / 3 - d) : a
        }
        return function(b, c, d) {
            b = module$node_modules$three$build$three.default.Math.euclideanModulo(b, 1);
            c = module$node_modules$three$build$three.default.Math.clamp(c, 0, 1);
            d = module$node_modules$three$build$three.default.Math.clamp(d, 0, 1);
            0 === c ? this.r = this.g = this.b = d : (c = .5 >= d ? d * (1 + c) : d + c - d * c, d = 2 * d - c, this.r = a(d, c, b + 1 / 3), this.g = a(d, c, b), this.b = a(d, c, b - 1 / 3));
            return this
        }
    }(),
    setStyle: function(a) {
        function b(b) {
            void 0 !== b && 1 > parseFloat(b) &&
                console.warn("THREE.Color: Alpha component of " + a + " will be ignored.")
        }
        var c;
        if (c = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(a)) {
            var d = c[2];
            switch (c[1]) {
                case "rgb":
                case "rgba":
                    if (c = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) return this.r = Math.min(255, parseInt(c[1], 10)) / 255, this.g = Math.min(255, parseInt(c[2], 10)) / 255, this.b = Math.min(255, parseInt(c[3], 10)) / 255, b(c[5]), this;
                    if (c = /^(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) return this.r = Math.min(100,
                        parseInt(c[1], 10)) / 100, this.g = Math.min(100, parseInt(c[2], 10)) / 100, this.b = Math.min(100, parseInt(c[3], 10)) / 100, b(c[5]), this;
                    break;
                case "hsl":
                case "hsla":
                    if (c = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) {
                        d = parseFloat(c[1]) / 360;
                        var e = parseInt(c[2], 10) / 100,
                            f = parseInt(c[3], 10) / 100;
                        b(c[5]);
                        return this.setHSL(d, e, f)
                    }
            }
        } else if (c = /^#([A-Fa-f0-9]+)$/.exec(a)) {
            c = c[1];
            d = c.length;
            if (3 === d) return this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255, this.g = parseInt(c.charAt(1) +
                c.charAt(1), 16) / 255, this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255, this;
            if (6 === d) return this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255, this.g = parseInt(c.charAt(2) + c.charAt(3), 16) / 255, this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255, this
        }
        a && 0 < a.length && (c = ColorKeywords$$module$node_modules$three$build$three[a], void 0 !== c ? this.setHex(c) : console.warn("THREE.Color: Unknown color " + a));
        return this
    },
    clone: function() {
        return new this.constructor(this.r, this.g, this.b)
    },
    copy: function(a) {
        this.r = a.r;
        this.g =
            a.g;
        this.b = a.b;
        return this
    },
    copyGammaToLinear: function(a, b) {
        void 0 === b && (b = 2);
        this.r = Math.pow(a.r, b);
        this.g = Math.pow(a.g, b);
        this.b = Math.pow(a.b, b);
        return this
    },
    copyLinearToGamma: function(a, b) {
        void 0 === b && (b = 2);
        b = 0 < b ? 1 / b : 1;
        this.r = Math.pow(a.r, b);
        this.g = Math.pow(a.g, b);
        this.b = Math.pow(a.b, b);
        return this
    },
    convertGammaToLinear: function(a) {
        this.copyGammaToLinear(this, a);
        return this
    },
    convertLinearToGamma: function(a) {
        this.copyLinearToGamma(this, a);
        return this
    },
    copySRGBToLinear: function() {
        function a(a) {
            return .04045 >
                a ? .0773993808 * a : Math.pow(.9478672986 * a + .0521327014, 2.4)
        }
        return function(b) {
            this.r = a(b.r);
            this.g = a(b.g);
            this.b = a(b.b);
            return this
        }
    }(),
    copyLinearToSRGB: function() {
        function a(a) {
            return .0031308 > a ? 12.92 * a : 1.055 * Math.pow(a, .41666) - .055
        }
        return function(b) {
            this.r = a(b.r);
            this.g = a(b.g);
            this.b = a(b.b);
            return this
        }
    }(),
    convertSRGBToLinear: function() {
        this.copySRGBToLinear(this);
        return this
    },
    convertLinearToSRGB: function() {
        this.copyLinearToSRGB(this);
        return this
    },
    getHex: function() {
        return 255 * this.r << 16 ^ 255 * this.g <<
            8 ^ 255 * this.b << 0
    },
    getHexString: function() {
        return ("000000" + this.getHex().toString(16)).slice(-6)
    },
    getHSL: function(a) {
        void 0 === a && (console.warn("THREE.Color: .getHSL() target is now required"), a = {
            h: 0,
            s: 0,
            l: 0
        });
        var b = this.r,
            c = this.g,
            d = this.b,
            e = Math.max(b, c, d),
            f = Math.min(b, c, d),
            g, h = (f + e) / 2;
        if (f === e) f = g = 0;
        else {
            var k = e - f;
            f = .5 >= h ? k / (e + f) : k / (2 - e - f);
            switch (e) {
                case b:
                    g = (c - d) / k + (c < d ? 6 : 0);
                    break;
                case c:
                    g = (d - b) / k + 2;
                    break;
                case d:
                    g = (b - c) / k + 4
            }
            g /= 6
        }
        a.h = g;
        a.s = f;
        a.l = h;
        return a
    },
    getStyle: function() {
        return "rgb(" + (255 * this.r |
            0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
    },
    offsetHSL: function() {
        var a = {};
        return function(b, c, d) {
            this.getHSL(a);
            a.h += b;
            a.s += c;
            a.l += d;
            this.setHSL(a.h, a.s, a.l);
            return this
        }
    }(),
    add: function(a) {
        this.r += a.r;
        this.g += a.g;
        this.b += a.b;
        return this
    },
    addColors: function(a, b) {
        this.r = a.r + b.r;
        this.g = a.g + b.g;
        this.b = a.b + b.b;
        return this
    },
    addScalar: function(a) {
        this.r += a;
        this.g += a;
        this.b += a;
        return this
    },
    sub: function(a) {
        this.r = Math.max(0, this.r - a.r);
        this.g = Math.max(0, this.g - a.g);
        this.b = Math.max(0, this.b - a.b);
        return this
    },
    multiply: function(a) {
        this.r *= a.r;
        this.g *= a.g;
        this.b *= a.b;
        return this
    },
    multiplyScalar: function(a) {
        this.r *= a;
        this.g *= a;
        this.b *= a;
        return this
    },
    lerp: function(a, b) {
        this.r += (a.r - this.r) * b;
        this.g += (a.g - this.g) * b;
        this.b += (a.b - this.b) * b;
        return this
    },
    equals: function(a) {
        return a.r === this.r && a.g === this.g && a.b === this.b
    },
    fromArray: function(a, b) {
        void 0 === b && (b = 0);
        this.r = a[b];
        this.g = a[b + 1];
        this.b = a[b + 2];
        return this
    },
    toArray: function(a, b) {
        void 0 === a && (a = []);
        void 0 === b && (b = 0);
        a[b] = this.r;
        a[b + 1] = this.g;
        a[b + 2] = this.b;
        return a
    },
    toJSON: function() {
        return this.getHex()
    }
});
module$node_modules$three$build$three.default.UniformsLib = {
    common: {
        diffuse: {
            value: new module$node_modules$three$build$three.default.Color(15658734)
        },
        opacity: {
            value: 1
        },
        map: {
            value: null
        },
        uvTransform: {
            value: new module$node_modules$three$build$three.default.Matrix3
        },
        alphaMap: {
            value: null
        }
    },
    specularmap: {
        specularMap: {
            value: null
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1
        },
        refractionRatio: {
            value: .98
        },
        maxMipLevel: {
            value: 0
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalScale: {
            value: new module$node_modules$three$build$three.default.Vector2(1, 1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 2.5E-4
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2E3
        },
        fogColor: {
            value: new module$node_modules$three$build$three.default.Color(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {},
                color: {},
                shadow: {},
                shadowBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {},
                shadow: {},
                shadowBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        spotShadowMap: {
            value: []
        },
        spotShadowMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                decay: {},
                distance: {},
                shadow: {},
                shadowBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            }
        },
        rectAreaLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                width: {},
                height: {}
            }
        }
    },
    points: {
        diffuse: {
            value: new module$node_modules$three$build$three.default.Color(15658734)
        },
        opacity: {
            value: 1
        },
        size: {
            value: 1
        },
        scale: {
            value: 1
        },
        map: {
            value: null
        },
        uvTransform: {
            value: new module$node_modules$three$build$three.default.Matrix3
        }
    },
    sprite: {
        diffuse: {
            value: new module$node_modules$three$build$three.default.Color(15658734)
        },
        opacity: {
            value: 1
        },
        center: {
            value: new module$node_modules$three$build$three.default.Vector2(.5, .5)
        },
        rotation: {
            value: 0
        },
        map: {
            value: null
        },
        uvTransform: {
            value: new module$node_modules$three$build$three.default.Matrix3
        }
    }
};
module$node_modules$three$build$three.default.ShaderLib = {
    basic: {
        uniforms: module$node_modules$three$build$three.default.UniformsUtils.merge([module$node_modules$three$build$three.default.UniformsLib.common, module$node_modules$three$build$three.default.UniformsLib.specularmap, module$node_modules$three$build$three.default.UniformsLib.envmap, module$node_modules$three$build$three.default.UniformsLib.aomap, module$node_modules$three$build$three.default.UniformsLib.lightmap, module$node_modules$three$build$three.default.UniformsLib.fog]),
        vertexShader: module$node_modules$three$build$three.default.ShaderChunk.meshbasic_vert,
        fragmentShader: module$node_modules$three$build$three.default.ShaderChunk.meshbasic_frag
    },
    lambert: {
        uniforms: module$node_modules$three$build$three.default.UniformsUtils.merge([module$node_modules$three$build$three.default.UniformsLib.common, module$node_modules$three$build$three.default.UniformsLib.specularmap, module$node_modules$three$build$three.default.UniformsLib.envmap, module$node_modules$three$build$three.default.UniformsLib.aomap,
            module$node_modules$three$build$three.default.UniformsLib.lightmap, module$node_modules$three$build$three.default.UniformsLib.emissivemap, module$node_modules$three$build$three.default.UniformsLib.fog, module$node_modules$three$build$three.default.UniformsLib.lights, {
                emissive: {
                    value: new module$node_modules$three$build$three.default.Color(0)
                }
            }
        ]),
        vertexShader: module$node_modules$three$build$three.default.ShaderChunk.meshlambert_vert,
        fragmentShader: module$node_modules$three$build$three.default.ShaderChunk.meshlambert_frag
    },
    phong: {
        uniforms: module$node_modules$three$build$three.default.UniformsUtils.merge([module$node_modules$three$build$three.default.UniformsLib.common, module$node_modules$three$build$three.default.UniformsLib.specularmap, module$node_modules$three$build$three.default.UniformsLib.envmap, module$node_modules$three$build$three.default.UniformsLib.aomap, module$node_modules$three$build$three.default.UniformsLib.lightmap, module$node_modules$three$build$three.default.UniformsLib.emissivemap, module$node_modules$three$build$three.default.UniformsLib.bumpmap,
            module$node_modules$three$build$three.default.UniformsLib.normalmap, module$node_modules$three$build$three.default.UniformsLib.displacementmap, module$node_modules$three$build$three.default.UniformsLib.gradientmap, module$node_modules$three$build$three.default.UniformsLib.fog, module$node_modules$three$build$three.default.UniformsLib.lights, {
                emissive: {
                    value: new module$node_modules$three$build$three.default.Color(0)
                },
                specular: {
                    value: new module$node_modules$three$build$three.default.Color(1118481)
                },
                shininess: {
                    value: 30
                }
            }
        ]),
        vertexShader: module$node_modules$three$build$three.default.ShaderChunk.meshphong_vert,
        fragmentShader: module$node_modules$three$build$three.default.ShaderChunk.meshphong_frag
    },
    standard: {
        uniforms: module$node_modules$three$build$three.default.UniformsUtils.merge([module$node_modules$three$build$three.default.UniformsLib.common, module$node_modules$three$build$three.default.UniformsLib.envmap, module$node_modules$three$build$three.default.UniformsLib.aomap, module$node_modules$three$build$three.default.UniformsLib.lightmap,
            module$node_modules$three$build$three.default.UniformsLib.emissivemap, module$node_modules$three$build$three.default.UniformsLib.bumpmap, module$node_modules$three$build$three.default.UniformsLib.normalmap, module$node_modules$three$build$three.default.UniformsLib.displacementmap, module$node_modules$three$build$three.default.UniformsLib.roughnessmap, module$node_modules$three$build$three.default.UniformsLib.metalnessmap, module$node_modules$three$build$three.default.UniformsLib.fog, module$node_modules$three$build$three.default.UniformsLib.lights, {
                emissive: {
                    value: new module$node_modules$three$build$three.default.Color(0)
                },
                roughness: {
                    value: .5
                },
                metalness: {
                    value: .5
                },
                envMapIntensity: {
                    value: 1
                }
            }
        ]),
        vertexShader: module$node_modules$three$build$three.default.ShaderChunk.meshphysical_vert,
        fragmentShader: module$node_modules$three$build$three.default.ShaderChunk.meshphysical_frag
    },
    points: {
        uniforms: module$node_modules$three$build$three.default.UniformsUtils.merge([module$node_modules$three$build$three.default.UniformsLib.points, module$node_modules$three$build$three.default.UniformsLib.fog]),
        vertexShader: module$node_modules$three$build$three.default.ShaderChunk.points_vert,
        fragmentShader: module$node_modules$three$build$three.default.ShaderChunk.points_frag
    },
    dashed: {
        uniforms: module$node_modules$three$build$three.default.UniformsUtils.merge([module$node_modules$three$build$three.default.UniformsLib.common, module$node_modules$three$build$three.default.UniformsLib.fog, {
            scale: {
                value: 1
            },
            dashSize: {
                value: 1
            },
            totalSize: {
                value: 2
            }
        }]),
        vertexShader: module$node_modules$three$build$three.default.ShaderChunk.linedashed_vert,
        fragmentShader: module$node_modules$three$build$three.default.ShaderChunk.linedashed_frag
    },
    depth: {
        uniforms: module$node_modules$three$build$three.default.UniformsUtils.merge([module$node_modules$three$build$three.default.UniformsLib.common, module$node_modules$three$build$three.default.UniformsLib.displacementmap]),
        vertexShader: module$node_modules$three$build$three.default.ShaderChunk.depth_vert,
        fragmentShader: module$node_modules$three$build$three.default.ShaderChunk.depth_frag
    },
    normal: {
        uniforms: module$node_modules$three$build$three.default.UniformsUtils.merge([module$node_modules$three$build$three.default.UniformsLib.common,
            module$node_modules$three$build$three.default.UniformsLib.bumpmap, module$node_modules$three$build$three.default.UniformsLib.normalmap, module$node_modules$three$build$three.default.UniformsLib.displacementmap, {
                opacity: {
                    value: 1
                }
            }
        ]),
        vertexShader: module$node_modules$three$build$three.default.ShaderChunk.normal_vert,
        fragmentShader: module$node_modules$three$build$three.default.ShaderChunk.normal_frag
    },
    sprite: {
        uniforms: module$node_modules$three$build$three.default.UniformsUtils.merge([module$node_modules$three$build$three.default.UniformsLib.sprite,
            module$node_modules$three$build$three.default.UniformsLib.fog
        ]),
        vertexShader: module$node_modules$three$build$three.default.ShaderChunk.sprite_vert,
        fragmentShader: module$node_modules$three$build$three.default.ShaderChunk.sprite_frag
    },
    cube: {
        uniforms: {
            tCube: {
                value: null
            },
            tFlip: {
                value: -1
            },
            opacity: {
                value: 1
            }
        },
        vertexShader: module$node_modules$three$build$three.default.ShaderChunk.cube_vert,
        fragmentShader: module$node_modules$three$build$three.default.ShaderChunk.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: module$node_modules$three$build$three.default.ShaderChunk.equirect_vert,
        fragmentShader: module$node_modules$three$build$three.default.ShaderChunk.equirect_frag
    },
    distanceRGBA: {
        uniforms: module$node_modules$three$build$three.default.UniformsUtils.merge([module$node_modules$three$build$three.default.UniformsLib.common, module$node_modules$three$build$three.default.UniformsLib.displacementmap, {
            referencePosition: {
                value: new module$node_modules$three$build$three.default.Vector3
            },
            nearDistance: {
                value: 1
            },
            farDistance: {
                value: 1E3
            }
        }]),
        vertexShader: module$node_modules$three$build$three.default.ShaderChunk.distanceRGBA_vert,
        fragmentShader: module$node_modules$three$build$three.default.ShaderChunk.distanceRGBA_frag
    },
    shadow: {
        uniforms: module$node_modules$three$build$three.default.UniformsUtils.merge([module$node_modules$three$build$three.default.UniformsLib.lights, module$node_modules$three$build$three.default.UniformsLib.fog, {
            color: {
                value: new module$node_modules$three$build$three.default.Color(0)
            },
            opacity: {
                value: 1
            }
        }]),
        vertexShader: module$node_modules$three$build$three.default.ShaderChunk.shadow_vert,
        fragmentShader: module$node_modules$three$build$three.default.ShaderChunk.shadow_frag
    }
};
module$node_modules$three$build$three.default.ShaderLib.physical = {
    uniforms: module$node_modules$three$build$three.default.UniformsUtils.merge([module$node_modules$three$build$three.default.ShaderLib.standard.uniforms, {
        clearCoat: {
            value: 0
        },
        clearCoatRoughness: {
            value: 0
        }
    }]),
    vertexShader: module$node_modules$three$build$three.default.ShaderChunk.meshphysical_vert,
    fragmentShader: module$node_modules$three$build$three.default.ShaderChunk.meshphysical_frag
};

function WebGLAnimation$$module$node_modules$three$build$three() {
    function a(e, f) {
        !1 !== c && (d(e, f), b.requestAnimationFrame(a))
    }
    var b = null,
        c = !1,
        d = null;
    return {
        start: function() {
            !0 !== c && null !== d && (b.requestAnimationFrame(a), c = !0)
        },
        stop: function() {
            c = !1
        },
        setAnimationLoop: function(a) {
            d = a
        },
        setContext: function(a) {
            b = a
        }
    }
}

function WebGLAttributes$$module$node_modules$three$build$three(a) {
    function b(b, c) {
        var d = b.array,
            e = b.dynamic ? a.DYNAMIC_DRAW : a.STATIC_DRAW,
            h = a.createBuffer();
        a.bindBuffer(c, h);
        a.bufferData(c, d, e);
        b.onUploadCallback();
        c = a.FLOAT;
        d instanceof Float32Array ? c = a.FLOAT : d instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : d instanceof Uint16Array ? c = a.UNSIGNED_SHORT : d instanceof Int16Array ? c = a.SHORT : d instanceof Uint32Array ? c = a.UNSIGNED_INT : d instanceof
        Int32Array ? c = a.INT : d instanceof Int8Array ? c = a.BYTE : d instanceof Uint8Array && (c = a.UNSIGNED_BYTE);
        return {
            buffer: h,
            type: c,
            bytesPerElement: d.BYTES_PER_ELEMENT,
            version: b.version
        }
    }
    var c = new WeakMap;
    return {
        get: function(a) {
            a.isInterleavedBufferAttribute && (a = a.data);
            return c.get(a)
        },
        remove: function(b) {
            b.isInterleavedBufferAttribute && (b = b.data);
            var d = c.get(b);
            d && (a.deleteBuffer(d.buffer), c.delete(b))
        },
        update: function(d, e) {
            d.isInterleavedBufferAttribute && (d = d.data);
            var f = c.get(d);
            if (void 0 === f) c.set(d, b(d, e));
            else if (f.version < d.version) {
                var g = d,
                    h = g.array,
                    k = g.updateRange;
                a.bindBuffer(e, f.buffer);
                !1 === g.dynamic ? a.bufferData(e, h, a.STATIC_DRAW) : -1 === k.count ? a.bufferSubData(e, 0, h) : 0 === k.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (a.bufferSubData(e, k.offset * h.BYTES_PER_ELEMENT, h.subarray(k.offset, k.offset + k.count)), k.count = -1);
                f.version = d.version
            }
        }
    }
}
module$node_modules$three$build$three.default.Euler.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" ");
module$node_modules$three$build$three.default.Euler.DefaultOrder = "XYZ";
Object.defineProperties(module$node_modules$three$build$three.default.Euler.prototype, {
    x: {
        get: function() {
            return this._x
        },
        set: function(a) {
            this._x = a;
            this.onChangeCallback()
        }
    },
    y: {
        get: function() {
            return this._y
        },
        set: function(a) {
            this._y = a;
            this.onChangeCallback()
        }
    },
    z: {
        get: function() {
            return this._z
        },
        set: function(a) {
            this._z = a;
            this.onChangeCallback()
        }
    },
    order: {
        get: function() {
            return this._order
        },
        set: function(a) {
            this._order = a;
            this.onChangeCallback()
        }
    }
});
Object.assign(module$node_modules$three$build$three.default.Euler.prototype, {
    isEuler: !0,
    set: function(a, b, c, d) {
        this._x = a;
        this._y = b;
        this._z = c;
        this._order = d || this._order;
        this.onChangeCallback();
        return this
    },
    clone: function() {
        return new this.constructor(this._x, this._y, this._z, this._order)
    },
    copy: function(a) {
        this._x = a._x;
        this._y = a._y;
        this._z = a._z;
        this._order = a._order;
        this.onChangeCallback();
        return this
    },
    setFromRotationMatrix: function(a, b, c) {
        var d = module$node_modules$three$build$three.default.Math.clamp,
            e = a.elements;
        a = e[0];
        var f = e[4],
            g = e[8],
            h = e[1],
            k = e[5],
            l = e[9],
            p = e[2],
            m = e[6];
        e = e[10];
        b = b || this._order;
        "XYZ" === b ? (this._y = Math.asin(d(g, -1, 1)), .99999 > Math.abs(g) ? (this._x = Math.atan2(-l, e), this._z = Math.atan2(-f, a)) : (this._x = Math.atan2(m, k), this._z = 0)) : "YXZ" === b ? (this._x = Math.asin(-d(l, -1, 1)), .99999 > Math.abs(l) ? (this._y = Math.atan2(g, e), this._z = Math.atan2(h, k)) : (this._y = Math.atan2(-p, a), this._z = 0)) : "ZXY" === b ? (this._x = Math.asin(d(m, -1, 1)), .99999 > Math.abs(m) ? (this._y = Math.atan2(-p, e), this._z = Math.atan2(-f,
            k)) : (this._y = 0, this._z = Math.atan2(h, a))) : "ZYX" === b ? (this._y = Math.asin(-d(p, -1, 1)), .99999 > Math.abs(p) ? (this._x = Math.atan2(m, e), this._z = Math.atan2(h, a)) : (this._x = 0, this._z = Math.atan2(-f, k))) : "YZX" === b ? (this._z = Math.asin(d(h, -1, 1)), .99999 > Math.abs(h) ? (this._x = Math.atan2(-l, k), this._y = Math.atan2(-p, a)) : (this._x = 0, this._y = Math.atan2(g, e))) : "XZY" === b ? (this._z = Math.asin(-d(f, -1, 1)), .99999 > Math.abs(f) ? (this._x = Math.atan2(m, k), this._y = Math.atan2(g, a)) : (this._x = Math.atan2(-l, e), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " +
            b);
        this._order = b;
        if (!1 !== c) this.onChangeCallback();
        return this
    },
    setFromQuaternion: function() {
        var a = new module$node_modules$three$build$three.default.Matrix4;
        return function(b, c, d) {
            a.makeRotationFromQuaternion(b);
            return this.setFromRotationMatrix(a, c, d)
        }
    }(),
    setFromVector3: function(a, b) {
        return this.set(a.x, a.y, a.z, b || this._order)
    },
    reorder: function() {
        var a = new module$node_modules$three$build$three.default.Quaternion;
        return function(b) {
            a.setFromEuler(this);
            return this.setFromQuaternion(a, b)
        }
    }(),
    equals: function(a) {
        return a._x ===
            this._x && a._y === this._y && a._z === this._z && a._order === this._order
    },
    fromArray: function(a) {
        this._x = a[0];
        this._y = a[1];
        this._z = a[2];
        void 0 !== a[3] && (this._order = a[3]);
        this.onChangeCallback();
        return this
    },
    toArray: function(a, b) {
        void 0 === a && (a = []);
        void 0 === b && (b = 0);
        a[b] = this._x;
        a[b + 1] = this._y;
        a[b + 2] = this._z;
        a[b + 3] = this._order;
        return a
    },
    toVector3: function(a) {
        return a ? a.set(this._x, this._y, this._z) : new module$node_modules$three$build$three.default.Vector3(this._x, this._y, this._z)
    },
    onChange: function(a) {
        this.onChangeCallback =
            a;
        return this
    },
    onChangeCallback: function() {}
});
Object.assign(module$node_modules$three$build$three.default.Layers.prototype, {
    set: function(a) {
        this.mask = 1 << a | 0
    },
    enable: function(a) {
        this.mask = this.mask | 1 << a | 0
    },
    toggle: function(a) {
        this.mask ^= 1 << a | 0
    },
    disable: function(a) {
        this.mask &= ~(1 << a | 0)
    },
    test: function(a) {
        return 0 !== (this.mask & a.mask)
    }
});
var object3DId$$module$node_modules$three$build$three = 0;
module$node_modules$three$build$three.default.Object3D.DefaultUp = new module$node_modules$three$build$three.default.Vector3(0, 1, 0);
module$node_modules$three$build$three.default.Object3D.DefaultMatrixAutoUpdate = !0;
module$node_modules$three$build$three.default.Object3D.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.EventDispatcher.prototype), {
    constructor: module$node_modules$three$build$three.default.Object3D,
    isObject3D: !0,
    onBeforeRender: function() {},
    onAfterRender: function() {},
    applyMatrix: function(a) {
        this.matrix.multiplyMatrices(a, this.matrix);
        this.matrix.decompose(this.position, this.quaternion, this.scale)
    },
    applyQuaternion: function(a) {
        this.quaternion.premultiply(a);
        return this
    },
    setRotationFromAxisAngle: function(a, b) {
        this.quaternion.setFromAxisAngle(a, b)
    },
    setRotationFromEuler: function(a) {
        this.quaternion.setFromEuler(a, !0)
    },
    setRotationFromMatrix: function(a) {
        this.quaternion.setFromRotationMatrix(a)
    },
    setRotationFromQuaternion: function(a) {
        this.quaternion.copy(a)
    },
    rotateOnAxis: function() {
        var a = new module$node_modules$three$build$three.default.Quaternion;
        return function(b, c) {
            a.setFromAxisAngle(b, c);
            this.quaternion.multiply(a);
            return this
        }
    }(),
    rotateOnWorldAxis: function() {
        var a =
            new module$node_modules$three$build$three.default.Quaternion;
        return function(b, c) {
            a.setFromAxisAngle(b, c);
            this.quaternion.premultiply(a);
            return this
        }
    }(),
    rotateX: function() {
        var a = new module$node_modules$three$build$three.default.Vector3(1, 0, 0);
        return function(b) {
            return this.rotateOnAxis(a, b)
        }
    }(),
    rotateY: function() {
        var a = new module$node_modules$three$build$three.default.Vector3(0, 1, 0);
        return function(b) {
            return this.rotateOnAxis(a, b)
        }
    }(),
    rotateZ: function() {
        var a = new module$node_modules$three$build$three.default.Vector3(0,
            0, 1);
        return function(b) {
            return this.rotateOnAxis(a, b)
        }
    }(),
    translateOnAxis: function() {
        var a = new module$node_modules$three$build$three.default.Vector3;
        return function(b, c) {
            a.copy(b).applyQuaternion(this.quaternion);
            this.position.add(a.multiplyScalar(c));
            return this
        }
    }(),
    translateX: function() {
        var a = new module$node_modules$three$build$three.default.Vector3(1, 0, 0);
        return function(b) {
            return this.translateOnAxis(a, b)
        }
    }(),
    translateY: function() {
        var a = new module$node_modules$three$build$three.default.Vector3(0,
            1, 0);
        return function(b) {
            return this.translateOnAxis(a, b)
        }
    }(),
    translateZ: function() {
        var a = new module$node_modules$three$build$three.default.Vector3(0, 0, 1);
        return function(b) {
            return this.translateOnAxis(a, b)
        }
    }(),
    localToWorld: function(a) {
        return a.applyMatrix4(this.matrixWorld)
    },
    worldToLocal: function() {
        var a = new module$node_modules$three$build$three.default.Matrix4;
        return function(b) {
            return b.applyMatrix4(a.getInverse(this.matrixWorld))
        }
    }(),
    lookAt: function() {
        var a = new module$node_modules$three$build$three.default.Matrix4,
            b = new module$node_modules$three$build$three.default.Vector3;
        return function(c, d, e) {
            c.isVector3 ? b.copy(c) : b.set(c, d, e);
            this.isCamera ? a.lookAt(this.position, b, this.up) : a.lookAt(b, this.position, this.up);
            this.quaternion.setFromRotationMatrix(a)
        }
    }(),
    add: function(a) {
        if (1 < arguments.length) {
            for (var b = 0; b < arguments.length; b++) this.add(arguments[b]);
            return this
        }
        if (a === this) return console.error("THREE.Object3D.add: object can't be added as a child of itself.", a), this;
        a && a.isObject3D ? (null !== a.parent && a.parent.remove(a),
            a.parent = this, a.dispatchEvent({
                type: "added"
            }), this.children.push(a)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", a);
        return this
    },
    remove: function(a) {
        if (1 < arguments.length) {
            for (var b = 0; b < arguments.length; b++) this.remove(arguments[b]);
            return this
        }
        b = this.children.indexOf(a); - 1 !== b && (a.parent = null, a.dispatchEvent({
            type: "removed"
        }), this.children.splice(b, 1));
        return this
    },
    getObjectById: function(a) {
        return this.getObjectByProperty("id", a)
    },
    getObjectByName: function(a) {
        return this.getObjectByProperty("name",
            a)
    },
    getObjectByProperty: function(a, b) {
        if (this[a] === b) return this;
        for (var c = 0, d = this.children.length; c < d; c++) {
            var e = this.children[c].getObjectByProperty(a, b);
            if (void 0 !== e) return e
        }
    },
    getWorldPosition: function(a) {
        void 0 === a && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), a = new module$node_modules$three$build$three.default.Vector3);
        this.updateMatrixWorld(!0);
        return a.setFromMatrixPosition(this.matrixWorld)
    },
    getWorldQuaternion: function() {
        var a = new module$node_modules$three$build$three.default.Vector3,
            b = new module$node_modules$three$build$three.default.Vector3;
        return function(c) {
            void 0 === c && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), c = new module$node_modules$three$build$three.default.Quaternion);
            this.updateMatrixWorld(!0);
            this.matrixWorld.decompose(a, c, b);
            return c
        }
    }(),
    getWorldScale: function() {
        var a = new module$node_modules$three$build$three.default.Vector3,
            b = new module$node_modules$three$build$three.default.Quaternion;
        return function(c) {
            void 0 === c && (console.warn("THREE.Object3D: .getWorldScale() target is now required"),
                c = new module$node_modules$three$build$three.default.Vector3);
            this.updateMatrixWorld(!0);
            this.matrixWorld.decompose(a, b, c);
            return c
        }
    }(),
    getWorldDirection: function() {
        var a = new module$node_modules$three$build$three.default.Quaternion;
        return function(b) {
            void 0 === b && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), b = new module$node_modules$three$build$three.default.Vector3);
            this.getWorldQuaternion(a);
            return b.set(0, 0, 1).applyQuaternion(a)
        }
    }(),
    raycast: function() {},
    traverse: function(a) {
        a(this);
        for (var b = this.children, c = 0, d = b.length; c < d; c++) b[c].traverse(a)
    },
    traverseVisible: function(a) {
        if (!1 !== this.visible) {
            a(this);
            for (var b = this.children, c = 0, d = b.length; c < d; c++) b[c].traverseVisible(a)
        }
    },
    traverseAncestors: function(a) {
        var b = this.parent;
        null !== b && (a(b), b.traverseAncestors(a))
    },
    updateMatrix: function() {
        this.matrix.compose(this.position, this.quaternion, this.scale);
        this.matrixWorldNeedsUpdate = !0
    },
    updateMatrixWorld: function(a) {
        this.matrixAutoUpdate && this.updateMatrix();
        if (this.matrixWorldNeedsUpdate ||
            a) null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, a = !0;
        for (var b = this.children, c = 0, d = b.length; c < d; c++) b[c].updateMatrixWorld(a)
    },
    toJSON: function(a) {
        function b(b, c) {
            void 0 === b[c.uuid] && (b[c.uuid] = c.toJSON(a));
            return c.uuid
        }

        function c(a) {
            var b = [],
                c;
            for (c in a) {
                var d = a[c];
                delete d.metadata;
                b.push(d)
            }
            return b
        }
        var d = void 0 === a || "string" === typeof a,
            e = {};
        d && (a = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {}
        }, e.metadata = {
            version: 4.5,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        var f = {};
        f.uuid = this.uuid;
        f.type = this.type;
        "" !== this.name && (f.name = this.name);
        !0 === this.castShadow && (f.castShadow = !0);
        !0 === this.receiveShadow && (f.receiveShadow = !0);
        !1 === this.visible && (f.visible = !1);
        !1 === this.frustumCulled && (f.frustumCulled = !1);
        0 !== this.renderOrder && (f.renderOrder = this.renderOrder);
        "{}" !== JSON.stringify(this.userData) && (f.userData = this.userData);
        f.layers = this.layers.mask;
        f.matrix = this.matrix.toArray();
        !1 === this.matrixAutoUpdate && (f.matrixAutoUpdate = !1);
        if (this.isMesh || this.isLine || this.isPoints) {
            f.geometry = b(a.geometries, this.geometry);
            var g = this.geometry.parameters;
            if (void 0 !== g && void 0 !== g.shapes)
                if (g = g.shapes, Array.isArray(g))
                    for (var h = 0, k = g.length; h < k; h++) b(a.shapes, g[h]);
                else b(a.shapes, g)
        }
        if (void 0 !== this.material)
            if (Array.isArray(this.material)) {
                g = [];
                h = 0;
                for (k = this.material.length; h < k; h++) g.push(b(a.materials, this.material[h]));
                f.material = g
            } else f.material = b(a.materials, this.material);
        if (0 <
            this.children.length)
            for (f.children = [], h = 0; h < this.children.length; h++) f.children.push(this.children[h].toJSON(a).object);
        if (d) {
            d = c(a.geometries);
            h = c(a.materials);
            k = c(a.textures);
            var l = c(a.images);
            g = c(a.shapes);
            0 < d.length && (e.geometries = d);
            0 < h.length && (e.materials = h);
            0 < k.length && (e.textures = k);
            0 < l.length && (e.images = l);
            0 < g.length && (e.shapes = g)
        }
        e.object = f;
        return e
    },
    clone: function(a) {
        return (new this.constructor).copy(this, a)
    },
    copy: function(a, b) {
        void 0 === b && (b = !0);
        this.name = a.name;
        this.up.copy(a.up);
        this.position.copy(a.position);
        this.quaternion.copy(a.quaternion);
        this.scale.copy(a.scale);
        this.matrix.copy(a.matrix);
        this.matrixWorld.copy(a.matrixWorld);
        this.matrixAutoUpdate = a.matrixAutoUpdate;
        this.matrixWorldNeedsUpdate = a.matrixWorldNeedsUpdate;
        this.layers.mask = a.layers.mask;
        this.visible = a.visible;
        this.castShadow = a.castShadow;
        this.receiveShadow = a.receiveShadow;
        this.frustumCulled = a.frustumCulled;
        this.renderOrder = a.renderOrder;
        this.userData = JSON.parse(JSON.stringify(a.userData));
        if (!0 === b)
            for (b = 0; b < a.children.length; b++) this.add(a.children[b].clone());
        return this
    }
});
module$node_modules$three$build$three.default.Camera.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.Object3D.prototype), {
    constructor: module$node_modules$three$build$three.default.Camera,
    isCamera: !0,
    copy: function(a, b) {
        module$node_modules$three$build$three.default.Object3D.prototype.copy.call(this, a, b);
        this.matrixWorldInverse.copy(a.matrixWorldInverse);
        this.projectionMatrix.copy(a.projectionMatrix);
        return this
    },
    getWorldDirection: function() {
        var a = new module$node_modules$three$build$three.default.Quaternion;
        return function(b) {
            void 0 ===
                b && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), b = new module$node_modules$three$build$three.default.Vector3);
            this.getWorldQuaternion(a);
            return b.set(0, 0, -1).applyQuaternion(a)
        }
    }(),
    updateMatrixWorld: function(a) {
        module$node_modules$three$build$three.default.Object3D.prototype.updateMatrixWorld.call(this, a);
        this.matrixWorldInverse.getInverse(this.matrixWorld)
    },
    clone: function() {
        return (new this.constructor).copy(this)
    }
});
module$node_modules$three$build$three.default.OrthographicCamera.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.Camera.prototype), {
    constructor: module$node_modules$three$build$three.default.OrthographicCamera,
    isOrthographicCamera: !0,
    copy: function(a, b) {
        module$node_modules$three$build$three.default.Camera.prototype.copy.call(this, a, b);
        this.left = a.left;
        this.right = a.right;
        this.top = a.top;
        this.bottom = a.bottom;
        this.near = a.near;
        this.far = a.far;
        this.zoom = a.zoom;
        this.view =
            null === a.view ? null : Object.assign({}, a.view);
        return this
    },
    setViewOffset: function(a, b, c, d, e, f) {
        null === this.view && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        });
        this.view.enabled = !0;
        this.view.fullWidth = a;
        this.view.fullHeight = b;
        this.view.offsetX = c;
        this.view.offsetY = d;
        this.view.width = e;
        this.view.height = f;
        this.updateProjectionMatrix()
    },
    clearViewOffset: function() {
        null !== this.view && (this.view.enabled = !1);
        this.updateProjectionMatrix()
    },
    updateProjectionMatrix: function() {
        var a =
            (this.right - this.left) / (2 * this.zoom),
            b = (this.top - this.bottom) / (2 * this.zoom),
            c = (this.right + this.left) / 2,
            d = (this.top + this.bottom) / 2,
            e = c - a;
        c += a;
        a = d + b;
        b = d - b;
        if (null !== this.view && this.view.enabled) {
            c = this.zoom / (this.view.width / this.view.fullWidth);
            b = this.zoom / (this.view.height / this.view.fullHeight);
            var f = (this.right - this.left) / this.view.width;
            d = (this.top - this.bottom) / this.view.height;
            e += this.view.offsetX / c * f;
            c = e + this.view.width / c * f;
            a -= this.view.offsetY / b * d;
            b = a - this.view.height / b * d
        }
        this.projectionMatrix.makeOrthographic(e,
            c, a, b, this.near, this.far)
    },
    toJSON: function(a) {
        a = module$node_modules$three$build$three.default.Object3D.prototype.toJSON.call(this, a);
        a.object.zoom = this.zoom;
        a.object.left = this.left;
        a.object.right = this.right;
        a.object.top = this.top;
        a.object.bottom = this.bottom;
        a.object.near = this.near;
        a.object.far = this.far;
        null !== this.view && (a.object.view = Object.assign({}, this.view));
        return a
    }
});
Object.assign(module$node_modules$three$build$three.default.Face3.prototype, {
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(a) {
        this.a = a.a;
        this.b = a.b;
        this.c = a.c;
        this.normal.copy(a.normal);
        this.color.copy(a.color);
        this.materialIndex = a.materialIndex;
        for (var b = 0, c = a.vertexNormals.length; b < c; b++) this.vertexNormals[b] = a.vertexNormals[b].clone();
        b = 0;
        for (c = a.vertexColors.length; b < c; b++) this.vertexColors[b] = a.vertexColors[b].clone();
        return this
    }
});
var geometryId$$module$node_modules$three$build$three = 0;
module$node_modules$three$build$three.default.Geometry.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.EventDispatcher.prototype), {
    constructor: module$node_modules$three$build$three.default.Geometry,
    isGeometry: !0,
    applyMatrix: function(a) {
        for (var b = (new module$node_modules$three$build$three.default.Matrix3).getNormalMatrix(a), c = 0, d = this.vertices.length; c < d; c++) this.vertices[c].applyMatrix4(a);
        c = 0;
        for (d = this.faces.length; c < d; c++) {
            a = this.faces[c];
            a.normal.applyMatrix3(b).normalize();
            for (var e = 0, f = a.vertexNormals.length; e < f; e++) a.vertexNormals[e].applyMatrix3(b).normalize()
        }
        null !== this.boundingBox && this.computeBoundingBox();
        null !== this.boundingSphere && this.computeBoundingSphere();
        this.normalsNeedUpdate = this.verticesNeedUpdate = !0;
        return this
    },
    rotateX: function() {
        var a = new module$node_modules$three$build$three.default.Matrix4;
        return function(b) {
            a.makeRotationX(b);
            this.applyMatrix(a);
            return this
        }
    }(),
    rotateY: function() {
        var a = new module$node_modules$three$build$three.default.Matrix4;
        return function(b) {
            a.makeRotationY(b);
            this.applyMatrix(a);
            return this
        }
    }(),
    rotateZ: function() {
        var a = new module$node_modules$three$build$three.default.Matrix4;
        return function(b) {
            a.makeRotationZ(b);
            this.applyMatrix(a);
            return this
        }
    }(),
    translate: function() {
        var a = new module$node_modules$three$build$three.default.Matrix4;
        return function(b, c, d) {
            a.makeTranslation(b, c, d);
            this.applyMatrix(a);
            return this
        }
    }(),
    scale: function() {
        var a = new module$node_modules$three$build$three.default.Matrix4;
        return function(b, c,
            d) {
            a.makeScale(b, c, d);
            this.applyMatrix(a);
            return this
        }
    }(),
    lookAt: function() {
        var a = new module$node_modules$three$build$three.default.Object3D;
        return function(b) {
            a.lookAt(b);
            a.updateMatrix();
            this.applyMatrix(a.matrix)
        }
    }(),
    fromBufferGeometry: function(a) {
        function b(a, b, d, e) {
            var f = void 0 !== g ? [p[a].clone(), p[b].clone(), p[d].clone()] : [],
                n = void 0 !== h ? [c.colors[a].clone(), c.colors[b].clone(), c.colors[d].clone()] : [];
            e = new module$node_modules$three$build$three.default.Face3(a, b, d, f, n, e);
            c.faces.push(e);
            void 0 !==
                k && c.faceVertexUvs[0].push([m[a].clone(), m[b].clone(), m[d].clone()]);
            void 0 !== l && c.faceVertexUvs[1].push([q[a].clone(), q[b].clone(), q[d].clone()])
        }
        var c = this,
            d = null !== a.index ? a.index.array : void 0,
            e = a.attributes,
            f = e.position.array,
            g = void 0 !== e.normal ? e.normal.array : void 0,
            h = void 0 !== e.color ? e.color.array : void 0,
            k = void 0 !== e.uv ? e.uv.array : void 0,
            l = void 0 !== e.uv2 ? e.uv2.array : void 0;
        void 0 !== l && (this.faceVertexUvs[1] = []);
        for (var p = [], m = [], q = [], r = e = 0; e < f.length; e += 3, r += 2) c.vertices.push(new module$node_modules$three$build$three.default.Vector3(f[e],
            f[e + 1], f[e + 2])), void 0 !== g && p.push(new module$node_modules$three$build$three.default.Vector3(g[e], g[e + 1], g[e + 2])), void 0 !== h && c.colors.push(new module$node_modules$three$build$three.default.Color(h[e], h[e + 1], h[e + 2])), void 0 !== k && m.push(new module$node_modules$three$build$three.default.Vector2(k[r], k[r + 1])), void 0 !== l && q.push(new module$node_modules$three$build$three.default.Vector2(l[r], l[r + 1]));
        var n = a.groups;
        if (0 < n.length)
            for (e = 0; e < n.length; e++) {
                f = n[e];
                var t = f.start,
                    u = f.count;
                r = t;
                for (t += u; r < t; r +=
                    3) void 0 !== d ? b(d[r], d[r + 1], d[r + 2], f.materialIndex) : b(r, r + 1, r + 2, f.materialIndex)
            } else if (void 0 !== d)
                for (e = 0; e < d.length; e += 3) b(d[e], d[e + 1], d[e + 2]);
            else
                for (e = 0; e < f.length / 3; e += 3) b(e, e + 1, e + 2);
        this.computeFaceNormals();
        null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());
        null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone());
        return this
    },
    center: function() {
        var a = new module$node_modules$three$build$three.default.Vector3;
        return function() {
            this.computeBoundingBox();
            this.boundingBox.getCenter(a).negate();
            this.translate(a.x, a.y, a.z);
            return this
        }
    }(),
    normalize: function() {
        this.computeBoundingSphere();
        var a = this.boundingSphere.center,
            b = this.boundingSphere.radius;
        b = 0 === b ? 1 : 1 / b;
        var c = new module$node_modules$three$build$three.default.Matrix4;
        c.set(b, 0, 0, -b * a.x, 0, b, 0, -b * a.y, 0, 0, b, -b * a.z, 0, 0, 0, 1);
        this.applyMatrix(c);
        return this
    },
    computeFaceNormals: function() {
        for (var a = new module$node_modules$three$build$three.default.Vector3, b = new module$node_modules$three$build$three.default.Vector3, c = 0, d = this.faces.length; c <
            d; c++) {
            var e = this.faces[c],
                f = this.vertices[e.a],
                g = this.vertices[e.b];
            a.subVectors(this.vertices[e.c], g);
            b.subVectors(f, g);
            a.cross(b);
            a.normalize();
            e.normal.copy(a)
        }
    },
    computeVertexNormals: function(a) {
        void 0 === a && (a = !0);
        var b;
        var c = Array(this.vertices.length);
        var d = 0;
        for (b = this.vertices.length; d < b; d++) c[d] = new module$node_modules$three$build$three.default.Vector3;
        if (a) {
            var e = new module$node_modules$three$build$three.default.Vector3,
                f = new module$node_modules$three$build$three.default.Vector3;
            a = 0;
            for (d =
                this.faces.length; a < d; a++) {
                b = this.faces[a];
                var g = this.vertices[b.a];
                var h = this.vertices[b.b];
                var k = this.vertices[b.c];
                e.subVectors(k, h);
                f.subVectors(g, h);
                e.cross(f);
                c[b.a].add(e);
                c[b.b].add(e);
                c[b.c].add(e)
            }
        } else
            for (this.computeFaceNormals(), a = 0, d = this.faces.length; a < d; a++) b = this.faces[a], c[b.a].add(b.normal), c[b.b].add(b.normal), c[b.c].add(b.normal);
        d = 0;
        for (b = this.vertices.length; d < b; d++) c[d].normalize();
        a = 0;
        for (d = this.faces.length; a < d; a++) b = this.faces[a], g = b.vertexNormals, 3 === g.length ? (g[0].copy(c[b.a]),
            g[1].copy(c[b.b]), g[2].copy(c[b.c])) : (g[0] = c[b.a].clone(), g[1] = c[b.b].clone(), g[2] = c[b.c].clone());
        0 < this.faces.length && (this.normalsNeedUpdate = !0)
    },
    computeFlatVertexNormals: function() {
        var a;
        this.computeFaceNormals();
        var b = 0;
        for (a = this.faces.length; b < a; b++) {
            var c = this.faces[b];
            var d = c.vertexNormals;
            3 === d.length ? (d[0].copy(c.normal), d[1].copy(c.normal), d[2].copy(c.normal)) : (d[0] = c.normal.clone(), d[1] = c.normal.clone(), d[2] = c.normal.clone())
        }
        0 < this.faces.length && (this.normalsNeedUpdate = !0)
    },
    computeMorphNormals: function() {
        var a,
            b;
        var c = 0;
        for (b = this.faces.length; c < b; c++) {
            var d = this.faces[c];
            d.__originalFaceNormal ? d.__originalFaceNormal.copy(d.normal) : d.__originalFaceNormal = d.normal.clone();
            d.__originalVertexNormals || (d.__originalVertexNormals = []);
            var e = 0;
            for (a = d.vertexNormals.length; e < a; e++) d.__originalVertexNormals[e] ? d.__originalVertexNormals[e].copy(d.vertexNormals[e]) : d.__originalVertexNormals[e] = d.vertexNormals[e].clone()
        }
        var f = new module$node_modules$three$build$three.default.Geometry;
        f.faces = this.faces;
        e = 0;
        for (a = this.morphTargets.length; e <
            a; e++) {
            if (!this.morphNormals[e]) {
                this.morphNormals[e] = {};
                this.morphNormals[e].faceNormals = [];
                this.morphNormals[e].vertexNormals = [];
                d = this.morphNormals[e].faceNormals;
                var g = this.morphNormals[e].vertexNormals;
                c = 0;
                for (b = this.faces.length; c < b; c++) {
                    var h = new module$node_modules$three$build$three.default.Vector3;
                    var k = {
                        a: new module$node_modules$three$build$three.default.Vector3,
                        b: new module$node_modules$three$build$three.default.Vector3,
                        c: new module$node_modules$three$build$three.default.Vector3
                    };
                    d.push(h);
                    g.push(k)
                }
            }
            g = this.morphNormals[e];
            f.vertices = this.morphTargets[e].vertices;
            f.computeFaceNormals();
            f.computeVertexNormals();
            c = 0;
            for (b = this.faces.length; c < b; c++) d = this.faces[c], h = g.faceNormals[c], k = g.vertexNormals[c], h.copy(d.normal), k.a.copy(d.vertexNormals[0]), k.b.copy(d.vertexNormals[1]), k.c.copy(d.vertexNormals[2])
        }
        c = 0;
        for (b = this.faces.length; c < b; c++) d = this.faces[c], d.normal = d.__originalFaceNormal, d.vertexNormals = d.__originalVertexNormals
    },
    computeBoundingBox: function() {
        null === this.boundingBox &&
            (this.boundingBox = new module$node_modules$three$build$three.default.Box3);
        this.boundingBox.setFromPoints(this.vertices)
    },
    computeBoundingSphere: function() {
        null === this.boundingSphere && (this.boundingSphere = new module$node_modules$three$build$three.default.Sphere);
        this.boundingSphere.setFromPoints(this.vertices)
    },
    merge: function(a, b, c) {
        if (a && a.isGeometry) {
            var d, e = this.vertices.length,
                f = this.vertices,
                g = a.vertices,
                h = this.faces,
                k = a.faces,
                l = this.faceVertexUvs[0],
                p = a.faceVertexUvs[0],
                m = this.colors,
                q = a.colors;
            void 0 === c && (c = 0);
            void 0 !== b && (d = (new module$node_modules$three$build$three.default.Matrix3).getNormalMatrix(b));
            a = 0;
            for (var r = g.length; a < r; a++) {
                var n = g[a].clone();
                void 0 !== b && n.applyMatrix4(b);
                f.push(n)
            }
            a = 0;
            for (r = q.length; a < r; a++) m.push(q[a].clone());
            a = 0;
            for (r = k.length; a < r; a++) {
                g = k[a];
                var t = g.vertexNormals;
                q = g.vertexColors;
                m = new module$node_modules$three$build$three.default.Face3(g.a + e, g.b + e, g.c + e);
                m.normal.copy(g.normal);
                void 0 !== d && m.normal.applyMatrix3(d).normalize();
                b = 0;
                for (f = t.length; b < f; b++) n =
                    t[b].clone(), void 0 !== d && n.applyMatrix3(d).normalize(), m.vertexNormals.push(n);
                m.color.copy(g.color);
                b = 0;
                for (f = q.length; b < f; b++) n = q[b], m.vertexColors.push(n.clone());
                m.materialIndex = g.materialIndex + c;
                h.push(m)
            }
            a = 0;
            for (r = p.length; a < r; a++)
                if (c = p[a], d = [], void 0 !== c) {
                    b = 0;
                    for (f = c.length; b < f; b++) d.push(c[b].clone());
                    l.push(d)
                }
        } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", a)
    },
    mergeMesh: function(a) {
        a && a.isMesh ? (a.matrixAutoUpdate && a.updateMatrix(), this.merge(a.geometry,
            a.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", a)
    },
    mergeVertices: function() {
        var a = {},
            b = [],
            c = [],
            d = Math.pow(10, 4),
            e;
        var f = 0;
        for (e = this.vertices.length; f < e; f++) {
            var g = this.vertices[f];
            g = Math.round(g.x * d) + "_" + Math.round(g.y * d) + "_" + Math.round(g.z * d);
            void 0 === a[g] ? (a[g] = f, b.push(this.vertices[f]), c[f] = b.length - 1) : c[f] = c[a[g]]
        }
        a = [];
        f = 0;
        for (e = this.faces.length; f < e; f++)
            for (d = this.faces[f], d.a = c[d.a], d.b = c[d.b], d.c = c[d.c], d = [d.a, d.b, d.c], g = 0; 3 > g; g++)
                if (d[g] === d[(g +
                        1) % 3]) {
                    a.push(f);
                    break
                }
        for (f = a.length - 1; 0 <= f; f--)
            for (d = a[f], this.faces.splice(d, 1), c = 0, e = this.faceVertexUvs.length; c < e; c++) this.faceVertexUvs[c].splice(d, 1);
        f = this.vertices.length - b.length;
        this.vertices = b;
        return f
    },
    setFromPoints: function(a) {
        this.vertices = [];
        for (var b = 0, c = a.length; b < c; b++) {
            var d = a[b];
            this.vertices.push(new module$node_modules$three$build$three.default.Vector3(d.x, d.y, d.z || 0))
        }
        return this
    },
    sortFacesByMaterialIndex: function() {
        for (var a = this.faces, b = a.length, c = 0; c < b; c++) a[c]._id = c;
        a.sort(function(a,
            b) {
            return a.materialIndex - b.materialIndex
        });
        var d = this.faceVertexUvs[0],
            e = this.faceVertexUvs[1],
            f, g;
        d && d.length === b && (f = []);
        e && e.length === b && (g = []);
        for (c = 0; c < b; c++) {
            var h = a[c]._id;
            f && f.push(d[h]);
            g && g.push(e[h])
        }
        f && (this.faceVertexUvs[0] = f);
        g && (this.faceVertexUvs[1] = g)
    },
    toJSON: function() {
        function a(a, b, c) {
            return c ? a | 1 << b : a & ~(1 << b)
        }

        function b(a) {
            var b = a.x.toString() + a.y.toString() + a.z.toString();
            if (void 0 !== l[b]) return l[b];
            l[b] = k.length / 3;
            k.push(a.x, a.y, a.z);
            return l[b]
        }

        function c(a) {
            var b = a.r.toString() +
                a.g.toString() + a.b.toString();
            if (void 0 !== m[b]) return m[b];
            m[b] = p.length;
            p.push(a.getHex());
            return m[b]
        }

        function d(a) {
            var b = a.x.toString() + a.y.toString();
            if (void 0 !== r[b]) return r[b];
            r[b] = q.length / 2;
            q.push(a.x, a.y);
            return r[b]
        }
        var e = {
            metadata: {
                version: 4.5,
                type: "Geometry",
                generator: "Geometry.toJSON"
            }
        };
        e.uuid = this.uuid;
        e.type = this.type;
        "" !== this.name && (e.name = this.name);
        if (void 0 !== this.parameters) {
            var f = this.parameters,
                g;
            for (g in f) void 0 !== f[g] && (e[g] = f[g]);
            return e
        }
        f = [];
        for (g = 0; g < this.vertices.length; g++) {
            var h =
                this.vertices[g];
            f.push(h.x, h.y, h.z)
        }
        h = [];
        var k = [],
            l = {},
            p = [],
            m = {},
            q = [],
            r = {};
        for (g = 0; g < this.faces.length; g++) {
            var n = this.faces[g],
                t = void 0 !== this.faceVertexUvs[0][g],
                u = 0 < n.normal.length(),
                w = 0 < n.vertexNormals.length,
                v = 1 !== n.color.r || 1 !== n.color.g || 1 !== n.color.b,
                y = 0 < n.vertexColors.length,
                A = 0;
            A = a(A, 0, 0);
            A = a(A, 1, !0);
            A = a(A, 2, !1);
            A = a(A, 3, t);
            A = a(A, 4, u);
            A = a(A, 5, w);
            A = a(A, 6, v);
            A = a(A, 7, y);
            h.push(A);
            h.push(n.a, n.b, n.c);
            h.push(n.materialIndex);
            t && (t = this.faceVertexUvs[0][g], h.push(d(t[0]), d(t[1]), d(t[2])));
            u &&
                h.push(b(n.normal));
            w && (u = n.vertexNormals, h.push(b(u[0]), b(u[1]), b(u[2])));
            v && h.push(c(n.color));
            y && (n = n.vertexColors, h.push(c(n[0]), c(n[1]), c(n[2])))
        }
        e.data = {};
        e.data.vertices = f;
        e.data.normals = k;
        0 < p.length && (e.data.colors = p);
        0 < q.length && (e.data.uvs = [q]);
        e.data.faces = h;
        return e
    },
    clone: function() {
        return (new module$node_modules$three$build$three.default.Geometry).copy(this)
    },
    copy: function(a) {
        var b, c, d;
        this.vertices = [];
        this.colors = [];
        this.faces = [];
        this.faceVertexUvs = [
            []
        ];
        this.morphTargets = [];
        this.morphNormals = [];
        this.skinWeights = [];
        this.skinIndices = [];
        this.lineDistances = [];
        this.boundingSphere = this.boundingBox = null;
        this.name = a.name;
        var e = a.vertices;
        var f = 0;
        for (b = e.length; f < b; f++) this.vertices.push(e[f].clone());
        e = a.colors;
        f = 0;
        for (b = e.length; f < b; f++) this.colors.push(e[f].clone());
        e = a.faces;
        f = 0;
        for (b = e.length; f < b; f++) this.faces.push(e[f].clone());
        f = 0;
        for (b = a.faceVertexUvs.length; f < b; f++) {
            var g = a.faceVertexUvs[f];
            void 0 === this.faceVertexUvs[f] && (this.faceVertexUvs[f] = []);
            e = 0;
            for (c = g.length; e < c; e++) {
                var h =
                    g[e],
                    k = [];
                var l = 0;
                for (d = h.length; l < d; l++) k.push(h[l].clone());
                this.faceVertexUvs[f].push(k)
            }
        }
        l = a.morphTargets;
        f = 0;
        for (b = l.length; f < b; f++) {
            d = {};
            d.name = l[f].name;
            if (void 0 !== l[f].vertices)
                for (d.vertices = [], e = 0, c = l[f].vertices.length; e < c; e++) d.vertices.push(l[f].vertices[e].clone());
            if (void 0 !== l[f].normals)
                for (d.normals = [], e = 0, c = l[f].normals.length; e < c; e++) d.normals.push(l[f].normals[e].clone());
            this.morphTargets.push(d)
        }
        l = a.morphNormals;
        f = 0;
        for (b = l.length; f < b; f++) {
            d = {};
            if (void 0 !== l[f].vertexNormals)
                for (d.vertexNormals = [], e = 0, c = l[f].vertexNormals.length; e < c; e++) g = l[f].vertexNormals[e], h = {}, h.a = g.a.clone(), h.b = g.b.clone(), h.c = g.c.clone(), d.vertexNormals.push(h);
            if (void 0 !== l[f].faceNormals)
                for (d.faceNormals = [], e = 0, c = l[f].faceNormals.length; e < c; e++) d.faceNormals.push(l[f].faceNormals[e].clone());
            this.morphNormals.push(d)
        }
        e = a.skinWeights;
        f = 0;
        for (b = e.length; f < b; f++) this.skinWeights.push(e[f].clone());
        e = a.skinIndices;
        f = 0;
        for (b = e.length; f < b; f++) this.skinIndices.push(e[f].clone());
        e = a.lineDistances;
        f = 0;
        for (b = e.length; f <
            b; f++) this.lineDistances.push(e[f]);
        f = a.boundingBox;
        null !== f && (this.boundingBox = f.clone());
        f = a.boundingSphere;
        null !== f && (this.boundingSphere = f.clone());
        this.elementsNeedUpdate = a.elementsNeedUpdate;
        this.verticesNeedUpdate = a.verticesNeedUpdate;
        this.uvsNeedUpdate = a.uvsNeedUpdate;
        this.normalsNeedUpdate = a.normalsNeedUpdate;
        this.colorsNeedUpdate = a.colorsNeedUpdate;
        this.lineDistancesNeedUpdate = a.lineDistancesNeedUpdate;
        this.groupsNeedUpdate = a.groupsNeedUpdate;
        return this
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
});
Object.defineProperty(module$node_modules$three$build$three.default.BufferAttribute.prototype, "needsUpdate", {
    set: function(a) {
        !0 === a && this.version++
    }
});
Object.assign(module$node_modules$three$build$three.default.BufferAttribute.prototype, {
    isBufferAttribute: !0,
    onUploadCallback: function() {},
    setArray: function(a) {
        if (Array.isArray(a)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.count = void 0 !== a ? a.length / this.itemSize : 0;
        this.array = a;
        return this
    },
    setDynamic: function(a) {
        this.dynamic = a;
        return this
    },
    copy: function(a) {
        this.name = a.name;
        this.array = new a.array.constructor(a.array);
        this.itemSize = a.itemSize;
        this.count = a.count;
        this.normalized = a.normalized;
        this.dynamic = a.dynamic;
        return this
    },
    copyAt: function(a, b, c) {
        a *= this.itemSize;
        c *= b.itemSize;
        for (var d = 0, e = this.itemSize; d < e; d++) this.array[a + d] = b.array[c + d];
        return this
    },
    copyArray: function(a) {
        this.array.set(a);
        return this
    },
    copyColorsArray: function(a) {
        for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
            var f = a[d];
            void 0 === f && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", d), f = new module$node_modules$three$build$three.default.Color);
            b[c++] = f.r;
            b[c++] =
                f.g;
            b[c++] = f.b
        }
        return this
    },
    copyVector2sArray: function(a) {
        for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
            var f = a[d];
            void 0 === f && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", d), f = new module$node_modules$three$build$three.default.Vector2);
            b[c++] = f.x;
            b[c++] = f.y
        }
        return this
    },
    copyVector3sArray: function(a) {
        for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
            var f = a[d];
            void 0 === f && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", d), f = new module$node_modules$three$build$three.default.Vector3);
            b[c++] = f.x;
            b[c++] = f.y;
            b[c++] = f.z
        }
        return this
    },
    copyVector4sArray: function(a) {
        for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
            var f = a[d];
            void 0 === f && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", d), f = new module$node_modules$three$build$three.default.Vector4);
            b[c++] = f.x;
            b[c++] = f.y;
            b[c++] = f.z;
            b[c++] = f.w
        }
        return this
    },
    set: function(a, b) {
        void 0 === b && (b = 0);
        this.array.set(a, b);
        return this
    },
    getX: function(a) {
        return this.array[a * this.itemSize]
    },
    setX: function(a, b) {
        this.array[a *
            this.itemSize] = b;
        return this
    },
    getY: function(a) {
        return this.array[a * this.itemSize + 1]
    },
    setY: function(a, b) {
        this.array[a * this.itemSize + 1] = b;
        return this
    },
    getZ: function(a) {
        return this.array[a * this.itemSize + 2]
    },
    setZ: function(a, b) {
        this.array[a * this.itemSize + 2] = b;
        return this
    },
    getW: function(a) {
        return this.array[a * this.itemSize + 3]
    },
    setW: function(a, b) {
        this.array[a * this.itemSize + 3] = b;
        return this
    },
    setXY: function(a, b, c) {
        a *= this.itemSize;
        this.array[a + 0] = b;
        this.array[a + 1] = c;
        return this
    },
    setXYZ: function(a, b, c, d) {
        a *=
            this.itemSize;
        this.array[a + 0] = b;
        this.array[a + 1] = c;
        this.array[a + 2] = d;
        return this
    },
    setXYZW: function(a, b, c, d, e) {
        a *= this.itemSize;
        this.array[a + 0] = b;
        this.array[a + 1] = c;
        this.array[a + 2] = d;
        this.array[a + 3] = e;
        return this
    },
    onUpload: function(a) {
        this.onUploadCallback = a;
        return this
    },
    clone: function() {
        return (new this.constructor(this.array, this.itemSize)).copy(this)
    }
});
module$node_modules$three$build$three.default.Int8BufferAttribute.prototype = Object.create(module$node_modules$three$build$three.default.BufferAttribute.prototype);
module$node_modules$three$build$three.default.Int8BufferAttribute.prototype.constructor = module$node_modules$three$build$three.default.Int8BufferAttribute;
module$node_modules$three$build$three.default.Uint8BufferAttribute.prototype = Object.create(module$node_modules$three$build$three.default.BufferAttribute.prototype);
module$node_modules$three$build$three.default.Uint8BufferAttribute.prototype.constructor = module$node_modules$three$build$three.default.Uint8BufferAttribute;
module$node_modules$three$build$three.default.Uint8ClampedBufferAttribute.prototype = Object.create(module$node_modules$three$build$three.default.BufferAttribute.prototype);
module$node_modules$three$build$three.default.Uint8ClampedBufferAttribute.prototype.constructor = module$node_modules$three$build$three.default.Uint8ClampedBufferAttribute;
module$node_modules$three$build$three.default.Int16BufferAttribute.prototype = Object.create(module$node_modules$three$build$three.default.BufferAttribute.prototype);
module$node_modules$three$build$three.default.Int16BufferAttribute.prototype.constructor = module$node_modules$three$build$three.default.Int16BufferAttribute;
module$node_modules$three$build$three.default.Uint16BufferAttribute.prototype = Object.create(module$node_modules$three$build$three.default.BufferAttribute.prototype);
module$node_modules$three$build$three.default.Uint16BufferAttribute.prototype.constructor = module$node_modules$three$build$three.default.Uint16BufferAttribute;
module$node_modules$three$build$three.default.Int32BufferAttribute.prototype = Object.create(module$node_modules$three$build$three.default.BufferAttribute.prototype);
module$node_modules$three$build$three.default.Int32BufferAttribute.prototype.constructor = module$node_modules$three$build$three.default.Int32BufferAttribute;
module$node_modules$three$build$three.default.Uint32BufferAttribute.prototype = Object.create(module$node_modules$three$build$three.default.BufferAttribute.prototype);
module$node_modules$three$build$three.default.Uint32BufferAttribute.prototype.constructor = module$node_modules$three$build$three.default.Uint32BufferAttribute;
module$node_modules$three$build$three.default.Float32BufferAttribute.prototype = Object.create(module$node_modules$three$build$three.default.BufferAttribute.prototype);
module$node_modules$three$build$three.default.Float32BufferAttribute.prototype.constructor = module$node_modules$three$build$three.default.Float32BufferAttribute;
module$node_modules$three$build$three.default.Float64BufferAttribute.prototype = Object.create(module$node_modules$three$build$three.default.BufferAttribute.prototype);
module$node_modules$three$build$three.default.Float64BufferAttribute.prototype.constructor = module$node_modules$three$build$three.default.Float64BufferAttribute;

function DirectGeometry$$module$node_modules$three$build$three() {
    this.vertices = [];
    this.normals = [];
    this.colors = [];
    this.uvs = [];
    this.uvs2 = [];
    this.groups = [];
    this.morphTargets = {};
    this.skinWeights = [];
    this.skinIndices = [];
    this.boundingSphere = this.boundingBox = null;
    this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1
}
Object.assign(DirectGeometry$$module$node_modules$three$build$three.prototype, {
    computeGroups: function(a) {
        var b = [],
            c = void 0;
        a = a.faces;
        for (var d = 0; d < a.length; d++) {
            var e = a[d];
            if (e.materialIndex !== c) {
                c = e.materialIndex;
                void 0 !== f && (f.count = 3 * d - f.start, b.push(f));
                var f = {
                    start: 3 * d,
                    materialIndex: c
                }
            }
        }
        void 0 !== f && (f.count = 3 * d - f.start, b.push(f));
        this.groups = b
    },
    fromGeometry: function(a) {
        var b = a.faces,
            c = a.vertices,
            d = a.faceVertexUvs,
            e = d[0] && 0 < d[0].length,
            f = d[1] && 0 < d[1].length,
            g = a.morphTargets,
            h = g.length;
        if (0 < h) {
            var k = [];
            for (var l = 0; l < h; l++) k[l] = [];
            this.morphTargets.position = k
        }
        var p = a.morphNormals,
            m = p.length;
        if (0 < m) {
            var q = [];
            for (l = 0; l < m; l++) q[l] = [];
            this.morphTargets.normal = q
        }
        var r = a.skinIndices,
            n = a.skinWeights,
            t = r.length === c.length,
            u = n.length === c.length;
        0 < c.length && 0 === b.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
        for (l = 0; l < b.length; l++) {
            var w = b[l];
            this.vertices.push(c[w.a], c[w.b], c[w.c]);
            var v = w.vertexNormals;
            3 === v.length ? this.normals.push(v[0], v[1], v[2]) : (v = w.normal,
                this.normals.push(v, v, v));
            v = w.vertexColors;
            3 === v.length ? this.colors.push(v[0], v[1], v[2]) : (v = w.color, this.colors.push(v, v, v));
            !0 === e && (v = d[0][l], void 0 !== v ? this.uvs.push(v[0], v[1], v[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", l), this.uvs.push(new module$node_modules$three$build$three.default.Vector2, new module$node_modules$three$build$three.default.Vector2, new module$node_modules$three$build$three.default.Vector2)));
            !0 === f && (v = d[1][l], void 0 !== v ? this.uvs2.push(v[0],
                v[1], v[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", l), this.uvs2.push(new module$node_modules$three$build$three.default.Vector2, new module$node_modules$three$build$three.default.Vector2, new module$node_modules$three$build$three.default.Vector2)));
            for (v = 0; v < h; v++) {
                var y = g[v].vertices;
                k[v].push(y[w.a], y[w.b], y[w.c])
            }
            for (v = 0; v < m; v++) y = p[v].vertexNormals[l], q[v].push(y.a, y.b, y.c);
            t && this.skinIndices.push(r[w.a], r[w.b], r[w.c]);
            u && this.skinWeights.push(n[w.a], n[w.b], n[w.c])
        }
        this.computeGroups(a);
        this.verticesNeedUpdate = a.verticesNeedUpdate;
        this.normalsNeedUpdate = a.normalsNeedUpdate;
        this.colorsNeedUpdate = a.colorsNeedUpdate;
        this.uvsNeedUpdate = a.uvsNeedUpdate;
        this.groupsNeedUpdate = a.groupsNeedUpdate;
        return this
    }
});

function arrayMax$$module$node_modules$three$build$three(a) {
    if (0 === a.length) return -Infinity;
    for (var b = a[0], c = 1, d = a.length; c < d; ++c) a[c] > b && (b = a[c]);
    return b
}
var bufferGeometryId$$module$node_modules$three$build$three = 1;
module$node_modules$three$build$three.default.BufferGeometry.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.EventDispatcher.prototype), {
    constructor: module$node_modules$three$build$three.default.BufferGeometry,
    isBufferGeometry: !0,
    getIndex: function() {
        return this.index
    },
    setIndex: function(a) {
        Array.isArray(a) ? this.index = new(65535 < arrayMax$$module$node_modules$three$build$three(a) ? module$node_modules$three$build$three.default.Uint32BufferAttribute : module$node_modules$three$build$three.default.Uint16BufferAttribute)(a,
            1) : this.index = a
    },
    addAttribute: function(a, b, c) {
        if (!(b && b.isBufferAttribute || b && b.isInterleavedBufferAttribute)) return console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(a, new module$node_modules$three$build$three.default.BufferAttribute(b, c));
        if ("index" === a) return console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(b), this;
        this.attributes[a] = b;
        return this
    },
    getAttribute: function(a) {
        return this.attributes[a]
    },
    removeAttribute: function(a) {
        delete this.attributes[a];
        return this
    },
    addGroup: function(a, b, c) {
        this.groups.push({
            start: a,
            count: b,
            materialIndex: void 0 !== c ? c : 0
        })
    },
    clearGroups: function() {
        this.groups = []
    },
    setDrawRange: function(a, b) {
        this.drawRange.start = a;
        this.drawRange.count = b
    },
    applyMatrix: function(a) {
        var b = this.attributes.position;
        void 0 !== b && (a.applyToBufferAttribute(b), b.needsUpdate = !0);
        b = this.attributes.normal;
        void 0 !== b && ((new module$node_modules$three$build$three.default.Matrix3).getNormalMatrix(a).applyToBufferAttribute(b),
            b.needsUpdate = !0);
        null !== this.boundingBox && this.computeBoundingBox();
        null !== this.boundingSphere && this.computeBoundingSphere();
        return this
    },
    rotateX: function() {
        var a = new module$node_modules$three$build$three.default.Matrix4;
        return function(b) {
            a.makeRotationX(b);
            this.applyMatrix(a);
            return this
        }
    }(),
    rotateY: function() {
        var a = new module$node_modules$three$build$three.default.Matrix4;
        return function(b) {
            a.makeRotationY(b);
            this.applyMatrix(a);
            return this
        }
    }(),
    rotateZ: function() {
        var a = new module$node_modules$three$build$three.default.Matrix4;
        return function(b) {
            a.makeRotationZ(b);
            this.applyMatrix(a);
            return this
        }
    }(),
    translate: function() {
        var a = new module$node_modules$three$build$three.default.Matrix4;
        return function(b, c, d) {
            a.makeTranslation(b, c, d);
            this.applyMatrix(a);
            return this
        }
    }(),
    scale: function() {
        var a = new module$node_modules$three$build$three.default.Matrix4;
        return function(b, c, d) {
            a.makeScale(b, c, d);
            this.applyMatrix(a);
            return this
        }
    }(),
    lookAt: function() {
        var a = new module$node_modules$three$build$three.default.Object3D;
        return function(b) {
            a.lookAt(b);
            a.updateMatrix();
            this.applyMatrix(a.matrix)
        }
    }(),
    center: function() {
        var a = new module$node_modules$three$build$three.default.Vector3;
        return function() {
            this.computeBoundingBox();
            this.boundingBox.getCenter(a).negate();
            this.translate(a.x, a.y, a.z);
            return this
        }
    }(),
    setFromObject: function(a) {
        var b = a.geometry;
        if (a.isPoints || a.isLine) {
            a = new module$node_modules$three$build$three.default.Float32BufferAttribute(3 * b.vertices.length, 3);
            var c = new module$node_modules$three$build$three.default.Float32BufferAttribute(3 *
                b.colors.length, 3);
            this.addAttribute("position", a.copyVector3sArray(b.vertices));
            this.addAttribute("color", c.copyColorsArray(b.colors));
            b.lineDistances && b.lineDistances.length === b.vertices.length && (a = new module$node_modules$three$build$three.default.Float32BufferAttribute(b.lineDistances.length, 1), this.addAttribute("lineDistance", a.copyArray(b.lineDistances)));
            null !== b.boundingSphere && (this.boundingSphere = b.boundingSphere.clone());
            null !== b.boundingBox && (this.boundingBox = b.boundingBox.clone())
        } else a.isMesh &&
            b && b.isGeometry && this.fromGeometry(b);
        return this
    },
    setFromPoints: function(a) {
        for (var b = [], c = 0, d = a.length; c < d; c++) {
            var e = a[c];
            b.push(e.x, e.y, e.z || 0)
        }
        this.addAttribute("position", new module$node_modules$three$build$three.default.Float32BufferAttribute(b, 3));
        return this
    },
    updateFromObject: function(a) {
        var b = a.geometry;
        if (a.isMesh) {
            var c = b.__directGeometry;
            !0 === b.elementsNeedUpdate && (c = void 0, b.elementsNeedUpdate = !1);
            if (void 0 === c) return this.fromGeometry(b);
            c.verticesNeedUpdate = b.verticesNeedUpdate;
            c.normalsNeedUpdate =
                b.normalsNeedUpdate;
            c.colorsNeedUpdate = b.colorsNeedUpdate;
            c.uvsNeedUpdate = b.uvsNeedUpdate;
            c.groupsNeedUpdate = b.groupsNeedUpdate;
            b.verticesNeedUpdate = !1;
            b.normalsNeedUpdate = !1;
            b.colorsNeedUpdate = !1;
            b.uvsNeedUpdate = !1;
            b.groupsNeedUpdate = !1;
            b = c
        }!0 === b.verticesNeedUpdate && (c = this.attributes.position, void 0 !== c && (c.copyVector3sArray(b.vertices), c.needsUpdate = !0), b.verticesNeedUpdate = !1);
        !0 === b.normalsNeedUpdate && (c = this.attributes.normal, void 0 !== c && (c.copyVector3sArray(b.normals), c.needsUpdate = !0), b.normalsNeedUpdate = !1);
        !0 === b.colorsNeedUpdate && (c = this.attributes.color, void 0 !== c && (c.copyColorsArray(b.colors), c.needsUpdate = !0), b.colorsNeedUpdate = !1);
        b.uvsNeedUpdate && (c = this.attributes.uv, void 0 !== c && (c.copyVector2sArray(b.uvs), c.needsUpdate = !0), b.uvsNeedUpdate = !1);
        b.lineDistancesNeedUpdate && (c = this.attributes.lineDistance, void 0 !== c && (c.copyArray(b.lineDistances), c.needsUpdate = !0), b.lineDistancesNeedUpdate = !1);
        b.groupsNeedUpdate && (b.computeGroups(a.geometry), this.groups = b.groups, b.groupsNeedUpdate = !1);
        return this
    },
    fromGeometry: function(a) {
        a.__directGeometry = (new DirectGeometry$$module$node_modules$three$build$three).fromGeometry(a);
        return this.fromDirectGeometry(a.__directGeometry)
    },
    fromDirectGeometry: function(a) {
        var b = new Float32Array(3 * a.vertices.length);
        this.addAttribute("position", (new module$node_modules$three$build$three.default.BufferAttribute(b, 3)).copyVector3sArray(a.vertices));
        0 < a.normals.length && (b = new Float32Array(3 * a.normals.length), this.addAttribute("normal", (new module$node_modules$three$build$three.default.BufferAttribute(b,
            3)).copyVector3sArray(a.normals)));
        0 < a.colors.length && (b = new Float32Array(3 * a.colors.length), this.addAttribute("color", (new module$node_modules$three$build$three.default.BufferAttribute(b, 3)).copyColorsArray(a.colors)));
        0 < a.uvs.length && (b = new Float32Array(2 * a.uvs.length), this.addAttribute("uv", (new module$node_modules$three$build$three.default.BufferAttribute(b, 2)).copyVector2sArray(a.uvs)));
        0 < a.uvs2.length && (b = new Float32Array(2 * a.uvs2.length), this.addAttribute("uv2", (new module$node_modules$three$build$three.default.BufferAttribute(b,
            2)).copyVector2sArray(a.uvs2)));
        this.groups = a.groups;
        for (var c in a.morphTargets) {
            b = [];
            for (var d = a.morphTargets[c], e = 0, f = d.length; e < f; e++) {
                var g = d[e],
                    h = new module$node_modules$three$build$three.default.Float32BufferAttribute(3 * g.length, 3);
                b.push(h.copyVector3sArray(g))
            }
            this.morphAttributes[c] = b
        }
        0 < a.skinIndices.length && (c = new module$node_modules$three$build$three.default.Float32BufferAttribute(4 * a.skinIndices.length, 4), this.addAttribute("skinIndex", c.copyVector4sArray(a.skinIndices)));
        0 < a.skinWeights.length &&
            (c = new module$node_modules$three$build$three.default.Float32BufferAttribute(4 * a.skinWeights.length, 4), this.addAttribute("skinWeight", c.copyVector4sArray(a.skinWeights)));
        null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone());
        null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());
        return this
    },
    computeBoundingBox: function() {
        null === this.boundingBox && (this.boundingBox = new module$node_modules$three$build$three.default.Box3);
        var a = this.attributes.position;
        void 0 !== a ? this.boundingBox.setFromBufferAttribute(a) :
            this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    },
    computeBoundingSphere: function() {
        var a = new module$node_modules$three$build$three.default.Box3,
            b = new module$node_modules$three$build$three.default.Vector3;
        return function() {
            null === this.boundingSphere && (this.boundingSphere = new module$node_modules$three$build$three.default.Sphere);
            var c = this.attributes.position;
            if (c) {
                var d = this.boundingSphere.center;
                a.setFromBufferAttribute(c);
                a.getCenter(d);
                for (var e = 0, f = 0, g = c.count; f < g; f++) b.x = c.getX(f), b.y = c.getY(f), b.z = c.getZ(f), e = Math.max(e, d.distanceToSquared(b));
                this.boundingSphere.radius = Math.sqrt(e);
                isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
            }
        }
    }(),
    computeFaceNormals: function() {},
    computeVertexNormals: function() {
        var a =
            this.index,
            b = this.attributes,
            c = this.groups;
        if (b.position) {
            var d = b.position.array;
            if (void 0 === b.normal) this.addAttribute("normal", new module$node_modules$three$build$three.default.BufferAttribute(new Float32Array(d.length), 3));
            else
                for (var e = b.normal.array, f = 0, g = e.length; f < g; f++) e[f] = 0;
            e = b.normal.array;
            var h = new module$node_modules$three$build$three.default.Vector3,
                k = new module$node_modules$three$build$three.default.Vector3,
                l = new module$node_modules$three$build$three.default.Vector3,
                p = new module$node_modules$three$build$three.default.Vector3,
                m = new module$node_modules$three$build$three.default.Vector3;
            if (a) {
                a = a.array;
                0 === c.length && this.addGroup(0, a.length);
                for (var q = 0, r = c.length; q < r; ++q) {
                    f = c[q];
                    g = f.start;
                    var n = f.count;
                    f = g;
                    for (g += n; f < g; f += 3) {
                        n = 3 * a[f + 0];
                        var t = 3 * a[f + 1];
                        var u = 3 * a[f + 2];
                        h.fromArray(d, n);
                        k.fromArray(d, t);
                        l.fromArray(d, u);
                        p.subVectors(l, k);
                        m.subVectors(h, k);
                        p.cross(m);
                        e[n] += p.x;
                        e[n + 1] += p.y;
                        e[n + 2] += p.z;
                        e[t] += p.x;
                        e[t + 1] += p.y;
                        e[t + 2] += p.z;
                        e[u] += p.x;
                        e[u + 1] += p.y;
                        e[u + 2] += p.z
                    }
                }
            } else
                for (f = 0, g = d.length; f < g; f += 9) h.fromArray(d, f), k.fromArray(d,
                    f + 3), l.fromArray(d, f + 6), p.subVectors(l, k), m.subVectors(h, k), p.cross(m), e[f] = p.x, e[f + 1] = p.y, e[f + 2] = p.z, e[f + 3] = p.x, e[f + 4] = p.y, e[f + 5] = p.z, e[f + 6] = p.x, e[f + 7] = p.y, e[f + 8] = p.z;
            this.normalizeNormals();
            b.normal.needsUpdate = !0
        }
    },
    merge: function(a, b) {
        if (a && a.isBufferGeometry) {
            void 0 === b && (b = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
            var c = this.attributes,
                d;
            for (d in c)
                if (void 0 !== a.attributes[d]) {
                    var e =
                        c[d].array,
                        f = a.attributes[d],
                        g = f.array,
                        h = 0;
                    for (f = f.itemSize * b; h < g.length; h++, f++) e[f] = g[h]
                }
            return this
        }
        console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", a)
    },
    normalizeNormals: function() {
        var a = new module$node_modules$three$build$three.default.Vector3;
        return function() {
            for (var b = this.attributes.normal, c = 0, d = b.count; c < d; c++) a.x = b.getX(c), a.y = b.getY(c), a.z = b.getZ(c), a.normalize(), b.setXYZ(c, a.x, a.y, a.z)
        }
    }(),
    toNonIndexed: function() {
        if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."),
            this;
        var a = new module$node_modules$three$build$three.default.BufferGeometry,
            b = this.index.array,
            c = this.attributes,
            d;
        for (d in c) {
            var e = c[d],
                f = e.array,
                g = e.itemSize,
                h = new f.constructor(b.length * g),
                k = 0;
            e = 0;
            for (var l = b.length; e < l; e++) {
                var p = b[e] * g;
                for (var m = 0; m < g; m++) h[k++] = f[p++]
            }
            a.addAttribute(d, new module$node_modules$three$build$three.default.BufferAttribute(h, g))
        }
        b = this.groups;
        e = 0;
        for (l = b.length; e < l; e++) c = b[e], a.addGroup(c.start, c.count, c.materialIndex);
        return a
    },
    toJSON: function() {
        var a = {
            metadata: {
                version: 4.5,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        a.uuid = this.uuid;
        a.type = this.type;
        "" !== this.name && (a.name = this.name);
        0 < Object.keys(this.userData).length && (a.userData = this.userData);
        if (void 0 !== this.parameters) {
            var b = this.parameters;
            for (e in b) void 0 !== b[e] && (a[e] = b[e]);
            return a
        }
        a.data = {
            attributes: {}
        };
        var c = this.index;
        null !== c && (b = Array.prototype.slice.call(c.array), a.data.index = {
            type: c.array.constructor.name,
            array: b
        });
        c = this.attributes;
        for (e in c) {
            var d = c[e];
            b = Array.prototype.slice.call(d.array);
            a.data.attributes[e] = {
                itemSize: d.itemSize,
                type: d.array.constructor.name,
                array: b,
                normalized: d.normalized
            }
        }
        var e = this.groups;
        0 < e.length && (a.data.groups = JSON.parse(JSON.stringify(e)));
        e = this.boundingSphere;
        null !== e && (a.data.boundingSphere = {
            center: e.center.toArray(),
            radius: e.radius
        });
        return a
    },
    clone: function() {
        return (new module$node_modules$three$build$three.default.BufferGeometry).copy(this)
    },
    copy: function(a) {
        var b;
        this.index = null;
        this.attributes = {};
        this.morphAttributes = {};
        this.groups = [];
        this.boundingSphere =
            this.boundingBox = null;
        this.name = a.name;
        var c = a.index;
        null !== c && this.setIndex(c.clone());
        c = a.attributes;
        for (g in c) this.addAttribute(g, c[g].clone());
        var d = a.morphAttributes;
        for (g in d) {
            var e = [],
                f = d[g];
            c = 0;
            for (b = f.length; c < b; c++) e.push(f[c].clone());
            this.morphAttributes[g] = e
        }
        var g = a.groups;
        c = 0;
        for (b = g.length; c < b; c++) d = g[c], this.addGroup(d.start, d.count, d.materialIndex);
        g = a.boundingBox;
        null !== g && (this.boundingBox = g.clone());
        g = a.boundingSphere;
        null !== g && (this.boundingSphere = g.clone());
        this.drawRange.start =
            a.drawRange.start;
        this.drawRange.count = a.drawRange.count;
        this.userData = a.userData;
        return this
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
});
module$node_modules$three$build$three.default.BoxGeometry.prototype = Object.create(module$node_modules$three$build$three.default.Geometry.prototype);
module$node_modules$three$build$three.default.BoxGeometry.prototype.constructor = module$node_modules$three$build$three.default.BoxGeometry;
module$node_modules$three$build$three.default.BoxBufferGeometry.prototype = Object.create(module$node_modules$three$build$three.default.BufferGeometry.prototype);
module$node_modules$three$build$three.default.BoxBufferGeometry.prototype.constructor = module$node_modules$three$build$three.default.BoxBufferGeometry;
module$node_modules$three$build$three.default.PlaneGeometry.prototype = Object.create(module$node_modules$three$build$three.default.Geometry.prototype);
module$node_modules$three$build$three.default.PlaneGeometry.prototype.constructor = module$node_modules$three$build$three.default.PlaneGeometry;
module$node_modules$three$build$three.default.PlaneBufferGeometry.prototype = Object.create(module$node_modules$three$build$three.default.BufferGeometry.prototype);
module$node_modules$three$build$three.default.PlaneBufferGeometry.prototype.constructor = module$node_modules$three$build$three.default.PlaneBufferGeometry;
var materialId$$module$node_modules$three$build$three = 0;
module$node_modules$three$build$three.default.Material.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.EventDispatcher.prototype), {
    constructor: module$node_modules$three$build$three.default.Material,
    isMaterial: !0,
    onBeforeCompile: function() {},
    setValues: function(a) {
        if (void 0 !== a)
            for (var b in a) {
                var c = a[b];
                if (void 0 === c) console.warn("THREE.Material: '" + b + "' parameter is undefined.");
                else if ("shading" === b) console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                    this.flatShading = c === module$node_modules$three$build$three.default.FlatShading ? !0 : !1;
                else {
                    var d = this[b];
                    void 0 === d ? console.warn("THREE." + this.type + ": '" + b + "' is not a property of this material.") : d && d.isColor ? d.set(c) : d && d.isVector3 && c && c.isVector3 ? d.copy(c) : this[b] = "overdraw" === b ? Number(c) : c
                }
            }
    },
    toJSON: function(a) {
        function b(a) {
            var b = [],
                c;
            for (c in a) {
                var d = a[c];
                delete d.metadata;
                b.push(d)
            }
            return b
        }
        var c = void 0 === a || "string" === typeof a;
        c && (a = {
            textures: {},
            images: {}
        });
        var d = {
            metadata: {
                version: 4.5,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        d.uuid = this.uuid;
        d.type = this.type;
        "" !== this.name && (d.name = this.name);
        this.color && this.color.isColor && (d.color = this.color.getHex());
        void 0 !== this.roughness && (d.roughness = this.roughness);
        void 0 !== this.metalness && (d.metalness = this.metalness);
        this.emissive && this.emissive.isColor && (d.emissive = this.emissive.getHex());
        1 !== this.emissiveIntensity && (d.emissiveIntensity = this.emissiveIntensity);
        this.specular && this.specular.isColor && (d.specular = this.specular.getHex());
        void 0 !== this.shininess &&
            (d.shininess = this.shininess);
        void 0 !== this.clearCoat && (d.clearCoat = this.clearCoat);
        void 0 !== this.clearCoatRoughness && (d.clearCoatRoughness = this.clearCoatRoughness);
        this.map && this.map.isTexture && (d.map = this.map.toJSON(a).uuid);
        this.alphaMap && this.alphaMap.isTexture && (d.alphaMap = this.alphaMap.toJSON(a).uuid);
        this.lightMap && this.lightMap.isTexture && (d.lightMap = this.lightMap.toJSON(a).uuid);
        this.aoMap && this.aoMap.isTexture && (d.aoMap = this.aoMap.toJSON(a).uuid, d.aoMapIntensity = this.aoMapIntensity);
        this.bumpMap &&
            this.bumpMap.isTexture && (d.bumpMap = this.bumpMap.toJSON(a).uuid, d.bumpScale = this.bumpScale);
        this.normalMap && this.normalMap.isTexture && (d.normalMap = this.normalMap.toJSON(a).uuid, d.normalMapType = this.normalMapType, d.normalScale = this.normalScale.toArray());
        this.displacementMap && this.displacementMap.isTexture && (d.displacementMap = this.displacementMap.toJSON(a).uuid, d.displacementScale = this.displacementScale, d.displacementBias = this.displacementBias);
        this.roughnessMap && this.roughnessMap.isTexture && (d.roughnessMap =
            this.roughnessMap.toJSON(a).uuid);
        this.metalnessMap && this.metalnessMap.isTexture && (d.metalnessMap = this.metalnessMap.toJSON(a).uuid);
        this.emissiveMap && this.emissiveMap.isTexture && (d.emissiveMap = this.emissiveMap.toJSON(a).uuid);
        this.specularMap && this.specularMap.isTexture && (d.specularMap = this.specularMap.toJSON(a).uuid);
        this.envMap && this.envMap.isTexture && (d.envMap = this.envMap.toJSON(a).uuid, d.reflectivity = this.reflectivity);
        this.gradientMap && this.gradientMap.isTexture && (d.gradientMap = this.gradientMap.toJSON(a).uuid);
        void 0 !== this.size && (d.size = this.size);
        void 0 !== this.sizeAttenuation && (d.sizeAttenuation = this.sizeAttenuation);
        this.blending !== module$node_modules$three$build$three.default.NormalBlending && (d.blending = this.blending);
        !0 === this.flatShading && (d.flatShading = this.flatShading);
        this.side !== module$node_modules$three$build$three.default.FrontSide && (d.side = this.side);
        this.vertexColors !== module$node_modules$three$build$three.default.NoColors && (d.vertexColors = this.vertexColors);
        1 > this.opacity && (d.opacity = this.opacity);
        !0 === this.transparent && (d.transparent = this.transparent);
        d.depthFunc = this.depthFunc;
        d.depthTest = this.depthTest;
        d.depthWrite = this.depthWrite;
        0 !== this.rotation && (d.rotation = this.rotation);
        1 !== this.linewidth && (d.linewidth = this.linewidth);
        void 0 !== this.dashSize && (d.dashSize = this.dashSize);
        void 0 !== this.gapSize && (d.gapSize = this.gapSize);
        void 0 !== this.scale && (d.scale = this.scale);
        !0 === this.dithering && (d.dithering = !0);
        0 < this.alphaTest && (d.alphaTest = this.alphaTest);
        !0 === this.premultipliedAlpha && (d.premultipliedAlpha =
            this.premultipliedAlpha);
        !0 === this.wireframe && (d.wireframe = this.wireframe);
        1 < this.wireframeLinewidth && (d.wireframeLinewidth = this.wireframeLinewidth);
        "round" !== this.wireframeLinecap && (d.wireframeLinecap = this.wireframeLinecap);
        "round" !== this.wireframeLinejoin && (d.wireframeLinejoin = this.wireframeLinejoin);
        !0 === this.morphTargets && (d.morphTargets = !0);
        !0 === this.skinning && (d.skinning = !0);
        !1 === this.visible && (d.visible = !1);
        "{}" !== JSON.stringify(this.userData) && (d.userData = this.userData);
        c && (c = b(a.textures),
            a = b(a.images), 0 < c.length && (d.textures = c), 0 < a.length && (d.images = a));
        return d
    },
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(a) {
        this.name = a.name;
        this.fog = a.fog;
        this.lights = a.lights;
        this.blending = a.blending;
        this.side = a.side;
        this.flatShading = a.flatShading;
        this.vertexColors = a.vertexColors;
        this.opacity = a.opacity;
        this.transparent = a.transparent;
        this.blendSrc = a.blendSrc;
        this.blendDst = a.blendDst;
        this.blendEquation = a.blendEquation;
        this.blendSrcAlpha = a.blendSrcAlpha;
        this.blendDstAlpha =
            a.blendDstAlpha;
        this.blendEquationAlpha = a.blendEquationAlpha;
        this.depthFunc = a.depthFunc;
        this.depthTest = a.depthTest;
        this.depthWrite = a.depthWrite;
        this.colorWrite = a.colorWrite;
        this.precision = a.precision;
        this.polygonOffset = a.polygonOffset;
        this.polygonOffsetFactor = a.polygonOffsetFactor;
        this.polygonOffsetUnits = a.polygonOffsetUnits;
        this.dithering = a.dithering;
        this.alphaTest = a.alphaTest;
        this.premultipliedAlpha = a.premultipliedAlpha;
        this.overdraw = a.overdraw;
        this.visible = a.visible;
        this.userData = JSON.parse(JSON.stringify(a.userData));
        this.clipShadows = a.clipShadows;
        this.clipIntersection = a.clipIntersection;
        var b = a.clippingPlanes,
            c = null;
        if (null !== b) {
            var d = b.length;
            c = Array(d);
            for (var e = 0; e !== d; ++e) c[e] = b[e].clone()
        }
        this.clippingPlanes = c;
        this.shadowSide = a.shadowSide;
        return this
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
});
module$node_modules$three$build$three.default.MeshBasicMaterial.prototype = Object.create(module$node_modules$three$build$three.default.Material.prototype);
module$node_modules$three$build$three.default.MeshBasicMaterial.prototype.constructor = module$node_modules$three$build$three.default.MeshBasicMaterial;
module$node_modules$three$build$three.default.MeshBasicMaterial.prototype.isMeshBasicMaterial = !0;
module$node_modules$three$build$three.default.MeshBasicMaterial.prototype.copy = function(a) {
    module$node_modules$three$build$three.default.Material.prototype.copy.call(this, a);
    this.color.copy(a.color);
    this.map = a.map;
    this.lightMap = a.lightMap;
    this.lightMapIntensity = a.lightMapIntensity;
    this.aoMap = a.aoMap;
    this.aoMapIntensity = a.aoMapIntensity;
    this.specularMap = a.specularMap;
    this.alphaMap = a.alphaMap;
    this.envMap = a.envMap;
    this.combine = a.combine;
    this.reflectivity = a.reflectivity;
    this.refractionRatio = a.refractionRatio;
    this.wireframe = a.wireframe;
    this.wireframeLinewidth = a.wireframeLinewidth;
    this.wireframeLinecap = a.wireframeLinecap;
    this.wireframeLinejoin = a.wireframeLinejoin;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    return this
};
module$node_modules$three$build$three.default.ShaderMaterial.prototype = Object.create(module$node_modules$three$build$three.default.Material.prototype);
module$node_modules$three$build$three.default.ShaderMaterial.prototype.constructor = module$node_modules$three$build$three.default.ShaderMaterial;
module$node_modules$three$build$three.default.ShaderMaterial.prototype.isShaderMaterial = !0;
module$node_modules$three$build$three.default.ShaderMaterial.prototype.copy = function(a) {
    module$node_modules$three$build$three.default.Material.prototype.copy.call(this, a);
    this.fragmentShader = a.fragmentShader;
    this.vertexShader = a.vertexShader;
    this.uniforms = module$node_modules$three$build$three.default.UniformsUtils.clone(a.uniforms);
    this.defines = Object.assign({}, a.defines);
    this.wireframe = a.wireframe;
    this.wireframeLinewidth = a.wireframeLinewidth;
    this.lights = a.lights;
    this.clipping = a.clipping;
    this.skinning =
        a.skinning;
    this.morphTargets = a.morphTargets;
    this.morphNormals = a.morphNormals;
    this.extensions = a.extensions;
    return this
};
module$node_modules$three$build$three.default.ShaderMaterial.prototype.toJSON = function(a) {
    a = module$node_modules$three$build$three.default.Material.prototype.toJSON.call(this, a);
    a.uniforms = this.uniforms;
    a.vertexShader = this.vertexShader;
    a.fragmentShader = this.fragmentShader;
    return a
};
Object.assign(module$node_modules$three$build$three.default.Ray.prototype, {
    set: function(a, b) {
        this.origin.copy(a);
        this.direction.copy(b);
        return this
    },
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(a) {
        this.origin.copy(a.origin);
        this.direction.copy(a.direction);
        return this
    },
    at: function(a, b) {
        void 0 === b && (console.warn("THREE.Ray: .at() target is now required"), b = new module$node_modules$three$build$three.default.Vector3);
        return b.copy(this.direction).multiplyScalar(a).add(this.origin)
    },
    lookAt: function(a) {
        this.direction.copy(a).sub(this.origin).normalize();
        return this
    },
    recast: function() {
        var a = new module$node_modules$three$build$three.default.Vector3;
        return function(b) {
            this.origin.copy(this.at(b, a));
            return this
        }
    }(),
    closestPointToPoint: function(a, b) {
        void 0 === b && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), b = new module$node_modules$three$build$three.default.Vector3);
        b.subVectors(a, this.origin);
        a = b.dot(this.direction);
        return 0 > a ? b.copy(this.origin) : b.copy(this.direction).multiplyScalar(a).add(this.origin)
    },
    distanceToPoint: function(a) {
        return Math.sqrt(this.distanceSqToPoint(a))
    },
    distanceSqToPoint: function() {
        var a = new module$node_modules$three$build$three.default.Vector3;
        return function(b) {
            var c = a.subVectors(b, this.origin).dot(this.direction);
            if (0 > c) return this.origin.distanceToSquared(b);
            a.copy(this.direction).multiplyScalar(c).add(this.origin);
            return a.distanceToSquared(b)
        }
    }(),
    distanceSqToSegment: function() {
        var a = new module$node_modules$three$build$three.default.Vector3,
            b = new module$node_modules$three$build$three.default.Vector3,
            c = new module$node_modules$three$build$three.default.Vector3;
        return function(d, e, f, g) {
            a.copy(d).add(e).multiplyScalar(.5);
            b.copy(e).sub(d).normalize();
            c.copy(this.origin).sub(a);
            var h = .5 * d.distanceTo(e),
                k = -this.direction.dot(b),
                l = c.dot(this.direction),
                p = -c.dot(b),
                m = c.lengthSq(),
                q = Math.abs(1 - k * k);
            if (0 < q) {
                d = k * p - l;
                e = k * l - p;
                var r = h * q;
                0 <= d ? e >= -r ? e <= r ? (h = 1 / q, d *= h, e *= h, k = d * (d + k * e + 2 * l) + e * (k * d + e + 2 * p) + m) : (e = h, d = Math.max(0, -(k * e + l)), k = -d * d + e * (e + 2 * p) + m) : (e = -h, d = Math.max(0, -(k * e + l)), k = -d * d + e * (e + 2 * p) + m) : e <= -r ? (d =
                    Math.max(0, -(-k * h + l)), e = 0 < d ? -h : Math.min(Math.max(-h, -p), h), k = -d * d + e * (e + 2 * p) + m) : e <= r ? (d = 0, e = Math.min(Math.max(-h, -p), h), k = e * (e + 2 * p) + m) : (d = Math.max(0, -(k * h + l)), e = 0 < d ? h : Math.min(Math.max(-h, -p), h), k = -d * d + e * (e + 2 * p) + m)
            } else e = 0 < k ? -h : h, d = Math.max(0, -(k * e + l)), k = -d * d + e * (e + 2 * p) + m;
            f && f.copy(this.direction).multiplyScalar(d).add(this.origin);
            g && g.copy(b).multiplyScalar(e).add(a);
            return k
        }
    }(),
    intersectSphere: function() {
        var a = new module$node_modules$three$build$three.default.Vector3;
        return function(b, c) {
            a.subVectors(b.center,
                this.origin);
            var d = a.dot(this.direction),
                e = a.dot(a) - d * d;
            b = b.radius * b.radius;
            if (e > b) return null;
            b = Math.sqrt(b - e);
            e = d - b;
            d += b;
            return 0 > e && 0 > d ? null : 0 > e ? this.at(d, c) : this.at(e, c)
        }
    }(),
    intersectsSphere: function(a) {
        return this.distanceToPoint(a.center) <= a.radius
    },
    distanceToPlane: function(a) {
        var b = a.normal.dot(this.direction);
        if (0 === b) return 0 === a.distanceToPoint(this.origin) ? 0 : null;
        a = -(this.origin.dot(a.normal) + a.constant) / b;
        return 0 <= a ? a : null
    },
    intersectPlane: function(a, b) {
        a = this.distanceToPlane(a);
        return null ===
            a ? null : this.at(a, b)
    },
    intersectsPlane: function(a) {
        var b = a.distanceToPoint(this.origin);
        return 0 === b || 0 > a.normal.dot(this.direction) * b ? !0 : !1
    },
    intersectBox: function(a, b) {
        var c = 1 / this.direction.x;
        var d = 1 / this.direction.y;
        var e = 1 / this.direction.z,
            f = this.origin;
        if (0 <= c) {
            var g = (a.min.x - f.x) * c;
            c *= a.max.x - f.x
        } else g = (a.max.x - f.x) * c, c *= a.min.x - f.x;
        if (0 <= d) {
            var h = (a.min.y - f.y) * d;
            d *= a.max.y - f.y
        } else h = (a.max.y - f.y) * d, d *= a.min.y - f.y;
        if (g > d || h > c) return null;
        if (h > g || g !== g) g = h;
        if (d < c || c !== c) c = d;
        0 <= e ? (h = (a.min.z -
            f.z) * e, a = (a.max.z - f.z) * e) : (h = (a.max.z - f.z) * e, a = (a.min.z - f.z) * e);
        if (g > a || h > c) return null;
        if (h > g || g !== g) g = h;
        if (a < c || c !== c) c = a;
        return 0 > c ? null : this.at(0 <= g ? g : c, b)
    },
    intersectsBox: function() {
        var a = new module$node_modules$three$build$three.default.Vector3;
        return function(b) {
            return null !== this.intersectBox(b, a)
        }
    }(),
    intersectTriangle: function() {
        var a = new module$node_modules$three$build$three.default.Vector3,
            b = new module$node_modules$three$build$three.default.Vector3,
            c = new module$node_modules$three$build$three.default.Vector3,
            d = new module$node_modules$three$build$three.default.Vector3;
        return function(e, f, g, h, k) {
            b.subVectors(f, e);
            c.subVectors(g, e);
            d.crossVectors(b, c);
            f = this.direction.dot(d);
            if (0 < f) {
                if (h) return null;
                h = 1
            } else if (0 > f) h = -1, f = -f;
            else return null;
            a.subVectors(this.origin, e);
            e = h * this.direction.dot(c.crossVectors(a, c));
            if (0 > e) return null;
            g = h * this.direction.dot(b.cross(a));
            if (0 > g || e + g > f) return null;
            e = -h * a.dot(d);
            return 0 > e ? null : this.at(e / f, k)
        }
    }(),
    applyMatrix4: function(a) {
        this.origin.applyMatrix4(a);
        this.direction.transformDirection(a);
        return this
    },
    equals: function(a) {
        return a.origin.equals(this.origin) && a.direction.equals(this.direction)
    }
});
Object.assign(module$node_modules$three$build$three.default.Triangle, {
    getNormal: function() {
        var a = new module$node_modules$three$build$three.default.Vector3;
        return function(b, c, d, e) {
            void 0 === e && (console.warn("THREE.Triangle: .getNormal() target is now required"), e = new module$node_modules$three$build$three.default.Vector3);
            e.subVectors(d, c);
            a.subVectors(b, c);
            e.cross(a);
            b = e.lengthSq();
            return 0 < b ? e.multiplyScalar(1 / Math.sqrt(b)) : e.set(0, 0, 0)
        }
    }(),
    getBarycoord: function() {
        var a = new module$node_modules$three$build$three.default.Vector3,
            b = new module$node_modules$three$build$three.default.Vector3,
            c = new module$node_modules$three$build$three.default.Vector3;
        return function(d, e, f, g, h) {
            a.subVectors(g, e);
            b.subVectors(f, e);
            c.subVectors(d, e);
            d = a.dot(a);
            e = a.dot(b);
            f = a.dot(c);
            var k = b.dot(b);
            g = b.dot(c);
            var l = d * k - e * e;
            void 0 === h && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), h = new module$node_modules$three$build$three.default.Vector3);
            if (0 === l) return h.set(-2, -1, -1);
            l = 1 / l;
            k = (k * f - e * g) * l;
            d = (d * g - e * f) * l;
            return h.set(1 - k -
                d, d, k)
        }
    }(),
    containsPoint: function() {
        var a = new module$node_modules$three$build$three.default.Vector3;
        return function(b, c, d, e) {
            module$node_modules$three$build$three.default.Triangle.getBarycoord(b, c, d, e, a);
            return 0 <= a.x && 0 <= a.y && 1 >= a.x + a.y
        }
    }()
});
Object.assign(module$node_modules$three$build$three.default.Triangle.prototype, {
    set: function(a, b, c) {
        this.a.copy(a);
        this.b.copy(b);
        this.c.copy(c);
        return this
    },
    setFromPointsAndIndices: function(a, b, c, d) {
        this.a.copy(a[b]);
        this.b.copy(a[c]);
        this.c.copy(a[d]);
        return this
    },
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(a) {
        this.a.copy(a.a);
        this.b.copy(a.b);
        this.c.copy(a.c);
        return this
    },
    getArea: function() {
        var a = new module$node_modules$three$build$three.default.Vector3,
            b = new module$node_modules$three$build$three.default.Vector3;
        return function() {
            a.subVectors(this.c, this.b);
            b.subVectors(this.a, this.b);
            return .5 * a.cross(b).length()
        }
    }(),
    getMidpoint: function(a) {
        void 0 === a && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), a = new module$node_modules$three$build$three.default.Vector3);
        return a.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    },
    getNormal: function(a) {
        return module$node_modules$three$build$three.default.Triangle.getNormal(this.a, this.b, this.c, a)
    },
    getPlane: function(a) {
        void 0 === a && (console.warn("THREE.Triangle: .getPlane() target is now required"),
            a = new module$node_modules$three$build$three.default.Vector3);
        return a.setFromCoplanarPoints(this.a, this.b, this.c)
    },
    getBarycoord: function(a, b) {
        return module$node_modules$three$build$three.default.Triangle.getBarycoord(a, this.a, this.b, this.c, b)
    },
    containsPoint: function(a) {
        return module$node_modules$three$build$three.default.Triangle.containsPoint(a, this.a, this.b, this.c)
    },
    intersectsBox: function(a) {
        return a.intersectsTriangle(this)
    },
    closestPointToPoint: function() {
        var a = new module$node_modules$three$build$three.default.Vector3,
            b = new module$node_modules$three$build$three.default.Vector3,
            c = new module$node_modules$three$build$three.default.Vector3,
            d = new module$node_modules$three$build$three.default.Vector3,
            e = new module$node_modules$three$build$three.default.Vector3,
            f = new module$node_modules$three$build$three.default.Vector3;
        return function(g, h) {
            void 0 === h && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), h = new module$node_modules$three$build$three.default.Vector3);
            var k = this.a,
                l = this.b,
                p = this.c;
            a.subVectors(l, k);
            b.subVectors(p, k);
            d.subVectors(g, k);
            var m = a.dot(d),
                q = b.dot(d);
            if (0 >= m && 0 >= q) return h.copy(k);
            e.subVectors(g, l);
            var r = a.dot(e),
                n = b.dot(e);
            if (0 <= r && n <= r) return h.copy(l);
            var t = m * n - r * q;
            if (0 >= t && 0 <= m && 0 >= r) return l = m / (m - r), h.copy(k).addScaledVector(a, l);
            f.subVectors(g, p);
            g = a.dot(f);
            var u = b.dot(f);
            if (0 <= u && g <= u) return h.copy(p);
            m = g * q - m * u;
            if (0 >= m && 0 <= q && 0 >= u) return t = q / (q - u), h.copy(k).addScaledVector(b, t);
            q = r * u - g * n;
            if (0 >= q && 0 <= n - r && 0 <= g - u) return c.subVectors(p, l), t = (n - r) / (n - r + (g - u)), h.copy(l).addScaledVector(c,
                t);
            p = 1 / (q + m + t);
            l = m * p;
            t *= p;
            return h.copy(k).addScaledVector(a, l).addScaledVector(b, t)
        }
    }(),
    equals: function(a) {
        return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c)
    }
});
module$node_modules$three$build$three.default.Mesh.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.Object3D.prototype), {
    constructor: module$node_modules$three$build$three.default.Mesh,
    isMesh: !0,
    setDrawMode: function(a) {
        this.drawMode = a
    },
    copy: function(a) {
        module$node_modules$three$build$three.default.Object3D.prototype.copy.call(this, a);
        this.drawMode = a.drawMode;
        void 0 !== a.morphTargetInfluences && (this.morphTargetInfluences = a.morphTargetInfluences.slice());
        void 0 !== a.morphTargetDictionary &&
            (this.morphTargetDictionary = Object.assign({}, a.morphTargetDictionary));
        return this
    },
    updateMorphTargets: function() {
        var a = this.geometry;
        if (a.isBufferGeometry) {
            a = a.morphAttributes;
            var b = Object.keys(a);
            if (0 < b.length) {
                var c = a[b[0]];
                if (void 0 !== c)
                    for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, a = 0, b = c.length; a < b; a++) {
                        var d = c[a].name || String(a);
                        this.morphTargetInfluences.push(0);
                        this.morphTargetDictionary[d] = a
                    }
            }
        } else if (c = a.morphTargets, void 0 !== c && 0 < c.length)
            for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, a = 0, b = c.length; a < b; a++) d = c[a].name || String(a), this.morphTargetInfluences.push(0), this.morphTargetDictionary[d] = a
    },
    raycast: function() {
        function a(a, b, c, d, e, f, g) {
            module$node_modules$three$build$three.default.Triangle.getBarycoord(a, b, c, d, t);
            e.multiplyScalar(t.x);
            f.multiplyScalar(t.y);
            g.multiplyScalar(t.z);
            e.add(f).add(g);
            return e.clone()
        }

        function b(a, b, c, d, e, f, g, h) {
            if (null === (b.side === module$node_modules$three$build$three.default.BackSide ? d.intersectTriangle(g, f, e, !0,
                    h) : d.intersectTriangle(e, f, g, b.side !== module$node_modules$three$build$three.default.DoubleSide, h))) return null;
            w.copy(h);
            w.applyMatrix4(a.matrixWorld);
            b = c.ray.origin.distanceTo(w);
            return b < c.near || b > c.far ? null : {
                distance: b,
                point: w.clone(),
                object: a
            }
        }

        function c(c, d, e, f, l, m, p, t, w) {
            g.fromBufferAttribute(l, p);
            h.fromBufferAttribute(l, t);
            k.fromBufferAttribute(l, w);
            if (c = b(c, d, e, f, g, h, k, u)) m && (q.fromBufferAttribute(m, p), r.fromBufferAttribute(m, t), n.fromBufferAttribute(m, w), c.uv = a(u, g, h, k, q, r, n)), m = new module$node_modules$three$build$three.default.Face3(p,
                t, w), module$node_modules$three$build$three.default.Triangle.getNormal(g, h, k, m.normal), c.face = m;
            return c
        }
        var d = new module$node_modules$three$build$three.default.Matrix4,
            e = new module$node_modules$three$build$three.default.Ray,
            f = new module$node_modules$three$build$three.default.Sphere,
            g = new module$node_modules$three$build$three.default.Vector3,
            h = new module$node_modules$three$build$three.default.Vector3,
            k = new module$node_modules$three$build$three.default.Vector3,
            l = new module$node_modules$three$build$three.default.Vector3,
            p = new module$node_modules$three$build$three.default.Vector3,
            m = new module$node_modules$three$build$three.default.Vector3,
            q = new module$node_modules$three$build$three.default.Vector2,
            r = new module$node_modules$three$build$three.default.Vector2,
            n = new module$node_modules$three$build$three.default.Vector2,
            t = new module$node_modules$three$build$three.default.Vector3,
            u = new module$node_modules$three$build$three.default.Vector3,
            w = new module$node_modules$three$build$three.default.Vector3;
        return function(t, y) {
            var A =
                this.geometry,
                x = this.material,
                z = this.matrixWorld;
            if (void 0 !== x && (null === A.boundingSphere && A.computeBoundingSphere(), f.copy(A.boundingSphere), f.applyMatrix4(z), !1 !== t.ray.intersectsSphere(f) && (d.getInverse(z), e.copy(t.ray).applyMatrix4(d), null === A.boundingBox || !1 !== e.intersectsBox(A.boundingBox))))
                if (A.isBufferGeometry) {
                    var B = A.index,
                        v = A.attributes.position,
                        w = A.attributes.uv,
                        H = A.groups;
                    A = A.drawRange;
                    var D;
                    if (null !== B)
                        if (Array.isArray(x)) {
                            var I = 0;
                            for (D = H.length; I < D; I++) {
                                var G = H[I];
                                var T = x[G.materialIndex];
                                z = Math.max(G.start, A.start);
                                var L = Math.min(G.start + G.count, A.start + A.count);
                                for (G = z; G < L; G += 3) {
                                    z = B.getX(G);
                                    var F = B.getX(G + 1);
                                    var M = B.getX(G + 2);
                                    if (z = c(this, T, t, e, v, w, z, F, M)) z.faceIndex = Math.floor(G / 3), y.push(z)
                                }
                            }
                        } else
                            for (z = Math.max(0, A.start), L = Math.min(B.count, A.start + A.count), I = z, D = L; I < D; I += 3) {
                                if (z = B.getX(I), F = B.getX(I + 1), M = B.getX(I + 2), z = c(this, x, t, e, v, w, z, F, M)) z.faceIndex = Math.floor(I / 3), y.push(z)
                            } else if (void 0 !== v)
                                if (Array.isArray(x))
                                    for (I = 0, D = H.length; I < D; I++)
                                        for (G = H[I], T = x[G.materialIndex],
                                            z = Math.max(G.start, A.start), L = Math.min(G.start + G.count, A.start + A.count), G = z; G < L; G += 3) {
                                            if (z = G, F = G + 1, M = G + 2, z = c(this, T, t, e, v, w, z, F, M)) z.faceIndex = Math.floor(G / 3), y.push(z)
                                        } else
                                            for (z = Math.max(0, A.start), L = Math.min(v.count, A.start + A.count), I = z, D = L; I < D; I += 3)
                                                if (z = I, F = I + 1, M = I + 2, z = c(this, x, t, e, v, w, z, F, M)) z.faceIndex = Math.floor(I / 3), y.push(z)
                } else if (A.isGeometry)
                for (v = Array.isArray(x), w = A.vertices, H = A.faces, z = A.faceVertexUvs[0], 0 < z.length && (B = z), G = 0, L = H.length; G < L; G++)
                    if (F = H[G], z = v ? x[F.materialIndex] : x, void 0 !==
                        z) {
                        I = w[F.a];
                        D = w[F.b];
                        T = w[F.c];
                        if (!0 === z.morphTargets) {
                            M = A.morphTargets;
                            var J = this.morphTargetInfluences;
                            g.set(0, 0, 0);
                            h.set(0, 0, 0);
                            k.set(0, 0, 0);
                            for (var R = 0, V = M.length; R < V; R++) {
                                var S = J[R];
                                if (0 !== S) {
                                    var O = M[R].vertices;
                                    g.addScaledVector(l.subVectors(O[F.a], I), S);
                                    h.addScaledVector(p.subVectors(O[F.b], D), S);
                                    k.addScaledVector(m.subVectors(O[F.c], T), S)
                                }
                            }
                            g.add(I);
                            h.add(D);
                            k.add(T);
                            I = g;
                            D = h;
                            T = k
                        }
                        if (z = b(this, z, t, e, I, D, T, u)) B && B[G] && (M = B[G], q.copy(M[0]), r.copy(M[1]), n.copy(M[2]), z.uv = a(u, I, D, T, q, r, n)), z.face =
                            F, z.faceIndex = G, y.push(z)
                    }
        }
    }(),
    clone: function() {
        return (new this.constructor(this.geometry, this.material)).copy(this)
    }
});

function WebGLBackground$$module$node_modules$three$build$three(a, b, c, d) {
    function e(a, c) {
        b.buffers.color.setClear(a.r, a.g, a.b, c, d)
    }
    var f = new module$node_modules$three$build$three.default.Color(0),
        g = 0,
        h, k, l;
    return {
        getClearColor: function() {
            return f
        },
        setClearColor: function(a, b) {
            f.set(a);
            g = void 0 !== b ? b : 1;
            e(f, g)
        },
        getClearAlpha: function() {
            return g
        },
        setClearAlpha: function(a) {
            g = a;
            e(f, g)
        },
        render: function(b, d, q, r) {
            d = d.background;
            null === d ? e(f, g) : d && d.isColor && (e(d, 1), r = !0);
            (a.autoClear || r) && a.clear(a.autoClearColor,
                a.autoClearDepth, a.autoClearStencil);
            d && d.isCubeTexture ? (void 0 === l && (l = new module$node_modules$three$build$three.default.Mesh(new module$node_modules$three$build$three.default.BoxBufferGeometry(1, 1, 1), new module$node_modules$three$build$three.default.ShaderMaterial({
                uniforms: module$node_modules$three$build$three.default.ShaderLib.cube.uniforms,
                vertexShader: module$node_modules$three$build$three.default.ShaderLib.cube.vertexShader,
                fragmentShader: module$node_modules$three$build$three.default.ShaderLib.cube.fragmentShader,
                side: module$node_modules$three$build$three.default.BackSide,
                depthTest: !0,
                depthWrite: !1,
                fog: !1
            })), l.geometry.removeAttribute("normal"), l.geometry.removeAttribute("uv"), l.onBeforeRender = function(a, b, c) {
                this.matrixWorld.copyPosition(c.matrixWorld)
            }, c.update(l)), l.material.uniforms.tCube.value = d, b.push(l, l.geometry, l.material, 0, null)) : d && d.isTexture && (void 0 === h && (h = new module$node_modules$three$build$three.default.OrthographicCamera(-1, 1, 1, -1, 0, 1), k = new module$node_modules$three$build$three.default.Mesh(new module$node_modules$three$build$three.default.PlaneBufferGeometry(2,
                2), new module$node_modules$three$build$three.default.MeshBasicMaterial({
                depthTest: !1,
                depthWrite: !1,
                fog: !1
            })), c.update(k)), k.material.map = d, a.renderBufferDirect(h, null, k.geometry, k.material, k, null))
        }
    }
}

function WebGLBufferRenderer$$module$node_modules$three$build$three(a, b, c, d) {
    var e;
    this.setMode = function(a) {
        e = a
    };
    this.render = function(b, d) {
        a.drawArrays(e, b, d);
        c.update(d, e)
    };
    this.renderInstances = function(f, g, h) {
        if (d.isWebGL2) var k = a;
        else if (k = b.get("ANGLE_instanced_arrays"), null === k) {
            console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
        }
        k[d.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](e,
            g, h, f.maxInstancedCount);
        c.update(h, e, f.maxInstancedCount)
    }
}

function WebGLCapabilities$$module$node_modules$three$build$three(a, b, c) {
    function d(b) {
        if ("highp" === b) {
            if (0 < a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.HIGH_FLOAT).precision && 0 < a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.HIGH_FLOAT).precision) return "highp";
            b = "mediump"
        }
        return "mediump" === b && 0 < a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.MEDIUM_FLOAT).precision && 0 < a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.MEDIUM_FLOAT).precision ? "mediump" : "lowp"
    }
    var e, f = "undefined" !== typeof WebGL2RenderingContext &&
        a instanceof WebGL2RenderingContext,
        g = void 0 !== c.precision ? c.precision : "highp",
        h = d(g);
    h !== g && (console.warn("THREE.WebGLRenderer:", g, "not supported, using", h, "instead."), g = h);
    c = !0 === c.logarithmicDepthBuffer;
    h = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS);
    var k = a.getParameter(a.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
        l = a.getParameter(a.MAX_TEXTURE_SIZE),
        p = a.getParameter(a.MAX_CUBE_MAP_TEXTURE_SIZE),
        m = a.getParameter(a.MAX_VERTEX_ATTRIBS),
        q = a.getParameter(a.MAX_VERTEX_UNIFORM_VECTORS),
        r = a.getParameter(a.MAX_VARYING_VECTORS),
        n = a.getParameter(a.MAX_FRAGMENT_UNIFORM_VECTORS),
        t = 0 < k,
        u = f || !!b.get("OES_texture_float");
    return {
        isWebGL2: f,
        getMaxAnisotropy: function() {
            if (void 0 !== e) return e;
            var c = b.get("EXT_texture_filter_anisotropic");
            return e = null !== c ? a.getParameter(c.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
        },
        getMaxPrecision: d,
        precision: g,
        logarithmicDepthBuffer: c,
        maxTextures: h,
        maxVertexTextures: k,
        maxTextureSize: l,
        maxCubemapSize: p,
        maxAttributes: m,
        maxVertexUniforms: q,
        maxVaryings: r,
        maxFragmentUniforms: n,
        vertexTextures: t,
        floatFragmentTextures: u,
        floatVertexTextures: t && u
    }
}

function WebGLClipping$$module$node_modules$three$build$three() {
    function a() {
        l.value !== d && (l.value = d, l.needsUpdate = 0 < e);
        c.numPlanes = e;
        c.numIntersection = 0
    }

    function b(a, b, d, e) {
        var f = null !== a ? a.length : 0,
            g = null;
        if (0 !== f) {
            g = l.value;
            if (!0 !== e || null === g) {
                e = d + 4 * f;
                b = b.matrixWorldInverse;
                k.getNormalMatrix(b);
                if (null === g || g.length < e) g = new Float32Array(e);
                for (e = 0; e !== f; ++e, d += 4) h.copy(a[e]).applyMatrix4(b, k), h.normal.toArray(g, d), g[d + 3] = h.constant
            }
            l.value = g;
            l.needsUpdate = !0
        }
        c.numPlanes = f;
        return g
    }
    var c = this,
        d = null,
        e = 0,
        f = !1,
        g = !1,
        h = new module$node_modules$three$build$three.default.Plane,
        k = new module$node_modules$three$build$three.default.Matrix3,
        l = {
            value: null,
            needsUpdate: !1
        };
    this.uniform = l;
    this.numIntersection = this.numPlanes = 0;
    this.init = function(a, c, g) {
        var h = 0 !== a.length || c || 0 !== e || f;
        f = c;
        d = b(a, g, 0);
        e = a.length;
        return h
    };
    this.beginShadows = function() {
        g = !0;
        b(null)
    };
    this.endShadows = function() {
        g = !1;
        a()
    };
    this.setState = function(c, h, k, r, n, t) {
        if (!f || null === c || 0 === c.length || g && !k) g ? b(null) : a();
        else {
            k = g ? 0 : e;
            var m =
                4 * k,
                q = n.clippingState || null;
            l.value = q;
            q = b(c, r, m, t);
            for (c = 0; c !== m; ++c) q[c] = d[c];
            n.clippingState = q;
            this.numIntersection = h ? this.numPlanes : 0;
            this.numPlanes += k
        }
    }
}

function WebGLExtensions$$module$node_modules$three$build$three(a) {
    var b = {};
    return {
        get: function(c) {
            if (void 0 !== b[c]) return b[c];
            switch (c) {
                case "WEBGL_depth_texture":
                    var d = a.getExtension("WEBGL_depth_texture") || a.getExtension("MOZ_WEBGL_depth_texture") || a.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;
                case "EXT_texture_filter_anisotropic":
                    d = a.getExtension("EXT_texture_filter_anisotropic") || a.getExtension("MOZ_EXT_texture_filter_anisotropic") || a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    d = a.getExtension("WEBGL_compressed_texture_s3tc") || a.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    d = a.getExtension("WEBGL_compressed_texture_pvrtc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                default:
                    d = a.getExtension(c)
            }
            null === d && console.warn("THREE.WebGLRenderer: " + c + " extension not supported.");
            return b[c] = d
        }
    }
}

function WebGLGeometries$$module$node_modules$three$build$three(a, b, c) {
    function d(a) {
        var g = a.target;
        a = e[g.id];
        null !== a.index && b.remove(a.index);
        for (var k in a.attributes) b.remove(a.attributes[k]);
        g.removeEventListener("dispose", d);
        delete e[g.id];
        if (k = f[a.id]) b.remove(k), delete f[a.id];
        c.memory.geometries--
    }
    var e = {},
        f = {};
    return {
        get: function(a, b) {
            var f = e[b.id];
            if (f) return f;
            b.addEventListener("dispose", d);
            b.isBufferGeometry ? f = b : b.isGeometry && (void 0 === b._bufferGeometry && (b._bufferGeometry = (new module$node_modules$three$build$three.default.BufferGeometry).setFromObject(a)),
                f = b._bufferGeometry);
            e[b.id] = f;
            c.memory.geometries++;
            return f
        },
        update: function(c) {
            var d = c.index,
                e = c.attributes;
            null !== d && b.update(d, a.ELEMENT_ARRAY_BUFFER);
            for (var f in e) b.update(e[f], a.ARRAY_BUFFER);
            c = c.morphAttributes;
            for (f in c) {
                d = c[f];
                e = 0;
                for (var g = d.length; e < g; e++) b.update(d[e], a.ARRAY_BUFFER)
            }
        },
        getWireframeAttribute: function(c) {
            var d = f[c.id];
            if (d) return d;
            d = [];
            var e = c.index,
                g = c.attributes;
            if (null !== e) {
                e = e.array;
                g = 0;
                for (var p = e.length; g < p; g += 3) {
                    var m = e[g + 0],
                        q = e[g + 1],
                        r = e[g + 2];
                    d.push(m, q, q, r,
                        r, m)
                }
            } else
                for (e = g.position.array, g = 0, p = e.length / 3 - 1; g < p; g += 3) m = g + 0, q = g + 1, r = g + 2, d.push(m, q, q, r, r, m);
            d = new(65535 < arrayMax$$module$node_modules$three$build$three(d) ? module$node_modules$three$build$three.default.Uint32BufferAttribute : module$node_modules$three$build$three.default.Uint16BufferAttribute)(d, 1);
            b.update(d, a.ELEMENT_ARRAY_BUFFER);
            return f[c.id] = d
        }
    }
}

function WebGLIndexedBufferRenderer$$module$node_modules$three$build$three(a, b, c, d) {
    var e, f, g;
    this.setMode = function(a) {
        e = a
    };
    this.setIndex = function(a) {
        f = a.type;
        g = a.bytesPerElement
    };
    this.render = function(b, d) {
        a.drawElements(e, d, f, b * g);
        c.update(d, e)
    };
    this.renderInstances = function(h, k, l) {
        if (d.isWebGL2) var p = a;
        else if (p = b.get("ANGLE_instanced_arrays"), null === p) {
            console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
        }
        p[d.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](e, l, f, k * g, h.maxInstancedCount);
        c.update(l, e, h.maxInstancedCount)
    }
}

function WebGLInfo$$module$node_modules$three$build$three(a) {
    var b = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    return {
        memory: {
            geometries: 0,
            textures: 0
        },
        render: b,
        programs: null,
        autoReset: !0,
        reset: function() {
            b.frame++;
            b.calls = 0;
            b.triangles = 0;
            b.points = 0;
            b.lines = 0
        },
        update: function(c, d, e) {
            e = e || 1;
            b.calls++;
            switch (d) {
                case a.TRIANGLES:
                    b.triangles += c / 3 * e;
                    break;
                case a.TRIANGLE_STRIP:
                case a.TRIANGLE_FAN:
                    b.triangles += e * (c - 2);
                    break;
                case a.LINES:
                    b.lines += c / 2 * e;
                    break;
                case a.LINE_STRIP:
                    b.lines += e * (c - 1);
                    break;
                case a.LINE_LOOP:
                    b.lines +=
                        e * c;
                    break;
                case a.POINTS:
                    b.points += e * c;
                    break;
                default:
                    console.error("THREE.WebGLInfo: Unknown draw mode:", d)
            }
        }
    }
}

function absNumericalSort$$module$node_modules$three$build$three(a, b) {
    return Math.abs(b[1]) - Math.abs(a[1])
}

function WebGLMorphtargets$$module$node_modules$three$build$three(a) {
    var b = {},
        c = new Float32Array(8);
    return {
        update: function(d, e, f, g) {
            var h = d.morphTargetInfluences,
                k = h.length;
            d = b[e.id];
            if (void 0 === d) {
                d = [];
                for (var l = 0; l < k; l++) d[l] = [l, 0];
                b[e.id] = d
            }
            var p = f.morphTargets && e.morphAttributes.position;
            f = f.morphNormals && e.morphAttributes.normal;
            for (l = 0; l < k; l++) {
                var m = d[l];
                0 !== m[1] && (p && e.removeAttribute("morphTarget" + l), f && e.removeAttribute("morphNormal" + l))
            }
            for (l = 0; l < k; l++) m = d[l], m[0] = l, m[1] = h[l];
            d.sort(absNumericalSort$$module$node_modules$three$build$three);
            for (l = 0; 8 > l; l++) {
                if (m = d[l])
                    if (h = m[0], k = m[1]) {
                        p && e.addAttribute("morphTarget" + l, p[h]);
                        f && e.addAttribute("morphNormal" + l, f[h]);
                        c[l] = k;
                        continue
                    }
                c[l] = 0
            }
            g.getUniforms().setValue(a, "morphTargetInfluences", c)
        }
    }
}

function WebGLObjects$$module$node_modules$three$build$three(a, b) {
    var c = {};
    return {
        update: function(d) {
            var e = b.render.frame,
                f = d.geometry,
                g = a.get(d, f);
            c[g.id] !== e && (f.isGeometry && g.updateFromObject(d), a.update(g), c[g.id] = e);
            return g
        },
        dispose: function() {
            c = {}
        }
    }
}
module$node_modules$three$build$three.default.CubeTexture.prototype = Object.create(module$node_modules$three$build$three.default.Texture.prototype);
module$node_modules$three$build$three.default.CubeTexture.prototype.constructor = module$node_modules$three$build$three.default.CubeTexture;
module$node_modules$three$build$three.default.CubeTexture.prototype.isCubeTexture = !0;
Object.defineProperty(module$node_modules$three$build$three.default.CubeTexture.prototype, "images", {
    get: function() {
        return this.image
    },
    set: function(a) {
        this.image = a
    }
});
var emptyTexture$$module$node_modules$three$build$three = new module$node_modules$three$build$three.default.Texture,
    emptyCubeTexture$$module$node_modules$three$build$three = new module$node_modules$three$build$three.default.CubeTexture;

function UniformContainer$$module$node_modules$three$build$three() {
    this.seq = [];
    this.map = {}
}
var arrayCacheF32$$module$node_modules$three$build$three = [],
    arrayCacheI32$$module$node_modules$three$build$three = [],
    mat4array$$module$node_modules$three$build$three = new Float32Array(16),
    mat3array$$module$node_modules$three$build$three = new Float32Array(9),
    mat2array$$module$node_modules$three$build$three = new Float32Array(4);

function flatten$$module$node_modules$three$build$three(a, b, c) {
    var d = a[0];
    if (0 >= d || 0 < d) return a;
    var e = b * c,
        f = arrayCacheF32$$module$node_modules$three$build$three[e];
    void 0 === f && (f = new Float32Array(e), arrayCacheF32$$module$node_modules$three$build$three[e] = f);
    if (0 !== b)
        for (d.toArray(f, 0), d = 1, e = 0; d !== b; ++d) e += c, a[d].toArray(f, e);
    return f
}

function arraysEqual$$module$node_modules$three$build$three(a, b) {
    if (a.length !== b.length) return !1;
    for (var c = 0, d = a.length; c < d; c++)
        if (a[c] !== b[c]) return !1;
    return !0
}

function copyArray$$module$node_modules$three$build$three(a, b) {
    for (var c = 0, d = b.length; c < d; c++) a[c] = b[c]
}

function allocTexUnits$$module$node_modules$three$build$three(a, b) {
    var c = arrayCacheI32$$module$node_modules$three$build$three[b];
    void 0 === c && (c = new Int32Array(b), arrayCacheI32$$module$node_modules$three$build$three[b] = c);
    for (var d = 0; d !== b; ++d) c[d] = a.allocTextureUnit();
    return c
}

function setValue1f$$module$node_modules$three$build$three(a, b) {
    var c = this.cache;
    c[0] !== b && (a.uniform1f(this.addr, b), c[0] = b)
}

function setValue1i$$module$node_modules$three$build$three(a, b) {
    var c = this.cache;
    c[0] !== b && (a.uniform1i(this.addr, b), c[0] = b)
}

function setValue2fv$$module$node_modules$three$build$three(a, b) {
    var c = this.cache;
    if (void 0 !== b.x) {
        if (c[0] !== b.x || c[1] !== b.y) a.uniform2f(this.addr, b.x, b.y), c[0] = b.x, c[1] = b.y
    } else arraysEqual$$module$node_modules$three$build$three(c, b) || (a.uniform2fv(this.addr, b), copyArray$$module$node_modules$three$build$three(c, b))
}

function setValue3fv$$module$node_modules$three$build$three(a, b) {
    var c = this.cache;
    if (void 0 !== b.x) {
        if (c[0] !== b.x || c[1] !== b.y || c[2] !== b.z) a.uniform3f(this.addr, b.x, b.y, b.z), c[0] = b.x, c[1] = b.y, c[2] = b.z
    } else if (void 0 !== b.r) {
        if (c[0] !== b.r || c[1] !== b.g || c[2] !== b.b) a.uniform3f(this.addr, b.r, b.g, b.b), c[0] = b.r, c[1] = b.g, c[2] = b.b
    } else arraysEqual$$module$node_modules$three$build$three(c, b) || (a.uniform3fv(this.addr, b), copyArray$$module$node_modules$three$build$three(c, b))
}

function setValue4fv$$module$node_modules$three$build$three(a, b) {
    var c = this.cache;
    if (void 0 !== b.x) {
        if (c[0] !== b.x || c[1] !== b.y || c[2] !== b.z || c[3] !== b.w) a.uniform4f(this.addr, b.x, b.y, b.z, b.w), c[0] = b.x, c[1] = b.y, c[2] = b.z, c[3] = b.w
    } else arraysEqual$$module$node_modules$three$build$three(c, b) || (a.uniform4fv(this.addr, b), copyArray$$module$node_modules$three$build$three(c, b))
}

function setValue2fm$$module$node_modules$three$build$three(a, b) {
    var c = this.cache,
        d = b.elements;
    void 0 === d ? arraysEqual$$module$node_modules$three$build$three(c, b) || (a.uniformMatrix2fv(this.addr, !1, b), copyArray$$module$node_modules$three$build$three(c, b)) : arraysEqual$$module$node_modules$three$build$three(c, d) || (mat2array$$module$node_modules$three$build$three.set(d), a.uniformMatrix2fv(this.addr, !1, mat2array$$module$node_modules$three$build$three), copyArray$$module$node_modules$three$build$three(c,
        d))
}

function setValue3fm$$module$node_modules$three$build$three(a, b) {
    var c = this.cache,
        d = b.elements;
    void 0 === d ? arraysEqual$$module$node_modules$three$build$three(c, b) || (a.uniformMatrix3fv(this.addr, !1, b), copyArray$$module$node_modules$three$build$three(c, b)) : arraysEqual$$module$node_modules$three$build$three(c, d) || (mat3array$$module$node_modules$three$build$three.set(d), a.uniformMatrix3fv(this.addr, !1, mat3array$$module$node_modules$three$build$three), copyArray$$module$node_modules$three$build$three(c, d))
}

function setValue4fm$$module$node_modules$three$build$three(a, b) {
    var c = this.cache,
        d = b.elements;
    void 0 === d ? arraysEqual$$module$node_modules$three$build$three(c, b) || (a.uniformMatrix4fv(this.addr, !1, b), copyArray$$module$node_modules$three$build$three(c, b)) : arraysEqual$$module$node_modules$three$build$three(c, d) || (mat4array$$module$node_modules$three$build$three.set(d), a.uniformMatrix4fv(this.addr, !1, mat4array$$module$node_modules$three$build$three), copyArray$$module$node_modules$three$build$three(c,
        d))
}

function setValueT1$$module$node_modules$three$build$three(a, b, c) {
    var d = this.cache,
        e = c.allocTextureUnit();
    d[0] !== e && (a.uniform1i(this.addr, e), d[0] = e);
    c.setTexture2D(b || emptyTexture$$module$node_modules$three$build$three, e)
}

function setValueT6$$module$node_modules$three$build$three(a, b, c) {
    var d = this.cache,
        e = c.allocTextureUnit();
    d[0] !== e && (a.uniform1i(this.addr, e), d[0] = e);
    c.setTextureCube(b || emptyCubeTexture$$module$node_modules$three$build$three, e)
}

function setValue2iv$$module$node_modules$three$build$three(a, b) {
    var c = this.cache;
    arraysEqual$$module$node_modules$three$build$three(c, b) || (a.uniform2iv(this.addr, b), copyArray$$module$node_modules$three$build$three(c, b))
}

function setValue3iv$$module$node_modules$three$build$three(a, b) {
    var c = this.cache;
    arraysEqual$$module$node_modules$three$build$three(c, b) || (a.uniform3iv(this.addr, b), copyArray$$module$node_modules$three$build$three(c, b))
}

function setValue4iv$$module$node_modules$three$build$three(a, b) {
    var c = this.cache;
    arraysEqual$$module$node_modules$three$build$three(c, b) || (a.uniform4iv(this.addr, b), copyArray$$module$node_modules$three$build$three(c, b))
}

function getSingularSetter$$module$node_modules$three$build$three(a) {
    switch (a) {
        case 5126:
            return setValue1f$$module$node_modules$three$build$three;
        case 35664:
            return setValue2fv$$module$node_modules$three$build$three;
        case 35665:
            return setValue3fv$$module$node_modules$three$build$three;
        case 35666:
            return setValue4fv$$module$node_modules$three$build$three;
        case 35674:
            return setValue2fm$$module$node_modules$three$build$three;
        case 35675:
            return setValue3fm$$module$node_modules$three$build$three;
        case 35676:
            return setValue4fm$$module$node_modules$three$build$three;
        case 35678:
        case 36198:
            return setValueT1$$module$node_modules$three$build$three;
        case 35680:
            return setValueT6$$module$node_modules$three$build$three;
        case 5124:
        case 35670:
            return setValue1i$$module$node_modules$three$build$three;
        case 35667:
        case 35671:
            return setValue2iv$$module$node_modules$three$build$three;
        case 35668:
        case 35672:
            return setValue3iv$$module$node_modules$three$build$three;
        case 35669:
        case 35673:
            return setValue4iv$$module$node_modules$three$build$three
    }
}

function setValue1fv$$module$node_modules$three$build$three(a, b) {
    var c = this.cache;
    arraysEqual$$module$node_modules$three$build$three(c, b) || (a.uniform1fv(this.addr, b), copyArray$$module$node_modules$three$build$three(c, b))
}

function setValue1iv$$module$node_modules$three$build$three(a, b) {
    var c = this.cache;
    arraysEqual$$module$node_modules$three$build$three(c, b) || (a.uniform1iv(this.addr, b), copyArray$$module$node_modules$three$build$three(c, b))
}

function setValueV2a$$module$node_modules$three$build$three(a, b) {
    var c = this.cache;
    b = flatten$$module$node_modules$three$build$three(b, this.size, 2);
    arraysEqual$$module$node_modules$three$build$three(c, b) || (a.uniform2fv(this.addr, b), this.updateCache(b))
}

function setValueV3a$$module$node_modules$three$build$three(a, b) {
    var c = this.cache;
    b = flatten$$module$node_modules$three$build$three(b, this.size, 3);
    arraysEqual$$module$node_modules$three$build$three(c, b) || (a.uniform3fv(this.addr, b), this.updateCache(b))
}

function setValueV4a$$module$node_modules$three$build$three(a, b) {
    var c = this.cache;
    b = flatten$$module$node_modules$three$build$three(b, this.size, 4);
    arraysEqual$$module$node_modules$three$build$three(c, b) || (a.uniform4fv(this.addr, b), this.updateCache(b))
}

function setValueM2a$$module$node_modules$three$build$three(a, b) {
    var c = this.cache;
    b = flatten$$module$node_modules$three$build$three(b, this.size, 4);
    arraysEqual$$module$node_modules$three$build$three(c, b) || (a.uniformMatrix2fv(this.addr, !1, b), this.updateCache(b))
}

function setValueM3a$$module$node_modules$three$build$three(a, b) {
    var c = this.cache;
    b = flatten$$module$node_modules$three$build$three(b, this.size, 9);
    arraysEqual$$module$node_modules$three$build$three(c, b) || (a.uniformMatrix3fv(this.addr, !1, b), this.updateCache(b))
}

function setValueM4a$$module$node_modules$three$build$three(a, b) {
    var c = this.cache;
    b = flatten$$module$node_modules$three$build$three(b, this.size, 16);
    arraysEqual$$module$node_modules$three$build$three(c, b) || (a.uniformMatrix4fv(this.addr, !1, b), this.updateCache(b))
}

function setValueT1a$$module$node_modules$three$build$three(a, b, c) {
    var d = this.cache,
        e = b.length,
        f = allocTexUnits$$module$node_modules$three$build$three(c, e);
    !1 === arraysEqual$$module$node_modules$three$build$three(d, f) && (a.uniform1iv(this.addr, f), copyArray$$module$node_modules$three$build$three(d, f));
    for (a = 0; a !== e; ++a) c.setTexture2D(b[a] || emptyTexture$$module$node_modules$three$build$three, f[a])
}

function setValueT6a$$module$node_modules$three$build$three(a, b, c) {
    var d = this.cache,
        e = b.length,
        f = allocTexUnits$$module$node_modules$three$build$three(c, e);
    !1 === arraysEqual$$module$node_modules$three$build$three(d, f) && (a.uniform1iv(this.addr, f), copyArray$$module$node_modules$three$build$three(d, f));
    for (a = 0; a !== e; ++a) c.setTextureCube(b[a] || emptyCubeTexture$$module$node_modules$three$build$three, f[a])
}

function getPureArraySetter$$module$node_modules$three$build$three(a) {
    switch (a) {
        case 5126:
            return setValue1fv$$module$node_modules$three$build$three;
        case 35664:
            return setValueV2a$$module$node_modules$three$build$three;
        case 35665:
            return setValueV3a$$module$node_modules$three$build$three;
        case 35666:
            return setValueV4a$$module$node_modules$three$build$three;
        case 35674:
            return setValueM2a$$module$node_modules$three$build$three;
        case 35675:
            return setValueM3a$$module$node_modules$three$build$three;
        case 35676:
            return setValueM4a$$module$node_modules$three$build$three;
        case 35678:
            return setValueT1a$$module$node_modules$three$build$three;
        case 35680:
            return setValueT6a$$module$node_modules$three$build$three;
        case 5124:
        case 35670:
            return setValue1iv$$module$node_modules$three$build$three;
        case 35667:
        case 35671:
            return setValue2iv$$module$node_modules$three$build$three;
        case 35668:
        case 35672:
            return setValue3iv$$module$node_modules$three$build$three;
        case 35669:
        case 35673:
            return setValue4iv$$module$node_modules$three$build$three
    }
}

function SingleUniform$$module$node_modules$three$build$three(a, b, c) {
    this.id = a;
    this.addr = c;
    this.cache = [];
    this.setValue = getSingularSetter$$module$node_modules$three$build$three(b.type)
}

function PureArrayUniform$$module$node_modules$three$build$three(a, b, c) {
    this.id = a;
    this.addr = c;
    this.cache = [];
    this.size = b.size;
    this.setValue = getPureArraySetter$$module$node_modules$three$build$three(b.type)
}
PureArrayUniform$$module$node_modules$three$build$three.prototype.updateCache = function(a) {
    var b = this.cache;
    a instanceof Float32Array && b.length !== a.length && (this.cache = new Float32Array(a.length));
    copyArray$$module$node_modules$three$build$three(b, a)
};

function StructuredUniform$$module$node_modules$three$build$three(a) {
    this.id = a;
    UniformContainer$$module$node_modules$three$build$three.call(this)
}
StructuredUniform$$module$node_modules$three$build$three.prototype.setValue = function(a, b, c) {
    for (var d = this.seq, e = 0, f = d.length; e !== f; ++e) {
        var g = d[e];
        g.setValue(a, b[g.id], c)
    }
};
var RePathPart$$module$node_modules$three$build$three = /([\w\d_]+)(\])?(\[|\.)?/g;

function addUniform$$module$node_modules$three$build$three(a, b) {
    a.seq.push(b);
    a.map[b.id] = b
}

function parseUniform$$module$node_modules$three$build$three(a, b, c) {
    var d = a.name,
        e = d.length;
    for (RePathPart$$module$node_modules$three$build$three.lastIndex = 0;;) {
        var f = RePathPart$$module$node_modules$three$build$three.exec(d),
            g = RePathPart$$module$node_modules$three$build$three.lastIndex,
            h = f[1],
            k = f[3];
        "]" === f[2] && (h |= 0);
        if (void 0 === k || "[" === k && g + 2 === e) {
            addUniform$$module$node_modules$three$build$three(c, void 0 === k ? new SingleUniform$$module$node_modules$three$build$three(h, a, b) : new PureArrayUniform$$module$node_modules$three$build$three(h,
                a, b));
            break
        } else f = c.map[h], void 0 === f && (f = new StructuredUniform$$module$node_modules$three$build$three(h), addUniform$$module$node_modules$three$build$three(c, f)), c = f
    }
}

function WebGLUniforms$$module$node_modules$three$build$three(a, b, c) {
    UniformContainer$$module$node_modules$three$build$three.call(this);
    this.renderer = c;
    c = a.getProgramParameter(b, a.ACTIVE_UNIFORMS);
    for (var d = 0; d < c; ++d) {
        var e = a.getActiveUniform(b, d),
            f = a.getUniformLocation(b, e.name);
        parseUniform$$module$node_modules$three$build$three(e, f, this)
    }
}
WebGLUniforms$$module$node_modules$three$build$three.prototype.setValue = function(a, b, c) {
    b = this.map[b];
    void 0 !== b && b.setValue(a, c, this.renderer)
};
WebGLUniforms$$module$node_modules$three$build$three.prototype.setOptional = function(a, b, c) {
    b = b[c];
    void 0 !== b && this.setValue(a, c, b)
};
WebGLUniforms$$module$node_modules$three$build$three.upload = function(a, b, c, d) {
    for (var e = 0, f = b.length; e !== f; ++e) {
        var g = b[e],
            h = c[g.id];
        !1 !== h.needsUpdate && g.setValue(a, h.value, d)
    }
};
WebGLUniforms$$module$node_modules$three$build$three.seqWithValue = function(a, b) {
    for (var c = [], d = 0, e = a.length; d !== e; ++d) {
        var f = a[d];
        f.id in b && c.push(f)
    }
    return c
};

function addLineNumbers$$module$node_modules$three$build$three(a) {
    a = a.split("\n");
    for (var b = 0; b < a.length; b++) a[b] = b + 1 + ": " + a[b];
    return a.join("\n")
}

function WebGLShader$$module$node_modules$three$build$three(a, b, c) {
    var d = a.createShader(b);
    a.shaderSource(d, c);
    a.compileShader(d);
    !1 === a.getShaderParameter(d, a.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile.");
    "" !== a.getShaderInfoLog(d) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", b === a.VERTEX_SHADER ? "vertex" : "fragment", a.getShaderInfoLog(d), addLineNumbers$$module$node_modules$three$build$three(c));
    return d
}
var programIdCount$$module$node_modules$three$build$three = 0;

function getEncodingComponents$$module$node_modules$three$build$three(a) {
    switch (a) {
        case module$node_modules$three$build$three.default.LinearEncoding:
            return ["Linear", "( value )"];
        case module$node_modules$three$build$three.default.sRGBEncoding:
            return ["sRGB", "( value )"];
        case module$node_modules$three$build$three.default.RGBEEncoding:
            return ["RGBE", "( value )"];
        case module$node_modules$three$build$three.default.RGBM7Encoding:
            return ["RGBM", "( value, 7.0 )"];
        case module$node_modules$three$build$three.default.RGBM16Encoding:
            return ["RGBM",
                "( value, 16.0 )"
            ];
        case module$node_modules$three$build$three.default.RGBDEncoding:
            return ["RGBD", "( value, 256.0 )"];
        case module$node_modules$three$build$three.default.GammaEncoding:
            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
        default:
            throw Error("unsupported encoding: " + a);
    }
}

function getTexelDecodingFunction$$module$node_modules$three$build$three(a, b) {
    b = getEncodingComponents$$module$node_modules$three$build$three(b);
    return "vec4 " + a + "( vec4 value ) { return " + b[0] + "ToLinear" + b[1] + "; }"
}

function getTexelEncodingFunction$$module$node_modules$three$build$three(a, b) {
    b = getEncodingComponents$$module$node_modules$three$build$three(b);
    return "vec4 " + a + "( vec4 value ) { return LinearTo" + b[0] + b[1] + "; }"
}

function getToneMappingFunction$$module$node_modules$three$build$three(a, b) {
    switch (b) {
        case module$node_modules$three$build$three.default.LinearToneMapping:
            b = "Linear";
            break;
        case module$node_modules$three$build$three.default.ReinhardToneMapping:
            b = "Reinhard";
            break;
        case module$node_modules$three$build$three.default.Uncharted2ToneMapping:
            b = "Uncharted2";
            break;
        case module$node_modules$three$build$three.default.CineonToneMapping:
            b = "OptimizedCineon";
            break;
        default:
            throw Error("unsupported toneMapping: " + b);
    }
    return "vec3 " + a + "( vec3 color ) { return " + b + "ToneMapping( color ); }"
}

function generateExtensions$$module$node_modules$three$build$three(a, b, c) {
    a = a || {};
    return [a.derivatives || b.envMapCubeUV || b.bumpMap || b.normalMap && !b.objectSpaceNormalMap || b.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (a.fragDepth || b.logarithmicDepthBuffer) && c.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", a.drawBuffers && c.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (a.shaderTextureLOD || b.envMap) && c.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" :
        ""
    ].filter(filterEmptyLine$$module$node_modules$three$build$three).join("\n")
}

function generateDefines$$module$node_modules$three$build$three(a) {
    var b = [],
        c;
    for (c in a) {
        var d = a[c];
        !1 !== d && b.push("#define " + c + " " + d)
    }
    return b.join("\n")
}

function fetchAttributeLocations$$module$node_modules$three$build$three(a, b) {
    for (var c = {}, d = a.getProgramParameter(b, a.ACTIVE_ATTRIBUTES), e = 0; e < d; e++) {
        var f = a.getActiveAttrib(b, e).name;
        c[f] = a.getAttribLocation(b, f)
    }
    return c
}

function filterEmptyLine$$module$node_modules$three$build$three(a) {
    return "" !== a
}

function replaceLightNums$$module$node_modules$three$build$three(a, b) {
    return a.replace(/NUM_DIR_LIGHTS/g, b.numDirLights).replace(/NUM_SPOT_LIGHTS/g, b.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, b.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, b.numPointLights).replace(/NUM_HEMI_LIGHTS/g, b.numHemiLights)
}

function replaceClippingPlaneNums$$module$node_modules$three$build$three(a, b) {
    return a.replace(/NUM_CLIPPING_PLANES/g, b.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, b.numClippingPlanes - b.numClipIntersection)
}

function parseIncludes$$module$node_modules$three$build$three(a) {
    return a.replace(/^[ \t]*#include +<([\w\d./]+)>/gm, function(a, c) {
        a = module$node_modules$three$build$three.default.ShaderChunk[c];
        if (void 0 === a) throw Error("Can not resolve #include <" + c + ">");
        return parseIncludes$$module$node_modules$three$build$three(a)
    })
}

function unrollLoops$$module$node_modules$three$build$three(a) {
    return a.replace(/#pragma unroll_loop[\s]+?for \( int i = (\d+); i < (\d+); i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function(a, c, d, e) {
        a = "";
        for (c = parseInt(c); c < parseInt(d); c++) a += e.replace(/\[ i \]/g, "[ " + c + " ]");
        return a
    })
}

function WebGLProgram$$module$node_modules$three$build$three(a, b, c, d, e, f, g) {
    var h = a.context,
        k = d.defines,
        l = e.vertexShader,
        p = e.fragmentShader,
        m = "SHADOWMAP_TYPE_BASIC";
    f.shadowMapType === module$node_modules$three$build$three.default.PCFShadowMap ? m = "SHADOWMAP_TYPE_PCF" : f.shadowMapType === module$node_modules$three$build$three.default.PCFSoftShadowMap && (m = "SHADOWMAP_TYPE_PCF_SOFT");
    var q = "ENVMAP_TYPE_CUBE",
        r = "ENVMAP_MODE_REFLECTION",
        n = "ENVMAP_BLENDING_MULTIPLY";
    if (f.envMap) {
        switch (d.envMap.mapping) {
            case module$node_modules$three$build$three.default.CubeReflectionMapping:
            case module$node_modules$three$build$three.default.CubeRefractionMapping:
                q =
                    "ENVMAP_TYPE_CUBE";
                break;
            case module$node_modules$three$build$three.default.CubeUVReflectionMapping:
            case module$node_modules$three$build$three.default.CubeUVRefractionMapping:
                q = "ENVMAP_TYPE_CUBE_UV";
                break;
            case module$node_modules$three$build$three.default.EquirectangularReflectionMapping:
            case module$node_modules$three$build$three.default.EquirectangularRefractionMapping:
                q = "ENVMAP_TYPE_EQUIREC";
                break;
            case module$node_modules$three$build$three.default.SphericalReflectionMapping:
                q = "ENVMAP_TYPE_SPHERE"
        }
        switch (d.envMap.mapping) {
            case module$node_modules$three$build$three.default.CubeRefractionMapping:
            case module$node_modules$three$build$three.default.EquirectangularRefractionMapping:
                r =
                    "ENVMAP_MODE_REFRACTION"
        }
        switch (d.combine) {
            case module$node_modules$three$build$three.default.MultiplyOperation:
                n = "ENVMAP_BLENDING_MULTIPLY";
                break;
            case module$node_modules$three$build$three.default.MixOperation:
                n = "ENVMAP_BLENDING_MIX";
                break;
            case module$node_modules$three$build$three.default.AddOperation:
                n = "ENVMAP_BLENDING_ADD"
        }
    }
    var t = 0 < a.gammaFactor ? a.gammaFactor : 1,
        u = g.isWebGL2 ? "" : generateExtensions$$module$node_modules$three$build$three(d.extensions, f, b),
        w = generateDefines$$module$node_modules$three$build$three(k),
        v = h.createProgram();
    d.isRawShaderMaterial ? (k = [w].filter(filterEmptyLine$$module$node_modules$three$build$three).join("\n"), 0 < k.length && (k += "\n"), b = [u, w].filter(filterEmptyLine$$module$node_modules$three$build$three).join("\n"), 0 < b.length && (b += "\n")) : (k = ["precision " + f.precision + " float;", "precision " + f.precision + " int;", "#define SHADER_NAME " + e.name, w, f.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + t, "#define MAX_BONES " + f.maxBones, f.useFog && f.fog ? "#define USE_FOG" : "",
        f.useFog && f.fogExp ? "#define FOG_EXP2" : "", f.map ? "#define USE_MAP" : "", f.envMap ? "#define USE_ENVMAP" : "", f.envMap ? "#define " + r : "", f.lightMap ? "#define USE_LIGHTMAP" : "", f.aoMap ? "#define USE_AOMAP" : "", f.emissiveMap ? "#define USE_EMISSIVEMAP" : "", f.bumpMap ? "#define USE_BUMPMAP" : "", f.normalMap ? "#define USE_NORMALMAP" : "", f.normalMap && f.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", f.displacementMap && f.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", f.specularMap ? "#define USE_SPECULARMAP" : "",
        f.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", f.metalnessMap ? "#define USE_METALNESSMAP" : "", f.alphaMap ? "#define USE_ALPHAMAP" : "", f.vertexColors ? "#define USE_COLOR" : "", f.flatShading ? "#define FLAT_SHADED" : "", f.skinning ? "#define USE_SKINNING" : "", f.useVertexTexture ? "#define BONE_TEXTURE" : "", f.morphTargets ? "#define USE_MORPHTARGETS" : "", f.morphNormals && !1 === f.flatShading ? "#define USE_MORPHNORMALS" : "", f.doubleSided ? "#define DOUBLE_SIDED" : "", f.flipSided ? "#define FLIP_SIDED" : "", f.shadowMapEnabled ? "#define USE_SHADOWMAP" :
        "", f.shadowMapEnabled ? "#define " + m : "", f.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", f.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", f.logarithmicDepthBuffer && (g.isWebGL2 || b.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR",
        "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;",
        "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"
    ].filter(filterEmptyLine$$module$node_modules$three$build$three).join("\n"), b = [u, "precision " + f.precision + " float;", "precision " + f.precision + " int;", "#define SHADER_NAME " + e.name, w, f.alphaTest ? "#define ALPHATEST " + f.alphaTest + (f.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + t, f.useFog && f.fog ? "#define USE_FOG" : "", f.useFog && f.fogExp ? "#define FOG_EXP2" : "", f.map ? "#define USE_MAP" : "", f.envMap ?
        "#define USE_ENVMAP" : "", f.envMap ? "#define " + q : "", f.envMap ? "#define " + r : "", f.envMap ? "#define " + n : "", f.lightMap ? "#define USE_LIGHTMAP" : "", f.aoMap ? "#define USE_AOMAP" : "", f.emissiveMap ? "#define USE_EMISSIVEMAP" : "", f.bumpMap ? "#define USE_BUMPMAP" : "", f.normalMap ? "#define USE_NORMALMAP" : "", f.normalMap && f.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", f.specularMap ? "#define USE_SPECULARMAP" : "", f.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", f.metalnessMap ? "#define USE_METALNESSMAP" : "", f.alphaMap ? "#define USE_ALPHAMAP" :
        "", f.vertexColors ? "#define USE_COLOR" : "", f.gradientMap ? "#define USE_GRADIENTMAP" : "", f.flatShading ? "#define FLAT_SHADED" : "", f.doubleSided ? "#define DOUBLE_SIDED" : "", f.flipSided ? "#define FLIP_SIDED" : "", f.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", f.shadowMapEnabled ? "#define " + m : "", f.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", f.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", f.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", f.logarithmicDepthBuffer && (g.isWebGL2 || b.get("EXT_frag_depth")) ?
        "#define USE_LOGDEPTHBUF_EXT" : "", f.envMap && (g.isWebGL2 || b.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", f.toneMapping !== module$node_modules$three$build$three.default.NoToneMapping ? "#define TONE_MAPPING" : "", f.toneMapping !== module$node_modules$three$build$three.default.NoToneMapping ? module$node_modules$three$build$three.default.ShaderChunk.tonemapping_pars_fragment : "", f.toneMapping !== module$node_modules$three$build$three.default.NoToneMapping ?
        getToneMappingFunction$$module$node_modules$three$build$three("toneMapping", f.toneMapping) : "", f.dithering ? "#define DITHERING" : "", f.outputEncoding || f.mapEncoding || f.envMapEncoding || f.emissiveMapEncoding ? module$node_modules$three$build$three.default.ShaderChunk.encodings_pars_fragment : "", f.mapEncoding ? getTexelDecodingFunction$$module$node_modules$three$build$three("mapTexelToLinear", f.mapEncoding) : "", f.envMapEncoding ? getTexelDecodingFunction$$module$node_modules$three$build$three("envMapTexelToLinear",
            f.envMapEncoding) : "", f.emissiveMapEncoding ? getTexelDecodingFunction$$module$node_modules$three$build$three("emissiveMapTexelToLinear", f.emissiveMapEncoding) : "", f.outputEncoding ? getTexelEncodingFunction$$module$node_modules$three$build$three("linearToOutputTexel", f.outputEncoding) : "", f.depthPacking ? "#define DEPTH_PACKING " + d.depthPacking : "", "\n"
    ].filter(filterEmptyLine$$module$node_modules$three$build$three).join("\n"));
    l = parseIncludes$$module$node_modules$three$build$three(l);
    l = replaceLightNums$$module$node_modules$three$build$three(l,
        f);
    l = replaceClippingPlaneNums$$module$node_modules$three$build$three(l, f);
    p = parseIncludes$$module$node_modules$three$build$three(p);
    p = replaceLightNums$$module$node_modules$three$build$three(p, f);
    p = replaceClippingPlaneNums$$module$node_modules$three$build$three(p, f);
    l = unrollLoops$$module$node_modules$three$build$three(l);
    p = unrollLoops$$module$node_modules$three$build$three(p);
    g.isWebGL2 && !d.isRawShaderMaterial && (g = !1, m = /^\s*#version\s+300\s+es\s*\n/, d.isShaderMaterial && null !== l.match(m) && null !== p.match(m) &&
        (g = !0, l = l.replace(m, ""), p = p.replace(m, "")), k = "#version 300 es\n\n#define attribute in\n#define varying out\n#define texture2D texture\n" + k, b = ["#version 300 es\n\n#define varying in", g ? "" : "out highp vec4 pc_fragColor;", g ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad"].join("\n") +
        "\n" + b);
    p = b + p;
    l = WebGLShader$$module$node_modules$three$build$three(h, h.VERTEX_SHADER, k + l);
    p = WebGLShader$$module$node_modules$three$build$three(h, h.FRAGMENT_SHADER, p);
    h.attachShader(v, l);
    h.attachShader(v, p);
    void 0 !== d.index0AttributeName ? h.bindAttribLocation(v, 0, d.index0AttributeName) : !0 === f.morphTargets && h.bindAttribLocation(v, 0, "position");
    h.linkProgram(v);
    f = h.getProgramInfoLog(v).trim();
    g = h.getShaderInfoLog(l).trim();
    m = h.getShaderInfoLog(p).trim();
    r = q = !0;
    if (!1 === h.getProgramParameter(v, h.LINK_STATUS)) q = !1, console.error("THREE.WebGLProgram: shader error: ", h.getError(), "gl.VALIDATE_STATUS", h.getProgramParameter(v, h.VALIDATE_STATUS), "gl.getProgramInfoLog", f, g, m);
    else if ("" !== f) console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", f);
    else if ("" === g || "" === m) r = !1;
    r && (this.diagnostics = {
        runnable: q,
        material: d,
        programLog: f,
        vertexShader: {
            log: g,
            prefix: k
        },
        fragmentShader: {
            log: m,
            prefix: b
        }
    });
    h.deleteShader(l);
    h.deleteShader(p);
    var y;
    this.getUniforms = function() {
        void 0 === y && (y = new WebGLUniforms$$module$node_modules$three$build$three(h,
            v, a));
        return y
    };
    var A;
    this.getAttributes = function() {
        void 0 === A && (A = fetchAttributeLocations$$module$node_modules$three$build$three(h, v));
        return A
    };
    this.destroy = function() {
        h.deleteProgram(v);
        this.program = void 0
    };
    Object.defineProperties(this, {
        uniforms: {
            get: function() {
                console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms().");
                return this.getUniforms()
            }
        },
        attributes: {
            get: function() {
                console.warn("THREE.WebGLProgram: .attributes is now .getAttributes().");
                return this.getAttributes()
            }
        }
    });
    this.name =
        e.name;
    this.id = programIdCount$$module$node_modules$three$build$three++;
    this.code = c;
    this.usedTimes = 1;
    this.program = v;
    this.vertexShader = l;
    this.fragmentShader = p;
    return this
}

function WebGLPrograms$$module$node_modules$three$build$three(a, b, c) {
    function d(a, b) {
        if (a) a.isTexture ? c = a.encoding : a.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), c = a.texture.encoding);
        else var c = module$node_modules$three$build$three.default.LinearEncoding;
        c === module$node_modules$three$build$three.default.LinearEncoding && b && (c = module$node_modules$three$build$three.default.GammaEncoding);
        return c
    }
    var e = [],
        f = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "phong",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite"
        },
        g = "precision supportsVertexTextures map mapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap objectSpaceNormalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering".split(" ");
    this.getParameters = function(b, e, g, p, m, q, r) {
        var h = f[b.type];
        if (r.isSkinnedMesh) {
            var k = r.skeleton.bones;
            if (c.floatVertexTextures) k = 1024;
            else {
                var l = Math.min(Math.floor((c.maxVertexUniforms - 20) / 4), k.length);
                l < k.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + k.length + " bones. This GPU supports " + l + "."), k = 0) : k = l
            }
        } else k = 0;
        l = c.precision;
        null !== b.precision && (l = c.getMaxPrecision(b.precision), l !== b.precision && console.warn("THREE.WebGLProgram.getParameters:", b.precision, "not supported, using", l, "instead."));
        var w = a.getRenderTarget();
        return {
            shaderID: h,
            precision: l,
            supportsVertexTextures: c.vertexTextures,
            outputEncoding: d(w ? w.texture : null, a.gammaOutput),
            map: !!b.map,
            mapEncoding: d(b.map, a.gammaInput),
            envMap: !!b.envMap,
            envMapMode: b.envMap && b.envMap.mapping,
            envMapEncoding: d(b.envMap, a.gammaInput),
            envMapCubeUV: !!b.envMap && (b.envMap.mapping === module$node_modules$three$build$three.default.CubeUVReflectionMapping || b.envMap.mapping === module$node_modules$three$build$three.default.CubeUVRefractionMapping),
            lightMap: !!b.lightMap,
            aoMap: !!b.aoMap,
            emissiveMap: !!b.emissiveMap,
            emissiveMapEncoding: d(b.emissiveMap, a.gammaInput),
            bumpMap: !!b.bumpMap,
            normalMap: !!b.normalMap,
            objectSpaceNormalMap: b.normalMapType === module$node_modules$three$build$three.default.ObjectSpaceNormalMap,
            displacementMap: !!b.displacementMap,
            roughnessMap: !!b.roughnessMap,
            metalnessMap: !!b.metalnessMap,
            specularMap: !!b.specularMap,
            alphaMap: !!b.alphaMap,
            gradientMap: !!b.gradientMap,
            combine: b.combine,
            vertexColors: b.vertexColors,
            fog: !!p,
            useFog: b.fog,
            fogExp: p && p.isFogExp2,
            flatShading: b.flatShading,
            sizeAttenuation: b.sizeAttenuation,
            logarithmicDepthBuffer: c.logarithmicDepthBuffer,
            skinning: b.skinning && 0 < k,
            maxBones: k,
            useVertexTexture: c.floatVertexTextures,
            morphTargets: b.morphTargets,
            morphNormals: b.morphNormals,
            maxMorphTargets: a.maxMorphTargets,
            maxMorphNormals: a.maxMorphNormals,
            numDirLights: e.directional.length,
            numPointLights: e.point.length,
            numSpotLights: e.spot.length,
            numRectAreaLights: e.rectArea.length,
            numHemiLights: e.hemi.length,
            numClippingPlanes: m,
            numClipIntersection: q,
            dithering: b.dithering,
            shadowMapEnabled: a.shadowMap.enabled && r.receiveShadow && 0 < g.length,
            shadowMapType: a.shadowMap.type,
            toneMapping: a.toneMapping,
            physicallyCorrectLights: a.physicallyCorrectLights,
            premultipliedAlpha: b.premultipliedAlpha,
            alphaTest: b.alphaTest,
            doubleSided: b.side === module$node_modules$three$build$three.default.DoubleSide,
            flipSided: b.side === module$node_modules$three$build$three.default.BackSide,
            depthPacking: void 0 !== b.depthPacking ? b.depthPacking : !1
        }
    };
    this.getProgramCode = function(b, c) {
        var d = [];
        c.shaderID ? d.push(c.shaderID) : (d.push(b.fragmentShader), d.push(b.vertexShader));
        if (void 0 !== b.defines)
            for (var e in b.defines) d.push(e), d.push(b.defines[e]);
        for (e = 0; e < g.length; e++) d.push(c[g[e]]);
        d.push(b.onBeforeCompile.toString());
        d.push(a.gammaOutput);
        return d.join()
    };
    this.acquireProgram = function(d, f, g, p) {
        for (var h, k = 0, l = e.length; k < l; k++) {
            var n = e[k];
            if (n.code === p) {
                h = n;
                ++h.usedTimes;
                break
            }
        }
        void 0 === h && (h = new WebGLProgram$$module$node_modules$three$build$three(a, b, p, d, f, g, c), e.push(h));
        return h
    };
    this.releaseProgram = function(a) {
        if (0 === --a.usedTimes) {
            var b = e.indexOf(a);
            e[b] = e[e.length - 1];
            e.pop();
            a.destroy()
        }
    };
    this.programs = e
}

function WebGLProperties$$module$node_modules$three$build$three() {
    var a = new WeakMap;
    return {
        get: function(b) {
            var c = a.get(b);
            void 0 === c && (c = {}, a.set(b, c));
            return c
        },
        remove: function(b) {
            a.delete(b)
        },
        update: function(b, c, d) {
            a.get(b)[c] = d
        },
        dispose: function() {
            a = new WeakMap
        }
    }
}

function painterSortStable$$module$node_modules$three$build$three(a, b) {
    return a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.program && b.program && a.program !== b.program ? a.program.id - b.program.id : a.material.id !== b.material.id ? a.material.id - b.material.id : a.z !== b.z ? a.z - b.z : a.id - b.id
}

function reversePainterSortStable$$module$node_modules$three$build$three(a, b) {
    return a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z !== b.z ? b.z - a.z : a.id - b.id
}

function WebGLRenderList$$module$node_modules$three$build$three() {
    var a = [],
        b = 0,
        c = [],
        d = [];
    return {
        opaque: c,
        transparent: d,
        init: function() {
            b = 0;
            c.length = 0;
            d.length = 0
        },
        push: function(e, f, g, h, k) {
            var l = a[b];
            void 0 === l ? (l = {
                id: e.id,
                object: e,
                geometry: f,
                material: g,
                program: g.program,
                renderOrder: e.renderOrder,
                z: h,
                group: k
            }, a[b] = l) : (l.id = e.id, l.object = e, l.geometry = f, l.material = g, l.program = g.program, l.renderOrder = e.renderOrder, l.z = h, l.group = k);
            (!0 === g.transparent ? d : c).push(l);
            b++
        },
        sort: function() {
            1 < c.length && c.sort(painterSortStable$$module$node_modules$three$build$three);
            1 < d.length && d.sort(reversePainterSortStable$$module$node_modules$three$build$three)
        }
    }
}

function WebGLRenderLists$$module$node_modules$three$build$three() {
    var a = {};
    return {
        get: function(b, c) {
            b = b.id + "," + c.id;
            c = a[b];
            void 0 === c && (c = new WebGLRenderList$$module$node_modules$three$build$three, a[b] = c);
            return c
        },
        dispose: function() {
            a = {}
        }
    }
}

function UniformsCache$$module$node_modules$three$build$three() {
    var a = {};
    return {
        get: function(b) {
            if (void 0 !== a[b.id]) return a[b.id];
            switch (b.type) {
                case "DirectionalLight":
                    var c = {
                        direction: new module$node_modules$three$build$three.default.Vector3,
                        color: new module$node_modules$three$build$three.default.Color,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new module$node_modules$three$build$three.default.Vector2
                    };
                    break;
                case "SpotLight":
                    c = {
                        position: new module$node_modules$three$build$three.default.Vector3,
                        direction: new module$node_modules$three$build$three.default.Vector3,
                        color: new module$node_modules$three$build$three.default.Color,
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new module$node_modules$three$build$three.default.Vector2
                    };
                    break;
                case "PointLight":
                    c = {
                        position: new module$node_modules$three$build$three.default.Vector3,
                        color: new module$node_modules$three$build$three.default.Color,
                        distance: 0,
                        decay: 0,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new module$node_modules$three$build$three.default.Vector2,
                        shadowCameraNear: 1,
                        shadowCameraFar: 1E3
                    };
                    break;
                case "HemisphereLight":
                    c = {
                        direction: new module$node_modules$three$build$three.default.Vector3,
                        skyColor: new module$node_modules$three$build$three.default.Color,
                        groundColor: new module$node_modules$three$build$three.default.Color
                    };
                    break;
                case "RectAreaLight":
                    c = {
                        color: new module$node_modules$three$build$three.default.Color,
                        position: new module$node_modules$three$build$three.default.Vector3,
                        halfWidth: new module$node_modules$three$build$three.default.Vector3,
                        halfHeight: new module$node_modules$three$build$three.default.Vector3
                    }
            }
            return a[b.id] = c
        }
    }
}
var count$$module$node_modules$three$build$three = 0;

function WebGLLights$$module$node_modules$three$build$three() {
    var a = new UniformsCache$$module$node_modules$three$build$three,
        b = {
            id: count$$module$node_modules$three$build$three++,
            hash: {
                stateID: -1,
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                shadowsLength: -1
            },
            ambient: [0, 0, 0],
            directional: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            point: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: []
        },
        c = new module$node_modules$three$build$three.default.Vector3,
        d = new module$node_modules$three$build$three.default.Matrix4,
        e = new module$node_modules$three$build$three.default.Matrix4;
    return {
        setup: function(f, g, h) {
            var k = 0,
                l = 0,
                p = 0,
                m = 0,
                q = 0,
                r = 0,
                n = 0,
                t = 0;
            h = h.matrixWorldInverse;
            for (var u = 0, w = f.length; u < w; u++) {
                var v = f[u],
                    y = v.color,
                    A = v.intensity,
                    x = v.distance,
                    z = v.shadow && v.shadow.map ? v.shadow.map.texture : null;
                if (v.isAmbientLight) k += y.r * A, l += y.g * A, p += y.b * A;
                else if (v.isDirectionalLight) {
                    var B = a.get(v);
                    B.color.copy(v.color).multiplyScalar(v.intensity);
                    B.direction.setFromMatrixPosition(v.matrixWorld);
                    c.setFromMatrixPosition(v.target.matrixWorld);
                    B.direction.sub(c);
                    B.direction.transformDirection(h);
                    if (B.shadow = v.castShadow) y = v.shadow, B.shadowBias = y.bias, B.shadowRadius = y.radius, B.shadowMapSize = y.mapSize;
                    b.directionalShadowMap[m] = z;
                    b.directionalShadowMatrix[m] = v.shadow.matrix;
                    b.directional[m] = B;
                    m++
                } else if (v.isSpotLight) {
                    B = a.get(v);
                    B.position.setFromMatrixPosition(v.matrixWorld);
                    B.position.applyMatrix4(h);
                    B.color.copy(y).multiplyScalar(A);
                    B.distance = x;
                    B.direction.setFromMatrixPosition(v.matrixWorld);
                    c.setFromMatrixPosition(v.target.matrixWorld);
                    B.direction.sub(c);
                    B.direction.transformDirection(h);
                    B.coneCos = Math.cos(v.angle);
                    B.penumbraCos = Math.cos(v.angle * (1 - v.penumbra));
                    B.decay = 0 === v.distance ? 0 : v.decay;
                    if (B.shadow = v.castShadow) y = v.shadow, B.shadowBias = y.bias, B.shadowRadius = y.radius, B.shadowMapSize = y.mapSize;
                    b.spotShadowMap[r] = z;
                    b.spotShadowMatrix[r] = v.shadow.matrix;
                    b.spot[r] = B;
                    r++
                } else if (v.isRectAreaLight) B = a.get(v), B.color.copy(y).multiplyScalar(A), B.position.setFromMatrixPosition(v.matrixWorld),
                    B.position.applyMatrix4(h), e.identity(), d.copy(v.matrixWorld), d.premultiply(h), e.extractRotation(d), B.halfWidth.set(.5 * v.width, 0, 0), B.halfHeight.set(0, .5 * v.height, 0), B.halfWidth.applyMatrix4(e), B.halfHeight.applyMatrix4(e), b.rectArea[n] = B, n++;
                else if (v.isPointLight) {
                    B = a.get(v);
                    B.position.setFromMatrixPosition(v.matrixWorld);
                    B.position.applyMatrix4(h);
                    B.color.copy(v.color).multiplyScalar(v.intensity);
                    B.distance = v.distance;
                    B.decay = 0 === v.distance ? 0 : v.decay;
                    if (B.shadow = v.castShadow) y = v.shadow, B.shadowBias =
                        y.bias, B.shadowRadius = y.radius, B.shadowMapSize = y.mapSize, B.shadowCameraNear = y.camera.near, B.shadowCameraFar = y.camera.far;
                    b.pointShadowMap[q] = z;
                    b.pointShadowMatrix[q] = v.shadow.matrix;
                    b.point[q] = B;
                    q++
                } else v.isHemisphereLight && (B = a.get(v), B.direction.setFromMatrixPosition(v.matrixWorld), B.direction.transformDirection(h), B.direction.normalize(), B.skyColor.copy(v.color).multiplyScalar(A), B.groundColor.copy(v.groundColor).multiplyScalar(A), b.hemi[t] = B, t++)
            }
            b.ambient[0] = k;
            b.ambient[1] = l;
            b.ambient[2] = p;
            b.directional.length = m;
            b.spot.length = r;
            b.rectArea.length = n;
            b.point.length = q;
            b.hemi.length = t;
            b.hash.stateID = b.id;
            b.hash.directionalLength = m;
            b.hash.pointLength = q;
            b.hash.spotLength = r;
            b.hash.rectAreaLength = n;
            b.hash.hemiLength = t;
            b.hash.shadowsLength = g.length
        },
        state: b
    }
}

function WebGLRenderState$$module$node_modules$three$build$three() {
    var a = new WebGLLights$$module$node_modules$three$build$three,
        b = [],
        c = [];
    return {
        init: function() {
            b.length = 0;
            c.length = 0
        },
        state: {
            lightsArray: b,
            shadowsArray: c,
            lights: a
        },
        setupLights: function(d) {
            a.setup(b, c, d)
        },
        pushLight: function(a) {
            b.push(a)
        },
        pushShadow: function(a) {
            c.push(a)
        }
    }
}

function WebGLRenderStates$$module$node_modules$three$build$three() {
    var a = {};
    return {
        get: function(b, c) {
            if (void 0 === a[b.id]) {
                var d = new WebGLRenderState$$module$node_modules$three$build$three;
                a[b.id] = {};
                a[b.id][c.id] = d
            } else void 0 === a[b.id][c.id] ? (d = new WebGLRenderState$$module$node_modules$three$build$three, a[b.id][c.id] = d) : d = a[b.id][c.id];
            return d
        },
        dispose: function() {
            a = {}
        }
    }
}
module$node_modules$three$build$three.default.MeshDepthMaterial.prototype = Object.create(module$node_modules$three$build$three.default.Material.prototype);
module$node_modules$three$build$three.default.MeshDepthMaterial.prototype.constructor = module$node_modules$three$build$three.default.MeshDepthMaterial;
module$node_modules$three$build$three.default.MeshDepthMaterial.prototype.isMeshDepthMaterial = !0;
module$node_modules$three$build$three.default.MeshDepthMaterial.prototype.copy = function(a) {
    module$node_modules$three$build$three.default.Material.prototype.copy.call(this, a);
    this.depthPacking = a.depthPacking;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.map = a.map;
    this.alphaMap = a.alphaMap;
    this.displacementMap = a.displacementMap;
    this.displacementScale = a.displacementScale;
    this.displacementBias = a.displacementBias;
    this.wireframe = a.wireframe;
    this.wireframeLinewidth = a.wireframeLinewidth;
    return this
};
module$node_modules$three$build$three.default.MeshDistanceMaterial.prototype = Object.create(module$node_modules$three$build$three.default.Material.prototype);
module$node_modules$three$build$three.default.MeshDistanceMaterial.prototype.constructor = module$node_modules$three$build$three.default.MeshDistanceMaterial;
module$node_modules$three$build$three.default.MeshDistanceMaterial.prototype.isMeshDistanceMaterial = !0;
module$node_modules$three$build$three.default.MeshDistanceMaterial.prototype.copy = function(a) {
    module$node_modules$three$build$three.default.Material.prototype.copy.call(this, a);
    this.referencePosition.copy(a.referencePosition);
    this.nearDistance = a.nearDistance;
    this.farDistance = a.farDistance;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.map = a.map;
    this.alphaMap = a.alphaMap;
    this.displacementMap = a.displacementMap;
    this.displacementScale = a.displacementScale;
    this.displacementBias = a.displacementBias;
    return this
};

function WebGLShadowMap$$module$node_modules$three$build$three(a, b, c) {
    function d(b, c, d, e, f, g) {
        var h = b.geometry;
        var k = m;
        var l = b.customDepthMaterial;
        d && (k = q, l = b.customDistanceMaterial);
        l ? k = l : (l = !1, c.morphTargets && (h && h.isBufferGeometry ? l = h.morphAttributes && h.morphAttributes.position && 0 < h.morphAttributes.position.length : h && h.isGeometry && (l = h.morphTargets && 0 < h.morphTargets.length)), b.isSkinnedMesh && !1 === c.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", b),
            b = b.isSkinnedMesh && c.skinning, h = 0, l && (h |= 1), b && (h |= 2), k = k[h]);
        a.localClippingEnabled && !0 === c.clipShadows && 0 !== c.clippingPlanes.length && (h = k.uuid, l = c.uuid, b = r[h], void 0 === b && (b = {}, r[h] = b), h = b[l], void 0 === h && (h = k.clone(), b[l] = h), k = h);
        k.visible = c.visible;
        k.wireframe = c.wireframe;
        k.side = null != c.shadowSide ? c.shadowSide : n[c.side];
        k.clipShadows = c.clipShadows;
        k.clippingPlanes = c.clippingPlanes;
        k.clipIntersection = c.clipIntersection;
        k.wireframeLinewidth = c.wireframeLinewidth;
        k.linewidth = c.linewidth;
        d && k.isMeshDistanceMaterial &&
            (k.referencePosition.copy(e), k.nearDistance = f, k.farDistance = g);
        return k
    }

    function e(c, g, h, k) {
        if (!1 !== c.visible) {
            if (c.layers.test(g.layers) && (c.isMesh || c.isLine || c.isPoints) && c.castShadow && (!c.frustumCulled || f.intersectsObject(c))) {
                c.modelViewMatrix.multiplyMatrices(h.matrixWorldInverse, c.matrixWorld);
                var l = b.update(c),
                    x = c.material;
                if (Array.isArray(x))
                    for (var m = l.groups, n = 0, q = m.length; n < q; n++) {
                        var r = m[n],
                            z = x[r.materialIndex];
                        z && z.visible && (z = d(c, z, k, p, h.near, h.far), a.renderBufferDirect(h, null, l, z, c,
                            r))
                    } else x.visible && (z = d(c, x, k, p, h.near, h.far), a.renderBufferDirect(h, null, l, z, c, null))
            }
            c = c.children;
            l = 0;
            for (x = c.length; l < x; l++) e(c[l], g, h, k)
        }
    }
    var f = new module$node_modules$three$build$three.default.Frustum,
        g = new module$node_modules$three$build$three.default.Matrix4,
        h = new module$node_modules$three$build$three.default.Vector2,
        k = new module$node_modules$three$build$three.default.Vector2(c, c),
        l = new module$node_modules$three$build$three.default.Vector3,
        p = new module$node_modules$three$build$three.default.Vector3,
        m = Array(4),
        q = Array(4),
        r = {},
        n = {
            0: module$node_modules$three$build$three.default.BackSide,
            1: module$node_modules$three$build$three.default.FrontSide,
            2: module$node_modules$three$build$three.default.DoubleSide
        },
        t = [new module$node_modules$three$build$three.default.Vector3(1, 0, 0), new module$node_modules$three$build$three.default.Vector3(-1, 0, 0), new module$node_modules$three$build$three.default.Vector3(0, 0, 1), new module$node_modules$three$build$three.default.Vector3(0, 0, -1), new module$node_modules$three$build$three.default.Vector3(0,
            1, 0), new module$node_modules$three$build$three.default.Vector3(0, -1, 0)],
        u = [new module$node_modules$three$build$three.default.Vector3(0, 1, 0), new module$node_modules$three$build$three.default.Vector3(0, 1, 0), new module$node_modules$three$build$three.default.Vector3(0, 1, 0), new module$node_modules$three$build$three.default.Vector3(0, 1, 0), new module$node_modules$three$build$three.default.Vector3(0, 0, 1), new module$node_modules$three$build$three.default.Vector3(0, 0, -1)],
        w = [new module$node_modules$three$build$three.default.Vector4,
            new module$node_modules$three$build$three.default.Vector4, new module$node_modules$three$build$three.default.Vector4, new module$node_modules$three$build$three.default.Vector4, new module$node_modules$three$build$three.default.Vector4, new module$node_modules$three$build$three.default.Vector4
        ];
    for (c = 0; 4 !== c; ++c) {
        var v = 0 !== (c & 1),
            y = 0 !== (c & 2),
            A = new module$node_modules$three$build$three.default.MeshDepthMaterial({
                depthPacking: module$node_modules$three$build$three.default.RGBADepthPacking,
                morphTargets: v,
                skinning: y
            });
        m[c] = A;
        v = new module$node_modules$three$build$three.default.MeshDistanceMaterial({
            morphTargets: v,
            skinning: y
        });
        q[c] = v
    }
    var x = this;
    this.enabled = !1;
    this.autoUpdate = !0;
    this.needsUpdate = !1;
    this.type = module$node_modules$three$build$three.default.PCFShadowMap;
    this.render = function(b, c, d) {
        if (!1 !== x.enabled && (!1 !== x.autoUpdate || !1 !== x.needsUpdate) && 0 !== b.length) {
            var m = a.state;
            m.disable(a.context.BLEND);
            m.buffers.color.setClear(1, 1, 1, 1);
            m.buffers.depth.setTest(!0);
            m.setScissorTest(!1);
            for (var n, q = 0, r = b.length; q <
                r; q++) {
                var z = b[q];
                n = z.shadow;
                var A = z && z.isPointLight;
                if (void 0 === n) console.warn("THREE.WebGLShadowMap:", z, "has no shadow.");
                else {
                    var y = n.camera;
                    h.copy(n.mapSize);
                    h.min(k);
                    if (A) {
                        var B = h.x,
                            v = h.y;
                        w[0].set(2 * B, v, B, v);
                        w[1].set(0, v, B, v);
                        w[2].set(3 * B, v, B, v);
                        w[3].set(B, v, B, v);
                        w[4].set(3 * B, 0, B, v);
                        w[5].set(B, 0, B, v);
                        h.x *= 4;
                        h.y *= 2
                    }
                    null === n.map && (n.map = new module$node_modules$three$build$three.default.WebGLRenderTarget(h.x, h.y, {
                        minFilter: module$node_modules$three$build$three.default.NearestFilter,
                        magFilter: module$node_modules$three$build$three.default.NearestFilter,
                        format: module$node_modules$three$build$three.default.RGBAFormat
                    }), n.map.texture.name = z.name + ".shadowMap", y.updateProjectionMatrix());
                    n.isSpotLightShadow && n.update(z);
                    B = n.map;
                    v = n.matrix;
                    p.setFromMatrixPosition(z.matrixWorld);
                    y.position.copy(p);
                    A ? (n = 6, v.makeTranslation(-p.x, -p.y, -p.z)) : (n = 1, l.setFromMatrixPosition(z.target.matrixWorld), y.lookAt(l), y.updateMatrixWorld(), v.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), v.multiply(y.projectionMatrix), v.multiply(y.matrixWorldInverse));
                    a.setRenderTarget(B);
                    a.clear();
                    for (z = 0; z < n; z++) A && (l.copy(y.position), l.add(t[z]), y.up.copy(u[z]), y.lookAt(l), y.updateMatrixWorld(), m.viewport(w[z])), g.multiplyMatrices(y.projectionMatrix, y.matrixWorldInverse), f.setFromMatrix(g), e(c, d, y, A)
                }
            }
            x.needsUpdate = !1
        }
    }
}

function WebGLState$$module$node_modules$three$build$three(a, b, c, d) {
    function e(b, c, d) {
        var e = new Uint8Array(4),
            f = a.createTexture();
        a.bindTexture(b, f);
        a.texParameteri(b, a.TEXTURE_MIN_FILTER, a.NEAREST);
        a.texParameteri(b, a.TEXTURE_MAG_FILTER, a.NEAREST);
        for (b = 0; b < d; b++) a.texImage2D(c + b, 0, a.RGBA, 1, 1, 0, a.RGBA, a.UNSIGNED_BYTE, e);
        return f
    }

    function f(c, e) {
        w[c] = 1;
        0 === v[c] && (a.enableVertexAttribArray(c), v[c] = 1);
        y[c] !== e && ((d.isWebGL2 ? a : b.get("ANGLE_instanced_arrays"))[d.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](c,
            e), y[c] = e)
    }

    function g(b) {
        !0 !== A[b] && (a.enable(b), A[b] = !0)
    }

    function h(b) {
        !1 !== A[b] && (a.disable(b), A[b] = !1)
    }

    function k(b, d, e, f, k, l, x, m) {
        b !== module$node_modules$three$build$three.default.NoBlending ? g(a.BLEND) : h(a.BLEND);
        if (b !== module$node_modules$three$build$three.default.CustomBlending) {
            if (b !== B || m !== T) switch (b) {
                case module$node_modules$three$build$three.default.AdditiveBlending:
                    m ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ONE, a.ONE, a.ONE, a.ONE)) : (a.blendEquation(a.FUNC_ADD),
                        a.blendFunc(a.SRC_ALPHA, a.ONE));
                    break;
                case module$node_modules$three$build$three.default.SubtractiveBlending:
                    m ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ZERO, a.ZERO, a.ONE_MINUS_SRC_COLOR, a.ONE_MINUS_SRC_ALPHA)) : (a.blendEquation(a.FUNC_ADD), a.blendFunc(a.ZERO, a.ONE_MINUS_SRC_COLOR));
                    break;
                case module$node_modules$three$build$three.default.MultiplyBlending:
                    m ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ZERO, a.SRC_COLOR, a.ZERO, a.SRC_ALPHA)) : (a.blendEquation(a.FUNC_ADD),
                        a.blendFunc(a.ZERO, a.SRC_COLOR));
                    break;
                default:
                    m ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ONE, a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE_MINUS_SRC_ALPHA)) : (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.SRC_ALPHA, a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE_MINUS_SRC_ALPHA))
            }
            G = I = D = H = K = N = null
        } else {
            k = k || d;
            l = l || e;
            x = x || f;
            if (d !== N || k !== D) a.blendEquationSeparate(c.convert(d), c.convert(k)), N = d, D = k;
            if (e !== K || f !== H || l !== I || x !== G) a.blendFuncSeparate(c.convert(e), c.convert(f),
                c.convert(l), c.convert(x)), K = e, H = f, I = l, G = x
        }
        B = b;
        T = m
    }

    function l(b) {
        L !== b && (b ? a.frontFace(a.CW) : a.frontFace(a.CCW), L = b)
    }

    function p(b) {
        b !== module$node_modules$three$build$three.default.CullFaceNone ? (g(a.CULL_FACE), b !== F && (b === module$node_modules$three$build$three.default.CullFaceBack ? a.cullFace(a.BACK) : b === module$node_modules$three$build$three.default.CullFaceFront ? a.cullFace(a.FRONT) : a.cullFace(a.FRONT_AND_BACK))) : h(a.CULL_FACE);
        F = b
    }

    function m(b, c, d) {
        if (b) {
            if (g(a.POLYGON_OFFSET_FILL), J !== c || R !== d) a.polygonOffset(c,
                d), J = c, R = d
        } else h(a.POLYGON_OFFSET_FILL)
    }

    function q(b) {
        void 0 === b && (b = a.TEXTURE0 + V - 1);
        O !== b && (a.activeTexture(b), O = b)
    }
    var r = new function() {
            var b = !1,
                c = new module$node_modules$three$build$three.default.Vector4,
                d = null,
                e = new module$node_modules$three$build$three.default.Vector4(0, 0, 0, 0);
            return {
                setMask: function(c) {
                    d === c || b || (a.colorMask(c, c, c, c), d = c)
                },
                setLocked: function(a) {
                    b = a
                },
                setClear: function(b, d, f, g, h) {
                    !0 === h && (b *= g, d *= g, f *= g);
                    c.set(b, d, f, g);
                    !1 === e.equals(c) && (a.clearColor(b, d, f, g), e.copy(c))
                },
                reset: function() {
                    b = !1;
                    d = null;
                    e.set(-1, 0, 0, 0)
                }
            }
        },
        n = new function() {
            var b = !1,
                c = null,
                d = null,
                e = null;
            return {
                setTest: function(b) {
                    b ? g(a.DEPTH_TEST) : h(a.DEPTH_TEST)
                },
                setMask: function(d) {
                    c === d || b || (a.depthMask(d), c = d)
                },
                setFunc: function(b) {
                    if (d !== b) {
                        if (b) switch (b) {
                            case module$node_modules$three$build$three.default.NeverDepth:
                                a.depthFunc(a.NEVER);
                                break;
                            case module$node_modules$three$build$three.default.AlwaysDepth:
                                a.depthFunc(a.ALWAYS);
                                break;
                            case module$node_modules$three$build$three.default.LessDepth:
                                a.depthFunc(a.LESS);
                                break;
                            case module$node_modules$three$build$three.default.LessEqualDepth:
                                a.depthFunc(a.LEQUAL);
                                break;
                            case module$node_modules$three$build$three.default.EqualDepth:
                                a.depthFunc(a.EQUAL);
                                break;
                            case module$node_modules$three$build$three.default.GreaterEqualDepth:
                                a.depthFunc(a.GEQUAL);
                                break;
                            case module$node_modules$three$build$three.default.GreaterDepth:
                                a.depthFunc(a.GREATER);
                                break;
                            case module$node_modules$three$build$three.default.NotEqualDepth:
                                a.depthFunc(a.NOTEQUAL);
                                break;
                            default:
                                a.depthFunc(a.LEQUAL)
                        } else a.depthFunc(a.LEQUAL);
                        d = b
                    }
                },
                setLocked: function(a) {
                    b = a
                },
                setClear: function(b) {
                    e !== b && (a.clearDepth(b), e = b)
                },
                reset: function() {
                    b = !1;
                    e = d = c = null
                }
            }
        },
        t = new function() {
            var b = !1,
                c = null,
                d = null,
                e = null,
                f = null,
                k = null,
                l = null,
                x = null,
                m = null;
            return {
                setTest: function(b) {
                    b ? g(a.STENCIL_TEST) : h(a.STENCIL_TEST)
                },
                setMask: function(d) {
                    c === d || b || (a.stencilMask(d), c = d)
                },
                setFunc: function(b, c, g) {
                    if (d !== b || e !== c || f !== g) a.stencilFunc(b, c, g), d = b, e = c, f = g
                },
                setOp: function(b, c, d) {
                    if (k !== b || l !== c || x !== d) a.stencilOp(b, c, d), k = b, l = c, x = d
                },
                setLocked: function(a) {
                    b =
                        a
                },
                setClear: function(b) {
                    m !== b && (a.clearStencil(b), m = b)
                },
                reset: function() {
                    b = !1;
                    m = x = l = k = f = e = d = c = null
                }
            }
        },
        u = a.getParameter(a.MAX_VERTEX_ATTRIBS),
        w = new Uint8Array(u),
        v = new Uint8Array(u),
        y = new Uint8Array(u),
        A = {},
        x = null,
        z = null,
        B = null,
        N = null,
        K = null,
        H = null,
        D = null,
        I = null,
        G = null,
        T = !1,
        L = null,
        F = null,
        M = null,
        J = null,
        R = null,
        V = a.getParameter(a.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
        S = !1;
    u = 0;
    u = a.getParameter(a.VERSION); - 1 !== u.indexOf("WebGL") ? (u = parseFloat(/^WebGL ([0-9])/.exec(u)[1]), S = 1 <= u) : -1 !== u.indexOf("OpenGL ES") &&
        (u = parseFloat(/^OpenGL ES ([0-9])/.exec(u)[1]), S = 2 <= u);
    var O = null,
        ba = {},
        X = new module$node_modules$three$build$three.default.Vector4,
        ca = new module$node_modules$three$build$three.default.Vector4,
        E = {};
    E[a.TEXTURE_2D] = e(a.TEXTURE_2D, a.TEXTURE_2D, 1);
    E[a.TEXTURE_CUBE_MAP] = e(a.TEXTURE_CUBE_MAP, a.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
    r.setClear(0, 0, 0, 1);
    n.setClear(1);
    t.setClear(0);
    g(a.DEPTH_TEST);
    n.setFunc(module$node_modules$three$build$three.default.LessEqualDepth);
    l(!1);
    p(module$node_modules$three$build$three.default.CullFaceBack);
    g(a.CULL_FACE);
    g(a.BLEND);
    k(module$node_modules$three$build$three.default.NormalBlending);
    return {
        buffers: {
            color: r,
            depth: n,
            stencil: t
        },
        initAttributes: function() {
            for (var a = 0, b = w.length; a < b; a++) w[a] = 0
        },
        enableAttribute: function(a) {
            f(a, 0)
        },
        enableAttributeAndDivisor: f,
        disableUnusedAttributes: function() {
            for (var b = 0, c = v.length; b !== c; ++b) v[b] !== w[b] && (a.disableVertexAttribArray(b), v[b] = 0)
        },
        enable: g,
        disable: h,
        getCompressedTextureFormats: function() {
            if (null === x && (x = [], b.get("WEBGL_compressed_texture_pvrtc") ||
                    b.get("WEBGL_compressed_texture_s3tc") || b.get("WEBGL_compressed_texture_etc1") || b.get("WEBGL_compressed_texture_astc")))
                for (var c = a.getParameter(a.COMPRESSED_TEXTURE_FORMATS), d = 0; d < c.length; d++) x.push(c[d]);
            return x
        },
        useProgram: function(b) {
            return z !== b ? (a.useProgram(b), z = b, !0) : !1
        },
        setBlending: k,
        setMaterial: function(b, c) {
            b.side === module$node_modules$three$build$three.default.DoubleSide ? h(a.CULL_FACE) : g(a.CULL_FACE);
            var d = b.side === module$node_modules$three$build$three.default.BackSide;
            c && (d = !d);
            l(d);
            b.blending === module$node_modules$three$build$three.default.NormalBlending && !1 === b.transparent ? k(module$node_modules$three$build$three.default.NoBlending) : k(b.blending, b.blendEquation, b.blendSrc, b.blendDst, b.blendEquationAlpha, b.blendSrcAlpha, b.blendDstAlpha, b.premultipliedAlpha);
            n.setFunc(b.depthFunc);
            n.setTest(b.depthTest);
            n.setMask(b.depthWrite);
            r.setMask(b.colorWrite);
            m(b.polygonOffset, b.polygonOffsetFactor, b.polygonOffsetUnits)
        },
        setFlipSided: l,
        setCullFace: p,
        setLineWidth: function(b) {
            b !== M && (S &&
                a.lineWidth(b), M = b)
        },
        setPolygonOffset: m,
        setScissorTest: function(b) {
            b ? g(a.SCISSOR_TEST) : h(a.SCISSOR_TEST)
        },
        activeTexture: q,
        bindTexture: function(b, c) {
            null === O && q();
            var d = ba[O];
            void 0 === d && (d = {
                type: void 0,
                texture: void 0
            }, ba[O] = d);
            if (d.type !== b || d.texture !== c) a.bindTexture(b, c || E[b]), d.type = b, d.texture = c
        },
        compressedTexImage2D: function() {
            try {
                a.compressedTexImage2D.apply(a, arguments)
            } catch (P) {
                console.error("THREE.WebGLState:", P)
            }
        },
        texImage2D: function() {
            try {
                a.texImage2D.apply(a, arguments)
            } catch (P) {
                console.error("THREE.WebGLState:",
                    P)
            }
        },
        scissor: function(b) {
            !1 === X.equals(b) && (a.scissor(b.x, b.y, b.z, b.w), X.copy(b))
        },
        viewport: function(b) {
            !1 === ca.equals(b) && (a.viewport(b.x, b.y, b.z, b.w), ca.copy(b))
        },
        reset: function() {
            for (var b = 0; b < v.length; b++) 1 === v[b] && (a.disableVertexAttribArray(b), v[b] = 0);
            A = {};
            O = x = null;
            ba = {};
            F = L = B = z = null;
            r.reset();
            n.reset();
            t.reset()
        }
    }
}

function WebGLTextures$$module$node_modules$three$build$three(a, b, c, d, e, f, g) {
    function h(a, b) {
        if (a.width > b || a.height > b) {
            if ("data" in a) {
                console.warn("THREE.WebGLRenderer: image in DataTexture is too big (" + a.width + "x" + a.height + ").");
                return
            }
            b /= Math.max(a.width, a.height);
            var c = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
            c.width = Math.floor(a.width * b);
            c.height = Math.floor(a.height * b);
            c.getContext("2d").drawImage(a, 0, 0, a.width, a.height, 0, 0, c.width, c.height);
            console.warn("THREE.WebGLRenderer: image is too big (" +
                a.width + "x" + a.height + "). Resized to " + c.width + "x" + c.height);
            return c
        }
        return a
    }

    function k(a) {
        return module$node_modules$three$build$three.default.Math.isPowerOfTwo(a.width) && module$node_modules$three$build$three.default.Math.isPowerOfTwo(a.height)
    }

    function l(a, b) {
        return a.generateMipmaps && b && a.minFilter !== module$node_modules$three$build$three.default.NearestFilter && a.minFilter !== module$node_modules$three$build$three.default.LinearFilter
    }

    function p(b, c, e, f) {
        a.generateMipmap(b);
        d.get(c).__maxMipLevel =
            Math.log(Math.max(e, f)) * Math.LOG2E
    }

    function m(b, c) {
        if (!e.isWebGL2) return b;
        if (b === a.RGB) {
            if (c === a.FLOAT) return a.RGB32F;
            if (c === a.HALF_FLOAT) return a.RGB16F;
            if (c === a.UNSIGNED_BYTE) return a.RGB8
        }
        if (b === a.RGBA) {
            if (c === a.FLOAT) return a.RGBA32F;
            if (c === a.HALF_FLOAT) return a.RGBA16F;
            if (c === a.UNSIGNED_BYTE) return a.RGBA8
        }
        return b
    }

    function q(b) {
        return b === module$node_modules$three$build$three.default.NearestFilter || b === module$node_modules$three$build$three.default.NearestMipMapNearestFilter || b === module$node_modules$three$build$three.default.NearestMipMapLinearFilter ?
            a.NEAREST : a.LINEAR
    }

    function r(b) {
        b = b.target;
        b.removeEventListener("dispose", r);
        a: {
            var c = d.get(b);
            if (b.image && c.__image__webglTextureCube) a.deleteTexture(c.__image__webglTextureCube);
            else {
                if (void 0 === c.__webglInit) break a;
                a.deleteTexture(c.__webglTexture)
            }
            d.remove(b)
        }
        b.isVideoTexture && delete y[b.id];
        g.memory.textures--
    }

    function n(b) {
        b = b.target;
        b.removeEventListener("dispose", n);
        var c = d.get(b),
            e = d.get(b.texture);
        if (b) {
            void 0 !== e.__webglTexture && a.deleteTexture(e.__webglTexture);
            b.depthTexture && b.depthTexture.dispose();
            if (b.isWebGLRenderTargetCube)
                for (e = 0; 6 > e; e++) a.deleteFramebuffer(c.__webglFramebuffer[e]), c.__webglDepthbuffer && a.deleteRenderbuffer(c.__webglDepthbuffer[e]);
            else a.deleteFramebuffer(c.__webglFramebuffer), c.__webglDepthbuffer && a.deleteRenderbuffer(c.__webglDepthbuffer);
            d.remove(b.texture);
            d.remove(b)
        }
        g.memory.textures--
    }

    function t(b, n) {
        var x = d.get(b);
        if (b.isVideoTexture) {
            var q = b.id,
                z = g.render.frame;
            y[q] !== z && (y[q] = z, b.update())
        }
        if (0 < b.version && x.__version !== b.version)
            if (q = b.image, void 0 === q) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
            else if (!1 === q.complete) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
        else {
            void 0 === x.__webglInit && (x.__webglInit = !0, b.addEventListener("dispose", r), x.__webglTexture = a.createTexture(), g.memory.textures++);
            c.activeTexture(a.TEXTURE0 + n);
            c.bindTexture(a.TEXTURE_2D, x.__webglTexture);
            a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, b.flipY);
            a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, b.premultiplyAlpha);
            a.pixelStorei(a.UNPACK_ALIGNMENT, b.unpackAlignment);
            n = h(b.image, e.maxTextureSize);
            (e.isWebGL2 ? 0 : b.wrapS !== module$node_modules$three$build$three.default.ClampToEdgeWrapping || b.wrapT !== module$node_modules$three$build$three.default.ClampToEdgeWrapping || b.minFilter !== module$node_modules$three$build$three.default.NearestFilter && b.minFilter !== module$node_modules$three$build$three.default.LinearFilter) && !1 === k(n) && (n instanceof HTMLImageElement || n instanceof HTMLCanvasElement || n instanceof ImageBitmap) && (void 0 === A && (A = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")),
                A.width = module$node_modules$three$build$three.default.Math.floorPowerOfTwo(n.width), A.height = module$node_modules$three$build$three.default.Math.floorPowerOfTwo(n.height), A.getContext("2d").drawImage(n, 0, 0, A.width, A.height), console.warn("THREE.WebGLRenderer: image is not power of two (" + n.width + "x" + n.height + "). Resized to " + A.width + "x" + A.height), n = A);
            q = k(n);
            z = f.convert(b.format);
            var t = f.convert(b.type),
                v = m(z, t);
            u(a.TEXTURE_2D, b, q);
            var w = b.mipmaps;
            if (b.isDepthTexture) {
                v = a.DEPTH_COMPONENT;
                if (b.type ===
                    module$node_modules$three$build$three.default.FloatType) {
                    if (!e.isWebGL2) throw Error("Float Depth Texture only supported in WebGL2.0");
                    v = a.DEPTH_COMPONENT32F
                } else e.isWebGL2 && (v = a.DEPTH_COMPONENT16);
                b.format === module$node_modules$three$build$three.default.DepthFormat && v === a.DEPTH_COMPONENT && b.type !== module$node_modules$three$build$three.default.UnsignedShortType && b.type !== module$node_modules$three$build$three.default.UnsignedIntType && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                    b.type = module$node_modules$three$build$three.default.UnsignedShortType, t = f.convert(b.type));
                b.format === module$node_modules$three$build$three.default.DepthStencilFormat && (v = a.DEPTH_STENCIL, b.type !== module$node_modules$three$build$three.default.UnsignedInt248Type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), b.type = module$node_modules$three$build$three.default.UnsignedInt248Type, t = f.convert(b.type)));
                c.texImage2D(a.TEXTURE_2D, 0, v, n.width, n.height,
                    0, z, t, null)
            } else if (b.isDataTexture)
                if (0 < w.length && q) {
                    for (var G = 0, T = w.length; G < T; G++) {
                        var L = w[G];
                        c.texImage2D(a.TEXTURE_2D, G, v, L.width, L.height, 0, z, t, L.data)
                    }
                    b.generateMipmaps = !1;
                    x.__maxMipLevel = w.length - 1
                } else c.texImage2D(a.TEXTURE_2D, 0, v, n.width, n.height, 0, z, t, n.data), x.__maxMipLevel = 0;
            else if (b.isCompressedTexture) {
                G = 0;
                for (T = w.length; G < T; G++) L = w[G], b.format !== module$node_modules$three$build$three.default.RGBAFormat && b.format !== module$node_modules$three$build$three.default.RGBFormat ? -1 < c.getCompressedTextureFormats().indexOf(z) ?
                    c.compressedTexImage2D(a.TEXTURE_2D, G, v, L.width, L.height, 0, L.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : c.texImage2D(a.TEXTURE_2D, G, v, L.width, L.height, 0, z, t, L.data);
                x.__maxMipLevel = w.length - 1
            } else if (0 < w.length && q) {
                G = 0;
                for (T = w.length; G < T; G++) L = w[G], c.texImage2D(a.TEXTURE_2D, G, v, z, t, L);
                b.generateMipmaps = !1;
                x.__maxMipLevel = w.length - 1
            } else c.texImage2D(a.TEXTURE_2D, 0, v, z, t, n), x.__maxMipLevel = 0;
            l(b, q) && p(a.TEXTURE_2D, b, n.width,
                n.height);
            x.__version = b.version;
            if (b.onUpdate) b.onUpdate(b);
            return
        }
        c.activeTexture(a.TEXTURE0 + n);
        c.bindTexture(a.TEXTURE_2D, x.__webglTexture)
    }

    function u(c, g, h) {
        h ? (a.texParameteri(c, a.TEXTURE_WRAP_S, f.convert(g.wrapS)), a.texParameteri(c, a.TEXTURE_WRAP_T, f.convert(g.wrapT)), a.texParameteri(c, a.TEXTURE_MAG_FILTER, f.convert(g.magFilter)), a.texParameteri(c, a.TEXTURE_MIN_FILTER, f.convert(g.minFilter))) : (a.texParameteri(c, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE), a.texParameteri(c, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE),
            g.wrapS === module$node_modules$three$build$three.default.ClampToEdgeWrapping && g.wrapT === module$node_modules$three$build$three.default.ClampToEdgeWrapping || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), a.texParameteri(c, a.TEXTURE_MAG_FILTER, q(g.magFilter)), a.texParameteri(c, a.TEXTURE_MIN_FILTER, q(g.minFilter)), g.minFilter !== module$node_modules$three$build$three.default.NearestFilter && g.minFilter !== module$node_modules$three$build$three.default.LinearFilter &&
            console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));
        !(h = b.get("EXT_texture_filter_anisotropic")) || g.type === module$node_modules$three$build$three.default.FloatType && null === b.get("OES_texture_float_linear") || g.type === module$node_modules$three$build$three.default.HalfFloatType && null === (e.isWebGL2 || b.get("OES_texture_half_float_linear")) || !(1 < g.anisotropy || d.get(g).__currentAnisotropy) || (a.texParameterf(c, h.TEXTURE_MAX_ANISOTROPY_EXT,
            Math.min(g.anisotropy, e.getMaxAnisotropy())), d.get(g).__currentAnisotropy = g.anisotropy)
    }

    function w(b, e, g, h) {
        var k = f.convert(e.texture.format),
            l = f.convert(e.texture.type),
            n = m(k, l);
        c.texImage2D(h, 0, n, e.width, e.height, 0, k, l, null);
        a.bindFramebuffer(a.FRAMEBUFFER, b);
        a.framebufferTexture2D(a.FRAMEBUFFER, g, h, d.get(e.texture).__webglTexture, 0);
        a.bindFramebuffer(a.FRAMEBUFFER, null)
    }

    function v(b, c) {
        a.bindRenderbuffer(a.RENDERBUFFER, b);
        c.depthBuffer && !c.stencilBuffer ? (a.renderbufferStorage(a.RENDERBUFFER, a.DEPTH_COMPONENT16,
            c.width, c.height), a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_ATTACHMENT, a.RENDERBUFFER, b)) : c.depthBuffer && c.stencilBuffer ? (a.renderbufferStorage(a.RENDERBUFFER, a.DEPTH_STENCIL, c.width, c.height), a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.RENDERBUFFER, b)) : a.renderbufferStorage(a.RENDERBUFFER, a.RGBA4, c.width, c.height);
        a.bindRenderbuffer(a.RENDERBUFFER, null)
    }
    var y = {},
        A;
    this.setTexture2D = t;
    this.setTextureCube = function(b, n) {
        var x = d.get(b);
        if (6 === b.image.length)
            if (0 < b.version &&
                x.__version !== b.version) {
                x.__image__webglTextureCube || (b.addEventListener("dispose", r), x.__image__webglTextureCube = a.createTexture(), g.memory.textures++);
                c.activeTexture(a.TEXTURE0 + n);
                c.bindTexture(a.TEXTURE_CUBE_MAP, x.__image__webglTextureCube);
                a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, b.flipY);
                n = b && b.isCompressedTexture;
                for (var q = b.image[0] && b.image[0].isDataTexture, z = [], A = 0; 6 > A; A++) z[A] = n || q ? q ? b.image[A].image : b.image[A] : h(b.image[A], e.maxCubemapSize);
                var t = z[0],
                    y = k(t),
                    v = f.convert(b.format),
                    w = f.convert(b.type),
                    L = m(v, w);
                u(a.TEXTURE_CUBE_MAP, b, y);
                for (A = 0; 6 > A; A++)
                    if (n)
                        for (var F, M = z[A].mipmaps, J = 0, R = M.length; J < R; J++) F = M[J], b.format !== module$node_modules$three$build$three.default.RGBAFormat && b.format !== module$node_modules$three$build$three.default.RGBFormat ? -1 < c.getCompressedTextureFormats().indexOf(v) ? c.compressedTexImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + A, J, L, F.width, F.height, 0, F.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : c.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X +
                            A, J, L, F.width, F.height, 0, v, w, F.data);
                    else q ? c.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + A, 0, L, z[A].width, z[A].height, 0, v, w, z[A].data) : c.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + A, 0, L, v, w, z[A]);
                x.__maxMipLevel = n ? M.length - 1 : 0;
                l(b, y) && p(a.TEXTURE_CUBE_MAP, b, t.width, t.height);
                x.__version = b.version;
                if (b.onUpdate) b.onUpdate(b)
            } else c.activeTexture(a.TEXTURE0 + n), c.bindTexture(a.TEXTURE_CUBE_MAP, x.__image__webglTextureCube)
    };
    this.setTextureCubeDynamic = function(b, e) {
        c.activeTexture(a.TEXTURE0 + e);
        c.bindTexture(a.TEXTURE_CUBE_MAP,
            d.get(b).__webglTexture)
    };
    this.setupRenderTarget = function(b) {
        var e = d.get(b),
            f = d.get(b.texture);
        b.addEventListener("dispose", n);
        f.__webglTexture = a.createTexture();
        g.memory.textures++;
        var h = !0 === b.isWebGLRenderTargetCube,
            m = k(b);
        if (h) {
            e.__webglFramebuffer = [];
            for (var q = 0; 6 > q; q++) e.__webglFramebuffer[q] = a.createFramebuffer()
        } else e.__webglFramebuffer = a.createFramebuffer();
        if (h) {
            c.bindTexture(a.TEXTURE_CUBE_MAP, f.__webglTexture);
            u(a.TEXTURE_CUBE_MAP, b.texture, m);
            for (q = 0; 6 > q; q++) w(e.__webglFramebuffer[q],
                b, a.COLOR_ATTACHMENT0, a.TEXTURE_CUBE_MAP_POSITIVE_X + q);
            l(b.texture, m) && p(a.TEXTURE_CUBE_MAP, b.texture, b.width, b.height);
            c.bindTexture(a.TEXTURE_CUBE_MAP, null)
        } else c.bindTexture(a.TEXTURE_2D, f.__webglTexture), u(a.TEXTURE_2D, b.texture, m), w(e.__webglFramebuffer, b, a.COLOR_ATTACHMENT0, a.TEXTURE_2D), l(b.texture, m) && p(a.TEXTURE_2D, b.texture, b.width, b.height), c.bindTexture(a.TEXTURE_2D, null);
        if (b.depthBuffer) {
            e = d.get(b);
            f = !0 === b.isWebGLRenderTargetCube;
            if (b.depthTexture) {
                if (f) throw Error("target.depthTexture not supported in Cube render targets");
                if (b && b.isWebGLRenderTargetCube) throw Error("Depth Texture with cube render targets is not supported");
                a.bindFramebuffer(a.FRAMEBUFFER, e.__webglFramebuffer);
                if (!b.depthTexture || !b.depthTexture.isDepthTexture) throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                d.get(b.depthTexture).__webglTexture && b.depthTexture.image.width === b.width && b.depthTexture.image.height === b.height || (b.depthTexture.image.width = b.width, b.depthTexture.image.height = b.height, b.depthTexture.needsUpdate = !0);
                t(b.depthTexture, 0);
                e = d.get(b.depthTexture).__webglTexture;
                if (b.depthTexture.format === module$node_modules$three$build$three.default.DepthFormat) a.framebufferTexture2D(a.FRAMEBUFFER, a.DEPTH_ATTACHMENT, a.TEXTURE_2D, e, 0);
                else if (b.depthTexture.format === module$node_modules$three$build$three.default.DepthStencilFormat) a.framebufferTexture2D(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.TEXTURE_2D, e, 0);
                else throw Error("Unknown depthTexture format");
            } else if (f)
                for (e.__webglDepthbuffer = [], f = 0; 6 > f; f++) a.bindFramebuffer(a.FRAMEBUFFER,
                    e.__webglFramebuffer[f]), e.__webglDepthbuffer[f] = a.createRenderbuffer(), v(e.__webglDepthbuffer[f], b);
            else a.bindFramebuffer(a.FRAMEBUFFER, e.__webglFramebuffer), e.__webglDepthbuffer = a.createRenderbuffer(), v(e.__webglDepthbuffer, b);
            a.bindFramebuffer(a.FRAMEBUFFER, null)
        }
    };
    this.updateRenderTargetMipmap = function(b) {
        var e = b.texture,
            f = k(b);
        if (l(e, f)) {
            f = b.isWebGLRenderTargetCube ? a.TEXTURE_CUBE_MAP : a.TEXTURE_2D;
            var g = d.get(e).__webglTexture;
            c.bindTexture(f, g);
            p(f, e, b.width, b.height);
            c.bindTexture(f, null)
        }
    }
}
module$node_modules$three$build$three.default.Group.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.Object3D.prototype), {
    constructor: module$node_modules$three$build$three.default.Group,
    isGroup: !0
});
module$node_modules$three$build$three.default.PerspectiveCamera.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.Camera.prototype), {
    constructor: module$node_modules$three$build$three.default.PerspectiveCamera,
    isPerspectiveCamera: !0,
    copy: function(a, b) {
        module$node_modules$three$build$three.default.Camera.prototype.copy.call(this, a, b);
        this.fov = a.fov;
        this.zoom = a.zoom;
        this.near = a.near;
        this.far = a.far;
        this.focus = a.focus;
        this.aspect = a.aspect;
        this.view = null === a.view ? null :
            Object.assign({}, a.view);
        this.filmGauge = a.filmGauge;
        this.filmOffset = a.filmOffset;
        return this
    },
    setFocalLength: function(a) {
        a = .5 * this.getFilmHeight() / a;
        this.fov = 2 * module$node_modules$three$build$three.default.Math.RAD2DEG * Math.atan(a);
        this.updateProjectionMatrix()
    },
    getFocalLength: function() {
        var a = Math.tan(.5 * module$node_modules$three$build$three.default.Math.DEG2RAD * this.fov);
        return .5 * this.getFilmHeight() / a
    },
    getEffectiveFOV: function() {
        return 2 * module$node_modules$three$build$three.default.Math.RAD2DEG *
            Math.atan(Math.tan(.5 * module$node_modules$three$build$three.default.Math.DEG2RAD * this.fov) / this.zoom)
    },
    getFilmWidth: function() {
        return this.filmGauge * Math.min(this.aspect, 1)
    },
    getFilmHeight: function() {
        return this.filmGauge / Math.max(this.aspect, 1)
    },
    setViewOffset: function(a, b, c, d, e, f) {
        this.aspect = a / b;
        null === this.view && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        });
        this.view.enabled = !0;
        this.view.fullWidth = a;
        this.view.fullHeight = b;
        this.view.offsetX = c;
        this.view.offsetY =
            d;
        this.view.width = e;
        this.view.height = f;
        this.updateProjectionMatrix()
    },
    clearViewOffset: function() {
        null !== this.view && (this.view.enabled = !1);
        this.updateProjectionMatrix()
    },
    updateProjectionMatrix: function() {
        var a = this.near,
            b = a * Math.tan(.5 * module$node_modules$three$build$three.default.Math.DEG2RAD * this.fov) / this.zoom,
            c = 2 * b,
            d = this.aspect * c,
            e = -.5 * d,
            f = this.view;
        if (null !== this.view && this.view.enabled) {
            var g = f.fullWidth,
                h = f.fullHeight;
            e += f.offsetX * d / g;
            b -= f.offsetY * c / h;
            d *= f.width / g;
            c *= f.height / h
        }
        f = this.filmOffset;
        0 !== f && (e += a * f / this.getFilmWidth());
        this.projectionMatrix.makePerspective(e, e + d, b, b - c, a, this.far)
    },
    toJSON: function(a) {
        a = module$node_modules$three$build$three.default.Object3D.prototype.toJSON.call(this, a);
        a.object.fov = this.fov;
        a.object.zoom = this.zoom;
        a.object.near = this.near;
        a.object.far = this.far;
        a.object.focus = this.focus;
        a.object.aspect = this.aspect;
        null !== this.view && (a.object.view = Object.assign({}, this.view));
        a.object.filmGauge = this.filmGauge;
        a.object.filmOffset = this.filmOffset;
        return a
    }
});
module$node_modules$three$build$three.default.ArrayCamera.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.PerspectiveCamera.prototype), {
    constructor: module$node_modules$three$build$three.default.ArrayCamera,
    isArrayCamera: !0
});

function WebVRManager$$module$node_modules$three$build$three(a) {
    function b() {
        return null !== e && !0 === e.isPresenting
    }

    function c() {
        if (b()) {
            var c = e.getEyeParameters("left"),
                f = c.renderWidth;
            c = c.renderHeight;
            w = a.getPixelRatio();
            u = a.getSize();
            a.setDrawingBufferSize(2 * f, c, 1);
            y.start()
        } else d.enabled && (a.setDrawingBufferSize(u.width, u.height, w), y.stop())
    }
    var d = this,
        e = null,
        f = null,
        g = null,
        h = [],
        k = new module$node_modules$three$build$three.default.Matrix4,
        l = new module$node_modules$three$build$three.default.Matrix4;
    "undefined" !== typeof window && "VRFrameData" in window && (f = new window.VRFrameData, window.addEventListener("vrdisplaypresentchange", c, !1));
    var p = new module$node_modules$three$build$three.default.Matrix4,
        m = new module$node_modules$three$build$three.default.Quaternion,
        q = new module$node_modules$three$build$three.default.Vector3,
        r = new module$node_modules$three$build$three.default.PerspectiveCamera;
    r.bounds = new module$node_modules$three$build$three.default.Vector4(0, 0, .5, 1);
    r.layers.enable(1);
    var n = new module$node_modules$three$build$three.default.PerspectiveCamera;
    n.bounds = new module$node_modules$three$build$three.default.Vector4(.5, 0, .5, 1);
    n.layers.enable(2);
    var t = new module$node_modules$three$build$three.default.ArrayCamera([r, n]);
    t.layers.enable(1);
    t.layers.enable(2);
    var u, w, v = [];
    this.enabled = !1;
    this.userHeight = 1.6;
    this.getController = function(a) {
        var b = h[a];
        void 0 === b && (b = new module$node_modules$three$build$three.default.Group, b.matrixAutoUpdate = !1, b.visible = !1, h[a] = b);
        return b
    };
    this.getDevice = function() {
        return e
    };
    this.setDevice = function(a) {
        void 0 !== a && (e =
            a);
        y.setContext(a)
    };
    this.setPoseTarget = function(a) {
        void 0 !== a && (g = a)
    };
    this.getCamera = function(a) {
        if (null === e) return a.position.set(0, d.userHeight, 0), a;
        e.depthNear = a.near;
        e.depthFar = a.far;
        e.getFrameData(f);
        var b = e.stageParameters;
        b ? k.fromArray(b.sittingToStandingTransform) : k.makeTranslation(0, d.userHeight, 0);
        b = f.pose;
        var c = null !== g ? g : a;
        c.matrix.copy(k);
        c.matrix.decompose(c.position, c.quaternion, c.scale);
        null !== b.orientation && (m.fromArray(b.orientation), c.quaternion.multiply(m));
        null !== b.position &&
            (m.setFromRotationMatrix(k), q.fromArray(b.position), q.applyQuaternion(m), c.position.add(q));
        c.updateMatrixWorld();
        if (!1 === e.isPresenting) return a;
        r.near = a.near;
        n.near = a.near;
        r.far = a.far;
        n.far = a.far;
        t.matrixWorld.copy(a.matrixWorld);
        t.matrixWorldInverse.copy(a.matrixWorldInverse);
        r.matrixWorldInverse.fromArray(f.leftViewMatrix);
        n.matrixWorldInverse.fromArray(f.rightViewMatrix);
        l.getInverse(k);
        r.matrixWorldInverse.multiply(l);
        n.matrixWorldInverse.multiply(l);
        a = c.parent;
        null !== a && (p.getInverse(a.matrixWorld),
            r.matrixWorldInverse.multiply(p), n.matrixWorldInverse.multiply(p));
        r.matrixWorld.getInverse(r.matrixWorldInverse);
        n.matrixWorld.getInverse(n.matrixWorldInverse);
        r.projectionMatrix.fromArray(f.leftProjectionMatrix);
        n.projectionMatrix.fromArray(f.rightProjectionMatrix);
        t.projectionMatrix.copy(r.projectionMatrix);
        a = e.getLayers();
        a.length && (a = a[0], null !== a.leftBounds && 4 === a.leftBounds.length && r.bounds.fromArray(a.leftBounds), null !== a.rightBounds && 4 === a.rightBounds.length && n.bounds.fromArray(a.rightBounds));
        a: for (a = 0; a < h.length; a++) {
            b = h[a];
            b: {
                c = a;
                for (var u = navigator.getGamepads && navigator.getGamepads(), A = 0, y = 0, w = u.length; A < w; A++) {
                    var D = u[A];
                    if (D && ("Daydream Controller" === D.id || "Gear VR Controller" === D.id || "Oculus Go Controller" === D.id || "OpenVR Gamepad" === D.id || D.id.startsWith("Oculus Touch") || D.id.startsWith("Spatial Controller"))) {
                        if (y === c) {
                            c = D;
                            break b
                        }
                        y++
                    }
                }
                c = void 0
            }
            if (void 0 !== c && void 0 !== c.pose) {
                if (null === c.pose) break a;
                u = c.pose;
                !1 === u.hasPosition && b.position.set(.2, -.6, -.05);
                null !== u.position && b.position.fromArray(u.position);
                null !== u.orientation && b.quaternion.fromArray(u.orientation);
                b.matrix.compose(b.position, b.quaternion, b.scale);
                b.matrix.premultiply(k);
                b.matrix.decompose(b.position, b.quaternion, b.scale);
                b.matrixWorldNeedsUpdate = !0;
                b.visible = !0;
                u = "Daydream Controller" === c.id ? 0 : 1;
                v[a] !== c.buttons[u].pressed && (v[a] = c.buttons[u].pressed, !0 === v[a] ? b.dispatchEvent({
                    type: "selectstart"
                }) : (b.dispatchEvent({
                    type: "selectend"
                }), b.dispatchEvent({
                    type: "select"
                })))
            } else b.visible = !1
        }
        return t
    };
    this.getStandingMatrix = function() {
        return k
    };
    this.isPresenting = b;
    var y = new WebGLAnimation$$module$node_modules$three$build$three;
    this.setAnimationLoop = function(a) {
        y.setAnimationLoop(a)
    };
    this.submitFrame = function() {
        b() && e.submitFrame()
    };
    this.dispose = function() {
        "undefined" !== typeof window && window.removeEventListener("vrdisplaypresentchange", c)
    }
}

function WebXRManager$$module$node_modules$three$build$three(a) {
    function b() {
        return null !== h && null !== k
    }

    function c(a) {
        var b = p[m.indexOf(a.inputSource)];
        b && b.dispatchEvent({
            type: a.type
        })
    }

    function d() {
        a.setFramebuffer(null);
        u.stop()
    }

    function e(a, b) {
        null === b ? a.matrixWorld.copy(a.matrix) : a.matrixWorld.multiplyMatrices(b.matrixWorld, a.matrix);
        a.matrixWorldInverse.getInverse(a.matrixWorld)
    }
    var f = a.context,
        g = null,
        h = null,
        k = null,
        l = null,
        p = [],
        m = [],
        q = new module$node_modules$three$build$three.default.PerspectiveCamera;
    q.layers.enable(1);
    q.viewport = new module$node_modules$three$build$three.default.Vector4;
    var r = new module$node_modules$three$build$three.default.PerspectiveCamera;
    r.layers.enable(2);
    r.viewport = new module$node_modules$three$build$three.default.Vector4;
    var n = new module$node_modules$three$build$three.default.ArrayCamera([q, r]);
    n.layers.enable(1);
    n.layers.enable(2);
    this.enabled = !1;
    this.getController = function(a) {
        var b = p[a];
        void 0 === b && (b = new module$node_modules$three$build$three.default.Group, b.matrixAutoUpdate = !1, b.visible = !1, p[a] = b);
        return b
    };
    this.getDevice = function() {
        return g
    };
    this.setDevice = function(a) {
        void 0 !== a && (g = a);
        a instanceof XRDevice && f.setCompatibleXRDevice(a)
    };
    this.setSession = function(b, e) {
        h = b;
        null !== h && (h.addEventListener("select", c), h.addEventListener("selectstart", c), h.addEventListener("selectend", c), h.addEventListener("end", d), h.baseLayer = new XRWebGLLayer(h, f), h.requestFrameOfReference(e.frameOfReferenceType).then(function(b) {
            k = b;
            a.setFramebuffer(h.baseLayer.framebuffer);
            u.setContext(h);
            u.start()
        }), m = h.getInputSources(), h.addEventListener("inputsourceschange", function() {
            m = h.getInputSources();
            console.log(m)
        }))
    };
    this.getCamera = function(a) {
        if (b()) {
            var c = a.parent,
                d = n.cameras;
            e(n, c);
            for (var f = 0; f < d.length; f++) e(d[f], c);
            a.matrixWorld.copy(n.matrixWorld);
            a = a.children;
            f = 0;
            for (c = a.length; f < c; f++) a[f].updateMatrixWorld(!0);
            return n
        }
        return a
    };
    this.isPresenting = b;
    var t = null,
        u = new WebGLAnimation$$module$node_modules$three$build$three;
    u.setAnimationLoop(function(a, b) {
        l = b.getDevicePose(k);
        if (null !==
            l)
            for (var c = h.baseLayer, d = b.views, e = 0; e < d.length; e++) {
                var f = d[e],
                    g = c.getViewport(f),
                    q = l.getViewMatrix(f),
                    r = n.cameras[e];
                r.matrix.fromArray(q).getInverse(r.matrix);
                r.projectionMatrix.fromArray(f.projectionMatrix);
                r.viewport.set(g.x, g.y, g.width, g.height);
                0 === e && (n.matrix.copy(r.matrix), n.projectionMatrix.copy(r.projectionMatrix))
            }
        for (e = 0; e < p.length; e++) {
            c = p[e];
            if (d = m[e])
                if (d = b.getInputPose(d, k), null !== d) {
                    c.matrix.elements = d.pointerMatrix;
                    c.matrix.decompose(c.position, c.rotation, c.scale);
                    c.visible = !0;
                    continue
                }
            c.visible = !1
        }
        t && t(a)
    });
    this.setAnimationLoop = function(a) {
        t = a
    };
    this.dispose = function() {};
    this.getStandingMatrix = function() {
        console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed.");
        return new THREE.Matrix4
    };
    this.submitFrame = function() {}
}
module$node_modules$three$build$three.default.FogExp2.prototype.isFogExp2 = !0;
module$node_modules$three$build$three.default.FogExp2.prototype.clone = function() {
    return new module$node_modules$three$build$three.default.FogExp2(this.color, this.density)
};
module$node_modules$three$build$three.default.FogExp2.prototype.toJSON = function() {
    return {
        type: "FogExp2",
        color: this.color.getHex(),
        density: this.density
    }
};
module$node_modules$three$build$three.default.Fog.prototype.isFog = !0;
module$node_modules$three$build$three.default.Fog.prototype.clone = function() {
    return new module$node_modules$three$build$three.default.Fog(this.color, this.near, this.far)
};
module$node_modules$three$build$three.default.Fog.prototype.toJSON = function() {
    return {
        type: "Fog",
        color: this.color.getHex(),
        near: this.near,
        far: this.far
    }
};
module$node_modules$three$build$three.default.Scene.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.Object3D.prototype), {
    constructor: module$node_modules$three$build$three.default.Scene,
    copy: function(a, b) {
        module$node_modules$three$build$three.default.Object3D.prototype.copy.call(this, a, b);
        null !== a.background && (this.background = a.background.clone());
        null !== a.fog && (this.fog = a.fog.clone());
        null !== a.overrideMaterial && (this.overrideMaterial = a.overrideMaterial.clone());
        this.autoUpdate = a.autoUpdate;
        this.matrixAutoUpdate = a.matrixAutoUpdate;
        return this
    },
    toJSON: function(a) {
        var b = module$node_modules$three$build$three.default.Object3D.prototype.toJSON.call(this, a);
        null !== this.background && (b.object.background = this.background.toJSON(a));
        null !== this.fog && (b.object.fog = this.fog.toJSON());
        return b
    }
});
Object.defineProperty(module$node_modules$three$build$three.default.InterleavedBuffer.prototype, "needsUpdate", {
    set: function(a) {
        !0 === a && this.version++
    }
});
Object.assign(module$node_modules$three$build$three.default.InterleavedBuffer.prototype, {
    isInterleavedBuffer: !0,
    onUploadCallback: function() {},
    setArray: function(a) {
        if (Array.isArray(a)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.count = void 0 !== a ? a.length / this.stride : 0;
        this.array = a;
        return this
    },
    setDynamic: function(a) {
        this.dynamic = a;
        return this
    },
    copy: function(a) {
        this.array = new a.array.constructor(a.array);
        this.count = a.count;
        this.stride = a.stride;
        this.dynamic = a.dynamic;
        return this
    },
    copyAt: function(a, b, c) {
        a *= this.stride;
        c *= b.stride;
        for (var d = 0, e = this.stride; d < e; d++) this.array[a + d] = b.array[c + d];
        return this
    },
    set: function(a, b) {
        void 0 === b && (b = 0);
        this.array.set(a, b);
        return this
    },
    clone: function() {
        return (new this.constructor).copy(this)
    },
    onUpload: function(a) {
        this.onUploadCallback = a;
        return this
    }
});
Object.defineProperties(module$node_modules$three$build$three.default.InterleavedBufferAttribute.prototype, {
    count: {
        get: function() {
            return this.data.count
        }
    },
    array: {
        get: function() {
            return this.data.array
        }
    }
});
Object.assign(module$node_modules$three$build$three.default.InterleavedBufferAttribute.prototype, {
    isInterleavedBufferAttribute: !0,
    setX: function(a, b) {
        this.data.array[a * this.data.stride + this.offset] = b;
        return this
    },
    setY: function(a, b) {
        this.data.array[a * this.data.stride + this.offset + 1] = b;
        return this
    },
    setZ: function(a, b) {
        this.data.array[a * this.data.stride + this.offset + 2] = b;
        return this
    },
    setW: function(a, b) {
        this.data.array[a * this.data.stride + this.offset + 3] = b;
        return this
    },
    getX: function(a) {
        return this.data.array[a *
            this.data.stride + this.offset]
    },
    getY: function(a) {
        return this.data.array[a * this.data.stride + this.offset + 1]
    },
    getZ: function(a) {
        return this.data.array[a * this.data.stride + this.offset + 2]
    },
    getW: function(a) {
        return this.data.array[a * this.data.stride + this.offset + 3]
    },
    setXY: function(a, b, c) {
        a = a * this.data.stride + this.offset;
        this.data.array[a + 0] = b;
        this.data.array[a + 1] = c;
        return this
    },
    setXYZ: function(a, b, c, d) {
        a = a * this.data.stride + this.offset;
        this.data.array[a + 0] = b;
        this.data.array[a + 1] = c;
        this.data.array[a + 2] = d;
        return this
    },
    setXYZW: function(a, b, c, d, e) {
        a = a * this.data.stride + this.offset;
        this.data.array[a + 0] = b;
        this.data.array[a + 1] = c;
        this.data.array[a + 2] = d;
        this.data.array[a + 3] = e;
        return this
    }
});
module$node_modules$three$build$three.default.SpriteMaterial.prototype = Object.create(module$node_modules$three$build$three.default.Material.prototype);
module$node_modules$three$build$three.default.SpriteMaterial.prototype.constructor = module$node_modules$three$build$three.default.SpriteMaterial;
module$node_modules$three$build$three.default.SpriteMaterial.prototype.isSpriteMaterial = !0;
module$node_modules$three$build$three.default.SpriteMaterial.prototype.copy = function(a) {
    module$node_modules$three$build$three.default.Material.prototype.copy.call(this, a);
    this.color.copy(a.color);
    this.map = a.map;
    this.rotation = a.rotation;
    return this
};
var geometry$$module$node_modules$three$build$three;
module$node_modules$three$build$three.default.Sprite.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.Object3D.prototype), {
    constructor: module$node_modules$three$build$three.default.Sprite,
    isSprite: !0,
    raycast: function() {
        function a(a, b, c, d, h, k) {
            e.subVectors(a, c).addScalar(.5).multiply(d);
            void 0 !== h ? (f.x = k * e.x - h * e.y, f.y = h * e.x + k * e.y) : f.copy(e);
            a.copy(b);
            a.x += f.x;
            a.y += f.y;
            a.applyMatrix4(g)
        }
        var b = new module$node_modules$three$build$three.default.Vector3,
            c = new module$node_modules$three$build$three.default.Vector3,
            d = new module$node_modules$three$build$three.default.Vector3,
            e = new module$node_modules$three$build$three.default.Vector2,
            f = new module$node_modules$three$build$three.default.Vector2,
            g = new module$node_modules$three$build$three.default.Matrix4,
            h = new module$node_modules$three$build$three.default.Vector3,
            k = new module$node_modules$three$build$three.default.Vector3,
            l = new module$node_modules$three$build$three.default.Vector3;
        return function(e, f) {
            c.setFromMatrixScale(this.matrixWorld);
            g.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld);
            d.setFromMatrixPosition(this.modelViewMatrix);
            var m = this.material.rotation;
            if (0 !== m) {
                var p = Math.cos(m);
                var n = Math.sin(m)
            }
            m = this.center;
            a(h.set(-.5, -.5, 0), d, m, c, n, p);
            a(k.set(.5, -.5, 0), d, m, c, n, p);
            a(l.set(.5, .5, 0), d, m, c, n, p);
            var t = e.ray.intersectTriangle(h, k, l, !1, b);
            if (null === t && (a(k.set(-.5, .5, 0), d, m, c, n, p), t = e.ray.intersectTriangle(h, l, k, !1, b), null === t)) return;
            n = e.ray.origin.distanceTo(b);
            n < e.near || n > e.far || f.push({
                distance: n,
                point: b.clone(),
                face: null,
                object: this
            })
        }
    }(),
    clone: function() {
        return (new this.constructor(this.material)).copy(this)
    },
    copy: function(a) {
        module$node_modules$three$build$three.default.Object3D.prototype.copy.call(this, a);
        void 0 !== a.center && this.center.copy(a.center);
        return this
    }
});
module$node_modules$three$build$three.default.LOD.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.Object3D.prototype), {
    constructor: module$node_modules$three$build$three.default.LOD,
    copy: function(a) {
        module$node_modules$three$build$three.default.Object3D.prototype.copy.call(this, a, !1);
        a = a.levels;
        for (var b = 0, c = a.length; b < c; b++) {
            var d = a[b];
            this.addLevel(d.object.clone(), d.distance)
        }
        return this
    },
    addLevel: function(a, b) {
        void 0 === b && (b = 0);
        b = Math.abs(b);
        for (var c = this.levels,
                d = 0; d < c.length && !(b < c[d].distance); d++);
        c.splice(d, 0, {
            distance: b,
            object: a
        });
        this.add(a)
    },
    getObjectForDistance: function(a) {
        for (var b = this.levels, c = 1, d = b.length; c < d && !(a < b[c].distance); c++);
        return b[c - 1].object
    },
    raycast: function() {
        var a = new module$node_modules$three$build$three.default.Vector3;
        return function(b, c) {
            a.setFromMatrixPosition(this.matrixWorld);
            var d = b.ray.origin.distanceTo(a);
            this.getObjectForDistance(d).raycast(b, c)
        }
    }(),
    update: function() {
        var a = new module$node_modules$three$build$three.default.Vector3,
            b = new module$node_modules$three$build$three.default.Vector3;
        return function(c) {
            var d = this.levels;
            if (1 < d.length) {
                a.setFromMatrixPosition(c.matrixWorld);
                b.setFromMatrixPosition(this.matrixWorld);
                c = a.distanceTo(b);
                d[0].object.visible = !0;
                for (var e = 1, f = d.length; e < f; e++)
                    if (c >= d[e].distance) d[e - 1].object.visible = !1, d[e].object.visible = !0;
                    else break;
                for (; e < f; e++) d[e].object.visible = !1
            }
        }
    }(),
    toJSON: function(a) {
        a = module$node_modules$three$build$three.default.Object3D.prototype.toJSON.call(this, a);
        a.object.levels = [];
        for (var b = this.levels, c = 0, d = b.length; c < d; c++) {
            var e = b[c];
            a.object.levels.push({
                object: e.object.uuid,
                distance: e.distance
            })
        }
        return a
    }
});
Object.assign(module$node_modules$three$build$three.default.Skeleton.prototype, {
    calculateInverses: function() {
        this.boneInverses = [];
        for (var a = 0, b = this.bones.length; a < b; a++) {
            var c = new module$node_modules$three$build$three.default.Matrix4;
            this.bones[a] && c.getInverse(this.bones[a].matrixWorld);
            this.boneInverses.push(c)
        }
    },
    pose: function() {
        var a, b;
        var c = 0;
        for (b = this.bones.length; c < b; c++)(a = this.bones[c]) && a.matrixWorld.getInverse(this.boneInverses[c]);
        c = 0;
        for (b = this.bones.length; c < b; c++)
            if (a = this.bones[c]) a.parent &&
                a.parent.isBone ? (a.matrix.getInverse(a.parent.matrixWorld), a.matrix.multiply(a.matrixWorld)) : a.matrix.copy(a.matrixWorld), a.matrix.decompose(a.position, a.quaternion, a.scale)
    },
    update: function() {
        var a = new module$node_modules$three$build$three.default.Matrix4,
            b = new module$node_modules$three$build$three.default.Matrix4;
        return function() {
            for (var c = this.bones, d = this.boneInverses, e = this.boneMatrices, f = this.boneTexture, g = 0, h = c.length; g < h; g++) a.multiplyMatrices(c[g] ? c[g].matrixWorld : b, d[g]), a.toArray(e, 16 *
                g);
            void 0 !== f && (f.needsUpdate = !0)
        }
    }(),
    clone: function() {
        return new module$node_modules$three$build$three.default.Skeleton(this.bones, this.boneInverses)
    },
    getBoneByName: function(a) {
        for (var b = 0, c = this.bones.length; b < c; b++) {
            var d = this.bones[b];
            if (d.name === a) return d
        }
    }
});
module$node_modules$three$build$three.default.Bone.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.Object3D.prototype), {
    constructor: module$node_modules$three$build$three.default.Bone,
    isBone: !0
});
module$node_modules$three$build$three.default.SkinnedMesh.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.Mesh.prototype), {
    constructor: module$node_modules$three$build$three.default.SkinnedMesh,
    isSkinnedMesh: !0,
    initBones: function() {
        var a = [],
            b;
        if (this.geometry && void 0 !== this.geometry.bones) {
            var c = 0;
            for (b = this.geometry.bones.length; c < b; c++) {
                var d = this.geometry.bones[c];
                var e = new module$node_modules$three$build$three.default.Bone;
                a.push(e);
                e.name = d.name;
                e.position.fromArray(d.pos);
                e.quaternion.fromArray(d.rotq);
                void 0 !== d.scl && e.scale.fromArray(d.scl)
            }
            c = 0;
            for (b = this.geometry.bones.length; c < b; c++) d = this.geometry.bones[c], -1 !== d.parent && null !== d.parent && void 0 !== a[d.parent] ? a[d.parent].add(a[c]) : this.add(a[c])
        }
        this.updateMatrixWorld(!0);
        return a
    },
    bind: function(a, b) {
        this.skeleton = a;
        void 0 === b && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), b = this.matrixWorld);
        this.bindMatrix.copy(b);
        this.bindMatrixInverse.getInverse(b)
    },
    pose: function() {
        this.skeleton.pose()
    },
    normalizeSkinWeights: function() {
        var a;
        if (this.geometry && this.geometry.isGeometry)
            for (a = 0; a < this.geometry.skinWeights.length; a++) {
                var b = this.geometry.skinWeights[a];
                var c = 1 / b.manhattanLength();
                Infinity !== c ? b.multiplyScalar(c) : b.set(1, 0, 0, 0)
            } else if (this.geometry && this.geometry.isBufferGeometry) {
                b = new module$node_modules$three$build$three.default.Vector4;
                var d = this.geometry.attributes.skinWeight;
                for (a = 0; a < d.count; a++) b.x = d.getX(a), b.y = d.getY(a), b.z = d.getZ(a), b.w = d.getW(a), c = 1 / b.manhattanLength(), Infinity !== c ? b.multiplyScalar(c) : b.set(1,
                    0, 0, 0), d.setXYZW(a, b.x, b.y, b.z, b.w)
            }
    },
    updateMatrixWorld: function(a) {
        module$node_modules$three$build$three.default.Mesh.prototype.updateMatrixWorld.call(this, a);
        "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
    },
    clone: function() {
        return (new this.constructor(this.geometry, this.material)).copy(this)
    }
});
module$node_modules$three$build$three.default.LineBasicMaterial.prototype = Object.create(module$node_modules$three$build$three.default.Material.prototype);
module$node_modules$three$build$three.default.LineBasicMaterial.prototype.constructor = module$node_modules$three$build$three.default.LineBasicMaterial;
module$node_modules$three$build$three.default.LineBasicMaterial.prototype.isLineBasicMaterial = !0;
module$node_modules$three$build$three.default.LineBasicMaterial.prototype.copy = function(a) {
    module$node_modules$three$build$three.default.Material.prototype.copy.call(this, a);
    this.color.copy(a.color);
    this.linewidth = a.linewidth;
    this.linecap = a.linecap;
    this.linejoin = a.linejoin;
    return this
};
module$node_modules$three$build$three.default.Line.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.Object3D.prototype), {
    constructor: module$node_modules$three$build$three.default.Line,
    isLine: !0,
    computeLineDistances: function() {
        var a = new module$node_modules$three$build$three.default.Vector3,
            b = new module$node_modules$three$build$three.default.Vector3;
        return function() {
            var c = this.geometry;
            if (c.isBufferGeometry)
                if (null === c.index) {
                    for (var d = c.attributes.position, e = [0],
                            f = 1, g = d.count; f < g; f++) a.fromBufferAttribute(d, f - 1), b.fromBufferAttribute(d, f), e[f] = e[f - 1], e[f] += a.distanceTo(b);
                    c.addAttribute("lineDistance", new module$node_modules$three$build$three.default.Float32BufferAttribute(e, 1))
                } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            else if (c.isGeometry)
                for (d = c.vertices, e = c.lineDistances, e[0] = 0, f = 1, g = d.length; f < g; f++) e[f] = e[f - 1], e[f] += d[f - 1].distanceTo(d[f]);
            return this
        }
    }(),
    raycast: function() {
        var a =
            new module$node_modules$three$build$three.default.Matrix4,
            b = new module$node_modules$three$build$three.default.Ray,
            c = new module$node_modules$three$build$three.default.Sphere;
        return function(d, e) {
            var f = d.linePrecision;
            f *= f;
            var g = this.geometry,
                h = this.matrixWorld;
            null === g.boundingSphere && g.computeBoundingSphere();
            c.copy(g.boundingSphere);
            c.applyMatrix4(h);
            if (!1 !== d.ray.intersectsSphere(c)) {
                a.getInverse(h);
                b.copy(d.ray).applyMatrix4(a);
                var k = new module$node_modules$three$build$three.default.Vector3,
                    l =
                    new module$node_modules$three$build$three.default.Vector3;
                h = new module$node_modules$three$build$three.default.Vector3;
                var p = new module$node_modules$three$build$three.default.Vector3,
                    m = this && this.isLineSegments ? 2 : 1;
                if (g.isBufferGeometry) {
                    var q = g.index,
                        r = g.attributes.position.array;
                    if (null !== q) {
                        q = q.array;
                        g = 0;
                        for (var n = q.length - 1; g < n; g += m) {
                            var t = q[g + 1];
                            k.fromArray(r, 3 * q[g]);
                            l.fromArray(r, 3 * t);
                            t = b.distanceSqToSegment(k, l, p, h);
                            t > f || (p.applyMatrix4(this.matrixWorld), t = d.ray.origin.distanceTo(p), t < d.near ||
                                t > d.far || e.push({
                                    distance: t,
                                    point: h.clone().applyMatrix4(this.matrixWorld),
                                    index: g,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                }))
                        }
                    } else
                        for (g = 0, n = r.length / 3 - 1; g < n; g += m) k.fromArray(r, 3 * g), l.fromArray(r, 3 * g + 3), t = b.distanceSqToSegment(k, l, p, h), t > f || (p.applyMatrix4(this.matrixWorld), t = d.ray.origin.distanceTo(p), t < d.near || t > d.far || e.push({
                            distance: t,
                            point: h.clone().applyMatrix4(this.matrixWorld),
                            index: g,
                            face: null,
                            faceIndex: null,
                            object: this
                        }))
                } else if (g.isGeometry)
                    for (k = g.vertices, l = k.length, g = 0; g < l - 1; g += m) t =
                        b.distanceSqToSegment(k[g], k[g + 1], p, h), t > f || (p.applyMatrix4(this.matrixWorld), t = d.ray.origin.distanceTo(p), t < d.near || t > d.far || e.push({
                            distance: t,
                            point: h.clone().applyMatrix4(this.matrixWorld),
                            index: g,
                            face: null,
                            faceIndex: null,
                            object: this
                        }))
            }
        }
    }(),
    clone: function() {
        return (new this.constructor(this.geometry, this.material)).copy(this)
    }
});
module$node_modules$three$build$three.default.LineSegments.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.Line.prototype), {
    constructor: module$node_modules$three$build$three.default.LineSegments,
    isLineSegments: !0,
    computeLineDistances: function() {
        var a = new module$node_modules$three$build$three.default.Vector3,
            b = new module$node_modules$three$build$three.default.Vector3;
        return function() {
            var c = this.geometry;
            if (c.isBufferGeometry)
                if (null === c.index) {
                    for (var d = c.attributes.position,
                            e = [], f = 0, g = d.count; f < g; f += 2) a.fromBufferAttribute(d, f), b.fromBufferAttribute(d, f + 1), e[f] = 0 === f ? 0 : e[f - 1], e[f + 1] = e[f] + a.distanceTo(b);
                    c.addAttribute("lineDistance", new module$node_modules$three$build$three.default.Float32BufferAttribute(e, 1))
                } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            else if (c.isGeometry)
                for (d = c.vertices, e = c.lineDistances, f = 0, g = d.length; f < g; f += 2) a.copy(d[f]), b.copy(d[f + 1]), e[f] = 0 === f ? 0 : e[f - 1], e[f + 1] = e[f] +
                    a.distanceTo(b);
            return this
        }
    }()
});
module$node_modules$three$build$three.default.LineLoop.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.Line.prototype), {
    constructor: module$node_modules$three$build$three.default.LineLoop,
    isLineLoop: !0
});
module$node_modules$three$build$three.default.PointsMaterial.prototype = Object.create(module$node_modules$three$build$three.default.Material.prototype);
module$node_modules$three$build$three.default.PointsMaterial.prototype.constructor = module$node_modules$three$build$three.default.PointsMaterial;
module$node_modules$three$build$three.default.PointsMaterial.prototype.isPointsMaterial = !0;
module$node_modules$three$build$three.default.PointsMaterial.prototype.copy = function(a) {
    module$node_modules$three$build$three.default.Material.prototype.copy.call(this, a);
    this.color.copy(a.color);
    this.map = a.map;
    this.size = a.size;
    this.sizeAttenuation = a.sizeAttenuation;
    this.morphTargets = a.morphTargets;
    return this
};
module$node_modules$three$build$three.default.Points.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.Object3D.prototype), {
    constructor: module$node_modules$three$build$three.default.Points,
    isPoints: !0,
    raycast: function() {
        var a = new module$node_modules$three$build$three.default.Matrix4,
            b = new module$node_modules$three$build$three.default.Ray,
            c = new module$node_modules$three$build$three.default.Sphere;
        return function(d, e) {
            function f(a, c) {
                var f = b.distanceSqToPoint(a);
                f <
                    p && (b.closestPointToPoint(a, m), m.applyMatrix4(k), a = d.ray.origin.distanceTo(m), a < d.near || a > d.far || e.push({
                        distance: a,
                        distanceToRay: Math.sqrt(f),
                        point: m.clone(),
                        index: c,
                        face: null,
                        object: g
                    }))
            }
            var g = this,
                h = this.geometry,
                k = this.matrixWorld,
                l = d.params.Points.threshold;
            null === h.boundingSphere && h.computeBoundingSphere();
            c.copy(h.boundingSphere);
            c.applyMatrix4(k);
            c.radius += l;
            if (!1 !== d.ray.intersectsSphere(c)) {
                a.getInverse(k);
                b.copy(d.ray).applyMatrix4(a);
                l /= (this.scale.x + this.scale.y + this.scale.z) / 3;
                var p =
                    l * l;
                l = new module$node_modules$three$build$three.default.Vector3;
                var m = new module$node_modules$three$build$three.default.Vector3;
                if (h.isBufferGeometry) {
                    var q = h.index;
                    h = h.attributes.position.array;
                    if (null !== q) {
                        var r = q.array;
                        q = 0;
                        for (var n = r.length; q < n; q++) {
                            var t = r[q];
                            l.fromArray(h, 3 * t);
                            f(l, t)
                        }
                    } else
                        for (q = 0, r = h.length / 3; q < r; q++) l.fromArray(h, 3 * q), f(l, q)
                } else
                    for (l = h.vertices, q = 0, r = l.length; q < r; q++) f(l[q], q)
            }
        }
    }(),
    clone: function() {
        return (new this.constructor(this.geometry, this.material)).copy(this)
    }
});
module$node_modules$three$build$three.default.VideoTexture.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.Texture.prototype), {
    constructor: module$node_modules$three$build$three.default.VideoTexture,
    isVideoTexture: !0,
    update: function() {
        var a = this.image;
        a.readyState >= a.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
    }
});
module$node_modules$three$build$three.default.CompressedTexture.prototype = Object.create(module$node_modules$three$build$three.default.Texture.prototype);
module$node_modules$three$build$three.default.CompressedTexture.prototype.constructor = module$node_modules$three$build$three.default.CompressedTexture;
module$node_modules$three$build$three.default.CompressedTexture.prototype.isCompressedTexture = !0;
module$node_modules$three$build$three.default.CanvasTexture.prototype = Object.create(module$node_modules$three$build$three.default.Texture.prototype);
module$node_modules$three$build$three.default.CanvasTexture.prototype.constructor = module$node_modules$three$build$three.default.CanvasTexture;
module$node_modules$three$build$three.default.CanvasTexture.prototype.isCanvasTexture = !0;
module$node_modules$three$build$three.default.DepthTexture.prototype = Object.create(module$node_modules$three$build$three.default.Texture.prototype);
module$node_modules$three$build$three.default.DepthTexture.prototype.constructor = module$node_modules$three$build$three.default.DepthTexture;
module$node_modules$three$build$three.default.DepthTexture.prototype.isDepthTexture = !0;
module$node_modules$three$build$three.default.WireframeGeometry.prototype = Object.create(module$node_modules$three$build$three.default.BufferGeometry.prototype);
module$node_modules$three$build$three.default.WireframeGeometry.prototype.constructor = module$node_modules$three$build$three.default.WireframeGeometry;
module$node_modules$three$build$three.default.ParametricGeometry.prototype = Object.create(module$node_modules$three$build$three.default.Geometry.prototype);
module$node_modules$three$build$three.default.ParametricGeometry.prototype.constructor = module$node_modules$three$build$three.default.ParametricGeometry;
module$node_modules$three$build$three.default.ParametricBufferGeometry.prototype = Object.create(module$node_modules$three$build$three.default.BufferGeometry.prototype);
module$node_modules$three$build$three.default.ParametricBufferGeometry.prototype.constructor = module$node_modules$three$build$three.default.ParametricBufferGeometry;
module$node_modules$three$build$three.default.PolyhedronGeometry.prototype = Object.create(module$node_modules$three$build$three.default.Geometry.prototype);
module$node_modules$three$build$three.default.PolyhedronGeometry.prototype.constructor = module$node_modules$three$build$three.default.PolyhedronGeometry;
module$node_modules$three$build$three.default.PolyhedronBufferGeometry.prototype = Object.create(module$node_modules$three$build$three.default.BufferGeometry.prototype);
module$node_modules$three$build$three.default.PolyhedronBufferGeometry.prototype.constructor = module$node_modules$three$build$three.default.PolyhedronBufferGeometry;
module$node_modules$three$build$three.default.TetrahedronGeometry.prototype = Object.create(module$node_modules$three$build$three.default.Geometry.prototype);
module$node_modules$three$build$three.default.TetrahedronGeometry.prototype.constructor = module$node_modules$three$build$three.default.TetrahedronGeometry;
module$node_modules$three$build$three.default.TetrahedronBufferGeometry.prototype = Object.create(module$node_modules$three$build$three.default.PolyhedronBufferGeometry.prototype);
module$node_modules$three$build$three.default.TetrahedronBufferGeometry.prototype.constructor = module$node_modules$three$build$three.default.TetrahedronBufferGeometry;
module$node_modules$three$build$three.default.OctahedronGeometry.prototype = Object.create(module$node_modules$three$build$three.default.Geometry.prototype);
module$node_modules$three$build$three.default.OctahedronGeometry.prototype.constructor = module$node_modules$three$build$three.default.OctahedronGeometry;
module$node_modules$three$build$three.default.OctahedronBufferGeometry.prototype = Object.create(module$node_modules$three$build$three.default.PolyhedronBufferGeometry.prototype);
module$node_modules$three$build$three.default.OctahedronBufferGeometry.prototype.constructor = module$node_modules$three$build$three.default.OctahedronBufferGeometry;
module$node_modules$three$build$three.default.IcosahedronGeometry.prototype = Object.create(module$node_modules$three$build$three.default.Geometry.prototype);
module$node_modules$three$build$three.default.IcosahedronGeometry.prototype.constructor = module$node_modules$three$build$three.default.IcosahedronGeometry;
module$node_modules$three$build$three.default.IcosahedronBufferGeometry.prototype = Object.create(module$node_modules$three$build$three.default.PolyhedronBufferGeometry.prototype);
module$node_modules$three$build$three.default.IcosahedronBufferGeometry.prototype.constructor = module$node_modules$three$build$three.default.IcosahedronBufferGeometry;
module$node_modules$three$build$three.default.DodecahedronGeometry.prototype = Object.create(module$node_modules$three$build$three.default.Geometry.prototype);
module$node_modules$three$build$three.default.DodecahedronGeometry.prototype.constructor = module$node_modules$three$build$three.default.DodecahedronGeometry;
module$node_modules$three$build$three.default.DodecahedronBufferGeometry.prototype = Object.create(module$node_modules$three$build$three.default.PolyhedronBufferGeometry.prototype);
module$node_modules$three$build$three.default.DodecahedronBufferGeometry.prototype.constructor = module$node_modules$three$build$three.default.DodecahedronBufferGeometry;
module$node_modules$three$build$three.default.TubeGeometry.prototype = Object.create(module$node_modules$three$build$three.default.Geometry.prototype);
module$node_modules$three$build$three.default.TubeGeometry.prototype.constructor = module$node_modules$three$build$three.default.TubeGeometry;
module$node_modules$three$build$three.default.TubeBufferGeometry.prototype = Object.create(module$node_modules$three$build$three.default.BufferGeometry.prototype);
module$node_modules$three$build$three.default.TubeBufferGeometry.prototype.constructor = module$node_modules$three$build$three.default.TubeBufferGeometry;
module$node_modules$three$build$three.default.TorusKnotGeometry.prototype = Object.create(module$node_modules$three$build$three.default.Geometry.prototype);
module$node_modules$three$build$three.default.TorusKnotGeometry.prototype.constructor = module$node_modules$three$build$three.default.TorusKnotGeometry;
module$node_modules$three$build$three.default.TorusKnotBufferGeometry.prototype = Object.create(module$node_modules$three$build$three.default.BufferGeometry.prototype);
module$node_modules$three$build$three.default.TorusKnotBufferGeometry.prototype.constructor = module$node_modules$three$build$three.default.TorusKnotBufferGeometry;
module$node_modules$three$build$three.default.TorusGeometry.prototype = Object.create(module$node_modules$three$build$three.default.Geometry.prototype);
module$node_modules$three$build$three.default.TorusGeometry.prototype.constructor = module$node_modules$three$build$three.default.TorusGeometry;
module$node_modules$three$build$three.default.TorusBufferGeometry.prototype = Object.create(module$node_modules$three$build$three.default.BufferGeometry.prototype);
module$node_modules$three$build$three.default.TorusBufferGeometry.prototype.constructor = module$node_modules$three$build$three.default.TorusBufferGeometry;
var Earcut$$module$node_modules$three$build$three = {
    triangulate: function(a, b, c) {
        c = c || 2;
        var d = b && b.length,
            e = d ? b[0] * c : a.length,
            f = linkedList$$module$node_modules$three$build$three(a, 0, e, c, !0),
            g = [];
        if (!f) return g;
        d && (f = eliminateHoles$$module$node_modules$three$build$three(a, b, f, c));
        if (a.length > 80 * c) {
            var h = b = a[0];
            var k = d = a[1];
            for (var l = c; l < e; l += c) {
                var p = a[l];
                var m = a[l + 1];
                p < h && (h = p);
                m < k && (k = m);
                p > b && (b = p);
                m > d && (d = m)
            }
            p = Math.max(b - h, d - k);
            p = 0 !== p ? 1 / p : 0
        }
        earcutLinked$$module$node_modules$three$build$three(f, g,
            c, h, k, p);
        return g
    }
};

function linkedList$$module$node_modules$three$build$three(a, b, c, d, e) {
    if (e === 0 < signedArea$$module$node_modules$three$build$three(a, b, c, d))
        for (e = b; e < c; e += d) var f = insertNode$$module$node_modules$three$build$three(e, a[e], a[e + 1], f);
    else
        for (e = c - d; e >= b; e -= d) f = insertNode$$module$node_modules$three$build$three(e, a[e], a[e + 1], f);
    f && equals$$module$node_modules$three$build$three(f, f.next) && (removeNode$$module$node_modules$three$build$three(f), f = f.next);
    return f
}

function filterPoints$$module$node_modules$three$build$three(a, b) {
    if (!a) return a;
    b || (b = a);
    do {
        var c = !1;
        if (a.steiner || !equals$$module$node_modules$three$build$three(a, a.next) && 0 !== area$$module$node_modules$three$build$three(a.prev, a, a.next)) a = a.next;
        else {
            removeNode$$module$node_modules$three$build$three(a);
            a = b = a.prev;
            if (a === a.next) break;
            c = !0
        }
    } while (c || a !== b);
    return b
}

function earcutLinked$$module$node_modules$three$build$three(a, b, c, d, e, f, g) {
    if (a) {
        !g && f && indexCurve$$module$node_modules$three$build$three(a, d, e, f);
        for (var h = a, k, l; a.prev !== a.next;)
            if (k = a.prev, l = a.next, f ? isEarHashed$$module$node_modules$three$build$three(a, d, e, f) : isEar$$module$node_modules$three$build$three(a)) b.push(k.i / c), b.push(a.i / c), b.push(l.i / c), removeNode$$module$node_modules$three$build$three(a), h = a = l.next;
            else if (a = l, a === h) {
            g ? 1 === g ? (a = cureLocalIntersections$$module$node_modules$three$build$three(a,
                b, c), earcutLinked$$module$node_modules$three$build$three(a, b, c, d, e, f, 2)) : 2 === g && splitEarcut$$module$node_modules$three$build$three(a, b, c, d, e, f) : earcutLinked$$module$node_modules$three$build$three(filterPoints$$module$node_modules$three$build$three(a), b, c, d, e, f, 1);
            break
        }
    }
}

function isEar$$module$node_modules$three$build$three(a) {
    var b = a.prev,
        c = a.next;
    if (0 <= area$$module$node_modules$three$build$three(b, a, c)) return !1;
    for (var d = a.next.next; d !== a.prev;) {
        if (pointInTriangle$$module$node_modules$three$build$three(b.x, b.y, a.x, a.y, c.x, c.y, d.x, d.y) && 0 <= area$$module$node_modules$three$build$three(d.prev, d, d.next)) return !1;
        d = d.next
    }
    return !0
}

function isEarHashed$$module$node_modules$three$build$three(a, b, c, d) {
    var e = a.prev,
        f = a.next;
    if (0 <= area$$module$node_modules$three$build$three(e, a, f)) return !1;
    var g = e.x > a.x ? e.x > f.x ? e.x : f.x : a.x > f.x ? a.x : f.x,
        h = e.y > a.y ? e.y > f.y ? e.y : f.y : a.y > f.y ? a.y : f.y,
        k = zOrder$$module$node_modules$three$build$three(e.x < a.x ? e.x < f.x ? e.x : f.x : a.x < f.x ? a.x : f.x, e.y < a.y ? e.y < f.y ? e.y : f.y : a.y < f.y ? a.y : f.y, b, c, d);
    b = zOrder$$module$node_modules$three$build$three(g, h, b, c, d);
    for (c = a.nextZ; c && c.z <= b;) {
        if (c !== a.prev && c !== a.next && pointInTriangle$$module$node_modules$three$build$three(e.x,
                e.y, a.x, a.y, f.x, f.y, c.x, c.y) && 0 <= area$$module$node_modules$three$build$three(c.prev, c, c.next)) return !1;
        c = c.nextZ
    }
    for (c = a.prevZ; c && c.z >= k;) {
        if (c !== a.prev && c !== a.next && pointInTriangle$$module$node_modules$three$build$three(e.x, e.y, a.x, a.y, f.x, f.y, c.x, c.y) && 0 <= area$$module$node_modules$three$build$three(c.prev, c, c.next)) return !1;
        c = c.prevZ
    }
    return !0
}

function cureLocalIntersections$$module$node_modules$three$build$three(a, b, c) {
    var d = a;
    do {
        var e = d.prev,
            f = d.next.next;
        !equals$$module$node_modules$three$build$three(e, f) && intersects$$module$node_modules$three$build$three(e, d, d.next, f) && locallyInside$$module$node_modules$three$build$three(e, f) && locallyInside$$module$node_modules$three$build$three(f, e) && (b.push(e.i / c), b.push(d.i / c), b.push(f.i / c), removeNode$$module$node_modules$three$build$three(d), removeNode$$module$node_modules$three$build$three(d.next),
            d = a = f);
        d = d.next
    } while (d !== a);
    return d
}

function splitEarcut$$module$node_modules$three$build$three(a, b, c, d, e, f) {
    var g = a;
    do {
        for (var h = g.next.next; h !== g.prev;) {
            if (g.i !== h.i && isValidDiagonal$$module$node_modules$three$build$three(g, h)) {
                a = splitPolygon$$module$node_modules$three$build$three(g, h);
                g = filterPoints$$module$node_modules$three$build$three(g, g.next);
                a = filterPoints$$module$node_modules$three$build$three(a, a.next);
                earcutLinked$$module$node_modules$three$build$three(g, b, c, d, e, f);
                earcutLinked$$module$node_modules$three$build$three(a, b,
                    c, d, e, f);
                return
            }
            h = h.next
        }
        g = g.next
    } while (g !== a)
}

function eliminateHoles$$module$node_modules$three$build$three(a, b, c, d) {
    var e = [],
        f;
    var g = 0;
    for (f = b.length; g < f; g++) {
        var h = b[g] * d;
        var k = g < f - 1 ? b[g + 1] * d : a.length;
        h = linkedList$$module$node_modules$three$build$three(a, h, k, d, !1);
        h === h.next && (h.steiner = !0);
        e.push(getLeftmost$$module$node_modules$three$build$three(h))
    }
    e.sort(compareX$$module$node_modules$three$build$three);
    for (g = 0; g < e.length; g++) eliminateHole$$module$node_modules$three$build$three(e[g], c), c = filterPoints$$module$node_modules$three$build$three(c, c.next);
    return c
}

function compareX$$module$node_modules$three$build$three(a, b) {
    return a.x - b.x
}

function eliminateHole$$module$node_modules$three$build$three(a, b) {
    if (b = findHoleBridge$$module$node_modules$three$build$three(a, b)) a = splitPolygon$$module$node_modules$three$build$three(b, a), filterPoints$$module$node_modules$three$build$three(a, a.next)
}

function findHoleBridge$$module$node_modules$three$build$three(a, b) {
    var c = b,
        d = a.x,
        e = a.y,
        f = -Infinity;
    do {
        if (e <= c.y && e >= c.next.y && c.next.y !== c.y) {
            var g = c.x + (e - c.y) * (c.next.x - c.x) / (c.next.y - c.y);
            if (g <= d && g > f) {
                f = g;
                if (g === d) {
                    if (e === c.y) return c;
                    if (e === c.next.y) return c.next
                }
                var h = c.x < c.next.x ? c : c.next
            }
        }
        c = c.next
    } while (c !== b);
    if (!h) return null;
    if (d === f) return h.prev;
    b = h;
    g = h.x;
    var k = h.y,
        l = Infinity;
    for (c = h.next; c !== b;) {
        if (d >= c.x && c.x >= g && d !== c.x && pointInTriangle$$module$node_modules$three$build$three(e < k ? d :
                f, e, g, k, e < k ? f : d, e, c.x, c.y)) {
            var p = Math.abs(e - c.y) / (d - c.x);
            (p < l || p === l && c.x > h.x) && locallyInside$$module$node_modules$three$build$three(c, a) && (h = c, l = p)
        }
        c = c.next
    }
    return h
}

function indexCurve$$module$node_modules$three$build$three(a, b, c, d) {
    var e = a;
    do null === e.z && (e.z = zOrder$$module$node_modules$three$build$three(e.x, e.y, b, c, d)), e.prevZ = e.prev, e = e.nextZ = e.next; while (e !== a);
    e.prevZ.nextZ = null;
    e.prevZ = null;
    sortLinked$$module$node_modules$three$build$three(e)
}

function sortLinked$$module$node_modules$three$build$three(a) {
    var b, c, d, e, f = 1;
    do {
        var g = a;
        var h = a = null;
        for (c = 0; g;) {
            c++;
            var k = g;
            for (b = d = 0; b < f && (d++, k = k.nextZ, k); b++);
            for (e = f; 0 < d || 0 < e && k;) 0 !== d && (0 === e || !k || g.z <= k.z) ? (b = g, g = g.nextZ, d--) : (b = k, k = k.nextZ, e--), h ? h.nextZ = b : a = b, b.prevZ = h, h = b;
            g = k
        }
        h.nextZ = null;
        f *= 2
    } while (1 < c);
    return a
}

function zOrder$$module$node_modules$three$build$three(a, b, c, d, e) {
    a = 32767 * (a - c) * e;
    b = 32767 * (b - d) * e;
    a = (a | a << 8) & 16711935;
    a = (a | a << 4) & 252645135;
    a = (a | a << 2) & 858993459;
    b = (b | b << 8) & 16711935;
    b = (b | b << 4) & 252645135;
    b = (b | b << 2) & 858993459;
    return (a | a << 1) & 1431655765 | ((b | b << 1) & 1431655765) << 1
}

function getLeftmost$$module$node_modules$three$build$three(a) {
    var b = a,
        c = a;
    do b.x < c.x && (c = b), b = b.next; while (b !== a);
    return c
}

function pointInTriangle$$module$node_modules$three$build$three(a, b, c, d, e, f, g, h) {
    return 0 <= (e - g) * (b - h) - (a - g) * (f - h) && 0 <= (a - g) * (d - h) - (c - g) * (b - h) && 0 <= (c - g) * (f - h) - (e - g) * (d - h)
}

function isValidDiagonal$$module$node_modules$three$build$three(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon$$module$node_modules$three$build$three(a, b) && locallyInside$$module$node_modules$three$build$three(a, b) && locallyInside$$module$node_modules$three$build$three(b, a) && middleInside$$module$node_modules$three$build$three(a, b)
}

function area$$module$node_modules$three$build$three(a, b, c) {
    return (b.y - a.y) * (c.x - b.x) - (b.x - a.x) * (c.y - b.y)
}

function equals$$module$node_modules$three$build$three(a, b) {
    return a.x === b.x && a.y === b.y
}

function intersects$$module$node_modules$three$build$three(a, b, c, d) {
    return equals$$module$node_modules$three$build$three(a, b) && equals$$module$node_modules$three$build$three(c, d) || equals$$module$node_modules$three$build$three(a, d) && equals$$module$node_modules$three$build$three(c, b) ? !0 : 0 < area$$module$node_modules$three$build$three(a, b, c) !== 0 < area$$module$node_modules$three$build$three(a, b, d) && 0 < area$$module$node_modules$three$build$three(c, d, a) !== 0 < area$$module$node_modules$three$build$three(c, d, b)
}

function intersectsPolygon$$module$node_modules$three$build$three(a, b) {
    var c = a;
    do {
        if (c.i !== a.i && c.next.i !== a.i && c.i !== b.i && c.next.i !== b.i && intersects$$module$node_modules$three$build$three(c, c.next, a, b)) return !0;
        c = c.next
    } while (c !== a);
    return !1
}

function locallyInside$$module$node_modules$three$build$three(a, b) {
    return 0 > area$$module$node_modules$three$build$three(a.prev, a, a.next) ? 0 <= area$$module$node_modules$three$build$three(a, b, a.next) && 0 <= area$$module$node_modules$three$build$three(a, a.prev, b) : 0 > area$$module$node_modules$three$build$three(a, b, a.prev) || 0 > area$$module$node_modules$three$build$three(a, a.next, b)
}

function middleInside$$module$node_modules$three$build$three(a, b) {
    var c = a,
        d = !1,
        e = (a.x + b.x) / 2;
    b = (a.y + b.y) / 2;
    do c.y > b !== c.next.y > b && c.next.y !== c.y && e < (c.next.x - c.x) * (b - c.y) / (c.next.y - c.y) + c.x && (d = !d), c = c.next; while (c !== a);
    return d
}

function splitPolygon$$module$node_modules$three$build$three(a, b) {
    var c = new Node$$module$node_modules$three$build$three(a.i, a.x, a.y),
        d = new Node$$module$node_modules$three$build$three(b.i, b.x, b.y),
        e = a.next,
        f = b.prev;
    a.next = b;
    b.prev = a;
    c.next = e;
    e.prev = c;
    d.next = c;
    c.prev = d;
    f.next = d;
    d.prev = f;
    return d
}

function insertNode$$module$node_modules$three$build$three(a, b, c, d) {
    a = new Node$$module$node_modules$three$build$three(a, b, c);
    d ? (a.next = d.next, a.prev = d, d.next.prev = a, d.next = a) : (a.prev = a, a.next = a);
    return a
}

function removeNode$$module$node_modules$three$build$three(a) {
    a.next.prev = a.prev;
    a.prev.next = a.next;
    a.prevZ && (a.prevZ.nextZ = a.nextZ);
    a.nextZ && (a.nextZ.prevZ = a.prevZ)
}

function Node$$module$node_modules$three$build$three(a, b, c) {
    this.i = a;
    this.x = b;
    this.y = c;
    this.nextZ = this.prevZ = this.z = this.next = this.prev = null;
    this.steiner = !1
}

function signedArea$$module$node_modules$three$build$three(a, b, c, d) {
    for (var e = 0, f = c - d; b < c; b += d) e += (a[f] - a[b]) * (a[b + 1] + a[f + 1]), f = b;
    return e
}
module$node_modules$three$build$three.default.ShapeUtils = {
    area: function(a) {
        for (var b = a.length, c = 0, d = b - 1, e = 0; e < b; d = e++) c += a[d].x * a[e].y - a[e].x * a[d].y;
        return .5 * c
    },
    isClockWise: function(a) {
        return 0 > module$node_modules$three$build$three.default.ShapeUtils.area(a)
    },
    triangulateShape: function(a, b) {
        var c = [],
            d = [],
            e = [];
        removeDupEndPts$$module$node_modules$three$build$three(a);
        addContour$$module$node_modules$three$build$three(c, a);
        var f = a.length;
        b.forEach(removeDupEndPts$$module$node_modules$three$build$three);
        for (a = 0; a < b.length; a++) d.push(f), f += b[a].length, addContour$$module$node_modules$three$build$three(c, b[a]);
        b = Earcut$$module$node_modules$three$build$three.triangulate(c, d);
        for (a = 0; a < b.length; a += 3) e.push(b.slice(a, a + 3));
        return e
    }
};

function removeDupEndPts$$module$node_modules$three$build$three(a) {
    var b = a.length;
    2 < b && a[b - 1].equals(a[0]) && a.pop()
}

function addContour$$module$node_modules$three$build$three(a, b) {
    for (var c = 0; c < b.length; c++) a.push(b[c].x), a.push(b[c].y)
}
module$node_modules$three$build$three.default.ExtrudeGeometry.prototype = Object.create(module$node_modules$three$build$three.default.Geometry.prototype);
module$node_modules$three$build$three.default.ExtrudeGeometry.prototype.constructor = module$node_modules$three$build$three.default.ExtrudeGeometry;
module$node_modules$three$build$three.default.ExtrudeGeometry.prototype.toJSON = function() {
    var a = module$node_modules$three$build$three.default.Geometry.prototype.toJSON.call(this);
    return toJSON$$module$node_modules$three$build$three(this.parameters.shapes, this.parameters.options, a)
};
module$node_modules$three$build$three.default.ExtrudeBufferGeometry.prototype = Object.create(module$node_modules$three$build$three.default.BufferGeometry.prototype);
module$node_modules$three$build$three.default.ExtrudeBufferGeometry.prototype.constructor = module$node_modules$three$build$three.default.ExtrudeBufferGeometry;
module$node_modules$three$build$three.default.ExtrudeBufferGeometry.prototype.toJSON = function() {
    var a = module$node_modules$three$build$three.default.BufferGeometry.prototype.toJSON.call(this);
    return toJSON$$module$node_modules$three$build$three(this.parameters.shapes, this.parameters.options, a)
};
var WorldUVGenerator$$module$node_modules$three$build$three = {
    generateTopUV: function(a, b, c, d, e) {
        a = b[3 * d];
        d = b[3 * d + 1];
        var f = b[3 * e];
        e = b[3 * e + 1];
        return [new module$node_modules$three$build$three.default.Vector2(b[3 * c], b[3 * c + 1]), new module$node_modules$three$build$three.default.Vector2(a, d), new module$node_modules$three$build$three.default.Vector2(f, e)]
    },
    generateSideWallUV: function(a, b, c, d, e, f) {
        a = b[3 * c];
        var g = b[3 * c + 1];
        c = b[3 * c + 2];
        var h = b[3 * d],
            k = b[3 * d + 1];
        d = b[3 * d + 2];
        var l = b[3 * e],
            p = b[3 * e + 1];
        e = b[3 * e + 2];
        var m =
            b[3 * f],
            q = b[3 * f + 1];
        b = b[3 * f + 2];
        return .01 > Math.abs(g - k) ? [new module$node_modules$three$build$three.default.Vector2(a, 1 - c), new module$node_modules$three$build$three.default.Vector2(h, 1 - d), new module$node_modules$three$build$three.default.Vector2(l, 1 - e), new module$node_modules$three$build$three.default.Vector2(m, 1 - b)] : [new module$node_modules$three$build$three.default.Vector2(g, 1 - c), new module$node_modules$three$build$three.default.Vector2(k, 1 - d), new module$node_modules$three$build$three.default.Vector2(p,
            1 - e), new module$node_modules$three$build$three.default.Vector2(q, 1 - b)]
    }
};

function toJSON$$module$node_modules$three$build$three(a, b, c) {
    c.shapes = [];
    if (Array.isArray(a))
        for (var d = 0, e = a.length; d < e; d++) c.shapes.push(a[d].uuid);
    else c.shapes.push(a.uuid);
    void 0 !== b.extrudePath && (c.options.extrudePath = b.extrudePath.toJSON());
    return c
}
module$node_modules$three$build$three.default.TextGeometry.prototype = Object.create(module$node_modules$three$build$three.default.Geometry.prototype);
module$node_modules$three$build$three.default.TextGeometry.prototype.constructor = module$node_modules$three$build$three.default.TextGeometry;
module$node_modules$three$build$three.default.TextBufferGeometry.prototype = Object.create(module$node_modules$three$build$three.default.ExtrudeBufferGeometry.prototype);
module$node_modules$three$build$three.default.TextBufferGeometry.prototype.constructor = module$node_modules$three$build$three.default.TextBufferGeometry;
module$node_modules$three$build$three.default.SphereGeometry.prototype = Object.create(module$node_modules$three$build$three.default.Geometry.prototype);
module$node_modules$three$build$three.default.SphereGeometry.prototype.constructor = module$node_modules$three$build$three.default.SphereGeometry;
module$node_modules$three$build$three.default.SphereBufferGeometry.prototype = Object.create(module$node_modules$three$build$three.default.BufferGeometry.prototype);
module$node_modules$three$build$three.default.SphereBufferGeometry.prototype.constructor = module$node_modules$three$build$three.default.SphereBufferGeometry;
module$node_modules$three$build$three.default.RingGeometry.prototype = Object.create(module$node_modules$three$build$three.default.Geometry.prototype);
module$node_modules$three$build$three.default.RingGeometry.prototype.constructor = module$node_modules$three$build$three.default.RingGeometry;
module$node_modules$three$build$three.default.RingBufferGeometry.prototype = Object.create(module$node_modules$three$build$three.default.BufferGeometry.prototype);
module$node_modules$three$build$three.default.RingBufferGeometry.prototype.constructor = module$node_modules$three$build$three.default.RingBufferGeometry;
module$node_modules$three$build$three.default.LatheGeometry.prototype = Object.create(module$node_modules$three$build$three.default.Geometry.prototype);
module$node_modules$three$build$three.default.LatheGeometry.prototype.constructor = module$node_modules$three$build$three.default.LatheGeometry;
module$node_modules$three$build$three.default.LatheBufferGeometry.prototype = Object.create(module$node_modules$three$build$three.default.BufferGeometry.prototype);
module$node_modules$three$build$three.default.LatheBufferGeometry.prototype.constructor = module$node_modules$three$build$three.default.LatheBufferGeometry;
module$node_modules$three$build$three.default.ShapeGeometry.prototype = Object.create(module$node_modules$three$build$three.default.Geometry.prototype);
module$node_modules$three$build$three.default.ShapeGeometry.prototype.constructor = module$node_modules$three$build$three.default.ShapeGeometry;
module$node_modules$three$build$three.default.ShapeGeometry.prototype.toJSON = function() {
    var a = module$node_modules$three$build$three.default.Geometry.prototype.toJSON.call(this);
    return toJSON$1$$module$node_modules$three$build$three(this.parameters.shapes, a)
};
module$node_modules$three$build$three.default.ShapeBufferGeometry.prototype = Object.create(module$node_modules$three$build$three.default.BufferGeometry.prototype);
module$node_modules$three$build$three.default.ShapeBufferGeometry.prototype.constructor = module$node_modules$three$build$three.default.ShapeBufferGeometry;
module$node_modules$three$build$three.default.ShapeBufferGeometry.prototype.toJSON = function() {
    var a = module$node_modules$three$build$three.default.BufferGeometry.prototype.toJSON.call(this);
    return toJSON$1$$module$node_modules$three$build$three(this.parameters.shapes, a)
};

function toJSON$1$$module$node_modules$three$build$three(a, b) {
    b.shapes = [];
    if (Array.isArray(a))
        for (var c = 0, d = a.length; c < d; c++) b.shapes.push(a[c].uuid);
    else b.shapes.push(a.uuid);
    return b
}
module$node_modules$three$build$three.default.EdgesGeometry.prototype = Object.create(module$node_modules$three$build$three.default.BufferGeometry.prototype);
module$node_modules$three$build$three.default.EdgesGeometry.prototype.constructor = module$node_modules$three$build$three.default.EdgesGeometry;
module$node_modules$three$build$three.default.CylinderGeometry.prototype = Object.create(module$node_modules$three$build$three.default.Geometry.prototype);
module$node_modules$three$build$three.default.CylinderGeometry.prototype.constructor = module$node_modules$three$build$three.default.CylinderGeometry;
module$node_modules$three$build$three.default.CylinderBufferGeometry.prototype = Object.create(module$node_modules$three$build$three.default.BufferGeometry.prototype);
module$node_modules$three$build$three.default.CylinderBufferGeometry.prototype.constructor = module$node_modules$three$build$three.default.CylinderBufferGeometry;
module$node_modules$three$build$three.default.ConeGeometry.prototype = Object.create(module$node_modules$three$build$three.default.CylinderGeometry.prototype);
module$node_modules$three$build$three.default.ConeGeometry.prototype.constructor = module$node_modules$three$build$three.default.ConeGeometry;
module$node_modules$three$build$three.default.ConeBufferGeometry.prototype = Object.create(module$node_modules$three$build$three.default.CylinderBufferGeometry.prototype);
module$node_modules$three$build$three.default.ConeBufferGeometry.prototype.constructor = module$node_modules$three$build$three.default.ConeBufferGeometry;
module$node_modules$three$build$three.default.CircleGeometry.prototype = Object.create(module$node_modules$three$build$three.default.Geometry.prototype);
module$node_modules$three$build$three.default.CircleGeometry.prototype.constructor = module$node_modules$three$build$three.default.CircleGeometry;
module$node_modules$three$build$three.default.CircleBufferGeometry.prototype = Object.create(module$node_modules$three$build$three.default.BufferGeometry.prototype);
module$node_modules$three$build$three.default.CircleBufferGeometry.prototype.constructor = module$node_modules$three$build$three.default.CircleBufferGeometry;
var Geometries$$module$node_modules$three$build$three = Object.freeze({
    WireframeGeometry: module$node_modules$three$build$three.default.WireframeGeometry,
    ParametricGeometry: module$node_modules$three$build$three.default.ParametricGeometry,
    ParametricBufferGeometry: module$node_modules$three$build$three.default.ParametricBufferGeometry,
    TetrahedronGeometry: module$node_modules$three$build$three.default.TetrahedronGeometry,
    TetrahedronBufferGeometry: module$node_modules$three$build$three.default.TetrahedronBufferGeometry,
    OctahedronGeometry: module$node_modules$three$build$three.default.OctahedronGeometry,
    OctahedronBufferGeometry: module$node_modules$three$build$three.default.OctahedronBufferGeometry,
    IcosahedronGeometry: module$node_modules$three$build$three.default.IcosahedronGeometry,
    IcosahedronBufferGeometry: module$node_modules$three$build$three.default.IcosahedronBufferGeometry,
    DodecahedronGeometry: module$node_modules$three$build$three.default.DodecahedronGeometry,
    DodecahedronBufferGeometry: module$node_modules$three$build$three.default.DodecahedronBufferGeometry,
    PolyhedronGeometry: module$node_modules$three$build$three.default.PolyhedronGeometry,
    PolyhedronBufferGeometry: module$node_modules$three$build$three.default.PolyhedronBufferGeometry,
    TubeGeometry: module$node_modules$three$build$three.default.TubeGeometry,
    TubeBufferGeometry: module$node_modules$three$build$three.default.TubeBufferGeometry,
    TorusKnotGeometry: module$node_modules$three$build$three.default.TorusKnotGeometry,
    TorusKnotBufferGeometry: module$node_modules$three$build$three.default.TorusKnotBufferGeometry,
    TorusGeometry: module$node_modules$three$build$three.default.TorusGeometry,
    TorusBufferGeometry: module$node_modules$three$build$three.default.TorusBufferGeometry,
    TextGeometry: module$node_modules$three$build$three.default.TextGeometry,
    TextBufferGeometry: module$node_modules$three$build$three.default.TextBufferGeometry,
    SphereGeometry: module$node_modules$three$build$three.default.SphereGeometry,
    SphereBufferGeometry: module$node_modules$three$build$three.default.SphereBufferGeometry,
    RingGeometry: module$node_modules$three$build$three.default.RingGeometry,
    RingBufferGeometry: module$node_modules$three$build$three.default.RingBufferGeometry,
    PlaneGeometry: module$node_modules$three$build$three.default.PlaneGeometry,
    PlaneBufferGeometry: module$node_modules$three$build$three.default.PlaneBufferGeometry,
    LatheGeometry: module$node_modules$three$build$three.default.LatheGeometry,
    LatheBufferGeometry: module$node_modules$three$build$three.default.LatheBufferGeometry,
    ShapeGeometry: module$node_modules$three$build$three.default.ShapeGeometry,
    ShapeBufferGeometry: module$node_modules$three$build$three.default.ShapeBufferGeometry,
    ExtrudeGeometry: module$node_modules$three$build$three.default.ExtrudeGeometry,
    ExtrudeBufferGeometry: module$node_modules$three$build$three.default.ExtrudeBufferGeometry,
    EdgesGeometry: module$node_modules$three$build$three.default.EdgesGeometry,
    ConeGeometry: module$node_modules$three$build$three.default.ConeGeometry,
    ConeBufferGeometry: module$node_modules$three$build$three.default.ConeBufferGeometry,
    CylinderGeometry: module$node_modules$three$build$three.default.CylinderGeometry,
    CylinderBufferGeometry: module$node_modules$three$build$three.default.CylinderBufferGeometry,
    CircleGeometry: module$node_modules$three$build$three.default.CircleGeometry,
    CircleBufferGeometry: module$node_modules$three$build$three.default.CircleBufferGeometry,
    BoxGeometry: module$node_modules$three$build$three.default.BoxGeometry,
    BoxBufferGeometry: module$node_modules$three$build$three.default.BoxBufferGeometry
});
module$node_modules$three$build$three.default.ShadowMaterial.prototype = Object.create(module$node_modules$three$build$three.default.Material.prototype);
module$node_modules$three$build$three.default.ShadowMaterial.prototype.constructor = module$node_modules$three$build$three.default.ShadowMaterial;
module$node_modules$three$build$three.default.ShadowMaterial.prototype.isShadowMaterial = !0;
module$node_modules$three$build$three.default.ShadowMaterial.prototype.copy = function(a) {
    module$node_modules$three$build$three.default.Material.prototype.copy.call(this, a);
    this.color.copy(a.color);
    return this
};
module$node_modules$three$build$three.default.RawShaderMaterial.prototype = Object.create(module$node_modules$three$build$three.default.ShaderMaterial.prototype);
module$node_modules$three$build$three.default.RawShaderMaterial.prototype.constructor = module$node_modules$three$build$three.default.RawShaderMaterial;
module$node_modules$three$build$three.default.RawShaderMaterial.prototype.isRawShaderMaterial = !0;
module$node_modules$three$build$three.default.MeshStandardMaterial.prototype = Object.create(module$node_modules$three$build$three.default.Material.prototype);
module$node_modules$three$build$three.default.MeshStandardMaterial.prototype.constructor = module$node_modules$three$build$three.default.MeshStandardMaterial;
module$node_modules$three$build$three.default.MeshStandardMaterial.prototype.isMeshStandardMaterial = !0;
module$node_modules$three$build$three.default.MeshStandardMaterial.prototype.copy = function(a) {
    module$node_modules$three$build$three.default.Material.prototype.copy.call(this, a);
    this.defines = {
        STANDARD: ""
    };
    this.color.copy(a.color);
    this.roughness = a.roughness;
    this.metalness = a.metalness;
    this.map = a.map;
    this.lightMap = a.lightMap;
    this.lightMapIntensity = a.lightMapIntensity;
    this.aoMap = a.aoMap;
    this.aoMapIntensity = a.aoMapIntensity;
    this.emissive.copy(a.emissive);
    this.emissiveMap = a.emissiveMap;
    this.emissiveIntensity =
        a.emissiveIntensity;
    this.bumpMap = a.bumpMap;
    this.bumpScale = a.bumpScale;
    this.normalMap = a.normalMap;
    this.normalMapType = a.normalMapType;
    this.normalScale.copy(a.normalScale);
    this.displacementMap = a.displacementMap;
    this.displacementScale = a.displacementScale;
    this.displacementBias = a.displacementBias;
    this.roughnessMap = a.roughnessMap;
    this.metalnessMap = a.metalnessMap;
    this.alphaMap = a.alphaMap;
    this.envMap = a.envMap;
    this.envMapIntensity = a.envMapIntensity;
    this.refractionRatio = a.refractionRatio;
    this.wireframe = a.wireframe;
    this.wireframeLinewidth = a.wireframeLinewidth;
    this.wireframeLinecap = a.wireframeLinecap;
    this.wireframeLinejoin = a.wireframeLinejoin;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.morphNormals = a.morphNormals;
    return this
};
module$node_modules$three$build$three.default.MeshPhysicalMaterial.prototype = Object.create(module$node_modules$three$build$three.default.MeshStandardMaterial.prototype);
module$node_modules$three$build$three.default.MeshPhysicalMaterial.prototype.constructor = module$node_modules$three$build$three.default.MeshPhysicalMaterial;
module$node_modules$three$build$three.default.MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = !0;
module$node_modules$three$build$three.default.MeshPhysicalMaterial.prototype.copy = function(a) {
    module$node_modules$three$build$three.default.MeshStandardMaterial.prototype.copy.call(this, a);
    this.defines = {
        PHYSICAL: ""
    };
    this.reflectivity = a.reflectivity;
    this.clearCoat = a.clearCoat;
    this.clearCoatRoughness = a.clearCoatRoughness;
    return this
};
module$node_modules$three$build$three.default.MeshPhongMaterial.prototype = Object.create(module$node_modules$three$build$three.default.Material.prototype);
module$node_modules$three$build$three.default.MeshPhongMaterial.prototype.constructor = module$node_modules$three$build$three.default.MeshPhongMaterial;
module$node_modules$three$build$three.default.MeshPhongMaterial.prototype.isMeshPhongMaterial = !0;
module$node_modules$three$build$three.default.MeshPhongMaterial.prototype.copy = function(a) {
    module$node_modules$three$build$three.default.Material.prototype.copy.call(this, a);
    this.color.copy(a.color);
    this.specular.copy(a.specular);
    this.shininess = a.shininess;
    this.map = a.map;
    this.lightMap = a.lightMap;
    this.lightMapIntensity = a.lightMapIntensity;
    this.aoMap = a.aoMap;
    this.aoMapIntensity = a.aoMapIntensity;
    this.emissive.copy(a.emissive);
    this.emissiveMap = a.emissiveMap;
    this.emissiveIntensity = a.emissiveIntensity;
    this.bumpMap = a.bumpMap;
    this.bumpScale = a.bumpScale;
    this.normalMap = a.normalMap;
    this.normalMapType = a.normalMapType;
    this.normalScale.copy(a.normalScale);
    this.displacementMap = a.displacementMap;
    this.displacementScale = a.displacementScale;
    this.displacementBias = a.displacementBias;
    this.specularMap = a.specularMap;
    this.alphaMap = a.alphaMap;
    this.envMap = a.envMap;
    this.combine = a.combine;
    this.reflectivity = a.reflectivity;
    this.refractionRatio = a.refractionRatio;
    this.wireframe = a.wireframe;
    this.wireframeLinewidth = a.wireframeLinewidth;
    this.wireframeLinecap = a.wireframeLinecap;
    this.wireframeLinejoin = a.wireframeLinejoin;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.morphNormals = a.morphNormals;
    return this
};
module$node_modules$three$build$three.default.MeshToonMaterial.prototype = Object.create(module$node_modules$three$build$three.default.MeshPhongMaterial.prototype);
module$node_modules$three$build$three.default.MeshToonMaterial.prototype.constructor = module$node_modules$three$build$three.default.MeshToonMaterial;
module$node_modules$three$build$three.default.MeshToonMaterial.prototype.isMeshToonMaterial = !0;
module$node_modules$three$build$three.default.MeshToonMaterial.prototype.copy = function(a) {
    module$node_modules$three$build$three.default.MeshPhongMaterial.prototype.copy.call(this, a);
    this.gradientMap = a.gradientMap;
    return this
};
module$node_modules$three$build$three.default.MeshNormalMaterial.prototype = Object.create(module$node_modules$three$build$three.default.Material.prototype);
module$node_modules$three$build$three.default.MeshNormalMaterial.prototype.constructor = module$node_modules$three$build$three.default.MeshNormalMaterial;
module$node_modules$three$build$three.default.MeshNormalMaterial.prototype.isMeshNormalMaterial = !0;
module$node_modules$three$build$three.default.MeshNormalMaterial.prototype.copy = function(a) {
    module$node_modules$three$build$three.default.Material.prototype.copy.call(this, a);
    this.bumpMap = a.bumpMap;
    this.bumpScale = a.bumpScale;
    this.normalMap = a.normalMap;
    this.normalMapType = a.normalMapType;
    this.normalScale.copy(a.normalScale);
    this.displacementMap = a.displacementMap;
    this.displacementScale = a.displacementScale;
    this.displacementBias = a.displacementBias;
    this.wireframe = a.wireframe;
    this.wireframeLinewidth = a.wireframeLinewidth;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.morphNormals = a.morphNormals;
    return this
};
module$node_modules$three$build$three.default.MeshLambertMaterial.prototype = Object.create(module$node_modules$three$build$three.default.Material.prototype);
module$node_modules$three$build$three.default.MeshLambertMaterial.prototype.constructor = module$node_modules$three$build$three.default.MeshLambertMaterial;
module$node_modules$three$build$three.default.MeshLambertMaterial.prototype.isMeshLambertMaterial = !0;
module$node_modules$three$build$three.default.MeshLambertMaterial.prototype.copy = function(a) {
    module$node_modules$three$build$three.default.Material.prototype.copy.call(this, a);
    this.color.copy(a.color);
    this.map = a.map;
    this.lightMap = a.lightMap;
    this.lightMapIntensity = a.lightMapIntensity;
    this.aoMap = a.aoMap;
    this.aoMapIntensity = a.aoMapIntensity;
    this.emissive.copy(a.emissive);
    this.emissiveMap = a.emissiveMap;
    this.emissiveIntensity = a.emissiveIntensity;
    this.specularMap = a.specularMap;
    this.alphaMap = a.alphaMap;
    this.envMap = a.envMap;
    this.combine = a.combine;
    this.reflectivity = a.reflectivity;
    this.refractionRatio = a.refractionRatio;
    this.wireframe = a.wireframe;
    this.wireframeLinewidth = a.wireframeLinewidth;
    this.wireframeLinecap = a.wireframeLinecap;
    this.wireframeLinejoin = a.wireframeLinejoin;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.morphNormals = a.morphNormals;
    return this
};
module$node_modules$three$build$three.default.LineDashedMaterial.prototype = Object.create(module$node_modules$three$build$three.default.LineBasicMaterial.prototype);
module$node_modules$three$build$three.default.LineDashedMaterial.prototype.constructor = module$node_modules$three$build$three.default.LineDashedMaterial;
module$node_modules$three$build$three.default.LineDashedMaterial.prototype.isLineDashedMaterial = !0;
module$node_modules$three$build$three.default.LineDashedMaterial.prototype.copy = function(a) {
    module$node_modules$three$build$three.default.LineBasicMaterial.prototype.copy.call(this, a);
    this.scale = a.scale;
    this.dashSize = a.dashSize;
    this.gapSize = a.gapSize;
    return this
};
var Materials$$module$node_modules$three$build$three = Object.freeze({
    ShadowMaterial: module$node_modules$three$build$three.default.ShadowMaterial,
    SpriteMaterial: module$node_modules$three$build$three.default.SpriteMaterial,
    RawShaderMaterial: module$node_modules$three$build$three.default.RawShaderMaterial,
    ShaderMaterial: module$node_modules$three$build$three.default.ShaderMaterial,
    PointsMaterial: module$node_modules$three$build$three.default.PointsMaterial,
    MeshPhysicalMaterial: module$node_modules$three$build$three.default.MeshPhysicalMaterial,
    MeshStandardMaterial: module$node_modules$three$build$three.default.MeshStandardMaterial,
    MeshPhongMaterial: module$node_modules$three$build$three.default.MeshPhongMaterial,
    MeshToonMaterial: module$node_modules$three$build$three.default.MeshToonMaterial,
    MeshNormalMaterial: module$node_modules$three$build$three.default.MeshNormalMaterial,
    MeshLambertMaterial: module$node_modules$three$build$three.default.MeshLambertMaterial,
    MeshDepthMaterial: module$node_modules$three$build$three.default.MeshDepthMaterial,
    MeshDistanceMaterial: module$node_modules$three$build$three.default.MeshDistanceMaterial,
    MeshBasicMaterial: module$node_modules$three$build$three.default.MeshBasicMaterial,
    LineDashedMaterial: module$node_modules$three$build$three.default.LineDashedMaterial,
    LineBasicMaterial: module$node_modules$three$build$three.default.LineBasicMaterial,
    Material: module$node_modules$three$build$three.default.Material
});
module$node_modules$three$build$three.default.Cache = {
    enabled: !1,
    files: {},
    add: function(a, b) {
        !1 !== this.enabled && (this.files[a] = b)
    },
    get: function(a) {
        if (!1 !== this.enabled) return this.files[a]
    },
    remove: function(a) {
        delete this.files[a]
    },
    clear: function() {
        this.files = {}
    }
};
module$node_modules$three$build$three.default.DefaultLoadingManager = new module$node_modules$three$build$three.default.LoadingManager;
var loading$$module$node_modules$three$build$three = {};
Object.assign(module$node_modules$three$build$three.default.FileLoader.prototype, {
    load: function(a, b, c, d) {
        void 0 === a && (a = "");
        void 0 !== this.path && (a = this.path + a);
        a = this.manager.resolveURL(a);
        var e = this,
            f = module$node_modules$three$build$three.default.Cache.get(a);
        if (void 0 !== f) return e.manager.itemStart(a), setTimeout(function() {
            b && b(f);
            e.manager.itemEnd(a)
        }, 0), f;
        if (void 0 !== loading$$module$node_modules$three$build$three[a]) loading$$module$node_modules$three$build$three[a].push({
            onLoad: b,
            onProgress: c,
            onError: d
        });
        else {
            var g = a.match(/^data:(.*?)(;base64)?,(.*)$/);
            if (g) {
                c = g[1];
                var h = !!g[2];
                g = g[3];
                g = window.decodeURIComponent(g);
                h && (g = window.atob(g));
                try {
                    var k = (this.responseType || "").toLowerCase();
                    switch (k) {
                        case "arraybuffer":
                        case "blob":
                            var l = new Uint8Array(g.length);
                            for (h = 0; h < g.length; h++) l[h] = g.charCodeAt(h);
                            var p = "blob" === k ? new Blob([l.buffer], {
                                type: c
                            }) : l.buffer;
                            break;
                        case "document":
                            p = (new DOMParser).parseFromString(g, c);
                            break;
                        case "json":
                            p = JSON.parse(g);
                            break;
                        default:
                            p = g
                    }
                    window.setTimeout(function() {
                        b &&
                            b(p);
                        e.manager.itemEnd(a)
                    }, 0)
                } catch (q) {
                    window.setTimeout(function() {
                        d && d(q);
                        e.manager.itemEnd(a);
                        e.manager.itemError(a)
                    }, 0)
                }
            } else {
                loading$$module$node_modules$three$build$three[a] = [];
                loading$$module$node_modules$three$build$three[a].push({
                    onLoad: b,
                    onProgress: c,
                    onError: d
                });
                var m = new XMLHttpRequest;
                m.open("GET", a, !0);
                m.addEventListener("load", function(b) {
                    var c = this.response;
                    module$node_modules$three$build$three.default.Cache.add(a, c);
                    var d = loading$$module$node_modules$three$build$three[a];
                    delete loading$$module$node_modules$three$build$three[a];
                    if (200 === this.status || 0 === this.status) {
                        0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received.");
                        for (var f = 0, g = d.length; f < g; f++) {
                            var h = d[f];
                            if (h.onLoad) h.onLoad(c)
                        }
                        e.manager.itemEnd(a)
                    } else {
                        f = 0;
                        for (g = d.length; f < g; f++)
                            if (h = d[f], h.onError) h.onError(b);
                        e.manager.itemEnd(a);
                        e.manager.itemError(a)
                    }
                }, !1);
                m.addEventListener("progress", function(b) {
                    for (var c = loading$$module$node_modules$three$build$three[a], d = 0, e = c.length; d < e; d++) {
                        var f = c[d];
                        if (f.onProgress) f.onProgress(b)
                    }
                }, !1);
                m.addEventListener("error",
                    function(b) {
                        var c = loading$$module$node_modules$three$build$three[a];
                        delete loading$$module$node_modules$three$build$three[a];
                        for (var d = 0, f = c.length; d < f; d++) {
                            var g = c[d];
                            if (g.onError) g.onError(b)
                        }
                        e.manager.itemEnd(a);
                        e.manager.itemError(a)
                    }, !1);
                void 0 !== this.responseType && (m.responseType = this.responseType);
                void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials);
                m.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                for (h in this.requestHeader) m.setRequestHeader(h,
                    this.requestHeader[h]);
                m.send(null)
            }
            e.manager.itemStart(a);
            return m
        }
    },
    setPath: function(a) {
        this.path = a;
        return this
    },
    setResponseType: function(a) {
        this.responseType = a;
        return this
    },
    setWithCredentials: function(a) {
        this.withCredentials = a;
        return this
    },
    setMimeType: function(a) {
        this.mimeType = a;
        return this
    },
    setRequestHeader: function(a) {
        this.requestHeader = a;
        return this
    }
});
Object.assign(module$node_modules$three$build$three.default.CompressedTextureLoader.prototype, {
    load: function(a, b, c, d) {
        function e(e) {
            k.load(a[e], function(a) {
                a = f._parser(a, !0);
                g[e] = {
                    width: a.width,
                    height: a.height,
                    format: a.format,
                    mipmaps: a.mipmaps
                };
                l += 1;
                6 === l && (1 === a.mipmapCount && (h.minFilter = module$node_modules$three$build$three.default.LinearFilter), h.format = a.format, h.needsUpdate = !0, b && b(h))
            }, c, d)
        }
        var f = this,
            g = [],
            h = new module$node_modules$three$build$three.default.CompressedTexture;
        h.image = g;
        var k =
            new module$node_modules$three$build$three.default.FileLoader(this.manager);
        k.setPath(this.path);
        k.setResponseType("arraybuffer");
        if (Array.isArray(a))
            for (var l = 0, p = 0, m = a.length; p < m; ++p) e(p);
        else k.load(a, function(a) {
            a = f._parser(a, !0);
            if (a.isCubemap)
                for (var c = a.mipmaps.length / a.mipmapCount, d = 0; d < c; d++) {
                    g[d] = {
                        mipmaps: []
                    };
                    for (var e = 0; e < a.mipmapCount; e++) g[d].mipmaps.push(a.mipmaps[d * a.mipmapCount + e]), g[d].format = a.format, g[d].width = a.width, g[d].height = a.height
                } else h.image.width = a.width, h.image.height =
                    a.height, h.mipmaps = a.mipmaps;
            1 === a.mipmapCount && (h.minFilter = module$node_modules$three$build$three.default.LinearFilter);
            h.format = a.format;
            h.needsUpdate = !0;
            b && b(h)
        }, c, d);
        return h
    },
    setPath: function(a) {
        this.path = a;
        return this
    }
});
Object.assign(module$node_modules$three$build$three.default.DataTextureLoader.prototype, {
    load: function(a, b, c, d) {
        var e = this,
            f = new module$node_modules$three$build$three.default.DataTexture,
            g = new module$node_modules$three$build$three.default.FileLoader(this.manager);
        g.setResponseType("arraybuffer");
        g.load(a, function(a) {
            if (a = e._parser(a)) void 0 !== a.image ? f.image = a.image : void 0 !== a.data && (f.image.width = a.width, f.image.height = a.height, f.image.data = a.data), f.wrapS = void 0 !== a.wrapS ? a.wrapS : module$node_modules$three$build$three.default.ClampToEdgeWrapping,
                f.wrapT = void 0 !== a.wrapT ? a.wrapT : module$node_modules$three$build$three.default.ClampToEdgeWrapping, f.magFilter = void 0 !== a.magFilter ? a.magFilter : module$node_modules$three$build$three.default.LinearFilter, f.minFilter = void 0 !== a.minFilter ? a.minFilter : module$node_modules$three$build$three.default.LinearMipMapLinearFilter, f.anisotropy = void 0 !== a.anisotropy ? a.anisotropy : 1, void 0 !== a.format && (f.format = a.format), void 0 !== a.type && (f.type = a.type), void 0 !== a.mipmaps && (f.mipmaps = a.mipmaps), 1 === a.mipmapCount &&
                (f.minFilter = module$node_modules$three$build$three.default.LinearFilter), f.needsUpdate = !0, b && b(f, a)
        }, c, d);
        return f
    }
});
Object.assign(module$node_modules$three$build$three.default.ImageLoader.prototype, {
    crossOrigin: "anonymous",
    load: function(a, b, c, d) {
        function e() {
            k.removeEventListener("load", e, !1);
            k.removeEventListener("error", f, !1);
            module$node_modules$three$build$three.default.Cache.add(a, this);
            b && b(this);
            g.manager.itemEnd(a)
        }

        function f(b) {
            k.removeEventListener("load", e, !1);
            k.removeEventListener("error", f, !1);
            d && d(b);
            g.manager.itemEnd(a);
            g.manager.itemError(a)
        }
        void 0 === a && (a = "");
        void 0 !== this.path && (a = this.path + a);
        a = this.manager.resolveURL(a);
        var g = this,
            h = module$node_modules$three$build$three.default.Cache.get(a);
        if (void 0 !== h) return g.manager.itemStart(a), setTimeout(function() {
            b && b(h);
            g.manager.itemEnd(a)
        }, 0), h;
        var k = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
        k.addEventListener("load", e, !1);
        k.addEventListener("error", f, !1);
        "data:" !== a.substr(0, 5) && void 0 !== this.crossOrigin && (k.crossOrigin = this.crossOrigin);
        g.manager.itemStart(a);
        k.src = a;
        return k
    },
    setCrossOrigin: function(a) {
        this.crossOrigin =
            a;
        return this
    },
    setPath: function(a) {
        this.path = a;
        return this
    }
});
Object.assign(module$node_modules$three$build$three.default.CubeTextureLoader.prototype, {
    crossOrigin: "anonymous",
    load: function(a, b, c, d) {
        function e(c) {
            g.load(a[c], function(a) {
                f.images[c] = a;
                h++;
                6 === h && (f.needsUpdate = !0, b && b(f))
            }, void 0, d)
        }
        var f = new module$node_modules$three$build$three.default.CubeTexture,
            g = new module$node_modules$three$build$three.default.ImageLoader(this.manager);
        g.setCrossOrigin(this.crossOrigin);
        g.setPath(this.path);
        var h = 0;
        for (c = 0; c < a.length; ++c) e(c);
        return f
    },
    setCrossOrigin: function(a) {
        this.crossOrigin =
            a;
        return this
    },
    setPath: function(a) {
        this.path = a;
        return this
    }
});
Object.assign(module$node_modules$three$build$three.default.TextureLoader.prototype, {
    crossOrigin: "anonymous",
    load: function(a, b, c, d) {
        var e = new module$node_modules$three$build$three.default.Texture,
            f = new module$node_modules$three$build$three.default.ImageLoader(this.manager);
        f.setCrossOrigin(this.crossOrigin);
        f.setPath(this.path);
        f.load(a, function(c) {
            e.image = c;
            c = 0 < a.search(/\.(jpg|jpeg)$/) || 0 === a.search(/^data:image\/jpeg/);
            e.format = c ? module$node_modules$three$build$three.default.RGBFormat : module$node_modules$three$build$three.default.RGBAFormat;
            e.needsUpdate = !0;
            void 0 !== b && b(e)
        }, c, d);
        return e
    },
    setCrossOrigin: function(a) {
        this.crossOrigin = a;
        return this
    },
    setPath: function(a) {
        this.path = a;
        return this
    }
});
Object.assign(module$node_modules$three$build$three.default.Curve.prototype, {
    getPoint: function() {
        console.warn("THREE.Curve: .getPoint() not implemented.");
        return null
    },
    getPointAt: function(a, b) {
        a = this.getUtoTmapping(a);
        return this.getPoint(a, b)
    },
    getPoints: function(a) {
        void 0 === a && (a = 5);
        for (var b = [], c = 0; c <= a; c++) b.push(this.getPoint(c / a));
        return b
    },
    getSpacedPoints: function(a) {
        void 0 === a && (a = 5);
        for (var b = [], c = 0; c <= a; c++) b.push(this.getPointAt(c / a));
        return b
    },
    getLength: function() {
        var a = this.getLengths();
        return a[a.length - 1]
    },
    getLengths: function(a) {
        void 0 === a && (a = this.arcLengthDivisions);
        if (this.cacheArcLengths && this.cacheArcLengths.length === a + 1 && !this.needsUpdate) return this.cacheArcLengths;
        this.needsUpdate = !1;
        var b = [],
            c = this.getPoint(0),
            d, e = 0;
        b.push(0);
        for (d = 1; d <= a; d++) {
            var f = this.getPoint(d / a);
            e += f.distanceTo(c);
            b.push(e);
            c = f
        }
        return this.cacheArcLengths = b
    },
    updateArcLengths: function() {
        this.needsUpdate = !0;
        this.getLengths()
    },
    getUtoTmapping: function(a, b) {
        var c = this.getLengths(),
            d = c.length;
        b = b ? b : a *
            c[d - 1];
        for (var e = 0, f = d - 1, g; e <= f;)
            if (a = Math.floor(e + (f - e) / 2), g = c[a] - b, 0 > g) e = a + 1;
            else if (0 < g) f = a - 1;
        else {
            f = a;
            break
        }
        a = f;
        if (c[a] === b) return a / (d - 1);
        e = c[a];
        return (a + (b - e) / (c[a + 1] - e)) / (d - 1)
    },
    getTangent: function(a) {
        var b = a - 1E-4;
        a += 1E-4;
        0 > b && (b = 0);
        1 < a && (a = 1);
        b = this.getPoint(b);
        return this.getPoint(a).clone().sub(b).normalize()
    },
    getTangentAt: function(a) {
        a = this.getUtoTmapping(a);
        return this.getTangent(a)
    },
    computeFrenetFrames: function(a, b) {
        var c = new module$node_modules$three$build$three.default.Vector3,
            d = [],
            e = [],
            f = [],
            g = new module$node_modules$three$build$three.default.Vector3,
            h = new module$node_modules$three$build$three.default.Matrix4,
            k;
        for (k = 0; k <= a; k++) {
            var l = k / a;
            d[k] = this.getTangentAt(l);
            d[k].normalize()
        }
        e[0] = new module$node_modules$three$build$three.default.Vector3;
        f[0] = new module$node_modules$three$build$three.default.Vector3;
        k = Number.MAX_VALUE;
        l = Math.abs(d[0].x);
        var p = Math.abs(d[0].y),
            m = Math.abs(d[0].z);
        l <= k && (k = l, c.set(1, 0, 0));
        p <= k && (k = p, c.set(0, 1, 0));
        m <= k && c.set(0, 0, 1);
        g.crossVectors(d[0], c).normalize();
        e[0].crossVectors(d[0], g);
        f[0].crossVectors(d[0], e[0]);
        for (k = 1; k <= a; k++) e[k] = e[k - 1].clone(), f[k] = f[k - 1].clone(), g.crossVectors(d[k - 1], d[k]), g.length() > Number.EPSILON && (g.normalize(), c = Math.acos(module$node_modules$three$build$three.default.Math.clamp(d[k - 1].dot(d[k]), -1, 1)), e[k].applyMatrix4(h.makeRotationAxis(g, c))), f[k].crossVectors(d[k], e[k]);
        if (!0 === b)
            for (c = Math.acos(module$node_modules$three$build$three.default.Math.clamp(e[0].dot(e[a]), -1, 1)), c /= a, 0 < d[0].dot(g.crossVectors(e[0], e[a])) && (c = -c),
                k = 1; k <= a; k++) e[k].applyMatrix4(h.makeRotationAxis(d[k], c * k)), f[k].crossVectors(d[k], e[k]);
        return {
            tangents: d,
            normals: e,
            binormals: f
        }
    },
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(a) {
        this.arcLengthDivisions = a.arcLengthDivisions;
        return this
    },
    toJSON: function() {
        var a = {
            metadata: {
                version: 4.5,
                type: "Curve",
                generator: "Curve.toJSON"
            }
        };
        a.arcLengthDivisions = this.arcLengthDivisions;
        a.type = this.type;
        return a
    },
    fromJSON: function(a) {
        this.arcLengthDivisions = a.arcLengthDivisions;
        return this
    }
});
module$node_modules$three$build$three.default.EllipseCurve.prototype = Object.create(module$node_modules$three$build$three.default.Curve.prototype);
module$node_modules$three$build$three.default.EllipseCurve.prototype.constructor = module$node_modules$three$build$three.default.EllipseCurve;
module$node_modules$three$build$three.default.EllipseCurve.prototype.isEllipseCurve = !0;
module$node_modules$three$build$three.default.EllipseCurve.prototype.getPoint = function(a, b) {
    b = b || new module$node_modules$three$build$three.default.Vector2;
    for (var c = 2 * Math.PI, d = this.aEndAngle - this.aStartAngle, e = Math.abs(d) < Number.EPSILON; 0 > d;) d += c;
    for (; d > c;) d -= c;
    d < Number.EPSILON && (d = e ? 0 : c);
    !0 !== this.aClockwise || e || (d = d === c ? -c : d - c);
    c = this.aStartAngle + a * d;
    a = this.aX + this.xRadius * Math.cos(c);
    var f = this.aY + this.yRadius * Math.sin(c);
    0 !== this.aRotation && (c = Math.cos(this.aRotation), d = Math.sin(this.aRotation),
        e = a - this.aX, f -= this.aY, a = e * c - f * d + this.aX, f = e * d + f * c + this.aY);
    return b.set(a, f)
};
module$node_modules$three$build$three.default.EllipseCurve.prototype.copy = function(a) {
    module$node_modules$three$build$three.default.Curve.prototype.copy.call(this, a);
    this.aX = a.aX;
    this.aY = a.aY;
    this.xRadius = a.xRadius;
    this.yRadius = a.yRadius;
    this.aStartAngle = a.aStartAngle;
    this.aEndAngle = a.aEndAngle;
    this.aClockwise = a.aClockwise;
    this.aRotation = a.aRotation;
    return this
};
module$node_modules$three$build$three.default.EllipseCurve.prototype.toJSON = function() {
    var a = module$node_modules$three$build$three.default.Curve.prototype.toJSON.call(this);
    a.aX = this.aX;
    a.aY = this.aY;
    a.xRadius = this.xRadius;
    a.yRadius = this.yRadius;
    a.aStartAngle = this.aStartAngle;
    a.aEndAngle = this.aEndAngle;
    a.aClockwise = this.aClockwise;
    a.aRotation = this.aRotation;
    return a
};
module$node_modules$three$build$three.default.EllipseCurve.prototype.fromJSON = function(a) {
    module$node_modules$three$build$three.default.Curve.prototype.fromJSON.call(this, a);
    this.aX = a.aX;
    this.aY = a.aY;
    this.xRadius = a.xRadius;
    this.yRadius = a.yRadius;
    this.aStartAngle = a.aStartAngle;
    this.aEndAngle = a.aEndAngle;
    this.aClockwise = a.aClockwise;
    this.aRotation = a.aRotation;
    return this
};
module$node_modules$three$build$three.default.ArcCurve.prototype = Object.create(module$node_modules$three$build$three.default.EllipseCurve.prototype);
module$node_modules$three$build$three.default.ArcCurve.prototype.constructor = module$node_modules$three$build$three.default.ArcCurve;
module$node_modules$three$build$three.default.ArcCurve.prototype.isArcCurve = !0;

function CubicPoly$$module$node_modules$three$build$three() {
    var a = 0,
        b = 0,
        c = 0,
        d = 0;
    return {
        initCatmullRom: function(e, f, g, h, k) {
            e = k * (g - e);
            h = k * (h - f);
            a = f;
            b = e;
            c = -3 * f + 3 * g - 2 * e - h;
            d = 2 * f - 2 * g + e + h
        },
        initNonuniformCatmullRom: function(e, f, g, h, k, l, p) {
            e = ((f - e) / k - (g - e) / (k + l) + (g - f) / l) * l;
            h = ((g - f) / l - (h - f) / (l + p) + (h - g) / p) * l;
            a = f;
            b = e;
            c = -3 * f + 3 * g - 2 * e - h;
            d = 2 * f - 2 * g + e + h
        },
        calc: function(e) {
            var f = e * e;
            return a + b * e + c * f + d * f * e
        }
    }
}
var tmp$$module$node_modules$three$build$three = new module$node_modules$three$build$three.default.Vector3,
    px$$module$node_modules$three$build$three = new CubicPoly$$module$node_modules$three$build$three,
    py$$module$node_modules$three$build$three = new CubicPoly$$module$node_modules$three$build$three,
    pz$$module$node_modules$three$build$three = new CubicPoly$$module$node_modules$three$build$three;
module$node_modules$three$build$three.default.CatmullRomCurve3.prototype = Object.create(module$node_modules$three$build$three.default.Curve.prototype);
module$node_modules$three$build$three.default.CatmullRomCurve3.prototype.constructor = module$node_modules$three$build$three.default.CatmullRomCurve3;
module$node_modules$three$build$three.default.CatmullRomCurve3.prototype.isCatmullRomCurve3 = !0;
module$node_modules$three$build$three.default.CatmullRomCurve3.prototype.getPoint = function(a, b) {
    b = b || new module$node_modules$three$build$three.default.Vector3;
    var c = this.points,
        d = c.length;
    a *= d - (this.closed ? 0 : 1);
    var e = Math.floor(a);
    a -= e;
    this.closed ? e += 0 < e ? 0 : (Math.floor(Math.abs(e) / d) + 1) * d : 0 === a && e === d - 1 && (e = d - 2, a = 1);
    if (this.closed || 0 < e) var f = c[(e - 1) % d];
    else tmp$$module$node_modules$three$build$three.subVectors(c[0], c[1]).add(c[0]), f = tmp$$module$node_modules$three$build$three;
    var g = c[e % d];
    var h = c[(e +
        1) % d];
    this.closed || e + 2 < d ? c = c[(e + 2) % d] : (tmp$$module$node_modules$three$build$three.subVectors(c[d - 1], c[d - 2]).add(c[d - 1]), c = tmp$$module$node_modules$three$build$three);
    if ("centripetal" === this.curveType || "chordal" === this.curveType) {
        var k = "chordal" === this.curveType ? .5 : .25;
        d = Math.pow(f.distanceToSquared(g), k);
        e = Math.pow(g.distanceToSquared(h), k);
        k = Math.pow(h.distanceToSquared(c), k);
        1E-4 > e && (e = 1);
        1E-4 > d && (d = e);
        1E-4 > k && (k = e);
        px$$module$node_modules$three$build$three.initNonuniformCatmullRom(f.x, g.x, h.x,
            c.x, d, e, k);
        py$$module$node_modules$three$build$three.initNonuniformCatmullRom(f.y, g.y, h.y, c.y, d, e, k);
        pz$$module$node_modules$three$build$three.initNonuniformCatmullRom(f.z, g.z, h.z, c.z, d, e, k)
    } else "catmullrom" === this.curveType && (px$$module$node_modules$three$build$three.initCatmullRom(f.x, g.x, h.x, c.x, this.tension), py$$module$node_modules$three$build$three.initCatmullRom(f.y, g.y, h.y, c.y, this.tension), pz$$module$node_modules$three$build$three.initCatmullRom(f.z, g.z, h.z, c.z, this.tension));
    b.set(px$$module$node_modules$three$build$three.calc(a),
        py$$module$node_modules$three$build$three.calc(a), pz$$module$node_modules$three$build$three.calc(a));
    return b
};
module$node_modules$three$build$three.default.CatmullRomCurve3.prototype.copy = function(a) {
    module$node_modules$three$build$three.default.Curve.prototype.copy.call(this, a);
    this.points = [];
    for (var b = 0, c = a.points.length; b < c; b++) this.points.push(a.points[b].clone());
    this.closed = a.closed;
    this.curveType = a.curveType;
    this.tension = a.tension;
    return this
};
module$node_modules$three$build$three.default.CatmullRomCurve3.prototype.toJSON = function() {
    var a = module$node_modules$three$build$three.default.Curve.prototype.toJSON.call(this);
    a.points = [];
    for (var b = 0, c = this.points.length; b < c; b++) a.points.push(this.points[b].toArray());
    a.closed = this.closed;
    a.curveType = this.curveType;
    a.tension = this.tension;
    return a
};
module$node_modules$three$build$three.default.CatmullRomCurve3.prototype.fromJSON = function(a) {
    module$node_modules$three$build$three.default.Curve.prototype.fromJSON.call(this, a);
    this.points = [];
    for (var b = 0, c = a.points.length; b < c; b++) {
        var d = a.points[b];
        this.points.push((new module$node_modules$three$build$three.default.Vector3).fromArray(d))
    }
    this.closed = a.closed;
    this.curveType = a.curveType;
    this.tension = a.tension;
    return this
};

function CatmullRom$$module$node_modules$three$build$three(a, b, c, d, e) {
    b = .5 * (d - b);
    e = .5 * (e - c);
    var f = a * a;
    return (2 * c - 2 * d + b + e) * a * f + (-3 * c + 3 * d - 2 * b - e) * f + b * a + c
}

function QuadraticBezierP0$$module$node_modules$three$build$three(a, b) {
    a = 1 - a;
    return a * a * b
}

function QuadraticBezierP1$$module$node_modules$three$build$three(a, b) {
    return 2 * (1 - a) * a * b
}

function QuadraticBezierP2$$module$node_modules$three$build$three(a, b) {
    return a * a * b
}

function QuadraticBezier$$module$node_modules$three$build$three(a, b, c, d) {
    return QuadraticBezierP0$$module$node_modules$three$build$three(a, b) + QuadraticBezierP1$$module$node_modules$three$build$three(a, c) + QuadraticBezierP2$$module$node_modules$three$build$three(a, d)
}

function CubicBezierP0$$module$node_modules$three$build$three(a, b) {
    a = 1 - a;
    return a * a * a * b
}

function CubicBezierP1$$module$node_modules$three$build$three(a, b) {
    var c = 1 - a;
    return 3 * c * c * a * b
}

function CubicBezierP2$$module$node_modules$three$build$three(a, b) {
    return 3 * (1 - a) * a * a * b
}

function CubicBezierP3$$module$node_modules$three$build$three(a, b) {
    return a * a * a * b
}

function CubicBezier$$module$node_modules$three$build$three(a, b, c, d, e) {
    return CubicBezierP0$$module$node_modules$three$build$three(a, b) + CubicBezierP1$$module$node_modules$three$build$three(a, c) + CubicBezierP2$$module$node_modules$three$build$three(a, d) + CubicBezierP3$$module$node_modules$three$build$three(a, e)
}
module$node_modules$three$build$three.default.CubicBezierCurve.prototype = Object.create(module$node_modules$three$build$three.default.Curve.prototype);
module$node_modules$three$build$three.default.CubicBezierCurve.prototype.constructor = module$node_modules$three$build$three.default.CubicBezierCurve;
module$node_modules$three$build$three.default.CubicBezierCurve.prototype.isCubicBezierCurve = !0;
module$node_modules$three$build$three.default.CubicBezierCurve.prototype.getPoint = function(a, b) {
    b = b || new module$node_modules$three$build$three.default.Vector2;
    var c = this.v0,
        d = this.v1,
        e = this.v2,
        f = this.v3;
    b.set(CubicBezier$$module$node_modules$three$build$three(a, c.x, d.x, e.x, f.x), CubicBezier$$module$node_modules$three$build$three(a, c.y, d.y, e.y, f.y));
    return b
};
module$node_modules$three$build$three.default.CubicBezierCurve.prototype.copy = function(a) {
    module$node_modules$three$build$three.default.Curve.prototype.copy.call(this, a);
    this.v0.copy(a.v0);
    this.v1.copy(a.v1);
    this.v2.copy(a.v2);
    this.v3.copy(a.v3);
    return this
};
module$node_modules$three$build$three.default.CubicBezierCurve.prototype.toJSON = function() {
    var a = module$node_modules$three$build$three.default.Curve.prototype.toJSON.call(this);
    a.v0 = this.v0.toArray();
    a.v1 = this.v1.toArray();
    a.v2 = this.v2.toArray();
    a.v3 = this.v3.toArray();
    return a
};
module$node_modules$three$build$three.default.CubicBezierCurve.prototype.fromJSON = function(a) {
    module$node_modules$three$build$three.default.Curve.prototype.fromJSON.call(this, a);
    this.v0.fromArray(a.v0);
    this.v1.fromArray(a.v1);
    this.v2.fromArray(a.v2);
    this.v3.fromArray(a.v3);
    return this
};
module$node_modules$three$build$three.default.CubicBezierCurve3.prototype = Object.create(module$node_modules$three$build$three.default.Curve.prototype);
module$node_modules$three$build$three.default.CubicBezierCurve3.prototype.constructor = module$node_modules$three$build$three.default.CubicBezierCurve3;
module$node_modules$three$build$three.default.CubicBezierCurve3.prototype.isCubicBezierCurve3 = !0;
module$node_modules$three$build$three.default.CubicBezierCurve3.prototype.getPoint = function(a, b) {
    b = b || new module$node_modules$three$build$three.default.Vector3;
    var c = this.v0,
        d = this.v1,
        e = this.v2,
        f = this.v3;
    b.set(CubicBezier$$module$node_modules$three$build$three(a, c.x, d.x, e.x, f.x), CubicBezier$$module$node_modules$three$build$three(a, c.y, d.y, e.y, f.y), CubicBezier$$module$node_modules$three$build$three(a, c.z, d.z, e.z, f.z));
    return b
};
module$node_modules$three$build$three.default.CubicBezierCurve3.prototype.copy = function(a) {
    module$node_modules$three$build$three.default.Curve.prototype.copy.call(this, a);
    this.v0.copy(a.v0);
    this.v1.copy(a.v1);
    this.v2.copy(a.v2);
    this.v3.copy(a.v3);
    return this
};
module$node_modules$three$build$three.default.CubicBezierCurve3.prototype.toJSON = function() {
    var a = module$node_modules$three$build$three.default.Curve.prototype.toJSON.call(this);
    a.v0 = this.v0.toArray();
    a.v1 = this.v1.toArray();
    a.v2 = this.v2.toArray();
    a.v3 = this.v3.toArray();
    return a
};
module$node_modules$three$build$three.default.CubicBezierCurve3.prototype.fromJSON = function(a) {
    module$node_modules$three$build$three.default.Curve.prototype.fromJSON.call(this, a);
    this.v0.fromArray(a.v0);
    this.v1.fromArray(a.v1);
    this.v2.fromArray(a.v2);
    this.v3.fromArray(a.v3);
    return this
};
module$node_modules$three$build$three.default.LineCurve.prototype = Object.create(module$node_modules$three$build$three.default.Curve.prototype);
module$node_modules$three$build$three.default.LineCurve.prototype.constructor = module$node_modules$three$build$three.default.LineCurve;
module$node_modules$three$build$three.default.LineCurve.prototype.isLineCurve = !0;
module$node_modules$three$build$three.default.LineCurve.prototype.getPoint = function(a, b) {
    b = b || new module$node_modules$three$build$three.default.Vector2;
    1 === a ? b.copy(this.v2) : (b.copy(this.v2).sub(this.v1), b.multiplyScalar(a).add(this.v1));
    return b
};
module$node_modules$three$build$three.default.LineCurve.prototype.getPointAt = function(a, b) {
    return this.getPoint(a, b)
};
module$node_modules$three$build$three.default.LineCurve.prototype.getTangent = function() {
    return this.v2.clone().sub(this.v1).normalize()
};
module$node_modules$three$build$three.default.LineCurve.prototype.copy = function(a) {
    module$node_modules$three$build$three.default.Curve.prototype.copy.call(this, a);
    this.v1.copy(a.v1);
    this.v2.copy(a.v2);
    return this
};
module$node_modules$three$build$three.default.LineCurve.prototype.toJSON = function() {
    var a = module$node_modules$three$build$three.default.Curve.prototype.toJSON.call(this);
    a.v1 = this.v1.toArray();
    a.v2 = this.v2.toArray();
    return a
};
module$node_modules$three$build$three.default.LineCurve.prototype.fromJSON = function(a) {
    module$node_modules$three$build$three.default.Curve.prototype.fromJSON.call(this, a);
    this.v1.fromArray(a.v1);
    this.v2.fromArray(a.v2);
    return this
};
module$node_modules$three$build$three.default.LineCurve3.prototype = Object.create(module$node_modules$three$build$three.default.Curve.prototype);
module$node_modules$three$build$three.default.LineCurve3.prototype.constructor = module$node_modules$three$build$three.default.LineCurve3;
module$node_modules$three$build$three.default.LineCurve3.prototype.isLineCurve3 = !0;
module$node_modules$three$build$three.default.LineCurve3.prototype.getPoint = function(a, b) {
    b = b || new module$node_modules$three$build$three.default.Vector3;
    1 === a ? b.copy(this.v2) : (b.copy(this.v2).sub(this.v1), b.multiplyScalar(a).add(this.v1));
    return b
};
module$node_modules$three$build$three.default.LineCurve3.prototype.getPointAt = function(a, b) {
    return this.getPoint(a, b)
};
module$node_modules$three$build$three.default.LineCurve3.prototype.copy = function(a) {
    module$node_modules$three$build$three.default.Curve.prototype.copy.call(this, a);
    this.v1.copy(a.v1);
    this.v2.copy(a.v2);
    return this
};
module$node_modules$three$build$three.default.LineCurve3.prototype.toJSON = function() {
    var a = module$node_modules$three$build$three.default.Curve.prototype.toJSON.call(this);
    a.v1 = this.v1.toArray();
    a.v2 = this.v2.toArray();
    return a
};
module$node_modules$three$build$three.default.LineCurve3.prototype.fromJSON = function(a) {
    module$node_modules$three$build$three.default.Curve.prototype.fromJSON.call(this, a);
    this.v1.fromArray(a.v1);
    this.v2.fromArray(a.v2);
    return this
};
module$node_modules$three$build$three.default.QuadraticBezierCurve.prototype = Object.create(module$node_modules$three$build$three.default.Curve.prototype);
module$node_modules$three$build$three.default.QuadraticBezierCurve.prototype.constructor = module$node_modules$three$build$three.default.QuadraticBezierCurve;
module$node_modules$three$build$three.default.QuadraticBezierCurve.prototype.isQuadraticBezierCurve = !0;
module$node_modules$three$build$three.default.QuadraticBezierCurve.prototype.getPoint = function(a, b) {
    b = b || new module$node_modules$three$build$three.default.Vector2;
    var c = this.v0,
        d = this.v1,
        e = this.v2;
    b.set(QuadraticBezier$$module$node_modules$three$build$three(a, c.x, d.x, e.x), QuadraticBezier$$module$node_modules$three$build$three(a, c.y, d.y, e.y));
    return b
};
module$node_modules$three$build$three.default.QuadraticBezierCurve.prototype.copy = function(a) {
    module$node_modules$three$build$three.default.Curve.prototype.copy.call(this, a);
    this.v0.copy(a.v0);
    this.v1.copy(a.v1);
    this.v2.copy(a.v2);
    return this
};
module$node_modules$three$build$three.default.QuadraticBezierCurve.prototype.toJSON = function() {
    var a = module$node_modules$three$build$three.default.Curve.prototype.toJSON.call(this);
    a.v0 = this.v0.toArray();
    a.v1 = this.v1.toArray();
    a.v2 = this.v2.toArray();
    return a
};
module$node_modules$three$build$three.default.QuadraticBezierCurve.prototype.fromJSON = function(a) {
    module$node_modules$three$build$three.default.Curve.prototype.fromJSON.call(this, a);
    this.v0.fromArray(a.v0);
    this.v1.fromArray(a.v1);
    this.v2.fromArray(a.v2);
    return this
};
module$node_modules$three$build$three.default.QuadraticBezierCurve3.prototype = Object.create(module$node_modules$three$build$three.default.Curve.prototype);
module$node_modules$three$build$three.default.QuadraticBezierCurve3.prototype.constructor = module$node_modules$three$build$three.default.QuadraticBezierCurve3;
module$node_modules$three$build$three.default.QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = !0;
module$node_modules$three$build$three.default.QuadraticBezierCurve3.prototype.getPoint = function(a, b) {
    b = b || new module$node_modules$three$build$three.default.Vector3;
    var c = this.v0,
        d = this.v1,
        e = this.v2;
    b.set(QuadraticBezier$$module$node_modules$three$build$three(a, c.x, d.x, e.x), QuadraticBezier$$module$node_modules$three$build$three(a, c.y, d.y, e.y), QuadraticBezier$$module$node_modules$three$build$three(a, c.z, d.z, e.z));
    return b
};
module$node_modules$three$build$three.default.QuadraticBezierCurve3.prototype.copy = function(a) {
    module$node_modules$three$build$three.default.Curve.prototype.copy.call(this, a);
    this.v0.copy(a.v0);
    this.v1.copy(a.v1);
    this.v2.copy(a.v2);
    return this
};
module$node_modules$three$build$three.default.QuadraticBezierCurve3.prototype.toJSON = function() {
    var a = module$node_modules$three$build$three.default.Curve.prototype.toJSON.call(this);
    a.v0 = this.v0.toArray();
    a.v1 = this.v1.toArray();
    a.v2 = this.v2.toArray();
    return a
};
module$node_modules$three$build$three.default.QuadraticBezierCurve3.prototype.fromJSON = function(a) {
    module$node_modules$three$build$three.default.Curve.prototype.fromJSON.call(this, a);
    this.v0.fromArray(a.v0);
    this.v1.fromArray(a.v1);
    this.v2.fromArray(a.v2);
    return this
};
module$node_modules$three$build$three.default.SplineCurve.prototype = Object.create(module$node_modules$three$build$three.default.Curve.prototype);
module$node_modules$three$build$three.default.SplineCurve.prototype.constructor = module$node_modules$three$build$three.default.SplineCurve;
module$node_modules$three$build$three.default.SplineCurve.prototype.isSplineCurve = !0;
module$node_modules$three$build$three.default.SplineCurve.prototype.getPoint = function(a, b) {
    b = b || new module$node_modules$three$build$three.default.Vector2;
    var c = this.points,
        d = (c.length - 1) * a;
    a = Math.floor(d);
    d -= a;
    var e = c[0 === a ? a : a - 1],
        f = c[a],
        g = c[a > c.length - 2 ? c.length - 1 : a + 1];
    c = c[a > c.length - 3 ? c.length - 1 : a + 2];
    b.set(CatmullRom$$module$node_modules$three$build$three(d, e.x, f.x, g.x, c.x), CatmullRom$$module$node_modules$three$build$three(d, e.y, f.y, g.y, c.y));
    return b
};
module$node_modules$three$build$three.default.SplineCurve.prototype.copy = function(a) {
    module$node_modules$three$build$three.default.Curve.prototype.copy.call(this, a);
    this.points = [];
    for (var b = 0, c = a.points.length; b < c; b++) this.points.push(a.points[b].clone());
    return this
};
module$node_modules$three$build$three.default.SplineCurve.prototype.toJSON = function() {
    var a = module$node_modules$three$build$three.default.Curve.prototype.toJSON.call(this);
    a.points = [];
    for (var b = 0, c = this.points.length; b < c; b++) a.points.push(this.points[b].toArray());
    return a
};
module$node_modules$three$build$three.default.SplineCurve.prototype.fromJSON = function(a) {
    module$node_modules$three$build$three.default.Curve.prototype.fromJSON.call(this, a);
    this.points = [];
    for (var b = 0, c = a.points.length; b < c; b++) {
        var d = a.points[b];
        this.points.push((new module$node_modules$three$build$three.default.Vector2).fromArray(d))
    }
    return this
};
var Curves$$module$node_modules$three$build$three = Object.freeze({
    ArcCurve: module$node_modules$three$build$three.default.ArcCurve,
    CatmullRomCurve3: module$node_modules$three$build$three.default.CatmullRomCurve3,
    CubicBezierCurve: module$node_modules$three$build$three.default.CubicBezierCurve,
    CubicBezierCurve3: module$node_modules$three$build$three.default.CubicBezierCurve3,
    EllipseCurve: module$node_modules$three$build$three.default.EllipseCurve,
    LineCurve: module$node_modules$three$build$three.default.LineCurve,
    LineCurve3: module$node_modules$three$build$three.default.LineCurve3,
    QuadraticBezierCurve: module$node_modules$three$build$three.default.QuadraticBezierCurve,
    QuadraticBezierCurve3: module$node_modules$three$build$three.default.QuadraticBezierCurve3,
    SplineCurve: module$node_modules$three$build$three.default.SplineCurve
});
module$node_modules$three$build$three.default.CurvePath.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.Curve.prototype), {
    constructor: module$node_modules$three$build$three.default.CurvePath,
    add: function(a) {
        this.curves.push(a)
    },
    closePath: function() {
        var a = this.curves[0].getPoint(0),
            b = this.curves[this.curves.length - 1].getPoint(1);
        a.equals(b) || this.curves.push(new module$node_modules$three$build$three.default.LineCurve(b, a))
    },
    getPoint: function(a) {
        var b = a * this.getLength(),
            c = this.getCurveLengths();
        for (a = 0; a < c.length;) {
            if (c[a] >= b) return b = c[a] - b, a = this.curves[a], c = a.getLength(), a.getPointAt(0 === c ? 0 : 1 - b / c);
            a++
        }
        return null
    },
    getLength: function() {
        var a = this.getCurveLengths();
        return a[a.length - 1]
    },
    updateArcLengths: function() {
        this.needsUpdate = !0;
        this.cacheLengths = null;
        this.getCurveLengths()
    },
    getCurveLengths: function() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
        for (var a = [], b = 0, c = 0, d = this.curves.length; c < d; c++) b += this.curves[c].getLength(),
            a.push(b);
        return this.cacheLengths = a
    },
    getSpacedPoints: function(a) {
        void 0 === a && (a = 40);
        for (var b = [], c = 0; c <= a; c++) b.push(this.getPoint(c / a));
        this.autoClose && b.push(b[0]);
        return b
    },
    getPoints: function(a) {
        a = a || 12;
        for (var b = [], c, d = 0, e = this.curves; d < e.length; d++) {
            var f = e[d];
            f = f.getPoints(f && f.isEllipseCurve ? 2 * a : f && (f.isLineCurve || f.isLineCurve3) ? 1 : f && f.isSplineCurve ? a * f.points.length : a);
            for (var g = 0; g < f.length; g++) {
                var h = f[g];
                c && c.equals(h) || (b.push(h), c = h)
            }
        }
        this.autoClose && 1 < b.length && !b[b.length - 1].equals(b[0]) &&
            b.push(b[0]);
        return b
    },
    copy: function(a) {
        module$node_modules$three$build$three.default.Curve.prototype.copy.call(this, a);
        this.curves = [];
        for (var b = 0, c = a.curves.length; b < c; b++) this.curves.push(a.curves[b].clone());
        this.autoClose = a.autoClose;
        return this
    },
    toJSON: function() {
        var a = module$node_modules$three$build$three.default.Curve.prototype.toJSON.call(this);
        a.autoClose = this.autoClose;
        a.curves = [];
        for (var b = 0, c = this.curves.length; b < c; b++) a.curves.push(this.curves[b].toJSON());
        return a
    },
    fromJSON: function(a) {
        module$node_modules$three$build$three.default.Curve.prototype.fromJSON.call(this,
            a);
        this.autoClose = a.autoClose;
        this.curves = [];
        for (var b = 0, c = a.curves.length; b < c; b++) {
            var d = a.curves[b];
            this.curves.push((new Curves$$module$node_modules$three$build$three[d.type]).fromJSON(d))
        }
        return this
    }
});
module$node_modules$three$build$three.default.Path.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.CurvePath.prototype), {
    constructor: module$node_modules$three$build$three.default.Path,
    setFromPoints: function(a) {
        this.moveTo(a[0].x, a[0].y);
        for (var b = 1, c = a.length; b < c; b++) this.lineTo(a[b].x, a[b].y)
    },
    moveTo: function(a, b) {
        this.currentPoint.set(a, b)
    },
    lineTo: function(a, b) {
        var c = new module$node_modules$three$build$three.default.LineCurve(this.currentPoint.clone(), new module$node_modules$three$build$three.default.Vector2(a,
            b));
        this.curves.push(c);
        this.currentPoint.set(a, b)
    },
    quadraticCurveTo: function(a, b, c, d) {
        a = new module$node_modules$three$build$three.default.QuadraticBezierCurve(this.currentPoint.clone(), new module$node_modules$three$build$three.default.Vector2(a, b), new module$node_modules$three$build$three.default.Vector2(c, d));
        this.curves.push(a);
        this.currentPoint.set(c, d)
    },
    bezierCurveTo: function(a, b, c, d, e, f) {
        a = new module$node_modules$three$build$three.default.CubicBezierCurve(this.currentPoint.clone(), new module$node_modules$three$build$three.default.Vector2(a,
            b), new module$node_modules$three$build$three.default.Vector2(c, d), new module$node_modules$three$build$three.default.Vector2(e, f));
        this.curves.push(a);
        this.currentPoint.set(e, f)
    },
    splineThru: function(a) {
        var b = [this.currentPoint.clone()].concat(a);
        b = new module$node_modules$three$build$three.default.SplineCurve(b);
        this.curves.push(b);
        this.currentPoint.copy(a[a.length - 1])
    },
    arc: function(a, b, c, d, e, f) {
        this.absarc(a + this.currentPoint.x, b + this.currentPoint.y, c, d, e, f)
    },
    absarc: function(a, b, c, d, e, f) {
        this.absellipse(a,
            b, c, c, d, e, f)
    },
    ellipse: function(a, b, c, d, e, f, g, h) {
        this.absellipse(a + this.currentPoint.x, b + this.currentPoint.y, c, d, e, f, g, h)
    },
    absellipse: function(a, b, c, d, e, f, g, h) {
        a = new module$node_modules$three$build$three.default.EllipseCurve(a, b, c, d, e, f, g, h);
        0 < this.curves.length && (b = a.getPoint(0), b.equals(this.currentPoint) || this.lineTo(b.x, b.y));
        this.curves.push(a);
        a = a.getPoint(1);
        this.currentPoint.copy(a)
    },
    copy: function(a) {
        module$node_modules$three$build$three.default.CurvePath.prototype.copy.call(this, a);
        this.currentPoint.copy(a.currentPoint);
        return this
    },
    toJSON: function() {
        var a = module$node_modules$three$build$three.default.CurvePath.prototype.toJSON.call(this);
        a.currentPoint = this.currentPoint.toArray();
        return a
    },
    fromJSON: function(a) {
        module$node_modules$three$build$three.default.CurvePath.prototype.fromJSON.call(this, a);
        this.currentPoint.fromArray(a.currentPoint);
        return this
    }
});
module$node_modules$three$build$three.default.Shape.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.Path.prototype), {
    constructor: module$node_modules$three$build$three.default.Shape,
    getPointsHoles: function(a) {
        for (var b = [], c = 0, d = this.holes.length; c < d; c++) b[c] = this.holes[c].getPoints(a);
        return b
    },
    extractPoints: function(a) {
        return {
            shape: this.getPoints(a),
            holes: this.getPointsHoles(a)
        }
    },
    copy: function(a) {
        module$node_modules$three$build$three.default.Path.prototype.copy.call(this,
            a);
        this.holes = [];
        for (var b = 0, c = a.holes.length; b < c; b++) this.holes.push(a.holes[b].clone());
        return this
    },
    toJSON: function() {
        var a = module$node_modules$three$build$three.default.Path.prototype.toJSON.call(this);
        a.uuid = this.uuid;
        a.holes = [];
        for (var b = 0, c = this.holes.length; b < c; b++) a.holes.push(this.holes[b].toJSON());
        return a
    },
    fromJSON: function(a) {
        module$node_modules$three$build$three.default.Path.prototype.fromJSON.call(this, a);
        this.uuid = a.uuid;
        this.holes = [];
        for (var b = 0, c = a.holes.length; b < c; b++) {
            var d = a.holes[b];
            this.holes.push((new module$node_modules$three$build$three.default.Path).fromJSON(d))
        }
        return this
    }
});
module$node_modules$three$build$three.default.Light.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.Object3D.prototype), {
    constructor: module$node_modules$three$build$three.default.Light,
    isLight: !0,
    copy: function(a) {
        module$node_modules$three$build$three.default.Object3D.prototype.copy.call(this, a);
        this.color.copy(a.color);
        this.intensity = a.intensity;
        return this
    },
    toJSON: function(a) {
        a = module$node_modules$three$build$three.default.Object3D.prototype.toJSON.call(this, a);
        a.object.color = this.color.getHex();
        a.object.intensity = this.intensity;
        void 0 !== this.groundColor && (a.object.groundColor = this.groundColor.getHex());
        void 0 !== this.distance && (a.object.distance = this.distance);
        void 0 !== this.angle && (a.object.angle = this.angle);
        void 0 !== this.decay && (a.object.decay = this.decay);
        void 0 !== this.penumbra && (a.object.penumbra = this.penumbra);
        void 0 !== this.shadow && (a.object.shadow = this.shadow.toJSON());
        return a
    }
});
module$node_modules$three$build$three.default.HemisphereLight.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.Light.prototype), {
    constructor: module$node_modules$three$build$three.default.HemisphereLight,
    isHemisphereLight: !0,
    copy: function(a) {
        module$node_modules$three$build$three.default.Light.prototype.copy.call(this, a);
        this.groundColor.copy(a.groundColor);
        return this
    }
});
Object.assign(module$node_modules$three$build$three.default.LightShadow.prototype, {
    copy: function(a) {
        this.camera = a.camera.clone();
        this.bias = a.bias;
        this.radius = a.radius;
        this.mapSize.copy(a.mapSize);
        return this
    },
    clone: function() {
        return (new this.constructor).copy(this)
    },
    toJSON: function() {
        var a = {};
        0 !== this.bias && (a.bias = this.bias);
        1 !== this.radius && (a.radius = this.radius);
        if (512 !== this.mapSize.x || 512 !== this.mapSize.y) a.mapSize = this.mapSize.toArray();
        a.camera = this.camera.toJSON(!1).object;
        delete a.camera.matrix;
        return a
    }
});
module$node_modules$three$build$three.default.SpotLightShadow.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.LightShadow.prototype), {
    constructor: module$node_modules$three$build$three.default.SpotLightShadow,
    isSpotLightShadow: !0,
    update: function(a) {
        var b = this.camera,
            c = 2 * module$node_modules$three$build$three.default.Math.RAD2DEG * a.angle,
            d = this.mapSize.width / this.mapSize.height;
        a = a.distance || b.far;
        if (c !== b.fov || d !== b.aspect || a !== b.far) b.fov = c, b.aspect = d, b.far = a, b.updateProjectionMatrix()
    }
});
module$node_modules$three$build$three.default.SpotLight.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.Light.prototype), {
    constructor: module$node_modules$three$build$three.default.SpotLight,
    isSpotLight: !0,
    copy: function(a) {
        module$node_modules$three$build$three.default.Light.prototype.copy.call(this, a);
        this.distance = a.distance;
        this.angle = a.angle;
        this.penumbra = a.penumbra;
        this.decay = a.decay;
        this.target = a.target.clone();
        this.shadow = a.shadow.clone();
        return this
    }
});
module$node_modules$three$build$three.default.PointLight.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.Light.prototype), {
    constructor: module$node_modules$three$build$three.default.PointLight,
    isPointLight: !0,
    copy: function(a) {
        module$node_modules$three$build$three.default.Light.prototype.copy.call(this, a);
        this.distance = a.distance;
        this.decay = a.decay;
        this.shadow = a.shadow.clone();
        return this
    }
});
module$node_modules$three$build$three.default.DirectionalLightShadow.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.LightShadow.prototype), {
    constructor: module$node_modules$three$build$three.default.DirectionalLightShadow
});
module$node_modules$three$build$three.default.DirectionalLight.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.Light.prototype), {
    constructor: module$node_modules$three$build$three.default.DirectionalLight,
    isDirectionalLight: !0,
    copy: function(a) {
        module$node_modules$three$build$three.default.Light.prototype.copy.call(this, a);
        this.target = a.target.clone();
        this.shadow = a.shadow.clone();
        return this
    }
});
module$node_modules$three$build$three.default.AmbientLight.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.Light.prototype), {
    constructor: module$node_modules$three$build$three.default.AmbientLight,
    isAmbientLight: !0
});
module$node_modules$three$build$three.default.RectAreaLight.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.Light.prototype), {
    constructor: module$node_modules$three$build$three.default.RectAreaLight,
    isRectAreaLight: !0,
    copy: function(a) {
        module$node_modules$three$build$three.default.Light.prototype.copy.call(this, a);
        this.width = a.width;
        this.height = a.height;
        return this
    },
    toJSON: function(a) {
        a = module$node_modules$three$build$three.default.Light.prototype.toJSON.call(this,
            a);
        a.object.width = this.width;
        a.object.height = this.height;
        return a
    }
});
module$node_modules$three$build$three.default.AnimationUtils = {
    arraySlice: function(a, b, c) {
        return module$node_modules$three$build$three.default.AnimationUtils.isTypedArray(a) ? new a.constructor(a.subarray(b, void 0 !== c ? c : a.length)) : a.slice(b, c)
    },
    convertArray: function(a, b, c) {
        return !a || !c && a.constructor === b ? a : "number" === typeof b.BYTES_PER_ELEMENT ? new b(a) : Array.prototype.slice.call(a)
    },
    isTypedArray: function(a) {
        return ArrayBuffer.isView(a) && !(a instanceof DataView)
    },
    getKeyframeOrder: function(a) {
        for (var b =
                a.length, c = Array(b), d = 0; d !== b; ++d) c[d] = d;
        c.sort(function(b, c) {
            return a[b] - a[c]
        });
        return c
    },
    sortedArray: function(a, b, c) {
        for (var d = a.length, e = new a.constructor(d), f = 0, g = 0; g !== d; ++f)
            for (var h = c[f] * b, k = 0; k !== b; ++k) e[g++] = a[h + k];
        return e
    },
    flattenJSON: function(a, b, c, d) {
        for (var e = 1, f = a[0]; void 0 !== f && void 0 === f[d];) f = a[e++];
        if (void 0 !== f) {
            var g = f[d];
            if (void 0 !== g)
                if (Array.isArray(g)) {
                    do g = f[d], void 0 !== g && (b.push(f.time), c.push.apply(c, g)), f = a[e++]; while (void 0 !== f)
                } else if (void 0 !== g.toArray) {
                do g = f[d],
                    void 0 !== g && (b.push(f.time), g.toArray(c, c.length)), f = a[e++]; while (void 0 !== f)
            } else {
                do g = f[d], void 0 !== g && (b.push(f.time), c.push(g)), f = a[e++]; while (void 0 !== f)
            }
        }
    }
};
Object.assign(module$node_modules$three$build$three.default.Interpolant.prototype, {
    evaluate: function(a) {
        var b = this.parameterPositions,
            c = this._cachedIndex,
            d = b[c],
            e = b[c - 1];
        a: {
            b: {
                c: {
                    d: if (!(a < d)) {
                        for (var f = c + 2;;) {
                            if (void 0 === d) {
                                if (a < e) break d;
                                this._cachedIndex = c = b.length;
                                return this.afterEnd_(c - 1, a, e)
                            }
                            if (c === f) break;
                            e = d;
                            d = b[++c];
                            if (a < d) break b
                        }
                        d = b.length;
                        break c
                    }if (a >= e) break a;
                    else {
                        f = b[1];
                        a < f && (c = 2, e = f);
                        for (f = c - 2;;) {
                            if (void 0 === e) return this._cachedIndex = 0, this.beforeStart_(0, a, d);
                            if (c === f) break;
                            d = e;
                            e = b[--c - 1];
                            if (a >= e) break b
                        }
                        d = c;
                        c = 0
                    }
                }
                for (; c < d;) e = c + d >>> 1,
                a < b[e] ? d = e : c = e + 1;d = b[c];e = b[c - 1];
                if (void 0 === e) return this._cachedIndex = 0, this.beforeStart_(0, a, d);
                if (void 0 === d) return this._cachedIndex = c = b.length, this.afterEnd_(c - 1, e, a)
            }
            this._cachedIndex = c;this.intervalChanged_(c, e, d)
        }
        return this.interpolate_(c, e, a, d)
    },
    settings: null,
    DefaultSettings_: {},
    getSettings_: function() {
        return this.settings || this.DefaultSettings_
    },
    copySampleValue_: function(a) {
        var b = this.resultBuffer,
            c = this.sampleValues,
            d = this.valueSize;
        a *= d;
        for (var e = 0; e !== d; ++e) b[e] = c[a + e];
        return b
    },
    interpolate_: function() {
        throw Error("call to abstract method");
    },
    intervalChanged_: function() {}
});
Object.assign(module$node_modules$three$build$three.default.Interpolant.prototype, {
    beforeStart_: module$node_modules$three$build$three.default.Interpolant.prototype.copySampleValue_,
    afterEnd_: module$node_modules$three$build$three.default.Interpolant.prototype.copySampleValue_
});
module$node_modules$three$build$three.default.CubicInterpolant.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.Interpolant.prototype), {
    constructor: module$node_modules$three$build$three.default.CubicInterpolant,
    DefaultSettings_: {
        endingStart: module$node_modules$three$build$three.default.ZeroCurvatureEnding,
        endingEnd: module$node_modules$three$build$three.default.ZeroCurvatureEnding
    },
    intervalChanged_: function(a, b, c) {
        var d = this.parameterPositions,
            e = a - 2,
            f = a + 1,
            g = d[e],
            h = d[f];
        if (void 0 === g) switch (this.getSettings_().endingStart) {
            case module$node_modules$three$build$three.default.ZeroSlopeEnding:
                e = a;
                g = 2 * b - c;
                break;
            case module$node_modules$three$build$three.default.WrapAroundEnding:
                e = d.length - 2;
                g = b + d[e] - d[e + 1];
                break;
            default:
                e = a, g = c
        }
        if (void 0 === h) switch (this.getSettings_().endingEnd) {
            case module$node_modules$three$build$three.default.ZeroSlopeEnding:
                f = a;
                h = 2 * c - b;
                break;
            case module$node_modules$three$build$three.default.WrapAroundEnding:
                f = 1;
                h = c + d[1] - d[0];
                break;
            default:
                f =
                    a - 1, h = b
        }
        a = .5 * (c - b);
        d = this.valueSize;
        this._weightPrev = a / (b - g);
        this._weightNext = a / (h - c);
        this._offsetPrev = e * d;
        this._offsetNext = f * d
    },
    interpolate_: function(a, b, c, d) {
        var e = this.resultBuffer,
            f = this.sampleValues,
            g = this.valueSize;
        a *= g;
        var h = a - g,
            k = this._offsetPrev,
            l = this._offsetNext,
            p = this._weightPrev,
            m = this._weightNext,
            q = (c - b) / (d - b);
        c = q * q;
        d = c * q;
        b = -p * d + 2 * p * c - p * q;
        p = (1 + p) * d + (-1.5 - 2 * p) * c + (-.5 + p) * q + 1;
        q = (-1 - m) * d + (1.5 + m) * c + .5 * q;
        m = m * d - m * c;
        for (c = 0; c !== g; ++c) e[c] = b * f[k + c] + p * f[h + c] + q * f[a + c] + m * f[l + c];
        return e
    }
});
module$node_modules$three$build$three.default.LinearInterpolant.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.Interpolant.prototype), {
    constructor: module$node_modules$three$build$three.default.LinearInterpolant,
    interpolate_: function(a, b, c, d) {
        var e = this.resultBuffer,
            f = this.sampleValues,
            g = this.valueSize;
        a *= g;
        var h = a - g;
        b = (c - b) / (d - b);
        c = 1 - b;
        for (d = 0; d !== g; ++d) e[d] = f[h + d] * c + f[a + d] * b;
        return e
    }
});
module$node_modules$three$build$three.default.DiscreteInterpolant.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.Interpolant.prototype), {
    constructor: module$node_modules$three$build$three.default.DiscreteInterpolant,
    interpolate_: function(a) {
        return this.copySampleValue_(a - 1)
    }
});
Object.assign(module$node_modules$three$build$three.default.KeyframeTrack, {
    toJSON: function(a) {
        var b = a.constructor;
        if (void 0 !== b.toJSON) b = b.toJSON(a);
        else {
            b = {
                name: a.name,
                times: module$node_modules$three$build$three.default.AnimationUtils.convertArray(a.times, Array),
                values: module$node_modules$three$build$three.default.AnimationUtils.convertArray(a.values, Array)
            };
            var c = a.getInterpolation();
            c !== a.DefaultInterpolation && (b.interpolation = c)
        }
        b.type = a.ValueTypeName;
        return b
    }
});
Object.assign(module$node_modules$three$build$three.default.KeyframeTrack.prototype, {
    constructor: module$node_modules$three$build$three.default.KeyframeTrack,
    TimeBufferType: Float32Array,
    ValueBufferType: Float32Array,
    DefaultInterpolation: module$node_modules$three$build$three.default.InterpolateLinear,
    InterpolantFactoryMethodDiscrete: function(a) {
        return new module$node_modules$three$build$three.default.DiscreteInterpolant(this.times, this.values, this.getValueSize(), a)
    },
    InterpolantFactoryMethodLinear: function(a) {
        return new module$node_modules$three$build$three.default.LinearInterpolant(this.times,
            this.values, this.getValueSize(), a)
    },
    InterpolantFactoryMethodSmooth: function(a) {
        return new module$node_modules$three$build$three.default.CubicInterpolant(this.times, this.values, this.getValueSize(), a)
    },
    setInterpolation: function(a) {
        switch (a) {
            case module$node_modules$three$build$three.default.InterpolateDiscrete:
                var b = this.InterpolantFactoryMethodDiscrete;
                break;
            case module$node_modules$three$build$three.default.InterpolateLinear:
                b = this.InterpolantFactoryMethodLinear;
                break;
            case module$node_modules$three$build$three.default.InterpolateSmooth:
                b =
                    this.InterpolantFactoryMethodSmooth
        }
        if (void 0 === b) {
            b = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (void 0 === this.createInterpolant)
                if (a !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
                else throw Error(b);
            console.warn("THREE.KeyframeTrack:", b);
            return this
        }
        this.createInterpolant = b;
        return this
    },
    getInterpolation: function() {
        switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
                return module$node_modules$three$build$three.default.InterpolateDiscrete;
            case this.InterpolantFactoryMethodLinear:
                return module$node_modules$three$build$three.default.InterpolateLinear;
            case this.InterpolantFactoryMethodSmooth:
                return module$node_modules$three$build$three.default.InterpolateSmooth
        }
    },
    getValueSize: function() {
        return this.values.length / this.times.length
    },
    shift: function(a) {
        if (0 !== a)
            for (var b = this.times, c = 0, d = b.length; c !== d; ++c) b[c] += a;
        return this
    },
    scale: function(a) {
        if (1 !== a)
            for (var b = this.times, c = 0, d = b.length; c !== d; ++c) b[c] *= a;
        return this
    },
    trim: function(a, b) {
        for (var c =
                this.times, d = c.length, e = 0, f = d - 1; e !== d && c[e] < a;) ++e;
        for (; - 1 !== f && c[f] > b;) --f;
        ++f;
        if (0 !== e || f !== d) e >= f && (f = Math.max(f, 1), e = f - 1), a = this.getValueSize(), this.times = module$node_modules$three$build$three.default.AnimationUtils.arraySlice(c, e, f), this.values = module$node_modules$three$build$three.default.AnimationUtils.arraySlice(this.values, e * a, f * a);
        return this
    },
    validate: function() {
        var a = !0,
            b = this.getValueSize();
        0 !== b - Math.floor(b) && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
            a = !1);
        var c = this.times;
        b = this.values;
        var d = c.length;
        0 === d && (console.error("THREE.KeyframeTrack: Track is empty.", this), a = !1);
        for (var e = null, f = 0; f !== d; f++) {
            var g = c[f];
            if ("number" === typeof g && isNaN(g)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, f, g);
                a = !1;
                break
            }
            if (null !== e && e > g) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, f, g, e);
                a = !1;
                break
            }
            e = g
        }
        if (void 0 !== b && module$node_modules$three$build$three.default.AnimationUtils.isTypedArray(b))
            for (f = 0, c = b.length; f !==
                c; ++f)
                if (d = b[f], isNaN(d)) {
                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, f, d);
                    a = !1;
                    break
                }
        return a
    },
    optimize: function() {
        for (var a = this.times, b = this.values, c = this.getValueSize(), d = this.getInterpolation() === module$node_modules$three$build$three.default.InterpolateSmooth, e = 1, f = a.length - 1, g = 1; g < f; ++g) {
            var h = !1,
                k = a[g];
            if (k !== a[g + 1] && (1 !== g || k !== k[0]))
                if (d) h = !0;
                else {
                    var l = g * c,
                        p = l - c,
                        m = l + c;
                    for (k = 0; k !== c; ++k) {
                        var q = b[l + k];
                        if (q !== b[p + k] || q !== b[m + k]) {
                            h = !0;
                            break
                        }
                    }
                }
            if (h) {
                if (g !== e)
                    for (a[e] =
                        a[g], h = g * c, l = e * c, k = 0; k !== c; ++k) b[l + k] = b[h + k];
                ++e
            }
        }
        if (0 < f) {
            a[e] = a[f];
            h = f * c;
            l = e * c;
            for (k = 0; k !== c; ++k) b[l + k] = b[h + k];
            ++e
        }
        e !== a.length && (this.times = module$node_modules$three$build$three.default.AnimationUtils.arraySlice(a, 0, e), this.values = module$node_modules$three$build$three.default.AnimationUtils.arraySlice(b, 0, e * c));
        return this
    }
});
module$node_modules$three$build$three.default.BooleanKeyframeTrack.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.KeyframeTrack.prototype), {
    constructor: module$node_modules$three$build$three.default.BooleanKeyframeTrack,
    ValueTypeName: "bool",
    ValueBufferType: Array,
    DefaultInterpolation: module$node_modules$three$build$three.default.InterpolateDiscrete,
    InterpolantFactoryMethodLinear: void 0,
    InterpolantFactoryMethodSmooth: void 0
});
module$node_modules$three$build$three.default.ColorKeyframeTrack.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.KeyframeTrack.prototype), {
    constructor: module$node_modules$three$build$three.default.ColorKeyframeTrack,
    ValueTypeName: "color"
});
module$node_modules$three$build$three.default.NumberKeyframeTrack.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.KeyframeTrack.prototype), {
    constructor: module$node_modules$three$build$three.default.NumberKeyframeTrack,
    ValueTypeName: "number"
});
module$node_modules$three$build$three.default.QuaternionLinearInterpolant.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.Interpolant.prototype), {
    constructor: module$node_modules$three$build$three.default.QuaternionLinearInterpolant,
    interpolate_: function(a, b, c, d) {
        var e = this.resultBuffer,
            f = this.sampleValues,
            g = this.valueSize;
        a *= g;
        b = (c - b) / (d - b);
        for (c = a + g; a !== c; a += 4) module$node_modules$three$build$three.default.Quaternion.slerpFlat(e, 0, f, a - g, f, a, b);
        return e
    }
});
module$node_modules$three$build$three.default.QuaternionKeyframeTrack.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.KeyframeTrack.prototype), {
    constructor: module$node_modules$three$build$three.default.QuaternionKeyframeTrack,
    ValueTypeName: "quaternion",
    DefaultInterpolation: module$node_modules$three$build$three.default.InterpolateLinear,
    InterpolantFactoryMethodLinear: function(a) {
        return new module$node_modules$three$build$three.default.QuaternionLinearInterpolant(this.times,
            this.values, this.getValueSize(), a)
    },
    InterpolantFactoryMethodSmooth: void 0
});
module$node_modules$three$build$three.default.StringKeyframeTrack.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.KeyframeTrack.prototype), {
    constructor: module$node_modules$three$build$three.default.StringKeyframeTrack,
    ValueTypeName: "string",
    ValueBufferType: Array,
    DefaultInterpolation: module$node_modules$three$build$three.default.InterpolateDiscrete,
    InterpolantFactoryMethodLinear: void 0,
    InterpolantFactoryMethodSmooth: void 0
});
module$node_modules$three$build$three.default.VectorKeyframeTrack.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.KeyframeTrack.prototype), {
    constructor: module$node_modules$three$build$three.default.VectorKeyframeTrack,
    ValueTypeName: "vector"
});

function getTrackTypeForValueTypeName$$module$node_modules$three$build$three(a) {
    switch (a.toLowerCase()) {
        case "scalar":
        case "double":
        case "float":
        case "number":
        case "integer":
            return module$node_modules$three$build$three.default.NumberKeyframeTrack;
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
            return module$node_modules$three$build$three.default.VectorKeyframeTrack;
        case "color":
            return module$node_modules$three$build$three.default.ColorKeyframeTrack;
        case "quaternion":
            return module$node_modules$three$build$three.default.QuaternionKeyframeTrack;
        case "bool":
        case "boolean":
            return module$node_modules$three$build$three.default.BooleanKeyframeTrack;
        case "string":
            return module$node_modules$three$build$three.default.StringKeyframeTrack
    }
    throw Error("THREE.KeyframeTrack: Unsupported typeName: " + a);
}

function parseKeyframeTrack$$module$node_modules$three$build$three(a) {
    if (void 0 === a.type) throw Error("THREE.KeyframeTrack: track type undefined, can not parse");
    var b = getTrackTypeForValueTypeName$$module$node_modules$three$build$three(a.type);
    if (void 0 === a.times) {
        var c = [],
            d = [];
        module$node_modules$three$build$three.default.AnimationUtils.flattenJSON(a.keys, c, d, "value");
        a.times = c;
        a.values = d
    }
    return void 0 !== b.parse ? b.parse(a) : new b(a.name, a.times, a.values, a.interpolation)
}
Object.assign(module$node_modules$three$build$three.default.AnimationClip, {
    parse: function(a) {
        for (var b = [], c = a.tracks, d = 1 / (a.fps || 1), e = 0, f = c.length; e !== f; ++e) b.push(parseKeyframeTrack$$module$node_modules$three$build$three(c[e]).scale(d));
        return new module$node_modules$three$build$three.default.AnimationClip(a.name, a.duration, b)
    },
    toJSON: function(a) {
        var b = [],
            c = a.tracks;
        a = {
            name: a.name,
            duration: a.duration,
            tracks: b,
            uuid: a.uuid
        };
        for (var d = 0, e = c.length; d !== e; ++d) b.push(module$node_modules$three$build$three.default.KeyframeTrack.toJSON(c[d]));
        return a
    },
    CreateFromMorphTargetSequence: function(a, b, c, d) {
        for (var e = b.length, f = [], g = 0; g < e; g++) {
            var h = [],
                k = [];
            h.push((g + e - 1) % e, g, (g + 1) % e);
            k.push(0, 1, 0);
            var l = module$node_modules$three$build$three.default.AnimationUtils.getKeyframeOrder(h);
            h = module$node_modules$three$build$three.default.AnimationUtils.sortedArray(h, 1, l);
            k = module$node_modules$three$build$three.default.AnimationUtils.sortedArray(k, 1, l);
            d || 0 !== h[0] || (h.push(e), k.push(k[0]));
            f.push((new module$node_modules$three$build$three.default.NumberKeyframeTrack(".morphTargetInfluences[" +
                b[g].name + "]", h, k)).scale(1 / c))
        }
        return new module$node_modules$three$build$three.default.AnimationClip(a, -1, f)
    },
    findByName: function(a, b) {
        var c = a;
        Array.isArray(a) || (c = a.geometry && a.geometry.animations || a.animations);
        for (a = 0; a < c.length; a++)
            if (c[a].name === b) return c[a];
        return null
    },
    CreateClipsFromMorphTargetSequences: function(a, b, c) {
        for (var d = {}, e = /^([\w-]*?)([\d]+)$/, f = 0, g = a.length; f < g; f++) {
            var h = a[f],
                k = h.name.match(e);
            if (k && 1 < k.length) {
                var l = k[1];
                (k = d[l]) || (d[l] = k = []);
                k.push(h)
            }
        }
        a = [];
        for (l in d) a.push(module$node_modules$three$build$three.default.AnimationClip.CreateFromMorphTargetSequence(l,
            d[l], b, c));
        return a
    },
    parseAnimation: function(a, b) {
        if (!a) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
        var c = function(a, b, c, d, e) {
                if (0 !== c.length) {
                    var f = [],
                        g = [];
                    module$node_modules$three$build$three.default.AnimationUtils.flattenJSON(c, f, g, d);
                    0 !== f.length && e.push(new a(b, f, g))
                }
            },
            d = [],
            e = a.name || "default",
            f = a.length || -1,
            g = a.fps || 30;
        a = a.hierarchy || [];
        for (var h = 0; h < a.length; h++) {
            var k = a[h].keys;
            if (k && 0 !== k.length)
                if (k[0].morphTargets) {
                    f = {};
                    for (var l = 0; l < k.length; l++)
                        if (k[l].morphTargets)
                            for (var p =
                                    0; p < k[l].morphTargets.length; p++) f[k[l].morphTargets[p]] = -1;
                    for (var m in f) {
                        var q = [],
                            r = [];
                        for (p = 0; p !== k[l].morphTargets.length; ++p) {
                            var n = k[l];
                            q.push(n.time);
                            r.push(n.morphTarget === m ? 1 : 0)
                        }
                        d.push(new module$node_modules$three$build$three.default.NumberKeyframeTrack(".morphTargetInfluence[" + m + "]", q, r))
                    }
                    f = f.length * (g || 1)
                } else l = ".bones[" + b[h].name + "]", c(module$node_modules$three$build$three.default.VectorKeyframeTrack, l + ".position", k, "pos", d), c(module$node_modules$three$build$three.default.QuaternionKeyframeTrack,
                    l + ".quaternion", k, "rot", d), c(module$node_modules$three$build$three.default.VectorKeyframeTrack, l + ".scale", k, "scl", d)
        }
        return 0 === d.length ? null : new module$node_modules$three$build$three.default.AnimationClip(e, f, d)
    }
});
Object.assign(module$node_modules$three$build$three.default.AnimationClip.prototype, {
    resetDuration: function() {
        for (var a = 0, b = 0, c = this.tracks.length; b !== c; ++b) {
            var d = this.tracks[b];
            a = Math.max(a, d.times[d.times.length - 1])
        }
        this.duration = a;
        return this
    },
    trim: function() {
        for (var a = 0; a < this.tracks.length; a++) this.tracks[a].trim(0, this.duration);
        return this
    },
    validate: function() {
        for (var a = !0, b = 0; b < this.tracks.length; b++) a = a && this.tracks[b].validate();
        return a
    },
    optimize: function() {
        for (var a = 0; a < this.tracks.length; a++) this.tracks[a].optimize();
        return this
    }
});
Object.assign(module$node_modules$three$build$three.default.MaterialLoader.prototype, {
    load: function(a, b, c, d) {
        var e = this;
        (new module$node_modules$three$build$three.default.FileLoader(e.manager)).load(a, function(a) {
            b(e.parse(JSON.parse(a)))
        }, c, d)
    },
    setTextures: function(a) {
        this.textures = a
    },
    parse: function(a) {
        function b(a) {
            void 0 === c[a] && console.warn("THREE.MaterialLoader: Undefined texture", a);
            return c[a]
        }
        var c = this.textures,
            d = new Materials$$module$node_modules$three$build$three[a.type];
        void 0 !== a.uuid &&
            (d.uuid = a.uuid);
        void 0 !== a.name && (d.name = a.name);
        void 0 !== a.color && d.color.setHex(a.color);
        void 0 !== a.roughness && (d.roughness = a.roughness);
        void 0 !== a.metalness && (d.metalness = a.metalness);
        void 0 !== a.emissive && d.emissive.setHex(a.emissive);
        void 0 !== a.specular && d.specular.setHex(a.specular);
        void 0 !== a.shininess && (d.shininess = a.shininess);
        void 0 !== a.clearCoat && (d.clearCoat = a.clearCoat);
        void 0 !== a.clearCoatRoughness && (d.clearCoatRoughness = a.clearCoatRoughness);
        void 0 !== a.uniforms && (d.uniforms = a.uniforms);
        void 0 !== a.vertexShader && (d.vertexShader = a.vertexShader);
        void 0 !== a.fragmentShader && (d.fragmentShader = a.fragmentShader);
        void 0 !== a.vertexColors && (d.vertexColors = a.vertexColors);
        void 0 !== a.fog && (d.fog = a.fog);
        void 0 !== a.flatShading && (d.flatShading = a.flatShading);
        void 0 !== a.blending && (d.blending = a.blending);
        void 0 !== a.side && (d.side = a.side);
        void 0 !== a.opacity && (d.opacity = a.opacity);
        void 0 !== a.transparent && (d.transparent = a.transparent);
        void 0 !== a.alphaTest && (d.alphaTest = a.alphaTest);
        void 0 !== a.depthTest &&
            (d.depthTest = a.depthTest);
        void 0 !== a.depthWrite && (d.depthWrite = a.depthWrite);
        void 0 !== a.colorWrite && (d.colorWrite = a.colorWrite);
        void 0 !== a.wireframe && (d.wireframe = a.wireframe);
        void 0 !== a.wireframeLinewidth && (d.wireframeLinewidth = a.wireframeLinewidth);
        void 0 !== a.wireframeLinecap && (d.wireframeLinecap = a.wireframeLinecap);
        void 0 !== a.wireframeLinejoin && (d.wireframeLinejoin = a.wireframeLinejoin);
        void 0 !== a.rotation && (d.rotation = a.rotation);
        1 !== a.linewidth && (d.linewidth = a.linewidth);
        void 0 !== a.dashSize &&
            (d.dashSize = a.dashSize);
        void 0 !== a.gapSize && (d.gapSize = a.gapSize);
        void 0 !== a.scale && (d.scale = a.scale);
        void 0 !== a.polygonOffset && (d.polygonOffset = a.polygonOffset);
        void 0 !== a.polygonOffsetFactor && (d.polygonOffsetFactor = a.polygonOffsetFactor);
        void 0 !== a.polygonOffsetUnits && (d.polygonOffsetUnits = a.polygonOffsetUnits);
        void 0 !== a.skinning && (d.skinning = a.skinning);
        void 0 !== a.morphTargets && (d.morphTargets = a.morphTargets);
        void 0 !== a.dithering && (d.dithering = a.dithering);
        void 0 !== a.visible && (d.visible = a.visible);
        void 0 !== a.userData && (d.userData = a.userData);
        void 0 !== a.shading && (d.flatShading = 1 === a.shading);
        void 0 !== a.size && (d.size = a.size);
        void 0 !== a.sizeAttenuation && (d.sizeAttenuation = a.sizeAttenuation);
        void 0 !== a.map && (d.map = b(a.map));
        void 0 !== a.alphaMap && (d.alphaMap = b(a.alphaMap), d.transparent = !0);
        void 0 !== a.bumpMap && (d.bumpMap = b(a.bumpMap));
        void 0 !== a.bumpScale && (d.bumpScale = a.bumpScale);
        void 0 !== a.normalMap && (d.normalMap = b(a.normalMap));
        void 0 !== a.normalMapType && (d.normalMapType = a.normalMapType);
        if (void 0 !==
            a.normalScale) {
            var e = a.normalScale;
            !1 === Array.isArray(e) && (e = [e, e]);
            d.normalScale = (new module$node_modules$three$build$three.default.Vector2).fromArray(e)
        }
        void 0 !== a.displacementMap && (d.displacementMap = b(a.displacementMap));
        void 0 !== a.displacementScale && (d.displacementScale = a.displacementScale);
        void 0 !== a.displacementBias && (d.displacementBias = a.displacementBias);
        void 0 !== a.roughnessMap && (d.roughnessMap = b(a.roughnessMap));
        void 0 !== a.metalnessMap && (d.metalnessMap = b(a.metalnessMap));
        void 0 !== a.emissiveMap &&
            (d.emissiveMap = b(a.emissiveMap));
        void 0 !== a.emissiveIntensity && (d.emissiveIntensity = a.emissiveIntensity);
        void 0 !== a.specularMap && (d.specularMap = b(a.specularMap));
        void 0 !== a.envMap && (d.envMap = b(a.envMap));
        void 0 !== a.reflectivity && (d.reflectivity = a.reflectivity);
        void 0 !== a.lightMap && (d.lightMap = b(a.lightMap));
        void 0 !== a.lightMapIntensity && (d.lightMapIntensity = a.lightMapIntensity);
        void 0 !== a.aoMap && (d.aoMap = b(a.aoMap));
        void 0 !== a.aoMapIntensity && (d.aoMapIntensity = a.aoMapIntensity);
        void 0 !== a.gradientMap &&
            (d.gradientMap = b(a.gradientMap));
        return d
    }
});
Object.assign(module$node_modules$three$build$three.default.BufferGeometryLoader.prototype, {
    load: function(a, b, c, d) {
        var e = this;
        (new module$node_modules$three$build$three.default.FileLoader(e.manager)).load(a, function(a) {
            b(e.parse(JSON.parse(a)))
        }, c, d)
    },
    parse: function(a) {
        var b = new module$node_modules$three$build$three.default.BufferGeometry,
            c = a.data.index;
        void 0 !== c && (c = new TYPED_ARRAYS$$module$node_modules$three$build$three[c.type](c.array), b.setIndex(new module$node_modules$three$build$three.default.BufferAttribute(c, 1)));
        var d = a.data.attributes;
        for (f in d) {
            var e = d[f];
            c = new TYPED_ARRAYS$$module$node_modules$three$build$three[e.type](e.array);
            b.addAttribute(f, new module$node_modules$three$build$three.default.BufferAttribute(c, e.itemSize, e.normalized))
        }
        var f = a.data.groups || a.data.drawcalls || a.data.offsets;
        if (void 0 !== f)
            for (c = 0, d = f.length; c !== d; ++c) e = f[c], b.addGroup(e.start, e.count, e.materialIndex);
        a = a.data.boundingSphere;
        void 0 !== a && (f = new module$node_modules$three$build$three.default.Vector3, void 0 !== a.center && f.fromArray(a.center),
            b.boundingSphere = new module$node_modules$three$build$three.default.Sphere(f, a.radius));
        return b
    }
});
var TYPED_ARRAYS$$module$node_modules$three$build$three = {
    Int8Array: Int8Array,
    Uint8Array: Uint8Array,
    Uint8ClampedArray: "undefined" !== typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
    Int16Array: Int16Array,
    Uint16Array: Uint16Array,
    Int32Array: Int32Array,
    Uint32Array: Uint32Array,
    Float32Array: Float32Array,
    Float64Array: Float64Array
};
module$node_modules$three$build$three.default.Loader.Handlers = {
    handlers: [],
    add: function(a, b) {
        this.handlers.push(a, b)
    },
    get: function(a) {
        for (var b = this.handlers, c = 0, d = b.length; c < d; c += 2) {
            var e = b[c + 1];
            if (b[c].test(a)) return e
        }
        return null
    }
};
Object.assign(module$node_modules$three$build$three.default.Loader.prototype, {
    crossOrigin: "anonymous",
    onLoadStart: function() {},
    onLoadProgress: function() {},
    onLoadComplete: function() {},
    initMaterials: function(a, b, c) {
        for (var d = [], e = 0; e < a.length; ++e) d[e] = this.createMaterial(a[e], b, c);
        return d
    },
    createMaterial: function() {
        var a = {
                NoBlending: module$node_modules$three$build$three.default.NoBlending,
                NormalBlending: module$node_modules$three$build$three.default.NormalBlending,
                AdditiveBlending: module$node_modules$three$build$three.default.AdditiveBlending,
                SubtractiveBlending: module$node_modules$three$build$three.default.SubtractiveBlending,
                MultiplyBlending: module$node_modules$three$build$three.default.MultiplyBlending,
                CustomBlending: module$node_modules$three$build$three.default.CustomBlending
            },
            b = new module$node_modules$three$build$three.default.Color,
            c = new module$node_modules$three$build$three.default.TextureLoader,
            d = new module$node_modules$three$build$three.default.MaterialLoader;
        return function(e, f, g) {
            function h(a, b, d, e, h) {
                a = f + a;
                var l = module$node_modules$three$build$three.default.Loader.Handlers.get(a);
                null !== l ? a = l.load(a) : (c.setCrossOrigin(g), a = c.load(a));
                void 0 !== b && (a.repeat.fromArray(b), 1 !== b[0] && (a.wrapS = module$node_modules$three$build$three.default.RepeatWrapping), 1 !== b[1] && (a.wrapT = module$node_modules$three$build$three.default.RepeatWrapping));
                void 0 !== d && a.offset.fromArray(d);
                void 0 !== e && ("repeat" === e[0] && (a.wrapS = module$node_modules$three$build$three.default.RepeatWrapping), "mirror" === e[0] && (a.wrapS = module$node_modules$three$build$three.default.MirroredRepeatWrapping), "repeat" === e[1] &&
                    (a.wrapT = module$node_modules$three$build$three.default.RepeatWrapping), "mirror" === e[1] && (a.wrapT = module$node_modules$three$build$three.default.MirroredRepeatWrapping));
                void 0 !== h && (a.anisotropy = h);
                b = module$node_modules$three$build$three.default.Math.generateUUID();
                k[b] = a;
                return b
            }
            var k = {},
                l = {
                    uuid: module$node_modules$three$build$three.default.Math.generateUUID(),
                    type: "MeshLambertMaterial"
                },
                p;
            for (p in e) {
                var m = e[p];
                switch (p) {
                    case "DbgColor":
                    case "DbgIndex":
                    case "opticalDensity":
                    case "illumination":
                        break;
                    case "DbgName":
                        l.name = m;
                        break;
                    case "blending":
                        l.blending = a[m];
                        break;
                    case "colorAmbient":
                    case "mapAmbient":
                        console.warn("THREE.Loader.createMaterial:", p, "is no longer supported.");
                        break;
                    case "colorDiffuse":
                        l.color = b.fromArray(m).getHex();
                        break;
                    case "colorSpecular":
                        l.specular = b.fromArray(m).getHex();
                        break;
                    case "colorEmissive":
                        l.emissive = b.fromArray(m).getHex();
                        break;
                    case "specularCoef":
                        l.shininess = m;
                        break;
                    case "shading":
                        "basic" === m.toLowerCase() && (l.type = "MeshBasicMaterial");
                        "phong" === m.toLowerCase() &&
                            (l.type = "MeshPhongMaterial");
                        "standard" === m.toLowerCase() && (l.type = "MeshStandardMaterial");
                        break;
                    case "mapDiffuse":
                        l.map = h(m, e.mapDiffuseRepeat, e.mapDiffuseOffset, e.mapDiffuseWrap, e.mapDiffuseAnisotropy);
                        break;
                    case "mapDiffuseRepeat":
                    case "mapDiffuseOffset":
                    case "mapDiffuseWrap":
                    case "mapDiffuseAnisotropy":
                        break;
                    case "mapEmissive":
                        l.emissiveMap = h(m, e.mapEmissiveRepeat, e.mapEmissiveOffset, e.mapEmissiveWrap, e.mapEmissiveAnisotropy);
                        break;
                    case "mapEmissiveRepeat":
                    case "mapEmissiveOffset":
                    case "mapEmissiveWrap":
                    case "mapEmissiveAnisotropy":
                        break;
                    case "mapLight":
                        l.lightMap = h(m, e.mapLightRepeat, e.mapLightOffset, e.mapLightWrap, e.mapLightAnisotropy);
                        break;
                    case "mapLightRepeat":
                    case "mapLightOffset":
                    case "mapLightWrap":
                    case "mapLightAnisotropy":
                        break;
                    case "mapAO":
                        l.aoMap = h(m, e.mapAORepeat, e.mapAOOffset, e.mapAOWrap, e.mapAOAnisotropy);
                        break;
                    case "mapAORepeat":
                    case "mapAOOffset":
                    case "mapAOWrap":
                    case "mapAOAnisotropy":
                        break;
                    case "mapBump":
                        l.bumpMap = h(m, e.mapBumpRepeat, e.mapBumpOffset, e.mapBumpWrap, e.mapBumpAnisotropy);
                        break;
                    case "mapBumpScale":
                        l.bumpScale =
                            m;
                        break;
                    case "mapBumpRepeat":
                    case "mapBumpOffset":
                    case "mapBumpWrap":
                    case "mapBumpAnisotropy":
                        break;
                    case "mapNormal":
                        l.normalMap = h(m, e.mapNormalRepeat, e.mapNormalOffset, e.mapNormalWrap, e.mapNormalAnisotropy);
                        break;
                    case "mapNormalFactor":
                        l.normalScale = m;
                        break;
                    case "mapNormalRepeat":
                    case "mapNormalOffset":
                    case "mapNormalWrap":
                    case "mapNormalAnisotropy":
                        break;
                    case "mapSpecular":
                        l.specularMap = h(m, e.mapSpecularRepeat, e.mapSpecularOffset, e.mapSpecularWrap, e.mapSpecularAnisotropy);
                        break;
                    case "mapSpecularRepeat":
                    case "mapSpecularOffset":
                    case "mapSpecularWrap":
                    case "mapSpecularAnisotropy":
                        break;
                    case "mapMetalness":
                        l.metalnessMap = h(m, e.mapMetalnessRepeat, e.mapMetalnessOffset, e.mapMetalnessWrap, e.mapMetalnessAnisotropy);
                        break;
                    case "mapMetalnessRepeat":
                    case "mapMetalnessOffset":
                    case "mapMetalnessWrap":
                    case "mapMetalnessAnisotropy":
                        break;
                    case "mapRoughness":
                        l.roughnessMap = h(m, e.mapRoughnessRepeat, e.mapRoughnessOffset, e.mapRoughnessWrap, e.mapRoughnessAnisotropy);
                        break;
                    case "mapRoughnessRepeat":
                    case "mapRoughnessOffset":
                    case "mapRoughnessWrap":
                    case "mapRoughnessAnisotropy":
                        break;
                    case "mapAlpha":
                        l.alphaMap =
                            h(m, e.mapAlphaRepeat, e.mapAlphaOffset, e.mapAlphaWrap, e.mapAlphaAnisotropy);
                        break;
                    case "mapAlphaRepeat":
                    case "mapAlphaOffset":
                    case "mapAlphaWrap":
                    case "mapAlphaAnisotropy":
                        break;
                    case "flipSided":
                        l.side = module$node_modules$three$build$three.default.BackSide;
                        break;
                    case "doubleSided":
                        l.side = module$node_modules$three$build$three.default.DoubleSide;
                        break;
                    case "transparency":
                        console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity");
                        l.opacity = m;
                        break;
                    case "depthTest":
                    case "depthWrite":
                    case "colorWrite":
                    case "opacity":
                    case "reflectivity":
                    case "transparent":
                    case "visible":
                    case "wireframe":
                        l[p] =
                            m;
                        break;
                    case "vertexColors":
                        !0 === m && (l.vertexColors = module$node_modules$three$build$three.default.VertexColors);
                        "face" === m && (l.vertexColors = module$node_modules$three$build$three.default.FaceColors);
                        break;
                    default:
                        console.error("THREE.Loader.createMaterial: Unsupported", p, m)
                }
            }
            "MeshBasicMaterial" === l.type && delete l.emissive;
            "MeshPhongMaterial" !== l.type && delete l.specular;
            1 > l.opacity && (l.transparent = !0);
            d.setTextures(k);
            return d.parse(l)
        }
    }()
});
module$node_modules$three$build$three.default.LoaderUtils = {
    decodeText: function(a) {
        if ("undefined" !== typeof TextDecoder) return (new TextDecoder).decode(a);
        for (var b = "", c = 0, d = a.length; c < d; c++) b += String.fromCharCode(a[c]);
        return decodeURIComponent(escape(b))
    },
    extractUrlBase: function(a) {
        var b = a.lastIndexOf("/");
        return -1 === b ? "./" : a.substr(0, b + 1)
    }
};
Object.assign(module$node_modules$three$build$three.default.JSONLoader.prototype, {
    crossOrigin: "anonymous",
    load: function(a, b, c, d) {
        var e = this,
            f = this.texturePath && "string" === typeof this.texturePath ? this.texturePath : module$node_modules$three$build$three.default.LoaderUtils.extractUrlBase(a),
            g = new module$node_modules$three$build$three.default.FileLoader(this.manager);
        g.setWithCredentials(this.withCredentials);
        g.load(a, function(c) {
            c = JSON.parse(c);
            var d = c.metadata;
            if (void 0 !== d && (d = d.type, void 0 !== d && "object" ===
                    d.toLowerCase())) {
                console.error("THREE.JSONLoader: " + a + " should be loaded with THREE.ObjectLoader instead.");
                return
            }
            c = e.parse(c, f);
            b(c.geometry, c.materials)
        }, c, d)
    },
    setCrossOrigin: function(a) {
        this.crossOrigin = a;
        return this
    },
    setTexturePath: function(a) {
        this.texturePath = a;
        return this
    },
    parse: function() {
        return function(a, b) {
            void 0 !== a.data && (a = a.data);
            a.scale = void 0 !== a.scale ? 1 / a.scale : 1;
            var c = new module$node_modules$three$build$three.default.Geometry,
                d = a,
                e, f, g, h = d.faces;
            var k = d.vertices;
            var l = d.normals,
                p = d.colors;
            var m = d.scale;
            var q = 0;
            if (void 0 !== d.uvs) {
                for (e = 0; e < d.uvs.length; e++) d.uvs[e].length && q++;
                for (e = 0; e < q; e++) c.faceVertexUvs[e] = []
            }
            var r = 0;
            for (g = k.length; r < g;) e = new module$node_modules$three$build$three.default.Vector3, e.x = k[r++] * m, e.y = k[r++] * m, e.z = k[r++] * m, c.vertices.push(e);
            r = 0;
            for (g = h.length; r < g;) {
                k = h[r++];
                var n = k & 1;
                var t = k & 2;
                e = k & 8;
                var u = k & 16;
                var w = k & 32;
                m = k & 64;
                k &= 128;
                if (n) {
                    n = new module$node_modules$three$build$three.default.Face3;
                    n.a = h[r];
                    n.b = h[r + 1];
                    n.c = h[r + 3];
                    var v = new module$node_modules$three$build$three.default.Face3;
                    v.a = h[r + 1];
                    v.b = h[r + 2];
                    v.c = h[r + 3];
                    r += 4;
                    t && (t = h[r++], n.materialIndex = t, v.materialIndex = t);
                    t = c.faces.length;
                    if (e)
                        for (e = 0; e < q; e++) {
                            var y = d.uvs[e];
                            c.faceVertexUvs[e][t] = [];
                            c.faceVertexUvs[e][t + 1] = [];
                            for (f = 0; 4 > f; f++) {
                                var A = h[r++];
                                var x = y[2 * A];
                                A = y[2 * A + 1];
                                x = new module$node_modules$three$build$three.default.Vector2(x, A);
                                2 !== f && c.faceVertexUvs[e][t].push(x);
                                0 !== f && c.faceVertexUvs[e][t + 1].push(x)
                            }
                        }
                    u && (u = 3 * h[r++], n.normal.set(l[u++], l[u++], l[u]), v.normal.copy(n.normal));
                    if (w)
                        for (e = 0; 4 > e; e++) u = 3 * h[r++], w = new module$node_modules$three$build$three.default.Vector3(l[u++],
                            l[u++], l[u]), 2 !== e && n.vertexNormals.push(w), 0 !== e && v.vertexNormals.push(w);
                    m && (m = h[r++], m = p[m], n.color.setHex(m), v.color.setHex(m));
                    if (k)
                        for (e = 0; 4 > e; e++) m = h[r++], m = p[m], 2 !== e && n.vertexColors.push(new module$node_modules$three$build$three.default.Color(m)), 0 !== e && v.vertexColors.push(new module$node_modules$three$build$three.default.Color(m));
                    c.faces.push(n);
                    c.faces.push(v)
                } else {
                    n = new module$node_modules$three$build$three.default.Face3;
                    n.a = h[r++];
                    n.b = h[r++];
                    n.c = h[r++];
                    t && (t = h[r++], n.materialIndex = t);
                    t = c.faces.length;
                    if (e)
                        for (e = 0; e < q; e++)
                            for (y = d.uvs[e], c.faceVertexUvs[e][t] = [], f = 0; 3 > f; f++) A = h[r++], x = y[2 * A], A = y[2 * A + 1], x = new module$node_modules$three$build$three.default.Vector2(x, A), c.faceVertexUvs[e][t].push(x);
                    u && (u = 3 * h[r++], n.normal.set(l[u++], l[u++], l[u]));
                    if (w)
                        for (e = 0; 3 > e; e++) u = 3 * h[r++], w = new module$node_modules$three$build$three.default.Vector3(l[u++], l[u++], l[u]), n.vertexNormals.push(w);
                    m && (m = h[r++], n.color.setHex(p[m]));
                    if (k)
                        for (e = 0; 3 > e; e++) m = h[r++], n.vertexColors.push(new module$node_modules$three$build$three.default.Color(p[m]));
                    c.faces.push(n)
                }
            }
            d = a;
            r = void 0 !== d.influencesPerVertex ? d.influencesPerVertex : 2;
            if (d.skinWeights)
                for (g = 0, h = d.skinWeights.length; g < h; g += r) c.skinWeights.push(new module$node_modules$three$build$three.default.Vector4(d.skinWeights[g], 1 < r ? d.skinWeights[g + 1] : 0, 2 < r ? d.skinWeights[g + 2] : 0, 3 < r ? d.skinWeights[g + 3] : 0));
            if (d.skinIndices)
                for (g = 0, h = d.skinIndices.length; g < h; g += r) c.skinIndices.push(new module$node_modules$three$build$three.default.Vector4(d.skinIndices[g], 1 < r ? d.skinIndices[g + 1] : 0, 2 < r ? d.skinIndices[g +
                    2] : 0, 3 < r ? d.skinIndices[g + 3] : 0));
            c.bones = d.bones;
            c.bones && 0 < c.bones.length && (c.skinWeights.length !== c.skinIndices.length || c.skinIndices.length !== c.vertices.length) && console.warn("When skinning, number of vertices (" + c.vertices.length + "), skinIndices (" + c.skinIndices.length + "), and skinWeights (" + c.skinWeights.length + ") should match.");
            g = a;
            h = g.scale;
            if (void 0 !== g.morphTargets)
                for (d = 0, r = g.morphTargets.length; d < r; d++)
                    for (c.morphTargets[d] = {}, c.morphTargets[d].name = g.morphTargets[d].name, c.morphTargets[d].vertices = [], l = c.morphTargets[d].vertices, p = g.morphTargets[d].vertices, q = 0, k = p.length; q < k; q += 3) m = new module$node_modules$three$build$three.default.Vector3, m.x = p[q] * h, m.y = p[q + 1] * h, m.z = p[q + 2] * h, l.push(m);
            if (void 0 !== g.morphColors && 0 < g.morphColors.length)
                for (console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.'), h = c.faces, g = g.morphColors[0].colors, d = 0, r = h.length; d < r; d++) h[d].color.fromArray(g, 3 * d);
            g = a;
            d = [];
            r = [];
            void 0 !== g.animation && r.push(g.animation);
            void 0 !== g.animations &&
                (g.animations.length ? r = r.concat(g.animations) : r.push(g.animations));
            for (g = 0; g < r.length; g++)(h = module$node_modules$three$build$three.default.AnimationClip.parseAnimation(r[g], c.bones)) && d.push(h);
            c.morphTargets && (r = module$node_modules$three$build$three.default.AnimationClip.CreateClipsFromMorphTargetSequences(c.morphTargets, 10), d = d.concat(r));
            0 < d.length && (c.animations = d);
            c.computeFaceNormals();
            c.computeBoundingSphere();
            if (void 0 === a.materials || 0 === a.materials.length) return {
                geometry: c
            };
            a = module$node_modules$three$build$three.default.Loader.prototype.initMaterials(a.materials,
                b, this.crossOrigin);
            return {
                geometry: c,
                materials: a
            }
        }
    }()
});
Object.assign(module$node_modules$three$build$three.default.ObjectLoader.prototype, {
    crossOrigin: "anonymous",
    load: function(a, b, c, d) {
        "" === this.texturePath && (this.texturePath = a.substring(0, a.lastIndexOf("/") + 1));
        var e = this;
        (new module$node_modules$three$build$three.default.FileLoader(e.manager)).load(a, function(c) {
            var f = null;
            try {
                f = JSON.parse(c)
            } catch (h) {
                void 0 !== d && d(h);
                console.error("THREE:ObjectLoader: Can't parse " + a + ".", h.message);
                return
            }
            c = f.metadata;
            void 0 === c || void 0 === c.type || "geometry" === c.type.toLowerCase() ?
                console.error("THREE.ObjectLoader: Can't load " + a + ". Use THREE.JSONLoader instead.") : e.parse(f, b)
        }, c, d)
    },
    setTexturePath: function(a) {
        this.texturePath = a;
        return this
    },
    setCrossOrigin: function(a) {
        this.crossOrigin = a;
        return this
    },
    parse: function(a, b) {
        var c = this.parseShape(a.shapes);
        c = this.parseGeometries(a.geometries, c);
        var d = this.parseImages(a.images, function() {
            void 0 !== b && b(e)
        });
        d = this.parseTextures(a.textures, d);
        d = this.parseMaterials(a.materials, d);
        var e = this.parseObject(a.object, c, d);
        a.animations && (e.animations =
            this.parseAnimations(a.animations));
        void 0 !== a.images && 0 !== a.images.length || void 0 === b || b(e);
        return e
    },
    parseShape: function(a) {
        var b = {};
        if (void 0 !== a)
            for (var c = 0, d = a.length; c < d; c++) {
                var e = (new module$node_modules$three$build$three.default.Shape).fromJSON(a[c]);
                b[e.uuid] = e
            }
        return b
    },
    parseGeometries: function(a, b) {
        var c = {};
        if (void 0 !== a)
            for (var d = new module$node_modules$three$build$three.default.JSONLoader, e = new module$node_modules$three$build$three.default.BufferGeometryLoader, f = 0, g = a.length; f < g; f++) {
                var h =
                    a[f];
                switch (h.type) {
                    case "PlaneGeometry":
                    case "PlaneBufferGeometry":
                        var k = new Geometries$$module$node_modules$three$build$three[h.type](h.width, h.height, h.widthSegments, h.heightSegments);
                        break;
                    case "BoxGeometry":
                    case "BoxBufferGeometry":
                    case "CubeGeometry":
                        k = new Geometries$$module$node_modules$three$build$three[h.type](h.width, h.height, h.depth, h.widthSegments, h.heightSegments, h.depthSegments);
                        break;
                    case "CircleGeometry":
                    case "CircleBufferGeometry":
                        k = new Geometries$$module$node_modules$three$build$three[h.type](h.radius,
                            h.segments, h.thetaStart, h.thetaLength);
                        break;
                    case "CylinderGeometry":
                    case "CylinderBufferGeometry":
                        k = new Geometries$$module$node_modules$three$build$three[h.type](h.radiusTop, h.radiusBottom, h.height, h.radialSegments, h.heightSegments, h.openEnded, h.thetaStart, h.thetaLength);
                        break;
                    case "ConeGeometry":
                    case "ConeBufferGeometry":
                        k = new Geometries$$module$node_modules$three$build$three[h.type](h.radius, h.height, h.radialSegments, h.heightSegments, h.openEnded, h.thetaStart, h.thetaLength);
                        break;
                    case "SphereGeometry":
                    case "SphereBufferGeometry":
                        k =
                            new Geometries$$module$node_modules$three$build$three[h.type](h.radius, h.widthSegments, h.heightSegments, h.phiStart, h.phiLength, h.thetaStart, h.thetaLength);
                        break;
                    case "DodecahedronGeometry":
                    case "DodecahedronBufferGeometry":
                    case "IcosahedronGeometry":
                    case "IcosahedronBufferGeometry":
                    case "OctahedronGeometry":
                    case "OctahedronBufferGeometry":
                    case "TetrahedronGeometry":
                    case "TetrahedronBufferGeometry":
                        k = new Geometries$$module$node_modules$three$build$three[h.type](h.radius, h.detail);
                        break;
                    case "RingGeometry":
                    case "RingBufferGeometry":
                        k =
                            new Geometries$$module$node_modules$three$build$three[h.type](h.innerRadius, h.outerRadius, h.thetaSegments, h.phiSegments, h.thetaStart, h.thetaLength);
                        break;
                    case "TorusGeometry":
                    case "TorusBufferGeometry":
                        k = new Geometries$$module$node_modules$three$build$three[h.type](h.radius, h.tube, h.radialSegments, h.tubularSegments, h.arc);
                        break;
                    case "TorusKnotGeometry":
                    case "TorusKnotBufferGeometry":
                        k = new Geometries$$module$node_modules$three$build$three[h.type](h.radius, h.tube, h.tubularSegments, h.radialSegments,
                            h.p, h.q);
                        break;
                    case "LatheGeometry":
                    case "LatheBufferGeometry":
                        k = new Geometries$$module$node_modules$three$build$three[h.type](h.points, h.segments, h.phiStart, h.phiLength);
                        break;
                    case "PolyhedronGeometry":
                    case "PolyhedronBufferGeometry":
                        k = new Geometries$$module$node_modules$three$build$three[h.type](h.vertices, h.indices, h.radius, h.details);
                        break;
                    case "ShapeGeometry":
                    case "ShapeBufferGeometry":
                        k = [];
                        for (var l = 0, p = h.shapes.length; l < p; l++) {
                            var m = b[h.shapes[l]];
                            k.push(m)
                        }
                        k = new Geometries$$module$node_modules$three$build$three[h.type](k,
                            h.curveSegments);
                        break;
                    case "ExtrudeGeometry":
                    case "ExtrudeBufferGeometry":
                        k = [];
                        l = 0;
                        for (p = h.shapes.length; l < p; l++) m = b[h.shapes[l]], k.push(m);
                        l = h.options.extrudePath;
                        void 0 !== l && (h.options.extrudePath = (new Curves$$module$node_modules$three$build$three[l.type]).fromJSON(l));
                        k = new Geometries$$module$node_modules$three$build$three[h.type](k, h.options);
                        break;
                    case "BufferGeometry":
                        k = e.parse(h);
                        break;
                    case "Geometry":
                        k = d.parse(h, this.texturePath).geometry;
                        break;
                    default:
                        console.warn('THREE.ObjectLoader: Unsupported geometry type "' +
                            h.type + '"');
                        continue
                }
                k.uuid = h.uuid;
                void 0 !== h.name && (k.name = h.name);
                !0 === k.isBufferGeometry && void 0 !== h.userData && (k.userData = h.userData);
                c[h.uuid] = k
            }
        return c
    },
    parseMaterials: function(a, b) {
        var c = {};
        if (void 0 !== a) {
            var d = new module$node_modules$three$build$three.default.MaterialLoader;
            d.setTextures(b);
            b = 0;
            for (var e = a.length; b < e; b++) {
                var f = a[b];
                if ("MultiMaterial" === f.type) {
                    for (var g = [], h = 0; h < f.materials.length; h++) g.push(d.parse(f.materials[h]));
                    c[f.uuid] = g
                } else c[f.uuid] = d.parse(f)
            }
        }
        return c
    },
    parseAnimations: function(a) {
        for (var b = [], c = 0; c < a.length; c++) {
            var d = a[c],
                e = module$node_modules$three$build$three.default.AnimationClip.parse(d);
            void 0 !== d.uuid && (e.uuid = d.uuid);
            b.push(e)
        }
        return b
    },
    parseImages: function(a, b) {
        function c(a) {
            d.manager.itemStart(a);
            return f.load(a, function() {
                d.manager.itemEnd(a)
            }, void 0, function() {
                d.manager.itemEnd(a);
                d.manager.itemError(a)
            })
        }
        var d = this,
            e = {};
        if (void 0 !== a && 0 < a.length) {
            b = new module$node_modules$three$build$three.default.LoadingManager(b);
            var f = new module$node_modules$three$build$three.default.ImageLoader(b);
            f.setCrossOrigin(this.crossOrigin);
            b = 0;
            for (var g = a.length; b < g; b++) {
                var h = a[b],
                    k = h.url;
                if (Array.isArray(k)) {
                    e[h.uuid] = [];
                    for (var l = 0, p = k.length; l < p; l++) {
                        var m = k[l];
                        m = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(m) ? m : d.texturePath + m;
                        e[h.uuid].push(c(m))
                    }
                } else m = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(h.url) ? h.url : d.texturePath + h.url, e[h.uuid] = c(m)
            }
        }
        return e
    },
    parseTextures: function(a, b) {
        function c(a, b) {
            if ("number" === typeof a) return a;
            console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", a);
            return b[a]
        }
        var d = {};
        if (void 0 !== a)
            for (var e = 0, f = a.length; e < f; e++) {
                var g = a[e];
                void 0 === g.image && console.warn('THREE.ObjectLoader: No "image" specified for', g.uuid);
                void 0 === b[g.image] && console.warn("THREE.ObjectLoader: Undefined image", g.image);
                var h = Array.isArray(b[g.image]) ? new module$node_modules$three$build$three.default.CubeTexture(b[g.image]) : new module$node_modules$three$build$three.default.Texture(b[g.image]);
                h.needsUpdate = !0;
                h.uuid = g.uuid;
                void 0 !== g.name && (h.name = g.name);
                void 0 !== g.mapping &&
                    (h.mapping = c(g.mapping, TEXTURE_MAPPING$$module$node_modules$three$build$three));
                void 0 !== g.offset && h.offset.fromArray(g.offset);
                void 0 !== g.repeat && h.repeat.fromArray(g.repeat);
                void 0 !== g.center && h.center.fromArray(g.center);
                void 0 !== g.rotation && (h.rotation = g.rotation);
                void 0 !== g.wrap && (h.wrapS = c(g.wrap[0], TEXTURE_WRAPPING$$module$node_modules$three$build$three), h.wrapT = c(g.wrap[1], TEXTURE_WRAPPING$$module$node_modules$three$build$three));
                void 0 !== g.format && (h.format = g.format);
                void 0 !== g.minFilter &&
                    (h.minFilter = c(g.minFilter, TEXTURE_FILTER$$module$node_modules$three$build$three));
                void 0 !== g.magFilter && (h.magFilter = c(g.magFilter, TEXTURE_FILTER$$module$node_modules$three$build$three));
                void 0 !== g.anisotropy && (h.anisotropy = g.anisotropy);
                void 0 !== g.flipY && (h.flipY = g.flipY);
                d[g.uuid] = h
            }
        return d
    },
    parseObject: function(a, b, c) {
        function d(a) {
            void 0 === b[a] && console.warn("THREE.ObjectLoader: Undefined geometry", a);
            return b[a]
        }

        function e(a) {
            if (void 0 !== a) {
                if (Array.isArray(a)) {
                    for (var b = [], d = 0, e = a.length; d <
                        e; d++) {
                        var f = a[d];
                        void 0 === c[f] && console.warn("THREE.ObjectLoader: Undefined material", f);
                        b.push(c[f])
                    }
                    return b
                }
                void 0 === c[a] && console.warn("THREE.ObjectLoader: Undefined material", a);
                return c[a]
            }
        }
        switch (a.type) {
            case "Scene":
                var f = new module$node_modules$three$build$three.default.Scene;
                void 0 !== a.background && Number.isInteger(a.background) && (f.background = new module$node_modules$three$build$three.default.Color(a.background));
                void 0 !== a.fog && ("Fog" === a.fog.type ? f.fog = new module$node_modules$three$build$three.default.Fog(a.fog.color,
                    a.fog.near, a.fog.far) : "FogExp2" === a.fog.type && (f.fog = new module$node_modules$three$build$three.default.FogExp2(a.fog.color, a.fog.density)));
                break;
            case "PerspectiveCamera":
                f = new module$node_modules$three$build$three.default.PerspectiveCamera(a.fov, a.aspect, a.near, a.far);
                void 0 !== a.focus && (f.focus = a.focus);
                void 0 !== a.zoom && (f.zoom = a.zoom);
                void 0 !== a.filmGauge && (f.filmGauge = a.filmGauge);
                void 0 !== a.filmOffset && (f.filmOffset = a.filmOffset);
                void 0 !== a.view && (f.view = Object.assign({}, a.view));
                break;
            case "OrthographicCamera":
                f =
                    new module$node_modules$three$build$three.default.OrthographicCamera(a.left, a.right, a.top, a.bottom, a.near, a.far);
                void 0 !== a.zoom && (f.zoom = a.zoom);
                void 0 !== a.view && (f.view = Object.assign({}, a.view));
                break;
            case "AmbientLight":
                f = new module$node_modules$three$build$three.default.AmbientLight(a.color, a.intensity);
                break;
            case "DirectionalLight":
                f = new module$node_modules$three$build$three.default.DirectionalLight(a.color, a.intensity);
                break;
            case "PointLight":
                f = new module$node_modules$three$build$three.default.PointLight(a.color,
                    a.intensity, a.distance, a.decay);
                break;
            case "RectAreaLight":
                f = new module$node_modules$three$build$three.default.RectAreaLight(a.color, a.intensity, a.width, a.height);
                break;
            case "SpotLight":
                f = new module$node_modules$three$build$three.default.SpotLight(a.color, a.intensity, a.distance, a.angle, a.penumbra, a.decay);
                break;
            case "HemisphereLight":
                f = new module$node_modules$three$build$three.default.HemisphereLight(a.color, a.groundColor, a.intensity);
                break;
            case "SkinnedMesh":
                console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
            case "Mesh":
                f = d(a.geometry);
                var g = e(a.material);
                f = f.bones && 0 < f.bones.length ? new module$node_modules$three$build$three.default.SkinnedMesh(f, g) : new module$node_modules$three$build$three.default.Mesh(f, g);
                break;
            case "LOD":
                f = new module$node_modules$three$build$three.default.LOD;
                break;
            case "Line":
                f = new module$node_modules$three$build$three.default.Line(d(a.geometry), e(a.material), a.mode);
                break;
            case "LineLoop":
                f = new module$node_modules$three$build$three.default.LineLoop(d(a.geometry), e(a.material));
                break;
            case "LineSegments":
                f = new module$node_modules$three$build$three.default.LineSegments(d(a.geometry), e(a.material));
                break;
            case "PointCloud":
            case "Points":
                f = new module$node_modules$three$build$three.default.Points(d(a.geometry), e(a.material));
                break;
            case "Sprite":
                f = new module$node_modules$three$build$three.default.Sprite(e(a.material));
                break;
            case "Group":
                f = new module$node_modules$three$build$three.default.Group;
                break;
            default:
                f = new module$node_modules$three$build$three.default.Object3D
        }
        f.uuid = a.uuid;
        void 0 !==
            a.name && (f.name = a.name);
        void 0 !== a.matrix ? (f.matrix.fromArray(a.matrix), void 0 !== a.matrixAutoUpdate && (f.matrixAutoUpdate = a.matrixAutoUpdate), f.matrixAutoUpdate && f.matrix.decompose(f.position, f.quaternion, f.scale)) : (void 0 !== a.position && f.position.fromArray(a.position), void 0 !== a.rotation && f.rotation.fromArray(a.rotation), void 0 !== a.quaternion && f.quaternion.fromArray(a.quaternion), void 0 !== a.scale && f.scale.fromArray(a.scale));
        void 0 !== a.castShadow && (f.castShadow = a.castShadow);
        void 0 !== a.receiveShadow &&
            (f.receiveShadow = a.receiveShadow);
        a.shadow && (void 0 !== a.shadow.bias && (f.shadow.bias = a.shadow.bias), void 0 !== a.shadow.radius && (f.shadow.radius = a.shadow.radius), void 0 !== a.shadow.mapSize && f.shadow.mapSize.fromArray(a.shadow.mapSize), void 0 !== a.shadow.camera && (f.shadow.camera = this.parseObject(a.shadow.camera)));
        void 0 !== a.visible && (f.visible = a.visible);
        void 0 !== a.frustumCulled && (f.frustumCulled = a.frustumCulled);
        void 0 !== a.renderOrder && (f.renderOrder = a.renderOrder);
        void 0 !== a.userData && (f.userData = a.userData);
        void 0 !== a.layers && (f.layers.mask = a.layers);
        if (void 0 !== a.children) {
            g = a.children;
            for (var h = 0; h < g.length; h++) f.add(this.parseObject(g[h], b, c))
        }
        if ("LOD" === a.type)
            for (a = a.levels, g = 0; g < a.length; g++) {
                h = a[g];
                var k = f.getObjectByProperty("uuid", h.object);
                void 0 !== k && f.addLevel(k, h.distance)
            }
        return f
    }
});
var TEXTURE_MAPPING$$module$node_modules$three$build$three = {
        UVMapping: module$node_modules$three$build$three.default.UVMapping,
        CubeReflectionMapping: module$node_modules$three$build$three.default.CubeReflectionMapping,
        CubeRefractionMapping: module$node_modules$three$build$three.default.CubeRefractionMapping,
        EquirectangularReflectionMapping: module$node_modules$three$build$three.default.EquirectangularReflectionMapping,
        EquirectangularRefractionMapping: module$node_modules$three$build$three.default.EquirectangularRefractionMapping,
        SphericalReflectionMapping: module$node_modules$three$build$three.default.SphericalReflectionMapping,
        CubeUVReflectionMapping: module$node_modules$three$build$three.default.CubeUVReflectionMapping,
        CubeUVRefractionMapping: module$node_modules$three$build$three.default.CubeUVRefractionMapping
    },
    TEXTURE_WRAPPING$$module$node_modules$three$build$three = {
        RepeatWrapping: module$node_modules$three$build$three.default.RepeatWrapping,
        ClampToEdgeWrapping: module$node_modules$three$build$three.default.ClampToEdgeWrapping,
        MirroredRepeatWrapping: module$node_modules$three$build$three.default.MirroredRepeatWrapping
    },
    TEXTURE_FILTER$$module$node_modules$three$build$three = {
        NearestFilter: module$node_modules$three$build$three.default.NearestFilter,
        NearestMipMapNearestFilter: module$node_modules$three$build$three.default.NearestMipMapNearestFilter,
        NearestMipMapLinearFilter: module$node_modules$three$build$three.default.NearestMipMapLinearFilter,
        LinearFilter: module$node_modules$three$build$three.default.LinearFilter,
        LinearMipMapNearestFilter: module$node_modules$three$build$three.default.LinearMipMapNearestFilter,
        LinearMipMapLinearFilter: module$node_modules$three$build$three.default.LinearMipMapLinearFilter
    };
module$node_modules$three$build$three.default.ImageBitmapLoader.prototype = {
    constructor: module$node_modules$three$build$three.default.ImageBitmapLoader,
    setOptions: function(a) {
        this.options = a;
        return this
    },
    load: function(a, b, c, d) {
        void 0 === a && (a = "");
        void 0 !== this.path && (a = this.path + a);
        a = this.manager.resolveURL(a);
        var e = this,
            f = module$node_modules$three$build$three.default.Cache.get(a);
        if (void 0 !== f) return e.manager.itemStart(a), setTimeout(function() {
            b && b(f);
            e.manager.itemEnd(a)
        }, 0), f;
        fetch(a).then(function(a) {
            return a.blob()
        }).then(function(a) {
            return createImageBitmap(a,
                e.options)
        }).then(function(c) {
            module$node_modules$three$build$three.default.Cache.add(a, c);
            b && b(c);
            e.manager.itemEnd(a)
        }).catch(function(b) {
            d && d(b);
            e.manager.itemEnd(a);
            e.manager.itemError(a)
        })
    },
    setCrossOrigin: function() {
        return this
    },
    setPath: function(a) {
        this.path = a;
        return this
    }
};
Object.assign(module$node_modules$three$build$three.default.ShapePath.prototype, {
    moveTo: function(a, b) {
        this.currentPath = new module$node_modules$three$build$three.default.Path;
        this.subPaths.push(this.currentPath);
        this.currentPath.moveTo(a, b)
    },
    lineTo: function(a, b) {
        this.currentPath.lineTo(a, b)
    },
    quadraticCurveTo: function(a, b, c, d) {
        this.currentPath.quadraticCurveTo(a, b, c, d)
    },
    bezierCurveTo: function(a, b, c, d, e, f) {
        this.currentPath.bezierCurveTo(a, b, c, d, e, f)
    },
    splineThru: function(a) {
        this.currentPath.splineThru(a)
    },
    toShapes: function(a, b) {
        function c(a) {
            for (var b = [], c = 0, d = a.length; c < d; c++) {
                var e = a[c],
                    f = new module$node_modules$three$build$three.default.Shape;
                f.curves = e.curves;
                b.push(f)
            }
            return b
        }

        function d(a, b) {
            for (var c = b.length, d = !1, e = c - 1, f = 0; f < c; e = f++) {
                var g = b[e],
                    h = b[f],
                    k = h.x - g.x,
                    l = h.y - g.y;
                if (Math.abs(l) > Number.EPSILON) {
                    if (0 > l && (g = b[f], k = -k, h = b[e], l = -l), !(a.y < g.y || a.y > h.y))
                        if (a.y === g.y) {
                            if (a.x === g.x) return !0
                        } else {
                            e = l * (a.x - g.x) - k * (a.y - g.y);
                            if (0 === e) return !0;
                            0 > e || (d = !d)
                        }
                } else if (a.y === g.y && (h.x <= a.x && a.x <= g.x ||
                        g.x <= a.x && a.x <= h.x)) return !0
            }
            return d
        }
        var e = module$node_modules$three$build$three.default.ShapeUtils.isClockWise,
            f = this.subPaths;
        if (0 === f.length) return [];
        if (!0 === b) return c(f);
        b = [];
        if (1 === f.length) {
            var g = f[0];
            var h = new module$node_modules$three$build$three.default.Shape;
            h.curves = g.curves;
            b.push(h);
            return b
        }
        var k = !e(f[0].getPoints());
        k = a ? !k : k;
        h = [];
        var l = [],
            p = [],
            m = 0;
        l[m] = void 0;
        p[m] = [];
        for (var q = 0, r = f.length; q < r; q++) {
            g = f[q];
            var n = g.getPoints();
            var t = e(n);
            (t = a ? !t : t) ? (!k && l[m] && m++, l[m] = {
                s: new module$node_modules$three$build$three.default.Shape,
                p: n
            }, l[m].s.curves = g.curves, k && m++, p[m] = []) : p[m].push({
                h: g,
                p: n[0]
            })
        }
        if (!l[0]) return c(f);
        if (1 < l.length) {
            q = !1;
            a = [];
            e = 0;
            for (f = l.length; e < f; e++) h[e] = [];
            e = 0;
            for (f = l.length; e < f; e++)
                for (g = p[e], t = 0; t < g.length; t++) {
                    k = g[t];
                    m = !0;
                    for (n = 0; n < l.length; n++) d(k.p, l[n].p) && (e !== n && a.push({
                        froms: e,
                        tos: n,
                        hole: t
                    }), m ? (m = !1, h[n].push(k)) : q = !0);
                    m && h[e].push(k)
                }
            0 < a.length && (q || (p = h))
        }
        q = 0;
        for (e = l.length; q < e; q++)
            for (h = l[q].s, b.push(h), a = p[q], f = 0, g = a.length; f < g; f++) h.holes.push(a[f].h);
        return b
    }
});
Object.assign(module$node_modules$three$build$three.default.Font.prototype, {
    isFont: !0,
    generateShapes: function(a, b) {
        void 0 === b && (b = 100);
        var c = [];
        a = createPaths$$module$node_modules$three$build$three(a, b, this.data);
        b = 0;
        for (var d = a.length; b < d; b++) Array.prototype.push.apply(c, a[b].toShapes());
        return c
    }
});

function createPaths$$module$node_modules$three$build$three(a, b, c) {
    a = Array.from ? Array.from(a) : String(a).split("");
    b /= c.resolution;
    for (var d = (c.boundingBox.yMax - c.boundingBox.yMin + c.underlineThickness) * b, e = [], f = 0, g = 0, h = 0; h < a.length; h++) {
        var k = a[h];
        "\n" === k ? (f = 0, g -= d) : (k = createPath$$module$node_modules$three$build$three(k, b, f, g, c), f += k.offsetX, e.push(k.path))
    }
    return e
}

function createPath$$module$node_modules$three$build$three(a, b, c, d, e) {
    if (a = e.glyphs[a] || e.glyphs["?"]) {
        e = new module$node_modules$three$build$three.default.ShapePath;
        if (a.o)
            for (var f = a._cachedOutline || (a._cachedOutline = a.o.split(" ")), g = 0, h = f.length; g < h;) switch (f[g++]) {
                case "m":
                    var k = f[g++] * b + c;
                    var l = f[g++] * b + d;
                    e.moveTo(k, l);
                    break;
                case "l":
                    k = f[g++] * b + c;
                    l = f[g++] * b + d;
                    e.lineTo(k, l);
                    break;
                case "q":
                    k = f[g++] * b + c;
                    l = f[g++] * b + d;
                    var p = f[g++] * b + c;
                    var m = f[g++] * b + d;
                    e.quadraticCurveTo(p, m, k, l);
                    break;
                case "b":
                    k =
                        f[g++] * b + c;
                    l = f[g++] * b + d;
                    p = f[g++] * b + c;
                    m = f[g++] * b + d;
                    var q = f[g++] * b + c;
                    var r = f[g++] * b + d;
                    e.bezierCurveTo(p, m, q, r, k, l)
            }
        return {
            offsetX: a.ha * b,
            path: e
        }
    }
}
Object.assign(module$node_modules$three$build$three.default.FontLoader.prototype, {
    load: function(a, b, c, d) {
        var e = this,
            f = new module$node_modules$three$build$three.default.FileLoader(this.manager);
        f.setPath(this.path);
        f.load(a, function(a) {
            try {
                var c = JSON.parse(a)
            } catch (k) {
                console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), c = JSON.parse(a.substring(65, a.length - 2))
            }
            a = e.parse(c);
            b && b(a)
        }, c, d)
    },
    parse: function(a) {
        return new module$node_modules$three$build$three.default.Font(a)
    },
    setPath: function(a) {
        this.path = a;
        return this
    }
});
var context$$module$node_modules$three$build$three;
module$node_modules$three$build$three.default.AudioContext = {
    getContext: function() {
        void 0 === context$$module$node_modules$three$build$three && (context$$module$node_modules$three$build$three = new(window.AudioContext || window.webkitAudioContext));
        return context$$module$node_modules$three$build$three
    },
    setContext: function(a) {
        context$$module$node_modules$three$build$three = a
    }
};
Object.assign(module$node_modules$three$build$three.default.AudioLoader.prototype, {
    load: function(a, b, c, d) {
        var e = new module$node_modules$three$build$three.default.FileLoader(this.manager);
        e.setResponseType("arraybuffer");
        e.load(a, function(a) {
            a = a.slice(0);
            module$node_modules$three$build$three.default.AudioContext.getContext().decodeAudioData(a, function(a) {
                b(a)
            })
        }, c, d)
    }
});
Object.assign(module$node_modules$three$build$three.default.StereoCamera.prototype, {
    update: function() {
        var a, b, c, d, e, f, g, h, k = new module$node_modules$three$build$three.default.Matrix4,
            l = new module$node_modules$three$build$three.default.Matrix4;
        return function(p) {
            if (a !== this || b !== p.focus || c !== p.fov || d !== p.aspect * this.aspect || e !== p.near || f !== p.far || g !== p.zoom || h !== this.eyeSep) {
                a = this;
                b = p.focus;
                c = p.fov;
                d = p.aspect * this.aspect;
                e = p.near;
                f = p.far;
                g = p.zoom;
                var m = p.projectionMatrix.clone();
                h = this.eyeSep / 2;
                var q =
                    h * e / b,
                    r = e * Math.tan(module$node_modules$three$build$three.default.Math.DEG2RAD * c * .5) / g;
                l.elements[12] = -h;
                k.elements[12] = h;
                var n = -r * d + q;
                var t = r * d + q;
                m.elements[0] = 2 * e / (t - n);
                m.elements[8] = (t + n) / (t - n);
                this.cameraL.projectionMatrix.copy(m);
                n = -r * d - q;
                t = r * d - q;
                m.elements[0] = 2 * e / (t - n);
                m.elements[8] = (t + n) / (t - n);
                this.cameraR.projectionMatrix.copy(m)
            }
            this.cameraL.matrixWorld.copy(p.matrixWorld).multiply(l);
            this.cameraR.matrixWorld.copy(p.matrixWorld).multiply(k)
        }
    }()
});
module$node_modules$three$build$three.default.CubeCamera.prototype = Object.create(module$node_modules$three$build$three.default.Object3D.prototype);
module$node_modules$three$build$three.default.CubeCamera.prototype.constructor = module$node_modules$three$build$three.default.CubeCamera;
module$node_modules$three$build$three.default.AudioListener.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.Object3D.prototype), {
    constructor: module$node_modules$three$build$three.default.AudioListener,
    getInput: function() {
        return this.gain
    },
    removeFilter: function() {
        null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null);
        return this
    },
    getFilter: function() {
        return this.filter
    },
    setFilter: function(a) {
        null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination);
        this.filter = a;
        this.gain.connect(this.filter);
        this.filter.connect(this.context.destination);
        return this
    },
    getMasterVolume: function() {
        return this.gain.gain.value
    },
    setMasterVolume: function(a) {
        this.gain.gain.setTargetAtTime(a, this.context.currentTime, .01);
        return this
    },
    updateMatrixWorld: function() {
        var a = new module$node_modules$three$build$three.default.Vector3,
            b = new module$node_modules$three$build$three.default.Quaternion,
            c = new module$node_modules$three$build$three.default.Vector3,
            d = new module$node_modules$three$build$three.default.Vector3;
        return function(e) {
            module$node_modules$three$build$three.default.Object3D.prototype.updateMatrixWorld.call(this, e);
            e = this.context.listener;
            var f = this.up;
            this.matrixWorld.decompose(a, b, c);
            d.set(0, 0, -1).applyQuaternion(b);
            e.positionX ? (e.positionX.setValueAtTime(a.x, this.context.currentTime), e.positionY.setValueAtTime(a.y,
                this.context.currentTime), e.positionZ.setValueAtTime(a.z, this.context.currentTime), e.forwardX.setValueAtTime(d.x, this.context.currentTime), e.forwardY.setValueAtTime(d.y, this.context.currentTime), e.forwardZ.setValueAtTime(d.z, this.context.currentTime), e.upX.setValueAtTime(f.x, this.context.currentTime), e.upY.setValueAtTime(f.y, this.context.currentTime), e.upZ.setValueAtTime(f.z, this.context.currentTime)) : (e.setPosition(a.x, a.y, a.z), e.setOrientation(d.x, d.y, d.z, f.x, f.y, f.z))
        }
    }()
});
module$node_modules$three$build$three.default.Audio.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.Object3D.prototype), {
    constructor: module$node_modules$three$build$three.default.Audio,
    getOutput: function() {
        return this.gain
    },
    setNodeSource: function(a) {
        this.hasPlaybackControl = !1;
        this.sourceType = "audioNode";
        this.source = a;
        this.connect();
        return this
    },
    setMediaElementSource: function(a) {
        this.hasPlaybackControl = !1;
        this.sourceType = "mediaNode";
        this.source = this.context.createMediaElementSource(a);
        this.connect();
        return this
    },
    setBuffer: function(a) {
        this.buffer = a;
        this.sourceType = "buffer";
        this.autoplay && this.play();
        return this
    },
    play: function() {
        if (!0 === this.isPlaying) console.warn("THREE.Audio: Audio is already playing.");
        else if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control.");
        else {
            var a = this.context.createBufferSource();
            a.buffer = this.buffer;
            a.loop = this.loop;
            a.onended = this.onEnded.bind(this);
            a.playbackRate.setValueAtTime(this.playbackRate, this.startTime);
            this.startTime = this.context.currentTime;
            a.start(this.startTime, this.offset);
            this.isPlaying = !0;
            this.source = a;
            return this.connect()
        }
    },
    pause: function() {
        if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control.");
        else return !0 === this.isPlaying && (this.source.stop(), this.source.onended = null, this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this
    },
    stop: function() {
        if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control.");
        else return this.source.stop(), this.source.onended = null, this.offset = 0, this.isPlaying = !1, this
    },
    connect: function() {
        if (0 < this.filters.length) {
            this.source.connect(this.filters[0]);
            for (var a = 1, b = this.filters.length; a < b; a++) this.filters[a - 1].connect(this.filters[a]);
            this.filters[this.filters.length - 1].connect(this.getOutput())
        } else this.source.connect(this.getOutput());
        return this
    },
    disconnect: function() {
        if (0 < this.filters.length) {
            this.source.disconnect(this.filters[0]);
            for (var a = 1, b = this.filters.length; a <
                b; a++) this.filters[a - 1].disconnect(this.filters[a]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput())
        } else this.source.disconnect(this.getOutput());
        return this
    },
    getFilters: function() {
        return this.filters
    },
    setFilters: function(a) {
        a || (a = []);
        !0 === this.isPlaying ? (this.disconnect(), this.filters = a, this.connect()) : this.filters = a;
        return this
    },
    getFilter: function() {
        return this.getFilters()[0]
    },
    setFilter: function(a) {
        return this.setFilters(a ? [a] : [])
    },
    setPlaybackRate: function(a) {
        if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control.");
        else return this.playbackRate = a, !0 === this.isPlaying && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime), this
    },
    getPlaybackRate: function() {
        return this.playbackRate
    },
    onEnded: function() {
        this.isPlaying = !1
    },
    getLoop: function() {
        return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
    },
    setLoop: function(a) {
        if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control.");
        else return this.loop =
            a, !0 === this.isPlaying && (this.source.loop = this.loop), this
    },
    getVolume: function() {
        return this.gain.gain.value
    },
    setVolume: function(a) {
        this.gain.gain.setTargetAtTime(a, this.context.currentTime, .01);
        return this
    }
});
module$node_modules$three$build$three.default.PositionalAudio.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.Audio.prototype), {
    constructor: module$node_modules$three$build$three.default.PositionalAudio,
    getOutput: function() {
        return this.panner
    },
    getRefDistance: function() {
        return this.panner.refDistance
    },
    setRefDistance: function(a) {
        this.panner.refDistance = a;
        return this
    },
    getRolloffFactor: function() {
        return this.panner.rolloffFactor
    },
    setRolloffFactor: function(a) {
        this.panner.rolloffFactor =
            a;
        return this
    },
    getDistanceModel: function() {
        return this.panner.distanceModel
    },
    setDistanceModel: function(a) {
        this.panner.distanceModel = a;
        return this
    },
    getMaxDistance: function() {
        return this.panner.maxDistance
    },
    setMaxDistance: function(a) {
        this.panner.maxDistance = a;
        return this
    },
    setDirectionalCone: function(a, b, c) {
        this.panner.coneInnerAngle = a;
        this.panner.coneOuterAngle = b;
        this.panner.coneOuterGain = c;
        return this
    },
    updateMatrixWorld: function() {
        var a = new module$node_modules$three$build$three.default.Vector3,
            b = new module$node_modules$three$build$three.default.Quaternion,
            c = new module$node_modules$three$build$three.default.Vector3,
            d = new module$node_modules$three$build$three.default.Vector3;
        return function(e) {
            module$node_modules$three$build$three.default.Object3D.prototype.updateMatrixWorld.call(this, e);
            e = this.panner;
            this.matrixWorld.decompose(a, b, c);
            d.set(0, 0, 1).applyQuaternion(b);
            e.setPosition(a.x, a.y, a.z);
            e.setOrientation(d.x, d.y, d.z)
        }
    }()
});
Object.assign(module$node_modules$three$build$three.default.AudioAnalyser.prototype, {
    getFrequencyData: function() {
        this.analyser.getByteFrequencyData(this.data);
        return this.data
    },
    getAverageFrequency: function() {
        for (var a = 0, b = this.getFrequencyData(), c = 0; c < b.length; c++) a += b[c];
        return a / b.length
    }
});
Object.assign(module$node_modules$three$build$three.default.PropertyMixer.prototype, {
    accumulate: function(a, b) {
        var c = this.buffer,
            d = this.valueSize;
        a = a * d + d;
        var e = this.cumulativeWeight;
        if (0 === e) {
            for (e = 0; e !== d; ++e) c[a + e] = c[e];
            e = b
        } else e += b, this._mixBufferRegion(c, a, 0, b / e, d);
        this.cumulativeWeight = e
    },
    apply: function(a) {
        var b = this.valueSize,
            c = this.buffer;
        a = a * b + b;
        var d = this.cumulativeWeight,
            e = this.binding;
        this.cumulativeWeight = 0;
        1 > d && this._mixBufferRegion(c, a, 3 * b, 1 - d, b);
        d = b;
        for (var f = b + b; d !== f; ++d)
            if (c[d] !==
                c[d + b]) {
                e.setValue(c, a);
                break
            }
    },
    saveOriginalState: function() {
        var a = this.buffer,
            b = this.valueSize,
            c = 3 * b;
        this.binding.getValue(a, c);
        for (var d = b; d !== c; ++d) a[d] = a[c + d % b];
        this.cumulativeWeight = 0
    },
    restoreOriginalState: function() {
        this.binding.setValue(this.buffer, 3 * this.valueSize)
    },
    _select: function(a, b, c, d, e) {
        if (.5 <= d)
            for (d = 0; d !== e; ++d) a[b + d] = a[c + d]
    },
    _slerp: function(a, b, c, d) {
        module$node_modules$three$build$three.default.Quaternion.slerpFlat(a, b, a, b, a, c, d)
    },
    _lerp: function(a, b, c, d, e) {
        for (var f = 1 - d, g = 0; g !==
            e; ++g) {
            var h = b + g;
            a[h] = a[h] * f + a[c + g] * d
        }
    }
});
var RESERVED_CHARS_RE$$module$node_modules$three$build$three = "\\[\\]\\.:\\/";

function Composite$$module$node_modules$three$build$three(a, b, c) {
    c = c || module$node_modules$three$build$three.default.PropertyBinding.parseTrackName(b);
    this._targetGroup = a;
    this._bindings = a.subscribe_(b, c)
}
Object.assign(Composite$$module$node_modules$three$build$three.prototype, {
    getValue: function(a, b) {
        this.bind();
        var c = this._bindings[this._targetGroup.nCachedObjects_];
        void 0 !== c && c.getValue(a, b)
    },
    setValue: function(a, b) {
        for (var c = this._bindings, d = this._targetGroup.nCachedObjects_, e = c.length; d !== e; ++d) c[d].setValue(a, b)
    },
    bind: function() {
        for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, c = a.length; b !== c; ++b) a[b].bind()
    },
    unbind: function() {
        for (var a = this._bindings, b = this._targetGroup.nCachedObjects_,
                c = a.length; b !== c; ++b) a[b].unbind()
    }
});
Object.assign(module$node_modules$three$build$three.default.PropertyBinding, {
    Composite: Composite$$module$node_modules$three$build$three,
    create: function(a, b, c) {
        return a && a.isAnimationObjectGroup ? new module$node_modules$three$build$three.default.PropertyBinding.Composite(a, b, c) : new module$node_modules$three$build$three.default.PropertyBinding(a, b, c)
    },
    sanitizeNodeName: function() {
        var a = new RegExp("[" + RESERVED_CHARS_RE$$module$node_modules$three$build$three + "]", "g");
        return function(b) {
            return b.replace(/\s/g,
                "_").replace(a, "")
        }
    }(),
    parseTrackName: function() {
        var a = "[^" + RESERVED_CHARS_RE$$module$node_modules$three$build$three + "]",
            b = "[^" + RESERVED_CHARS_RE$$module$node_modules$three$build$three.replace("\\.", "") + "]",
            c = /((?:WC+[\/:])*)/.source.replace("WC", a);
        b = /(WCOD+)?/.source.replace("WCOD", b);
        var d = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", a);
        a = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", a);
        var e = new RegExp("^" + c + b + d + a + "$"),
            f = ["material", "materials", "bones"];
        return function(a) {
            var b = e.exec(a);
            if (!b) throw Error("PropertyBinding: Cannot parse trackName: " +
                a);
            b = {
                nodeName: b[2],
                objectName: b[3],
                objectIndex: b[4],
                propertyName: b[5],
                propertyIndex: b[6]
            };
            var c = b.nodeName && b.nodeName.lastIndexOf(".");
            if (void 0 !== c && -1 !== c) {
                var d = b.nodeName.substring(c + 1); - 1 !== f.indexOf(d) && (b.nodeName = b.nodeName.substring(0, c), b.objectName = d)
            }
            if (null === b.propertyName || 0 === b.propertyName.length) throw Error("PropertyBinding: can not parse propertyName from trackName: " + a);
            return b
        }
    }(),
    findNode: function(a, b) {
        if (!b || "" === b || "root" === b || "." === b || -1 === b || b === a.name || b === a.uuid) return a;
        if (a.skeleton) {
            var c = a.skeleton.getBoneByName(b);
            if (void 0 !== c) return c
        }
        if (a.children) {
            var d = function(a) {
                for (var c = 0; c < a.length; c++) {
                    var e = a[c];
                    if (e.name === b || e.uuid === b || (e = d(e.children))) return e
                }
                return null
            };
            if (a = d(a.children)) return a
        }
        return null
    }
});
Object.assign(module$node_modules$three$build$three.default.PropertyBinding.prototype, {
    _getValue_unavailable: function() {},
    _setValue_unavailable: function() {},
    BindingType: {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
    },
    Versioning: {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
    },
    GetterByBindingType: [function(a, b) {
            a[b] = this.node[this.propertyName]
        }, function(a, b) {
            for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) a[b++] = c[d]
        }, function(a, b) {
            a[b] = this.resolvedProperty[this.propertyIndex]
        },
        function(a, b) {
            this.resolvedProperty.toArray(a, b)
        }
    ],
    SetterByBindingTypeAndVersioning: [
        [function(a, b) {
            this.targetObject[this.propertyName] = a[b]
        }, function(a, b) {
            this.targetObject[this.propertyName] = a[b];
            this.targetObject.needsUpdate = !0
        }, function(a, b) {
            this.targetObject[this.propertyName] = a[b];
            this.targetObject.matrixWorldNeedsUpdate = !0
        }],
        [function(a, b) {
            for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) c[d] = a[b++]
        }, function(a, b) {
            for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) c[d] = a[b++];
            this.targetObject.needsUpdate = !0
        }, function(a, b) {
            for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) c[d] = a[b++];
            this.targetObject.matrixWorldNeedsUpdate = !0
        }],
        [function(a, b) {
            this.resolvedProperty[this.propertyIndex] = a[b]
        }, function(a, b) {
            this.resolvedProperty[this.propertyIndex] = a[b];
            this.targetObject.needsUpdate = !0
        }, function(a, b) {
            this.resolvedProperty[this.propertyIndex] = a[b];
            this.targetObject.matrixWorldNeedsUpdate = !0
        }],
        [function(a, b) {
            this.resolvedProperty.fromArray(a, b)
        }, function(a, b) {
            this.resolvedProperty.fromArray(a,
                b);
            this.targetObject.needsUpdate = !0
        }, function(a, b) {
            this.resolvedProperty.fromArray(a, b);
            this.targetObject.matrixWorldNeedsUpdate = !0
        }]
    ],
    getValue: function(a, b) {
        this.bind();
        this.getValue(a, b)
    },
    setValue: function(a, b) {
        this.bind();
        this.setValue(a, b)
    },
    bind: function() {
        var a = this.node,
            b = this.parsedPath,
            c = b.objectName,
            d = b.propertyName,
            e = b.propertyIndex;
        a || (this.node = a = module$node_modules$three$build$three.default.PropertyBinding.findNode(this.rootNode, b.nodeName) || this.rootNode);
        this.getValue = this._getValue_unavailable;
        this.setValue = this._setValue_unavailable;
        if (a) {
            if (c) {
                var f = b.objectIndex;
                switch (c) {
                    case "materials":
                        if (!a.material) {
                            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            return
                        }
                        if (!a.material.materials) {
                            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                            return
                        }
                        a = a.material.materials;
                        break;
                    case "bones":
                        if (!a.skeleton) {
                            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                                this);
                            return
                        }
                        a = a.skeleton.bones;
                        for (c = 0; c < a.length; c++)
                            if (a[c].name === f) {
                                f = c;
                                break
                            }
                        break;
                    default:
                        if (void 0 === a[c]) {
                            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                            return
                        }
                        a = a[c]
                }
                if (void 0 !== f) {
                    if (void 0 === a[f]) {
                        console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, a);
                        return
                    }
                    a = a[f]
                }
            }
            f = a[d];
            if (void 0 === f) console.error("THREE.PropertyBinding: Trying to update property for track: " + b.nodeName + "." + d + " but it wasn't found.",
                a);
            else {
                b = this.Versioning.None;
                void 0 !== a.needsUpdate ? (b = this.Versioning.NeedsUpdate, this.targetObject = a) : void 0 !== a.matrixWorldNeedsUpdate && (b = this.Versioning.MatrixWorldNeedsUpdate, this.targetObject = a);
                c = this.BindingType.Direct;
                if (void 0 !== e) {
                    if ("morphTargetInfluences" === d) {
                        if (!a.geometry) {
                            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                            return
                        }
                        if (a.geometry.isBufferGeometry) {
                            if (!a.geometry.morphAttributes) {
                                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                                    this);
                                return
                            }
                            for (c = 0; c < this.node.geometry.morphAttributes.position.length; c++)
                                if (a.geometry.morphAttributes.position[c].name === e) {
                                    e = c;
                                    break
                                }
                        } else {
                            if (!a.geometry.morphTargets) {
                                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                return
                            }
                            for (c = 0; c < this.node.geometry.morphTargets.length; c++)
                                if (a.geometry.morphTargets[c].name === e) {
                                    e = c;
                                    break
                                }
                        }
                    }
                    c = this.BindingType.ArrayElement;
                    this.resolvedProperty = f;
                    this.propertyIndex = e
                } else void 0 !==
                    f.fromArray && void 0 !== f.toArray ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = f) : Array.isArray(f) ? (c = this.BindingType.EntireArray, this.resolvedProperty = f) : this.propertyName = d;
                this.getValue = this.GetterByBindingType[c];
                this.setValue = this.SetterByBindingTypeAndVersioning[c][b]
            }
        } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
    },
    unbind: function() {
        this.node = null;
        this.getValue = this._getValue_unbound;
        this.setValue = this._setValue_unbound
    }
});
Object.assign(module$node_modules$three$build$three.default.PropertyBinding.prototype, {
    _getValue_unbound: module$node_modules$three$build$three.default.PropertyBinding.prototype.getValue,
    _setValue_unbound: module$node_modules$three$build$three.default.PropertyBinding.prototype.setValue
});
Object.assign(module$node_modules$three$build$three.default.AnimationObjectGroup.prototype, {
    isAnimationObjectGroup: !0,
    add: function() {
        for (var a = this._objects, b = a.length, c = this.nCachedObjects_, d = this._indicesByUUID, e = this._paths, f = this._parsedPaths, g = this._bindings, h = g.length, k = void 0, l = 0, p = arguments.length; l !== p; ++l) {
            var m = arguments[l],
                q = m.uuid,
                r = d[q];
            if (void 0 === r) {
                r = b++;
                d[q] = r;
                a.push(m);
                q = 0;
                for (var n = h; q !== n; ++q) g[q].push(new module$node_modules$three$build$three.default.PropertyBinding(m, e[q], f[q]))
            } else if (r <
                c) {
                k = a[r];
                var t = --c;
                n = a[t];
                d[n.uuid] = r;
                a[r] = n;
                d[q] = t;
                a[t] = m;
                q = 0;
                for (n = h; q !== n; ++q) {
                    var u = g[q],
                        w = u[r];
                    u[r] = u[t];
                    void 0 === w && (w = new module$node_modules$three$build$three.default.PropertyBinding(m, e[q], f[q]));
                    u[t] = w
                }
            } else a[r] !== k && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
        }
        this.nCachedObjects_ = c
    },
    remove: function() {
        for (var a = this._objects, b = this.nCachedObjects_, c = this._indicesByUUID,
                d = this._bindings, e = d.length, f = 0, g = arguments.length; f !== g; ++f) {
            var h = arguments[f],
                k = h.uuid,
                l = c[k];
            if (void 0 !== l && l >= b) {
                var p = b++,
                    m = a[p];
                c[m.uuid] = l;
                a[l] = m;
                c[k] = p;
                a[p] = h;
                h = 0;
                for (k = e; h !== k; ++h) {
                    m = d[h];
                    var q = m[l];
                    m[l] = m[p];
                    m[p] = q
                }
            }
        }
        this.nCachedObjects_ = b
    },
    uncache: function() {
        for (var a = this._objects, b = a.length, c = this.nCachedObjects_, d = this._indicesByUUID, e = this._bindings, f = e.length, g = 0, h = arguments.length; g !== h; ++g) {
            var k = arguments[g].uuid,
                l = d[k];
            if (void 0 !== l)
                if (delete d[k], l < c) {
                    k = --c;
                    var p = a[k],
                        m = --b,
                        q = a[m];
                    d[p.uuid] = l;
                    a[l] = p;
                    d[q.uuid] = k;
                    a[k] = q;
                    a.pop();
                    p = 0;
                    for (q = f; p !== q; ++p) {
                        var r = e[p],
                            n = r[m];
                        r[l] = r[k];
                        r[k] = n;
                        r.pop()
                    }
                } else
                    for (m = --b, q = a[m], d[q.uuid] = l, a[l] = q, a.pop(), p = 0, q = f; p !== q; ++p) r = e[p], r[l] = r[m], r.pop()
        }
        this.nCachedObjects_ = c
    },
    subscribe_: function(a, b) {
        var c = this._bindingsIndicesByPath,
            d = c[a],
            e = this._bindings;
        if (void 0 !== d) return e[d];
        var f = this._paths,
            g = this._parsedPaths,
            h = this._objects,
            k = this.nCachedObjects_,
            l = Array(h.length);
        d = e.length;
        c[a] = d;
        f.push(a);
        g.push(b);
        e.push(l);
        c = k;
        for (d = h.length; c !==
            d; ++c) l[c] = new module$node_modules$three$build$three.default.PropertyBinding(h[c], a, b);
        return l
    },
    unsubscribe_: function(a) {
        var b = this._bindingsIndicesByPath,
            c = b[a];
        if (void 0 !== c) {
            var d = this._paths,
                e = this._parsedPaths,
                f = this._bindings,
                g = f.length - 1,
                h = f[g];
            b[a[g]] = c;
            f[c] = h;
            f.pop();
            e[c] = e[g];
            e.pop();
            d[c] = d[g];
            d.pop()
        }
    }
});

function AnimationAction$$module$node_modules$three$build$three(a, b, c) {
    this._mixer = a;
    this._clip = b;
    this._localRoot = c || null;
    a = b.tracks;
    b = a.length;
    c = Array(b);
    for (var d = {
            endingStart: module$node_modules$three$build$three.default.ZeroCurvatureEnding,
            endingEnd: module$node_modules$three$build$three.default.ZeroCurvatureEnding
        }, e = 0; e !== b; ++e) {
        var f = a[e].createInterpolant(null);
        c[e] = f;
        f.settings = d
    }
    this._interpolantSettings = d;
    this._interpolants = c;
    this._propertyBindings = Array(b);
    this._weightInterpolant = this._timeScaleInterpolant =
        this._byClipCacheIndex = this._cacheIndex = null;
    this.loop = module$node_modules$three$build$three.default.LoopRepeat;
    this._loopCount = -1;
    this._startTime = null;
    this.time = 0;
    this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1;
    this.repetitions = Infinity;
    this.paused = !1;
    this.enabled = !0;
    this.clampWhenFinished = !1;
    this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0
}
Object.assign(AnimationAction$$module$node_modules$three$build$three.prototype, {
    play: function() {
        this._mixer._activateAction(this);
        return this
    },
    stop: function() {
        this._mixer._deactivateAction(this);
        return this.reset()
    },
    reset: function() {
        this.paused = !1;
        this.enabled = !0;
        this.time = 0;
        this._loopCount = -1;
        this._startTime = null;
        return this.stopFading().stopWarping()
    },
    isRunning: function() {
        return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
    },
    isScheduled: function() {
        return this._mixer._isActiveAction(this)
    },
    startAt: function(a) {
        this._startTime = a;
        return this
    },
    setLoop: function(a, b) {
        this.loop = a;
        this.repetitions = b;
        return this
    },
    setEffectiveWeight: function(a) {
        this.weight = a;
        this._effectiveWeight = this.enabled ? a : 0;
        return this.stopFading()
    },
    getEffectiveWeight: function() {
        return this._effectiveWeight
    },
    fadeIn: function(a) {
        return this._scheduleFading(a, 0, 1)
    },
    fadeOut: function(a) {
        return this._scheduleFading(a, 1, 0)
    },
    crossFadeFrom: function(a, b, c) {
        a.fadeOut(b);
        this.fadeIn(b);
        if (c) {
            c = this._clip.duration;
            var d = a._clip.duration,
                e = c / d;
            a.warp(1, d / c, b);
            this.warp(e, 1, b)
        }
        return this
    },
    crossFadeTo: function(a, b, c) {
        return a.crossFadeFrom(this, b, c)
    },
    stopFading: function() {
        var a = this._weightInterpolant;
        null !== a && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(a));
        return this
    },
    setEffectiveTimeScale: function(a) {
        this.timeScale = a;
        this._effectiveTimeScale = this.paused ? 0 : a;
        return this.stopWarping()
    },
    getEffectiveTimeScale: function() {
        return this._effectiveTimeScale
    },
    setDuration: function(a) {
        this.timeScale = this._clip.duration /
            a;
        return this.stopWarping()
    },
    syncWith: function(a) {
        this.time = a.time;
        this.timeScale = a.timeScale;
        return this.stopWarping()
    },
    halt: function(a) {
        return this.warp(this._effectiveTimeScale, 0, a)
    },
    warp: function(a, b, c) {
        var d = this._mixer,
            e = d.time,
            f = this._timeScaleInterpolant,
            g = this.timeScale;
        null === f && (this._timeScaleInterpolant = f = d._lendControlInterpolant());
        d = f.parameterPositions;
        f = f.sampleValues;
        d[0] = e;
        d[1] = e + c;
        f[0] = a / g;
        f[1] = b / g;
        return this
    },
    stopWarping: function() {
        var a = this._timeScaleInterpolant;
        null !== a &&
            (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(a));
        return this
    },
    getMixer: function() {
        return this._mixer
    },
    getClip: function() {
        return this._clip
    },
    getRoot: function() {
        return this._localRoot || this._mixer._root
    },
    _update: function(a, b, c, d) {
        if (this.enabled) {
            var e = this._startTime;
            if (null !== e) {
                b = (a - e) * c;
                if (0 > b || 0 === c) return;
                this._startTime = null;
                b *= c
            }
            b *= this._updateTimeScale(a);
            c = this._updateTime(b);
            a = this._updateWeight(a);
            if (0 < a) {
                b = this._interpolants;
                e = this._propertyBindings;
                for (var f =
                        0, g = b.length; f !== g; ++f) b[f].evaluate(c), e[f].accumulate(d, a)
            }
        } else this._updateWeight(a)
    },
    _updateWeight: function(a) {
        var b = 0;
        if (this.enabled) {
            b = this.weight;
            var c = this._weightInterpolant;
            if (null !== c) {
                var d = c.evaluate(a)[0];
                b *= d;
                a > c.parameterPositions[1] && (this.stopFading(), 0 === d && (this.enabled = !1))
            }
        }
        return this._effectiveWeight = b
    },
    _updateTimeScale: function(a) {
        var b = 0;
        if (!this.paused) {
            b = this.timeScale;
            var c = this._timeScaleInterpolant;
            if (null !== c) {
                var d = c.evaluate(a)[0];
                b *= d;
                a > c.parameterPositions[1] &&
                    (this.stopWarping(), 0 === b ? this.paused = !0 : this.timeScale = b)
            }
        }
        return this._effectiveTimeScale = b
    },
    _updateTime: function(a) {
        var b = this.time + a,
            c = this._clip.duration,
            d = this.loop,
            e = this._loopCount,
            f = d === module$node_modules$three$build$three.default.LoopPingPong;
        if (0 === a) return -1 === e ? b : f && 1 === (e & 1) ? c - b : b;
        if (d === module$node_modules$three$build$three.default.LoopOnce) a: {
            if (-1 === e && (this._loopCount = 0, this._setEndings(!0, !0, !1)), b >= c) b = c;
            else if (0 > b) b = 0;
            else break a;
            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1;
            this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: 0 > a ? -1 : 1
            })
        } else {
            -1 === e && (0 <= a ? (e = 0, this._setEndings(!0, 0 === this.repetitions, f)) : this._setEndings(0 === this.repetitions, !0, f));
            if (b >= c || 0 > b) {
                d = Math.floor(b / c);
                b -= c * d;
                e += Math.abs(d);
                var g = this.repetitions - e;
                0 >= g ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, b = 0 < a ? c : 0, this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: 0 < a ? 1 : -1
                })) : (1 === g ? (a = 0 > a, this._setEndings(a, !a, f)) : this._setEndings(!1, !1, f), this._loopCount =
                    e, this._mixer.dispatchEvent({
                        type: "loop",
                        action: this,
                        loopDelta: d
                    }))
            }
            if (f && 1 === (e & 1)) return this.time = b, c - b
        }
        return this.time = b
    },
    _setEndings: function(a, b, c) {
        var d = this._interpolantSettings;
        c ? (d.endingStart = module$node_modules$three$build$three.default.ZeroSlopeEnding, d.endingEnd = module$node_modules$three$build$three.default.ZeroSlopeEnding) : (d.endingStart = a ? this.zeroSlopeAtStart ? module$node_modules$three$build$three.default.ZeroSlopeEnding : module$node_modules$three$build$three.default.ZeroCurvatureEnding :
            module$node_modules$three$build$three.default.WrapAroundEnding, d.endingEnd = b ? this.zeroSlopeAtEnd ? module$node_modules$three$build$three.default.ZeroSlopeEnding : module$node_modules$three$build$three.default.ZeroCurvatureEnding : module$node_modules$three$build$three.default.WrapAroundEnding)
    },
    _scheduleFading: function(a, b, c) {
        var d = this._mixer,
            e = d.time,
            f = this._weightInterpolant;
        null === f && (this._weightInterpolant = f = d._lendControlInterpolant());
        d = f.parameterPositions;
        f = f.sampleValues;
        d[0] = e;
        f[0] = b;
        d[1] = e +
            a;
        f[1] = c;
        return this
    }
});
module$node_modules$three$build$three.default.AnimationMixer.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.EventDispatcher.prototype), {
    constructor: module$node_modules$three$build$three.default.AnimationMixer,
    _bindAction: function(a, b) {
        var c = a._localRoot || this._root,
            d = a._clip.tracks,
            e = d.length,
            f = a._propertyBindings;
        a = a._interpolants;
        var g = c.uuid,
            h = this._bindingsByRootAndName,
            k = h[g];
        void 0 === k && (k = {}, h[g] = k);
        for (h = 0; h !== e; ++h) {
            var l = d[h],
                p = l.name,
                m = k[p];
            if (void 0 ===
                m) {
                m = f[h];
                if (void 0 !== m) {
                    null === m._cacheIndex && (++m.referenceCount, this._addInactiveBinding(m, g, p));
                    continue
                }
                m = new module$node_modules$three$build$three.default.PropertyMixer(module$node_modules$three$build$three.default.PropertyBinding.create(c, p, b && b._propertyBindings[h].binding.parsedPath), l.ValueTypeName, l.getValueSize());
                ++m.referenceCount;
                this._addInactiveBinding(m, g, p)
            }
            f[h] = m;
            a[h].resultBuffer = m.buffer
        }
    },
    _activateAction: function(a) {
        if (!this._isActiveAction(a)) {
            if (null === a._cacheIndex) {
                var b =
                    (a._localRoot || this._root).uuid,
                    c = a._clip.uuid,
                    d = this._actionsByClip[c];
                this._bindAction(a, d && d.knownActions[0]);
                this._addInactiveAction(a, c, b)
            }
            b = a._propertyBindings;
            c = 0;
            for (d = b.length; c !== d; ++c) {
                var e = b[c];
                0 === e.useCount++ && (this._lendBinding(e), e.saveOriginalState())
            }
            this._lendAction(a)
        }
    },
    _deactivateAction: function(a) {
        if (this._isActiveAction(a)) {
            for (var b = a._propertyBindings, c = 0, d = b.length; c !== d; ++c) {
                var e = b[c];
                0 === --e.useCount && (e.restoreOriginalState(), this._takeBackBinding(e))
            }
            this._takeBackAction(a)
        }
    },
    _initMemoryManager: function() {
        this._actions = [];
        this._nActiveActions = 0;
        this._actionsByClip = {};
        this._bindings = [];
        this._nActiveBindings = 0;
        this._bindingsByRootAndName = {};
        this._controlInterpolants = [];
        this._nActiveControlInterpolants = 0;
        var a = this;
        this.stats = {
            actions: {get total() {
                    return a._actions.length
                },
                get inUse() {
                    return a._nActiveActions
                }
            },
            bindings: {get total() {
                    return a._bindings.length
                },
                get inUse() {
                    return a._nActiveBindings
                }
            },
            controlInterpolants: {get total() {
                    return a._controlInterpolants.length
                },
                get inUse() {
                    return a._nActiveControlInterpolants
                }
            }
        }
    },
    _isActiveAction: function(a) {
        a = a._cacheIndex;
        return null !== a && a < this._nActiveActions
    },
    _addInactiveAction: function(a, b, c) {
        var d = this._actions,
            e = this._actionsByClip,
            f = e[b];
        void 0 === f ? (f = {
            knownActions: [a],
            actionByRoot: {}
        }, a._byClipCacheIndex = 0, e[b] = f) : (b = f.knownActions, a._byClipCacheIndex = b.length, b.push(a));
        a._cacheIndex = d.length;
        d.push(a);
        f.actionByRoot[c] = a
    },
    _removeInactiveAction: function(a) {
        var b = this._actions,
            c = b[b.length - 1],
            d = a._cacheIndex;
        c._cacheIndex = d;
        b[d] = c;
        b.pop();
        a._cacheIndex = null;
        b = a._clip.uuid;
        c = this._actionsByClip;
        d = c[b];
        var e = d.knownActions,
            f = e[e.length - 1],
            g = a._byClipCacheIndex;
        f._byClipCacheIndex = g;
        e[g] = f;
        e.pop();
        a._byClipCacheIndex = null;
        delete d.actionByRoot[(a._localRoot || this._root).uuid];
        0 === e.length && delete c[b];
        this._removeInactiveBindingsForAction(a)
    },
    _removeInactiveBindingsForAction: function(a) {
        a = a._propertyBindings;
        for (var b = 0, c = a.length; b !== c; ++b) {
            var d = a[b];
            0 === --d.referenceCount && this._removeInactiveBinding(d)
        }
    },
    _lendAction: function(a) {
        var b = this._actions,
            c = a._cacheIndex,
            d = this._nActiveActions++,
            e = b[d];
        a._cacheIndex = d;
        b[d] = a;
        e._cacheIndex = c;
        b[c] = e
    },
    _takeBackAction: function(a) {
        var b = this._actions,
            c = a._cacheIndex,
            d = --this._nActiveActions,
            e = b[d];
        a._cacheIndex = d;
        b[d] = a;
        e._cacheIndex = c;
        b[c] = e
    },
    _addInactiveBinding: function(a, b, c) {
        var d = this._bindingsByRootAndName,
            e = d[b],
            f = this._bindings;
        void 0 === e && (e = {}, d[b] = e);
        e[c] = a;
        a._cacheIndex = f.length;
        f.push(a)
    },
    _removeInactiveBinding: function(a) {
        var b = this._bindings,
            c = a.binding,
            d = c.rootNode.uuid;
        c = c.path;
        var e = this._bindingsByRootAndName,
            f = e[d],
            g = b[b.length - 1];
        a = a._cacheIndex;
        g._cacheIndex = a;
        b[a] = g;
        b.pop();
        delete f[c];
        a: {
            for (var h in f) break a;
            delete e[d]
        }
    },
    _lendBinding: function(a) {
        var b = this._bindings,
            c = a._cacheIndex,
            d = this._nActiveBindings++,
            e = b[d];
        a._cacheIndex = d;
        b[d] = a;
        e._cacheIndex = c;
        b[c] = e
    },
    _takeBackBinding: function(a) {
        var b = this._bindings,
            c = a._cacheIndex,
            d = --this._nActiveBindings,
            e = b[d];
        a._cacheIndex = d;
        b[d] = a;
        e._cacheIndex = c;
        b[c] = e
    },
    _lendControlInterpolant: function() {
        var a = this._controlInterpolants,
            b = this._nActiveControlInterpolants++,
            c = a[b];
        void 0 === c && (c = new module$node_modules$three$build$three.default.LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), c.__cacheIndex = b, a[b] = c);
        return c
    },
    _takeBackControlInterpolant: function(a) {
        var b = this._controlInterpolants,
            c = a.__cacheIndex,
            d = --this._nActiveControlInterpolants,
            e = b[d];
        a.__cacheIndex = d;
        b[d] = a;
        e.__cacheIndex = c;
        b[c] = e
    },
    _controlInterpolantsResultBuffer: new Float32Array(1),
    clipAction: function(a, b) {
        var c = b || this._root,
            d = c.uuid;
        c = "string" ===
            typeof a ? module$node_modules$three$build$three.default.AnimationClip.findByName(c, a) : a;
        a = null !== c ? c.uuid : a;
        var e = this._actionsByClip[a],
            f = null;
        if (void 0 !== e) {
            f = e.actionByRoot[d];
            if (void 0 !== f) return f;
            f = e.knownActions[0];
            null === c && (c = f._clip)
        }
        if (null === c) return null;
        b = new AnimationAction$$module$node_modules$three$build$three(this, c, b);
        this._bindAction(b, f);
        this._addInactiveAction(b, a, d);
        return b
    },
    existingAction: function(a, b) {
        var c = b || this._root;
        b = c.uuid;
        c = "string" === typeof a ? module$node_modules$three$build$three.default.AnimationClip.findByName(c,
            a) : a;
        a = this._actionsByClip[c ? c.uuid : a];
        return void 0 !== a ? a.actionByRoot[b] || null : null
    },
    stopAllAction: function() {
        for (var a = this._actions, b = this._nActiveActions, c = this._bindings, d = this._nActiveBindings, e = this._nActiveBindings = this._nActiveActions = 0; e !== b; ++e) a[e].reset();
        for (e = 0; e !== d; ++e) c[e].useCount = 0;
        return this
    },
    update: function(a) {
        a *= this.timeScale;
        for (var b = this._actions, c = this._nActiveActions, d = this.time += a, e = Math.sign(a), f = this._accuIndex ^= 1, g = 0; g !== c; ++g) b[g]._update(d, a, e, f);
        a = this._bindings;
        b = this._nActiveBindings;
        for (g = 0; g !== b; ++g) a[g].apply(f);
        return this
    },
    getRoot: function() {
        return this._root
    },
    uncacheClip: function(a) {
        var b = this._actions;
        a = a.uuid;
        var c = this._actionsByClip,
            d = c[a];
        if (void 0 !== d) {
            d = d.knownActions;
            for (var e = 0, f = d.length; e !== f; ++e) {
                var g = d[e];
                this._deactivateAction(g);
                var h = g._cacheIndex,
                    k = b[b.length - 1];
                g._cacheIndex = null;
                g._byClipCacheIndex = null;
                k._cacheIndex = h;
                b[h] = k;
                b.pop();
                this._removeInactiveBindingsForAction(g)
            }
            delete c[a]
        }
    },
    uncacheRoot: function(a) {
        a = a.uuid;
        var b =
            this._actionsByClip;
        for (d in b) {
            var c = b[d].actionByRoot[a];
            void 0 !== c && (this._deactivateAction(c), this._removeInactiveAction(c))
        }
        var d = this._bindingsByRootAndName[a];
        if (void 0 !== d)
            for (var e in d) a = d[e], a.restoreOriginalState(), this._removeInactiveBinding(a)
    },
    uncacheAction: function(a, b) {
        a = this.existingAction(a, b);
        null !== a && (this._deactivateAction(a), this._removeInactiveAction(a))
    }
});
module$node_modules$three$build$three.default.Uniform.prototype.clone = function() {
    return new module$node_modules$three$build$three.default.Uniform(void 0 === this.value.clone ? this.value : this.value.clone())
};
module$node_modules$three$build$three.default.InstancedBufferGeometry.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.BufferGeometry.prototype), {
    constructor: module$node_modules$three$build$three.default.InstancedBufferGeometry,
    isInstancedBufferGeometry: !0,
    copy: function(a) {
        module$node_modules$three$build$three.default.BufferGeometry.prototype.copy.call(this, a);
        this.maxInstancedCount = a.maxInstancedCount;
        return this
    },
    clone: function() {
        return (new this.constructor).copy(this)
    }
});
module$node_modules$three$build$three.default.InstancedInterleavedBuffer.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.InterleavedBuffer.prototype), {
    constructor: module$node_modules$three$build$three.default.InstancedInterleavedBuffer,
    isInstancedInterleavedBuffer: !0,
    copy: function(a) {
        module$node_modules$three$build$three.default.InterleavedBuffer.prototype.copy.call(this, a);
        this.meshPerAttribute = a.meshPerAttribute;
        return this
    }
});
module$node_modules$three$build$three.default.InstancedBufferAttribute.prototype = Object.assign(Object.create(module$node_modules$three$build$three.default.BufferAttribute.prototype), {
    constructor: module$node_modules$three$build$three.default.InstancedBufferAttribute,
    isInstancedBufferAttribute: !0,
    copy: function(a) {
        module$node_modules$three$build$three.default.BufferAttribute.prototype.copy.call(this, a);
        this.meshPerAttribute = a.meshPerAttribute;
        return this
    }
});

function ascSort$$module$node_modules$three$build$three(a, b) {
    return a.distance - b.distance
}

function intersectObject$$module$node_modules$three$build$three(a, b, c, d) {
    if (!1 !== a.visible && (a.raycast(b, c), !0 === d)) {
        a = a.children;
        d = 0;
        for (var e = a.length; d < e; d++) intersectObject$$module$node_modules$three$build$three(a[d], b, c, !0)
    }
}
Object.assign(module$node_modules$three$build$three.default.Raycaster.prototype, {
    linePrecision: 1,
    set: function(a, b) {
        this.ray.set(a, b)
    },
    setFromCamera: function(a, b) {
        b && b.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(b.matrixWorld), this.ray.direction.set(a.x, a.y, .5).unproject(b).sub(this.ray.origin).normalize()) : b && b.isOrthographicCamera ? (this.ray.origin.set(a.x, a.y, (b.near + b.far) / (b.near - b.far)).unproject(b), this.ray.direction.set(0, 0, -1).transformDirection(b.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
    },
    intersectObject: function(a, b, c) {
        c = c || [];
        intersectObject$$module$node_modules$three$build$three(a, this, c, b);
        c.sort(ascSort$$module$node_modules$three$build$three);
        return c
    },
    intersectObjects: function(a, b, c) {
        c = c || [];
        if (!1 === Array.isArray(a)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), c;
        for (var d = 0, e = a.length; d < e; d++) intersectObject$$module$node_modules$three$build$three(a[d], this, c, b);
        c.sort(ascSort$$module$node_modules$three$build$three);
        return c
    }
});
Object.assign(module$node_modules$three$build$three.default.Clock.prototype, {
    start: function() {
        this.oldTime = this.startTime = ("undefined" === typeof performance ? Date : performance).now();
        this.elapsedTime = 0;
        this.running = !0
    },
    stop: function() {
        this.getElapsedTime();
        this.autoStart = this.running = !1
    },
    getElapsedTime: function() {
        this.getDelta();
        return this.elapsedTime
    },
    getDelta: function() {
        var a = 0;
        if (this.autoStart && !this.running) return this.start(), 0;
        if (this.running) {
            var b = ("undefined" === typeof performance ? Date : performance).now();
            a = (b - this.oldTime) / 1E3;
            this.oldTime = b;
            this.elapsedTime += a
        }
        return a
    }
});
Object.assign(module$node_modules$three$build$three.default.Spherical.prototype, {
    set: function(a, b, c) {
        this.radius = a;
        this.phi = b;
        this.theta = c;
        return this
    },
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(a) {
        this.radius = a.radius;
        this.phi = a.phi;
        this.theta = a.theta;
        return this
    },
    makeSafe: function() {
        this.phi = Math.max(1E-6, Math.min(Math.PI - 1E-6, this.phi));
        return this
    },
    setFromVector3: function(a) {
        this.radius = a.length();
        0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(a.x, a.z),
            this.phi = Math.acos(module$node_modules$three$build$three.default.Math.clamp(a.y / this.radius, -1, 1)));
        return this
    }
});
Object.assign(module$node_modules$three$build$three.default.Cylindrical.prototype, {
    set: function(a, b, c) {
        this.radius = a;
        this.theta = b;
        this.y = c;
        return this
    },
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(a) {
        this.radius = a.radius;
        this.theta = a.theta;
        this.y = a.y;
        return this
    },
    setFromVector3: function(a) {
        this.radius = Math.sqrt(a.x * a.x + a.z * a.z);
        this.theta = Math.atan2(a.x, a.z);
        this.y = a.y;
        return this
    }
});
Object.assign(module$node_modules$three$build$three.default.Box2.prototype, {
    set: function(a, b) {
        this.min.copy(a);
        this.max.copy(b);
        return this
    },
    setFromPoints: function(a) {
        this.makeEmpty();
        for (var b = 0, c = a.length; b < c; b++) this.expandByPoint(a[b]);
        return this
    },
    setFromCenterAndSize: function() {
        var a = new module$node_modules$three$build$three.default.Vector2;
        return function(b, c) {
            c = a.copy(c).multiplyScalar(.5);
            this.min.copy(b).sub(c);
            this.max.copy(b).add(c);
            return this
        }
    }(),
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(a) {
        this.min.copy(a.min);
        this.max.copy(a.max);
        return this
    },
    makeEmpty: function() {
        this.min.x = this.min.y = Infinity;
        this.max.x = this.max.y = -Infinity;
        return this
    },
    isEmpty: function() {
        return this.max.x < this.min.x || this.max.y < this.min.y
    },
    getCenter: function(a) {
        void 0 === a && (console.warn("THREE.Box2: .getCenter() target is now required"), a = new module$node_modules$three$build$three.default.Vector2);
        return this.isEmpty() ? a.set(0, 0) : a.addVectors(this.min, this.max).multiplyScalar(.5)
    },
    getSize: function(a) {
        void 0 ===
            a && (console.warn("THREE.Box2: .getSize() target is now required"), a = new module$node_modules$three$build$three.default.Vector2);
        return this.isEmpty() ? a.set(0, 0) : a.subVectors(this.max, this.min)
    },
    expandByPoint: function(a) {
        this.min.min(a);
        this.max.max(a);
        return this
    },
    expandByVector: function(a) {
        this.min.sub(a);
        this.max.add(a);
        return this
    },
    expandByScalar: function(a) {
        this.min.addScalar(-a);
        this.max.addScalar(a);
        return this
    },
    containsPoint: function(a) {
        return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y ||
            a.y > this.max.y ? !1 : !0
    },
    containsBox: function(a) {
        return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y
    },
    getParameter: function(a, b) {
        void 0 === b && (console.warn("THREE.Box2: .getParameter() target is now required"), b = new module$node_modules$three$build$three.default.Vector2);
        return b.set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y))
    },
    intersectsBox: function(a) {
        return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y >
            this.max.y ? !1 : !0
    },
    clampPoint: function(a, b) {
        void 0 === b && (console.warn("THREE.Box2: .clampPoint() target is now required"), b = new module$node_modules$three$build$three.default.Vector2);
        return b.copy(a).clamp(this.min, this.max)
    },
    distanceToPoint: function() {
        var a = new module$node_modules$three$build$three.default.Vector2;
        return function(b) {
            return a.copy(b).clamp(this.min, this.max).sub(b).length()
        }
    }(),
    intersect: function(a) {
        this.min.max(a.min);
        this.max.min(a.max);
        return this
    },
    union: function(a) {
        this.min.min(a.min);
        this.max.max(a.max);
        return this
    },
    translate: function(a) {
        this.min.add(a);
        this.max.add(a);
        return this
    },
    equals: function(a) {
        return a.min.equals(this.min) && a.max.equals(this.max)
    }
});
Object.assign(module$node_modules$three$build$three.default.Line3.prototype, {
    set: function(a, b) {
        this.start.copy(a);
        this.end.copy(b);
        return this
    },
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(a) {
        this.start.copy(a.start);
        this.end.copy(a.end);
        return this
    },
    getCenter: function(a) {
        void 0 === a && (console.warn("THREE.Line3: .getCenter() target is now required"), a = new module$node_modules$three$build$three.default.Vector3);
        return a.addVectors(this.start, this.end).multiplyScalar(.5)
    },
    delta: function(a) {
        void 0 ===
            a && (console.warn("THREE.Line3: .delta() target is now required"), a = new module$node_modules$three$build$three.default.Vector3);
        return a.subVectors(this.end, this.start)
    },
    distanceSq: function() {
        return this.start.distanceToSquared(this.end)
    },
    distance: function() {
        return this.start.distanceTo(this.end)
    },
    at: function(a, b) {
        void 0 === b && (console.warn("THREE.Line3: .at() target is now required"), b = new module$node_modules$three$build$three.default.Vector3);
        return this.delta(b).multiplyScalar(a).add(this.start)
    },
    closestPointToPointParameter: function() {
        var a = new module$node_modules$three$build$three.default.Vector3,
            b = new module$node_modules$three$build$three.default.Vector3;
        return function(c, d) {
            a.subVectors(c, this.start);
            b.subVectors(this.end, this.start);
            c = b.dot(b);
            c = b.dot(a) / c;
            d && (c = module$node_modules$three$build$three.default.Math.clamp(c, 0, 1));
            return c
        }
    }(),
    closestPointToPoint: function(a, b, c) {
        a = this.closestPointToPointParameter(a, b);
        void 0 === c && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"),
            c = new module$node_modules$three$build$three.default.Vector3);
        return this.delta(c).multiplyScalar(a).add(this.start)
    },
    applyMatrix4: function(a) {
        this.start.applyMatrix4(a);
        this.end.applyMatrix4(a);
        return this
    },
    equals: function(a) {
        return a.start.equals(this.start) && a.end.equals(this.end)
    }
});
module$node_modules$three$build$three.default.ImmediateRenderObject.prototype = Object.create(module$node_modules$three$build$three.default.Object3D.prototype);
module$node_modules$three$build$three.default.ImmediateRenderObject.prototype.constructor = module$node_modules$three$build$three.default.ImmediateRenderObject;
module$node_modules$three$build$three.default.ImmediateRenderObject.prototype.isImmediateRenderObject = !0;
module$node_modules$three$build$three.default.VertexNormalsHelper.prototype = Object.create(module$node_modules$three$build$three.default.LineSegments.prototype);
module$node_modules$three$build$three.default.VertexNormalsHelper.prototype.constructor = module$node_modules$three$build$three.default.VertexNormalsHelper;
module$node_modules$three$build$three.default.VertexNormalsHelper.prototype.update = function() {
    var a = new module$node_modules$three$build$three.default.Vector3,
        b = new module$node_modules$three$build$three.default.Vector3,
        c = new module$node_modules$three$build$three.default.Matrix3;
    return function() {
        var d = ["a", "b", "c"];
        this.object.updateMatrixWorld(!0);
        c.getNormalMatrix(this.object.matrixWorld);
        var e = this.object.matrixWorld,
            f = this.geometry.attributes.position,
            g = this.object.geometry;
        if (g && g.isGeometry)
            for (var h =
                    g.vertices, k = g.faces, l = g = 0, p = k.length; l < p; l++)
                for (var m = k[l], q = 0, r = m.vertexNormals.length; q < r; q++) {
                    var n = m.vertexNormals[q];
                    a.copy(h[m[d[q]]]).applyMatrix4(e);
                    b.copy(n).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a);
                    f.setXYZ(g, a.x, a.y, a.z);
                    g += 1;
                    f.setXYZ(g, b.x, b.y, b.z);
                    g += 1
                } else if (g && g.isBufferGeometry)
                    for (d = g.attributes.position, h = g.attributes.normal, q = g = 0, r = d.count; q < r; q++) a.set(d.getX(q), d.getY(q), d.getZ(q)).applyMatrix4(e), b.set(h.getX(q), h.getY(q), h.getZ(q)), b.applyMatrix3(c).normalize().multiplyScalar(this.size).add(a),
                        f.setXYZ(g, a.x, a.y, a.z), g += 1, f.setXYZ(g, b.x, b.y, b.z), g += 1;
        f.needsUpdate = !0
    }
}();
module$node_modules$three$build$three.default.SpotLightHelper.prototype = Object.create(module$node_modules$three$build$three.default.Object3D.prototype);
module$node_modules$three$build$three.default.SpotLightHelper.prototype.constructor = module$node_modules$three$build$three.default.SpotLightHelper;
module$node_modules$three$build$three.default.SpotLightHelper.prototype.dispose = function() {
    this.cone.geometry.dispose();
    this.cone.material.dispose()
};
module$node_modules$three$build$three.default.SpotLightHelper.prototype.update = function() {
    var a = new module$node_modules$three$build$three.default.Vector3,
        b = new module$node_modules$three$build$three.default.Vector3;
    return function() {
        this.light.updateMatrixWorld();
        var c = this.light.distance ? this.light.distance : 1E3,
            d = c * Math.tan(this.light.angle);
        this.cone.scale.set(d, d, c);
        a.setFromMatrixPosition(this.light.matrixWorld);
        b.setFromMatrixPosition(this.light.target.matrixWorld);
        this.cone.lookAt(b.sub(a));
        void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
    }
}();

function getBoneList$$module$node_modules$three$build$three(a) {
    var b = [];
    a && a.isBone && b.push(a);
    for (var c = 0; c < a.children.length; c++) b.push.apply(b, getBoneList$$module$node_modules$three$build$three(a.children[c]));
    return b
}
module$node_modules$three$build$three.default.SkeletonHelper.prototype = Object.create(module$node_modules$three$build$three.default.LineSegments.prototype);
module$node_modules$three$build$three.default.SkeletonHelper.prototype.constructor = module$node_modules$three$build$three.default.SkeletonHelper;
module$node_modules$three$build$three.default.SkeletonHelper.prototype.updateMatrixWorld = function() {
    var a = new module$node_modules$three$build$three.default.Vector3,
        b = new module$node_modules$three$build$three.default.Matrix4,
        c = new module$node_modules$three$build$three.default.Matrix4;
    return function(d) {
        var e = this.bones,
            f = this.geometry,
            g = f.getAttribute("position");
        c.getInverse(this.root.matrixWorld);
        for (var h = 0, k = 0; h < e.length; h++) {
            var l = e[h];
            l.parent && l.parent.isBone && (b.multiplyMatrices(c, l.matrixWorld),
                a.setFromMatrixPosition(b), g.setXYZ(k, a.x, a.y, a.z), b.multiplyMatrices(c, l.parent.matrixWorld), a.setFromMatrixPosition(b), g.setXYZ(k + 1, a.x, a.y, a.z), k += 2)
        }
        f.getAttribute("position").needsUpdate = !0;
        module$node_modules$three$build$three.default.Object3D.prototype.updateMatrixWorld.call(this, d)
    }
}();
module$node_modules$three$build$three.default.PointLightHelper.prototype = Object.create(module$node_modules$three$build$three.default.Mesh.prototype);
module$node_modules$three$build$three.default.PointLightHelper.prototype.constructor = module$node_modules$three$build$three.default.PointLightHelper;
module$node_modules$three$build$three.default.PointLightHelper.prototype.dispose = function() {
    this.geometry.dispose();
    this.material.dispose()
};
module$node_modules$three$build$three.default.PointLightHelper.prototype.update = function() {
    void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
};
module$node_modules$three$build$three.default.RectAreaLightHelper.prototype = Object.create(module$node_modules$three$build$three.default.Object3D.prototype);
module$node_modules$three$build$three.default.RectAreaLightHelper.prototype.constructor = module$node_modules$three$build$three.default.RectAreaLightHelper;
module$node_modules$three$build$three.default.RectAreaLightHelper.prototype.dispose = function() {
    this.children[0].geometry.dispose();
    this.children[0].material.dispose()
};
module$node_modules$three$build$three.default.RectAreaLightHelper.prototype.update = function() {
    var a = .5 * this.light.width,
        b = .5 * this.light.height,
        c = this.line.geometry.attributes.position,
        d = c.array;
    d[0] = a;
    d[1] = -b;
    d[2] = 0;
    d[3] = a;
    d[4] = b;
    d[5] = 0;
    d[6] = -a;
    d[7] = b;
    d[8] = 0;
    d[9] = -a;
    d[10] = -b;
    d[11] = 0;
    d[12] = a;
    d[13] = -b;
    d[14] = 0;
    c.needsUpdate = !0;
    void 0 !== this.color ? this.line.material.color.set(this.color) : this.line.material.color.copy(this.light.color)
};
module$node_modules$three$build$three.default.HemisphereLightHelper.prototype = Object.create(module$node_modules$three$build$three.default.Object3D.prototype);
module$node_modules$three$build$three.default.HemisphereLightHelper.prototype.constructor = module$node_modules$three$build$three.default.HemisphereLightHelper;
module$node_modules$three$build$three.default.HemisphereLightHelper.prototype.dispose = function() {
    this.children[0].geometry.dispose();
    this.children[0].material.dispose()
};
module$node_modules$three$build$three.default.HemisphereLightHelper.prototype.update = function() {
    var a = new module$node_modules$three$build$three.default.Vector3,
        b = new module$node_modules$three$build$three.default.Color,
        c = new module$node_modules$three$build$three.default.Color;
    return function() {
        var d = this.children[0];
        if (void 0 !== this.color) this.material.color.set(this.color);
        else {
            var e = d.geometry.getAttribute("color");
            b.copy(this.light.color);
            c.copy(this.light.groundColor);
            for (var f = 0, g = e.count; f < g; f++) {
                var h =
                    f < g / 2 ? b : c;
                e.setXYZ(f, h.r, h.g, h.b)
            }
            e.needsUpdate = !0
        }
        d.lookAt(a.setFromMatrixPosition(this.light.matrixWorld).negate())
    }
}();
module$node_modules$three$build$three.default.GridHelper.prototype = Object.create(module$node_modules$three$build$three.default.LineSegments.prototype);
module$node_modules$three$build$three.default.GridHelper.prototype.constructor = module$node_modules$three$build$three.default.GridHelper;
module$node_modules$three$build$three.default.PolarGridHelper.prototype = Object.create(module$node_modules$three$build$three.default.LineSegments.prototype);
module$node_modules$three$build$three.default.PolarGridHelper.prototype.constructor = module$node_modules$three$build$three.default.PolarGridHelper;
module$node_modules$three$build$three.default.FaceNormalsHelper.prototype = Object.create(module$node_modules$three$build$three.default.LineSegments.prototype);
module$node_modules$three$build$three.default.FaceNormalsHelper.prototype.constructor = module$node_modules$three$build$three.default.FaceNormalsHelper;
module$node_modules$three$build$three.default.FaceNormalsHelper.prototype.update = function() {
    var a = new module$node_modules$three$build$three.default.Vector3,
        b = new module$node_modules$three$build$three.default.Vector3,
        c = new module$node_modules$three$build$three.default.Matrix3;
    return function() {
        this.object.updateMatrixWorld(!0);
        c.getNormalMatrix(this.object.matrixWorld);
        var d = this.object.matrixWorld,
            e = this.geometry.attributes.position,
            f = this.object.geometry,
            g = f.vertices;
        f = f.faces;
        for (var h = 0, k = 0, l =
                f.length; k < l; k++) {
            var p = f[k],
                m = p.normal;
            a.copy(g[p.a]).add(g[p.b]).add(g[p.c]).divideScalar(3).applyMatrix4(d);
            b.copy(m).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a);
            e.setXYZ(h, a.x, a.y, a.z);
            h += 1;
            e.setXYZ(h, b.x, b.y, b.z);
            h += 1
        }
        e.needsUpdate = !0
    }
}();
module$node_modules$three$build$three.default.DirectionalLightHelper.prototype = Object.create(module$node_modules$three$build$three.default.Object3D.prototype);
module$node_modules$three$build$three.default.DirectionalLightHelper.prototype.constructor = module$node_modules$three$build$three.default.DirectionalLightHelper;
module$node_modules$three$build$three.default.DirectionalLightHelper.prototype.dispose = function() {
    this.lightPlane.geometry.dispose();
    this.lightPlane.material.dispose();
    this.targetLine.geometry.dispose();
    this.targetLine.material.dispose()
};
module$node_modules$three$build$three.default.DirectionalLightHelper.prototype.update = function() {
    var a = new module$node_modules$three$build$three.default.Vector3,
        b = new module$node_modules$three$build$three.default.Vector3,
        c = new module$node_modules$three$build$three.default.Vector3;
    return function() {
        a.setFromMatrixPosition(this.light.matrixWorld);
        b.setFromMatrixPosition(this.light.target.matrixWorld);
        c.subVectors(b, a);
        this.lightPlane.lookAt(c);
        void 0 !== this.color ? (this.lightPlane.material.color.set(this.color),
            this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color));
        this.targetLine.lookAt(c);
        this.targetLine.scale.z = c.length()
    }
}();
module$node_modules$three$build$three.default.CameraHelper.prototype = Object.create(module$node_modules$three$build$three.default.LineSegments.prototype);
module$node_modules$three$build$three.default.CameraHelper.prototype.constructor = module$node_modules$three$build$three.default.CameraHelper;
module$node_modules$three$build$three.default.CameraHelper.prototype.update = function() {
    function a(a, g, h, k) {
        d.set(g, h, k).unproject(e);
        a = c[a];
        if (void 0 !== a)
            for (g = b.getAttribute("position"), h = 0, k = a.length; h < k; h++) g.setXYZ(a[h], d.x, d.y, d.z)
    }
    var b, c, d = new module$node_modules$three$build$three.default.Vector3,
        e = new module$node_modules$three$build$three.default.Camera;
    return function() {
        b = this.geometry;
        c = this.pointMap;
        e.projectionMatrix.copy(this.camera.projectionMatrix);
        a("c", 0, 0, -1);
        a("t", 0, 0, 1);
        a("n1", -1, -1, -1);
        a("n2", 1, -1, -1);
        a("n3", -1, 1, -1);
        a("n4", 1, 1, -1);
        a("f1", -1, -1, 1);
        a("f2", 1, -1, 1);
        a("f3", -1, 1, 1);
        a("f4", 1, 1, 1);
        a("u1", .7, 1.1, -1);
        a("u2", -.7, 1.1, -1);
        a("u3", 0, 2, -1);
        a("cf1", -1, 0, 1);
        a("cf2", 1, 0, 1);
        a("cf3", 0, -1, 1);
        a("cf4", 0, 1, 1);
        a("cn1", -1, 0, -1);
        a("cn2", 1, 0, -1);
        a("cn3", 0, -1, -1);
        a("cn4", 0, 1, -1);
        b.getAttribute("position").needsUpdate = !0
    }
}();
module$node_modules$three$build$three.default.BoxHelper.prototype = Object.create(module$node_modules$three$build$three.default.LineSegments.prototype);
module$node_modules$three$build$three.default.BoxHelper.prototype.constructor = module$node_modules$three$build$three.default.BoxHelper;
module$node_modules$three$build$three.default.BoxHelper.prototype.update = function() {
    var a = new module$node_modules$three$build$three.default.Box3;
    return function(b) {
        void 0 !== b && console.warn("THREE.BoxHelper: .update() has no longer arguments.");
        void 0 !== this.object && a.setFromObject(this.object);
        if (!a.isEmpty()) {
            b = a.min;
            var c = a.max,
                d = this.geometry.attributes.position,
                e = d.array;
            e[0] = c.x;
            e[1] = c.y;
            e[2] = c.z;
            e[3] = b.x;
            e[4] = c.y;
            e[5] = c.z;
            e[6] = b.x;
            e[7] = b.y;
            e[8] = c.z;
            e[9] = c.x;
            e[10] = b.y;
            e[11] = c.z;
            e[12] = c.x;
            e[13] =
                c.y;
            e[14] = b.z;
            e[15] = b.x;
            e[16] = c.y;
            e[17] = b.z;
            e[18] = b.x;
            e[19] = b.y;
            e[20] = b.z;
            e[21] = c.x;
            e[22] = b.y;
            e[23] = b.z;
            d.needsUpdate = !0;
            this.geometry.computeBoundingSphere()
        }
    }
}();
module$node_modules$three$build$three.default.BoxHelper.prototype.setFromObject = function(a) {
    this.object = a;
    this.update();
    return this
};
module$node_modules$three$build$three.default.Box3Helper.prototype = Object.create(module$node_modules$three$build$three.default.LineSegments.prototype);
module$node_modules$three$build$three.default.Box3Helper.prototype.constructor = module$node_modules$three$build$three.default.Box3Helper;
module$node_modules$three$build$three.default.Box3Helper.prototype.updateMatrixWorld = function(a) {
    var b = this.box;
    b.isEmpty() || (b.getCenter(this.position), b.getSize(this.scale), this.scale.multiplyScalar(.5), module$node_modules$three$build$three.default.Object3D.prototype.updateMatrixWorld.call(this, a))
};
module$node_modules$three$build$three.default.PlaneHelper.prototype = Object.create(module$node_modules$three$build$three.default.Line.prototype);
module$node_modules$three$build$three.default.PlaneHelper.prototype.constructor = module$node_modules$three$build$three.default.PlaneHelper;
module$node_modules$three$build$three.default.PlaneHelper.prototype.updateMatrixWorld = function(a) {
    var b = -this.plane.constant;
    1E-8 > Math.abs(b) && (b = 1E-8);
    this.scale.set(.5 * this.size, .5 * this.size, b);
    this.children[0].material.side = 0 > b ? module$node_modules$three$build$three.default.BackSide : module$node_modules$three$build$three.default.FrontSide;
    this.lookAt(this.plane.normal);
    module$node_modules$three$build$three.default.Object3D.prototype.updateMatrixWorld.call(this, a)
};
var lineGeometry$$module$node_modules$three$build$three, coneGeometry$$module$node_modules$three$build$three;
module$node_modules$three$build$three.default.ArrowHelper.prototype = Object.create(module$node_modules$three$build$three.default.Object3D.prototype);
module$node_modules$three$build$three.default.ArrowHelper.prototype.constructor = module$node_modules$three$build$three.default.ArrowHelper;
module$node_modules$three$build$three.default.ArrowHelper.prototype.setDirection = function() {
    var a = new module$node_modules$three$build$three.default.Vector3,
        b;
    return function(c) {.99999 < c.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > c.y ? this.quaternion.set(1, 0, 0, 0) : (a.set(c.z, 0, -c.x).normalize(), b = Math.acos(c.y), this.quaternion.setFromAxisAngle(a, b))
    }
}();
module$node_modules$three$build$three.default.ArrowHelper.prototype.setLength = function(a, b, c) {
    void 0 === b && (b = .2 * a);
    void 0 === c && (c = .2 * b);
    this.line.scale.set(1, Math.max(0, a - b), 1);
    this.line.updateMatrix();
    this.cone.scale.set(c, b, c);
    this.cone.position.y = a;
    this.cone.updateMatrix()
};
module$node_modules$three$build$three.default.ArrowHelper.prototype.setColor = function(a) {
    this.line.material.color.copy(a);
    this.cone.material.color.copy(a)
};
module$node_modules$three$build$three.default.AxesHelper.prototype = Object.create(module$node_modules$three$build$three.default.LineSegments.prototype);
module$node_modules$three$build$three.default.AxesHelper.prototype.constructor = module$node_modules$three$build$three.default.AxesHelper;
module$node_modules$three$build$three.default.LineStrip = 0;
module$node_modules$three$build$three.default.LinePieces = 1;
module$node_modules$three$build$three.default.Curve.create = function(a, b) {
    console.log("THREE.Curve.create() has been deprecated");
    a.prototype = Object.create(module$node_modules$three$build$three.default.Curve.prototype);
    a.prototype.constructor = a;
    a.prototype.getPoint = b;
    return a
};
Object.assign(module$node_modules$three$build$three.default.CurvePath.prototype, {
    createPointsGeometry: function(a) {
        console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
        a = this.getPoints(a);
        return this.createGeometry(a)
    },
    createSpacedPointsGeometry: function(a) {
        console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
        a = this.getSpacedPoints(a);
        return this.createGeometry(a)
    },
    createGeometry: function(a) {
        console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
        for (var b = new module$node_modules$three$build$three.default.Geometry, c = 0, d = a.length; c < d; c++) {
            var e = a[c];
            b.vertices.push(new module$node_modules$three$build$three.default.Vector3(e.x, e.y, e.z || 0))
        }
        return b
    }
});
Object.assign(module$node_modules$three$build$three.default.Path.prototype, {
    fromPoints: function(a) {
        console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
        this.setFromPoints(a)
    }
});
module$node_modules$three$build$three.default.ClosedSplineCurve3.prototype = Object.create(module$node_modules$three$build$three.default.CatmullRomCurve3.prototype);
module$node_modules$three$build$three.default.SplineCurve3.prototype = Object.create(module$node_modules$three$build$three.default.CatmullRomCurve3.prototype);
module$node_modules$three$build$three.default.Spline.prototype = Object.create(module$node_modules$three$build$three.default.CatmullRomCurve3.prototype);
Object.assign(module$node_modules$three$build$three.default.Spline.prototype, {
    initFromArray: function() {
        console.error("THREE.Spline: .initFromArray() has been removed.")
    },
    getControlPointsArray: function() {
        console.error("THREE.Spline: .getControlPointsArray() has been removed.")
    },
    reparametrizeByArcLength: function() {
        console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
    }
});
module$node_modules$three$build$three.default.GridHelper.prototype.setColors = function() {
    console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
};
module$node_modules$three$build$three.default.SkeletonHelper.prototype.update = function() {
    console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
};
Object.assign(module$node_modules$three$build$three.default.Loader.prototype, {
    extractUrlBase: function(a) {
        console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
        return module$node_modules$three$build$three.default.LoaderUtils.extractUrlBase(a)
    }
});
Object.assign(module$node_modules$three$build$three.default.Box2.prototype, {
    center: function(a) {
        console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
        return this.getCenter(a)
    },
    empty: function() {
        console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
        return this.isEmpty()
    },
    isIntersectionBox: function(a) {
        console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
        return this.intersectsBox(a)
    },
    size: function(a) {
        console.warn("THREE.Box2: .size() has been renamed to .getSize().");
        return this.getSize(a)
    }
});
Object.assign(module$node_modules$three$build$three.default.Box3.prototype, {
    center: function(a) {
        console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
        return this.getCenter(a)
    },
    empty: function() {
        console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
        return this.isEmpty()
    },
    isIntersectionBox: function(a) {
        console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
        return this.intersectsBox(a)
    },
    isIntersectionSphere: function(a) {
        console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
        return this.intersectsSphere(a)
    },
    size: function(a) {
        console.warn("THREE.Box3: .size() has been renamed to .getSize().");
        return this.getSize(a)
    }
});
module$node_modules$three$build$three.default.Line3.prototype.center = function(a) {
    console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
    return this.getCenter(a)
};
Object.assign(module$node_modules$three$build$three.default.Math, {
    random16: function() {
        console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead.");
        return Math.random()
    },
    nearestPowerOfTwo: function(a) {
        console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().");
        return module$node_modules$three$build$three.default.Math.floorPowerOfTwo(a)
    },
    nextPowerOfTwo: function(a) {
        console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().");
        return module$node_modules$three$build$three.default.Math.ceilPowerOfTwo(a)
    }
});
Object.assign(module$node_modules$three$build$three.default.Matrix3.prototype, {
    flattenToArrayOffset: function(a, b) {
        console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
        return this.toArray(a, b)
    },
    multiplyVector3: function(a) {
        console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
        return a.applyMatrix3(this)
    },
    multiplyVector3Array: function() {
        console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
    },
    applyToBuffer: function(a) {
        console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.");
        return this.applyToBufferAttribute(a)
    },
    applyToVector3Array: function() {
        console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
    }
});
Object.assign(module$node_modules$three$build$three.default.Matrix4.prototype, {
    extractPosition: function(a) {
        console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
        return this.copyPosition(a)
    },
    flattenToArrayOffset: function(a, b) {
        console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
        return this.toArray(a, b)
    },
    getPosition: function() {
        var a;
        return function() {
            void 0 === a && (a = new module$node_modules$three$build$three.default.Vector3);
            console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
            return a.setFromMatrixColumn(this, 3)
        }
    }(),
    setRotationFromQuaternion: function(a) {
        console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
        return this.makeRotationFromQuaternion(a)
    },
    multiplyToArray: function() {
        console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
    },
    multiplyVector3: function(a) {
        console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return a.applyMatrix4(this)
    },
    multiplyVector4: function(a) {
        console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return a.applyMatrix4(this)
    },
    multiplyVector3Array: function() {
        console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
    },
    rotateAxis: function(a) {
        console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
        a.transformDirection(this)
    },
    crossVector: function(a) {
        console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return a.applyMatrix4(this)
    },
    translate: function() {
        console.error("THREE.Matrix4: .translate() has been removed.")
    },
    rotateX: function() {
        console.error("THREE.Matrix4: .rotateX() has been removed.")
    },
    rotateY: function() {
        console.error("THREE.Matrix4: .rotateY() has been removed.")
    },
    rotateZ: function() {
        console.error("THREE.Matrix4: .rotateZ() has been removed.")
    },
    rotateByAxis: function() {
        console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
    },
    applyToBuffer: function(a) {
        console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.");
        return this.applyToBufferAttribute(a)
    },
    applyToVector3Array: function() {
        console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
    },
    makeFrustum: function(a, b, c, d, e, f) {
        console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
        return this.makePerspective(a, b, d, c, e, f)
    }
});
module$node_modules$three$build$three.default.Plane.prototype.isIntersectionLine = function(a) {
    console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
    return this.intersectsLine(a)
};
module$node_modules$three$build$three.default.Quaternion.prototype.multiplyVector3 = function(a) {
    console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
    return a.applyQuaternion(this)
};
Object.assign(module$node_modules$three$build$three.default.Ray.prototype, {
    isIntersectionBox: function(a) {
        console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
        return this.intersectsBox(a)
    },
    isIntersectionPlane: function(a) {
        console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
        return this.intersectsPlane(a)
    },
    isIntersectionSphere: function(a) {
        console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
        return this.intersectsSphere(a)
    }
});
Object.assign(module$node_modules$three$build$three.default.Triangle.prototype, {
    area: function() {
        console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
        return this.getArea()
    },
    barycoordFromPoint: function(a, b) {
        console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
        return this.getBarycoord(a, b)
    },
    midpoint: function(a) {
        console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
        return this.getMidpoint(a)
    },
    normal: function(a) {
        console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
        return this.getNormal(a)
    },
    plane: function(a) {
        console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
        return this.getPlane(a)
    }
});
Object.assign(module$node_modules$three$build$three.default.Triangle, {
    barycoordFromPoint: function(a, b, c, d, e) {
        console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
        return module$node_modules$three$build$three.default.Triangle.getBarycoord(a, b, c, d, e)
    },
    normal: function(a, b, c, d) {
        console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
        return module$node_modules$three$build$three.default.Triangle.getNormal(a, b, c, d)
    }
});
Object.assign(module$node_modules$three$build$three.default.Shape.prototype, {
    extractAllPoints: function(a) {
        console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
        return this.extractPoints(a)
    },
    extrude: function(a) {
        console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
        return new module$node_modules$three$build$three.default.ExtrudeGeometry(this, a)
    },
    makeGeometry: function(a) {
        console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
        return new module$node_modules$three$build$three.default.ShapeGeometry(this, a)
    }
});
Object.assign(module$node_modules$three$build$three.default.Vector2.prototype, {
    fromAttribute: function(a, b, c) {
        console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
        return this.fromBufferAttribute(a, b, c)
    },
    distanceToManhattan: function(a) {
        console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
        return this.manhattanDistanceTo(a)
    },
    lengthManhattan: function() {
        console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
        return this.manhattanLength()
    }
});
Object.assign(module$node_modules$three$build$three.default.Vector3.prototype, {
    setEulerFromRotationMatrix: function() {
        console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
    },
    setEulerFromQuaternion: function() {
        console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
    },
    getPositionFromMatrix: function(a) {
        console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
        return this.setFromMatrixPosition(a)
    },
    getScaleFromMatrix: function(a) {
        console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
        return this.setFromMatrixScale(a)
    },
    getColumnFromMatrix: function(a, b) {
        console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
        return this.setFromMatrixColumn(b, a)
    },
    applyProjection: function(a) {
        console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
        return this.applyMatrix4(a)
    },
    fromAttribute: function(a, b, c) {
        console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
        return this.fromBufferAttribute(a, b, c)
    },
    distanceToManhattan: function(a) {
        console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
        return this.manhattanDistanceTo(a)
    },
    lengthManhattan: function() {
        console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
        return this.manhattanLength()
    }
});
Object.assign(module$node_modules$three$build$three.default.Vector4.prototype, {
    fromAttribute: function(a, b, c) {
        console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
        return this.fromBufferAttribute(a, b, c)
    },
    lengthManhattan: function() {
        console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
        return this.manhattanLength()
    }
});
Object.assign(module$node_modules$three$build$three.default.Geometry.prototype, {
    computeTangents: function() {
        console.error("THREE.Geometry: .computeTangents() has been removed.")
    },
    computeLineDistances: function() {
        console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
    }
});
Object.assign(module$node_modules$three$build$three.default.Object3D.prototype, {
    getChildByName: function(a) {
        console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
        return this.getObjectByName(a)
    },
    renderDepth: function() {
        console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
    },
    translate: function(a, b) {
        console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
        return this.translateOnAxis(b,
            a)
    },
    getWorldRotation: function() {
        console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
    }
});
Object.defineProperties(module$node_modules$three$build$three.default.Object3D.prototype, {
    eulerOrder: {
        get: function() {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
            return this.rotation.order
        },
        set: function(a) {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
            this.rotation.order = a
        }
    },
    useQuaternion: {
        get: function() {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
        },
        set: function() {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
        }
    }
});
Object.defineProperties(module$node_modules$three$build$three.default.LOD.prototype, {
    objects: {
        get: function() {
            console.warn("THREE.LOD: .objects has been renamed to .levels.");
            return this.levels
        }
    }
});
Object.defineProperty(module$node_modules$three$build$three.default.Skeleton.prototype, "useVertexTexture", {
    get: function() {
        console.warn("THREE.Skeleton: useVertexTexture has been removed.")
    },
    set: function() {
        console.warn("THREE.Skeleton: useVertexTexture has been removed.")
    }
});
Object.defineProperty(module$node_modules$three$build$three.default.Curve.prototype, "__arcLengthDivisions", {
    get: function() {
        console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
        return this.arcLengthDivisions
    },
    set: function(a) {
        console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
        this.arcLengthDivisions = a
    }
});
module$node_modules$three$build$three.default.PerspectiveCamera.prototype.setLens = function(a, b) {
    console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
    void 0 !== b && (this.filmGauge = b);
    this.setFocalLength(a)
};
Object.defineProperties(module$node_modules$three$build$three.default.Light.prototype, {
    onlyShadow: {
        set: function() {
            console.warn("THREE.Light: .onlyShadow has been removed.")
        }
    },
    shadowCameraFov: {
        set: function(a) {
            console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
            this.shadow.camera.fov = a
        }
    },
    shadowCameraLeft: {
        set: function(a) {
            console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
            this.shadow.camera.left = a
        }
    },
    shadowCameraRight: {
        set: function(a) {
            console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
            this.shadow.camera.right = a
        }
    },
    shadowCameraTop: {
        set: function(a) {
            console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
            this.shadow.camera.top = a
        }
    },
    shadowCameraBottom: {
        set: function(a) {
            console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
            this.shadow.camera.bottom = a
        }
    },
    shadowCameraNear: {
        set: function(a) {
            console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
            this.shadow.camera.near = a
        }
    },
    shadowCameraFar: {
        set: function(a) {
            console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
            this.shadow.camera.far = a
        }
    },
    shadowCameraVisible: {
        set: function() {
            console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
        }
    },
    shadowBias: {
        set: function(a) {
            console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
            this.shadow.bias = a
        }
    },
    shadowDarkness: {
        set: function() {
            console.warn("THREE.Light: .shadowDarkness has been removed.")
        }
    },
    shadowMapWidth: {
        set: function(a) {
            console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
            this.shadow.mapSize.width = a
        }
    },
    shadowMapHeight: {
        set: function(a) {
            console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
            this.shadow.mapSize.height = a
        }
    }
});
Object.defineProperties(module$node_modules$three$build$three.default.BufferAttribute.prototype, {
    length: {
        get: function() {
            console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
            return this.array.length
        }
    },
    copyIndicesArray: function() {
        console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
    }
});
Object.assign(module$node_modules$three$build$three.default.BufferGeometry.prototype, {
    addIndex: function(a) {
        console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
        this.setIndex(a)
    },
    addDrawCall: function(a, b, c) {
        void 0 !== c && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
        console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
        this.addGroup(a, b)
    },
    clearDrawCalls: function() {
        console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
        this.clearGroups()
    },
    computeTangents: function() {
        console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
    },
    computeOffsets: function() {
        console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
    }
});
Object.defineProperties(module$node_modules$three$build$three.default.BufferGeometry.prototype, {
    drawcalls: {
        get: function() {
            console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
            return this.groups
        }
    },
    offsets: {
        get: function() {
            console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
            return this.groups
        }
    }
});
Object.assign(module$node_modules$three$build$three.default.ExtrudeBufferGeometry.prototype, {
    getArrays: function() {
        console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
    },
    addShapeList: function() {
        console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
    },
    addShape: function() {
        console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
    }
});
Object.defineProperties(module$node_modules$three$build$three.default.Uniform.prototype, {
    dynamic: {
        set: function() {
            console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
        }
    },
    onUpdate: {
        value: function() {
            console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
            return this
        }
    }
});
Object.defineProperties(module$node_modules$three$build$three.default.Material.prototype, {
    wrapAround: {
        get: function() {
            console.warn("THREE.Material: .wrapAround has been removed.")
        },
        set: function() {
            console.warn("THREE.Material: .wrapAround has been removed.")
        }
    },
    wrapRGB: {
        get: function() {
            console.warn("THREE.Material: .wrapRGB has been removed.");
            return new module$node_modules$three$build$three.default.Color
        }
    },
    shading: {
        get: function() {
            console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
        },
        set: function(a) {
            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
            this.flatShading = a === module$node_modules$three$build$three.default.FlatShading
        }
    }
});
Object.defineProperties(module$node_modules$three$build$three.default.MeshPhongMaterial.prototype, {
    metal: {
        get: function() {
            console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.");
            return !1
        },
        set: function() {
            console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
        }
    }
});
Object.defineProperties(module$node_modules$three$build$three.default.ShaderMaterial.prototype, {
    derivatives: {
        get: function() {
            console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
            return this.extensions.derivatives
        },
        set: function(a) {
            console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
            this.extensions.derivatives = a
        }
    }
});
Object.assign(module$node_modules$three$build$three.default.WebGLRenderer.prototype, {
    animate: function(a) {
        console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
        this.setAnimationLoop(a)
    },
    getCurrentRenderTarget: function() {
        console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
        return this.getRenderTarget()
    },
    getMaxAnisotropy: function() {
        console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
        return this.capabilities.getMaxAnisotropy()
    },
    getPrecision: function() {
        console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
        return this.capabilities.precision
    },
    resetGLState: function() {
        console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
        return this.state.reset()
    },
    supportsFloatTextures: function() {
        console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
        return this.extensions.get("OES_texture_float")
    },
    supportsHalfFloatTextures: function() {
        console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
        return this.extensions.get("OES_texture_half_float")
    },
    supportsStandardDerivatives: function() {
        console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
        return this.extensions.get("OES_standard_derivatives")
    },
    supportsCompressedTextureS3TC: function() {
        console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
        return this.extensions.get("WEBGL_compressed_texture_s3tc")
    },
    supportsCompressedTexturePVRTC: function() {
        console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
        return this.extensions.get("WEBGL_compressed_texture_pvrtc")
    },
    supportsBlendMinMax: function() {
        console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
        return this.extensions.get("EXT_blend_minmax")
    },
    supportsVertexTextures: function() {
        console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
        return this.capabilities.vertexTextures
    },
    supportsInstancedArrays: function() {
        console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
        return this.extensions.get("ANGLE_instanced_arrays")
    },
    enableScissorTest: function(a) {
        console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
        this.setScissorTest(a)
    },
    initMaterial: function() {
        console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
    },
    addPrePlugin: function() {
        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
    },
    addPostPlugin: function() {
        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
    },
    updateShadowMap: function() {
        console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
    },
    setFaceCulling: function() {
        console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
    }
});
Object.defineProperties(module$node_modules$three$build$three.default.WebGLRenderer.prototype, {
    shadowMapEnabled: {
        get: function() {
            return this.shadowMap.enabled
        },
        set: function(a) {
            console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
            this.shadowMap.enabled = a
        }
    },
    shadowMapType: {
        get: function() {
            return this.shadowMap.type
        },
        set: function(a) {
            console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
            this.shadowMap.type = a
        }
    },
    shadowMapCullFace: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
        }
    }
});
Object.defineProperties(WebGLShadowMap$$module$node_modules$three$build$three.prototype, {
    cullFace: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
        }
    },
    renderReverseSided: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
        }
    },
    renderSingleSided: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
        }
    }
});
Object.defineProperties(module$node_modules$three$build$three.default.WebGLRenderTarget.prototype, {
    wrapS: {
        get: function() {
            console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
            return this.texture.wrapS
        },
        set: function(a) {
            console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
            this.texture.wrapS = a
        }
    },
    wrapT: {
        get: function() {
            console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
            return this.texture.wrapT
        },
        set: function(a) {
            console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
            this.texture.wrapT = a
        }
    },
    magFilter: {
        get: function() {
            console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
            return this.texture.magFilter
        },
        set: function(a) {
            console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
            this.texture.magFilter = a
        }
    },
    minFilter: {
        get: function() {
            console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
            return this.texture.minFilter
        },
        set: function(a) {
            console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
            this.texture.minFilter = a
        }
    },
    anisotropy: {
        get: function() {
            console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
            return this.texture.anisotropy
        },
        set: function(a) {
            console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
            this.texture.anisotropy = a
        }
    },
    offset: {
        get: function() {
            console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
            return this.texture.offset
        },
        set: function(a) {
            console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
            this.texture.offset = a
        }
    },
    repeat: {
        get: function() {
            console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
            return this.texture.repeat
        },
        set: function(a) {
            console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
            this.texture.repeat = a
        }
    },
    format: {
        get: function() {
            console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
            return this.texture.format
        },
        set: function(a) {
            console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
            this.texture.format = a
        }
    },
    type: {
        get: function() {
            console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
            return this.texture.type
        },
        set: function(a) {
            console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
            this.texture.type = a
        }
    },
    generateMipmaps: {
        get: function() {
            console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
            return this.texture.generateMipmaps
        },
        set: function(a) {
            console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
            this.texture.generateMipmaps = a
        }
    }
});
Object.defineProperties(WebVRManager$$module$node_modules$three$build$three.prototype, {
    standing: {
        set: function() {
            console.warn("THREE.WebVRManager: .standing has been removed.")
        }
    }
});
module$node_modules$three$build$three.default.Audio.prototype.load = function(a) {
    console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
    var b = this;
    (new module$node_modules$three$build$three.default.AudioLoader).load(a, function(a) {
        b.setBuffer(a)
    });
    return this
};
module$node_modules$three$build$three.default.AudioAnalyser.prototype.getData = function() {
    console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
    return this.getFrequencyData()
};
module$node_modules$three$build$three.default.CubeCamera.prototype.updateCubeMap = function(a, b) {
    console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
    return this.update(a, b)
};
module$node_modules$three$build$three.default.GeometryUtils = {
    merge: function(a, b, c) {
        console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
        if (b.isMesh) {
            b.matrixAutoUpdate && b.updateMatrix();
            var d = b.matrix;
            b = b.geometry
        }
        a.merge(b, d, c)
    },
    center: function(a) {
        console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.");
        return a.center()
    }
};
module$node_modules$three$build$three.default.ImageUtils.crossOrigin = void 0;
module$node_modules$three$build$three.default.ImageUtils.loadTexture = function(a, b, c, d) {
    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
    var e = new module$node_modules$three$build$three.default.TextureLoader;
    e.setCrossOrigin(this.crossOrigin);
    a = e.load(a, c, void 0, d);
    b && (a.mapping = b);
    return a
};
module$node_modules$three$build$three.default.ImageUtils.loadTextureCube = function(a, b, c, d) {
    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
    var e = new module$node_modules$three$build$three.default.CubeTextureLoader;
    e.setCrossOrigin(this.crossOrigin);
    a = e.load(a, c, void 0, d);
    b && (a.mapping = b);
    return a
};
module$node_modules$three$build$three.default.ImageUtils.loadCompressedTexture = function() {
    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
};
module$node_modules$three$build$three.default.ImageUtils.loadCompressedTextureCube = function() {
    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
};
module$node_modules$three$build$three.default.SceneUtils = {
    createMultiMaterialObject: function() {
        console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
    },
    detach: function() {
        console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
    },
    attach: function() {
        console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
    }
};
module$node_modules$three$build$three.default.CubeGeometry = module$node_modules$three$build$three.default.BoxGeometry;
Object.defineProperty(module$node_modules$three$build$three.default, "__esModule", {
    value: !0
});
var module$src$3d$materials$Reflector = {},
    THREE$$module$src$3d$materials$Reflector = module$src$externals$three.default,
    Shaders$$module$src$3d$materials$Reflector = module$src$3d$shaders$ShaderFile.default;
module$src$externals$three.default = module$node_modules$three$build$three.default;
module$src$externals$three.default.Reflector = function(a, b) {
    module$src$externals$three.default.Mesh.call(this, a);
    this.type = "Reflector";
    var c = this;
    b = b || {};
    a = void 0 !== b.color ? new module$src$externals$three.default.Color(b.color) : new module$src$externals$three.default.Color(8355711);
    var d = b.textureWidth || 512,
        e = b.textureHeight || 512,
        f = b.clipBias || 0,
        g = void 0 !== b.recursion ? b.recursion : 0,
        h = new module$src$externals$three.default.Plane,
        k = new module$src$externals$three.default.Vector3,
        l = new module$src$externals$three.default.Vector3,
        p = new module$src$externals$three.default.Vector3,
        m = new module$src$externals$three.default.Matrix4,
        q = new module$src$externals$three.default.Vector3(0, 0, -1),
        r = new module$src$externals$three.default.Vector4,
        n = new module$src$externals$three.default.Vector4,
        t = new module$src$externals$three.default.Vector3,
        u = new module$src$externals$three.default.Vector3,
        w = new module$src$externals$three.default.Vector4,
        v = new module$src$externals$three.default.Matrix4,
        y = new module$src$externals$three.default.PerspectiveCamera,
        A = new module$src$externals$three.default.WebGLRenderTarget(d, e, {
            minFilter: module$src$externals$three.default.LinearFilter,
            magFilter: module$src$externals$three.default.LinearFilter,
            format: module$src$externals$three.default.RGBFormat,
            stencilBuffer: !1
        });
    module$src$externals$three.default.Math.isPowerOfTwo(d) && module$src$externals$three.default.Math.isPowerOfTwo(e) || (A.texture.generateMipmaps = !1);
    b = {
        uniforms: {
            color: {
                type: "c",
                value: null
            },
            tDiffuse: {
                type: "t",
                value: null
            },
            tDepth: {
                type: "t",
                value: null
            },
            textureMatrix: {
                type: "m4",
                value: null
            },
            worldPosition: {
                type: "v3",
                value: new module$src$externals$three.default.Vector3(0, 0, 0)
            },
            far: {
                type: "f",
                value: 1
            },
            threshold: {
                type: "f",
                value: 100
            }
        },
        fragmentShader: module$src$3d$shaders$ShaderFile.default.refl_frag,
        vertexShader: module$src$3d$shaders$ShaderFile.default.refl_vert
    };
    var x = new module$src$externals$three.default.ShaderMaterial(b),
        z = new module$src$externals$three.default.ShaderMaterial({
            uniforms: {
                far: {
                    type: "f",
                    value: 1
                }
            },
            vertexShader: module$src$3d$shaders$ShaderFile.default.world_z_vert,
            fragmentShader: module$src$3d$shaders$ShaderFile.default.world_z_frag
        }),
        B = new module$src$externals$three.default.WebGLRenderTarget(d, e, {
            minFilter: module$src$externals$three.default.NearestFilter,
            magFilter: module$src$externals$three.default.NearestFilter,
            format: module$src$externals$three.default.RGBAFormat,
            type: module$src$externals$three.default.FloatType
        });
    x.uniforms.tDiffuse.value = A.texture;
    x.uniforms.tDepth.value = B.texture;
    x.uniforms.color.value = a;
    x.uniforms.textureMatrix.value = v;
    x.uniforms.worldPosition.value =
        l;
    x.uniforms.threshold.value = c.threshold = .01;
    this.material = x;
    this.material.transparent = !0;
    this.onBeforeRender = function(a, b, d) {
        if ("recursion" in d.userData) {
            if (d.userData.recursion === g) return;
            d.userData.recursion++
        }
        x.uniforms.threshold.value = c.threshold;
        z.uniforms.far.value = d.far;
        x.uniforms.far.value = d.far;
        l.setFromMatrixPosition(c.matrixWorld);
        p.setFromMatrixPosition(d.matrixWorld);
        m.extractRotation(c.matrixWorld);
        k.set(0, 0, 1);
        k.applyMatrix4(m);
        t.subVectors(l, p);
        if (!(0 < t.dot(k))) {
            t.reflect(k).negate();
            t.add(l);
            m.extractRotation(d.matrixWorld);
            q.set(0, 0, -1);
            q.applyMatrix4(m);
            q.add(p);
            u.subVectors(l, q);
            u.reflect(k).negate();
            u.add(l);
            y.position.copy(t);
            y.up.set(0, 1, 0);
            y.up.applyMatrix4(m);
            y.up.reflect(k);
            y.lookAt(u);
            y.far = d.far;
            y.updateMatrixWorld();
            y.projectionMatrix.copy(d.projectionMatrix);
            y.userData.recursion = 0;
            v.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1);
            v.multiply(y.projectionMatrix);
            v.multiply(y.matrixWorldInverse);
            v.multiply(c.matrixWorld);
            h.setFromNormalAndCoplanarPoint(k, l);
            h.applyMatrix4(y.matrixWorldInverse);
            r.set(h.normal.x, h.normal.y, h.normal.z, h.constant);
            var e = y.projectionMatrix;
            w.x = (Math.sign(r.x) + e.elements[8]) / e.elements[0];
            w.y = (Math.sign(r.y) + e.elements[9]) / e.elements[5];
            w.z = -1;
            w.w = (1 + e.elements[10]) / e.elements[14];
            r.multiplyScalar(2 / r.dot(w));
            e.elements[2] = r.x;
            e.elements[6] = r.y;
            e.elements[10] = r.z + 1 - f;
            e.elements[14] = r.w;
            c.visible = !1;
            e = b.background;
            b.background = null;
            var N = a.getRenderTarget(),
                H = a.vr.enabled,
                K = a.shadowMap.autoUpdate,
                L = a.getClearColor().getHex(),
                F = a.getClearAlpha();
            a.vr.enabled = !1;
            a.shadowMap.autoUpdate = !1;
            a.render(b, y, A, !0);
            a.setClearColor(16777215, 1);
            b.overrideMaterial = z;
            a.render(b, y, B, !0);
            a.vr.enabled = H;
            a.shadowMap.autoUpdate = K;
            a.setClearColor(L, F);
            b.overrideMaterial = null;
            a.setRenderTarget(N);
            b.background = e;
            b = d.bounds;
            void 0 !== b && (d = a.getSize(), e = a.getPixelRatio(), n.x = b.x * d.width * e, n.y = b.y * d.height * e, n.z = b.z * d.width * e, n.w = b.w * d.height * e, a.state.viewport(n));
            c.visible = !0
        }
    };
    this.getRenderTarget = function() {
        return A
    }
};
module$src$externals$three.default.Reflector.prototype = Object.create(module$src$externals$three.default.Mesh.prototype);
module$src$externals$three.default.Reflector.prototype.constructor = module$src$externals$three.default.Reflector;
var module$src$3d$ThreeDManagerConstants = {},
    loggingConstants$$module$src$3d$ThreeDManagerConstants = module$src$shared$constants$LoggingConstants.default,
    loggingLevels$$module$src$3d$ThreeDManagerConstants = module$src$shared$constants$LoggingConstants.default.loggingLevels,
    cameraViewTypes$$module$src$3d$ThreeDManagerConstants = {
        MIN: 0,
        PERSPECTIVE: 0,
        TOP: 1,
        BOTTOM: 2,
        RIGHT: 3,
        LEFT: 4,
        BACK: 5,
        FRONT: 6,
        AR: 7,
        MAX: 7
    },
    defaultSettings$$module$src$3d$ThreeDManagerConstants = {
        fullscreen: !1,
        gridVisibility: !0,
        groundPlaneVisibility: !0,
        groundPlaneReflectionVisibility: !1,
        groundPlaneReflectionThreshold: .01,
        initialized: !1,
        render: {
            ambientOcclusion: !0,
            clearColor: "#ffffff",
            clearAlpha: 1,
            devicePixelRatio: 1,
            pointSize: 1,
            sao: {
                samples: 8,
                intensity: .1,
                kernelRadius: 8,
                standardDev: 25
            },
            shadows: !0
        },
        camera: {
            autoRotationSpeed: 1,
            cameraMovementDuration: 0,
            damping: .1,
            defaults: {
                perspective: {
                    position: {
                        x: 5,
                        y: 5,
                        z: 5
                    },
                    target: {
                        x: 0,
                        y: 0,
                        z: 0
                    }
                },
                orthographic: {
                    position: {
                        x: 5,
                        y: 5,
                        z: 5
                    },
                    target: {
                        x: 0,
                        y: 0,
                        z: 0
                    }
                }
            },
            enableAutoRotation: !1,
            enableKeyPan: !1,
            enableOrbitControls: !0,
            enablePan: !0,
            enableRotation: !0,
            enableZoom: !0,
            far: 100,
            fov: 45,
            keyPanSpeed: 1,
            near: .01,
            restrictions: {
                position: {
                    cube: {
                        min: {
                            x: -Infinity,
                            y: -Infinity,
                            z: -Infinity
                        },
                        max: {
                            x: Infinity,
                            y: Infinity,
                            z: Infinity
                        }
                    },
                    sphere: {
                        center: {
                            x: 0,
                            y: 0,
                            z: 0
                        },
                        radius: Infinity
                    }
                },
                target: {
                    cube: {
                        min: {
                            x: -Infinity,
                            y: -Infinity,
                            z: -Infinity
                        },
                        max: {
                            x: Infinity,
                            y: Infinity,
                            z: Infinity
                        }
                    },
                    sphere: {
                        center: {
                            x: 0,
                            y: 0,
                            z: 0
                        },
                        radius: Infinity
                    }
                },
                rotation: {
                    minPolarAngle: 0,
                    maxPolarAngle: 180,
                    minAzimuthAngle: -Infinity,
                    maxAzimuthAngle: Infinity
                },
                zoom: {
                    minDistance: 0,
                    maxDistance: Infinity
                }
            },
            rotationSpeed: .25,
            panSpeed: .5,
            type: cameraViewTypes$$module$src$3d$ThreeDManagerConstants.PERSPECTIVE,
            zoomExtentsFactor: 1,
            zoomSpeed: 1
        },
        lights: {
            light0: {
                type: 999,
                properties: {}
            },
            light1: {
                type: 0,
                properties: {
                    color: 6579300
                }
            },
            light2: {
                type: 1,
                properties: {
                    direction: {
                        x: .5774,
                        y: -.5774,
                        z: .5774
                    },
                    shadows: !0
                }
            },
            light3: {},
            light4: {},
            light5: {},
            light6: {},
            light7: {},
            light8: {},
            light9: {}
        },
        material: {
            environmentMapAsBackground: !1,
            environmentMap: "default"
        }
    },
    threeDManagerConstants$$module$src$3d$ThreeDManagerConstants = {
        defaultSettings: defaultSettings$$module$src$3d$ThreeDManagerConstants,
        loggingLevels: loggingLevels$$module$src$3d$ThreeDManagerConstants,
        cameraViewTypes: cameraViewTypes$$module$src$3d$ThreeDManagerConstants
    },
    GlobalUtils$$module$src$3d$ThreeDManagerConstants = module$src$shared$util$GlobalUtils.default;
module$src$3d$ThreeDManagerConstants.default = module$src$shared$util$GlobalUtils.default.deepCopy(threeDManagerConstants$$module$src$3d$ThreeDManagerConstants);
var module$src$3d$PathUtils = {},
    THREE$$module$src$3d$PathUtils = module$src$externals$three.default,
    GlobalUtils$$module$src$3d$PathUtils = module$src$shared$util$GlobalUtils.default,
    _sceneIndex$$module$src$3d$PathUtils = {},
    _scene$$module$src$3d$PathUtils = null,
    setScene$$module$src$3d$PathUtils = function(a) {
        _scene$$module$src$3d$PathUtils = a;
        _scene$$module$src$3d$PathUtils._sdIndexObj = _sceneIndex$$module$src$3d$PathUtils;
        _sceneIndex$$module$src$3d$PathUtils.obj = _scene$$module$src$3d$PathUtils
    },
    getChildByName$$module$src$3d$PathUtils =
    function(a, b) {
        a = a._sdIndexObj;
        return null == a ? null : module$src$shared$util$GlobalUtils.default.getAtPath(a, b + ".obj")
    },
    getOrCreateChild$$module$src$3d$PathUtils = function(a, b) {
        var c = a._sdIndexObj;
        if (null == c) return null;
        var d = getChildByName$$module$src$3d$PathUtils(a, b);
        null == d && (d = new module$src$externals$three.default.Object3D, d.SDLocalPath = b, a.add(d), c[b] = {
            obj: d
        }, d._sdIndexObj = c[b]);
        return d
    },
    getPathObject$$module$src$3d$PathUtils = function(a, b) {
        a = a || _scene$$module$src$3d$PathUtils;
        a = a._sdIndexObj;
        return null ==
            a ? null : module$src$shared$util$GlobalUtils.default.getAtPath(a, b + ".obj")
    },
    ensurePath$$module$src$3d$PathUtils = function(a, b) {
        b = b.split(".");
        b = $jscomp.makeIterator(b);
        for (var c = b.next(); !c.done; c = b.next()) a = getOrCreateChild$$module$src$3d$PathUtils(a, c.value);
        return a
    },
    deletePath$$module$src$3d$PathUtils = function(a, b) {
        a = getPathObject$$module$src$3d$PathUtils(a, b);
        if (null == a) return !0;
        b = a.SDLocalPath;
        if (null == b || !module$src$shared$util$GlobalUtils.default.typeCheck(b, "string") || "" == b) return !1;
        var c = a.parent;
        if (null == c) return !1;
        var d = c._sdIndexObj;
        if (null == d) return !1;
        c.remove(a);
        delete d[b];
        return !0
    },
    getObjectPath$$module$src$3d$PathUtils = function(a) {
        if (!a) return null;
        a.hasOwnProperty("SDLocalPath") || (a = a.parent);
        for (var b = []; a && a.hasOwnProperty("SDLocalPath");) b.push(a.SDLocalPath), a = a.parent;
        b.reverse();
        a = b.join(".");
        return "" === a ? null : a
    };
module$src$3d$PathUtils.default = {
    getChildByName: getChildByName$$module$src$3d$PathUtils,
    getOrCreateChild: getOrCreateChild$$module$src$3d$PathUtils,
    getPathObject: getPathObject$$module$src$3d$PathUtils,
    getObjectPath: getObjectPath$$module$src$3d$PathUtils,
    ensurePath: ensurePath$$module$src$3d$PathUtils,
    deletePath: deletePath$$module$src$3d$PathUtils,
    setScene: setScene$$module$src$3d$PathUtils
};
var module$src$3d$passes$SSAAPass = {},
    THREE$$module$src$3d$passes$SSAAPass = module$src$externals$three.default,
    Shaders$$module$src$3d$passes$SSAAPass = module$src$3d$shaders$ShaderFile.default;
module$src$3d$passes$SSAAPass.default = function(a) {
    var b = new module$src$externals$three.default.ShaderMaterial({
        uniforms: {
            tDiffuse: {
                value: null
            },
            opacity: {
                value: 1
            }
        },
        vertexShader: module$src$3d$shaders$ShaderFile.default.basic_vert,
        fragmentShader: module$src$3d$shaders$ShaderFile.default.copy_frag
    });
    b.premultipliedAlpha = !0;
    b.transparent = !0;
    b.blending = module$src$externals$three.default.AdditiveBlending;
    b.depthTest = !1;
    b.depthWrite = !1;
    var c = new module$src$externals$three.default.OrthographicCamera(-1, 1, 1, -1, 0, 1),
        d = new module$src$externals$three.default.Scene,
        e = new module$src$externals$three.default.Mesh(new module$src$externals$three.default.PlaneGeometry(2, 2), b);
    e.frustumCulled = !1;
    d.add(e);
    var f = new module$src$externals$three.default.WebGLRenderTarget(a.width, a.height, {
        minFilter: module$src$externals$three.default.LinearFilter,
        magFilter: module$src$externals$three.default.LinearFilter,
        format: module$src$externals$three.default.RGBAFormat
    });
    f.texture.name = "SSAAPass.sample";
    var g = [
        [
            [0, 0]
        ],
        [
            [4, 4],
            [-4, -4]
        ],
        [
            [-2, -6],
            [6, -2],
            [-6, 2],
            [2, 6]
        ],
        [
            [1, -3],
            [-1, 3],
            [5, 1],
            [-3, -5],
            [-5, 5],
            [-7, -1],
            [3, 7],
            [7, -7]
        ],
        [
            [1, 1],
            [-1, -3],
            [-3, 2],
            [4, -1],
            [-5, -2],
            [2, 5],
            [5, 3],
            [3, -5],
            [-2, 6],
            [0, -7],
            [-4, -6],
            [-6, 4],
            [-8, 0],
            [7, -4],
            [6, 7],
            [-7, -8]
        ],
        [
            [-4, -7],
            [-7, -5],
            [-3, -5],
            [-5, -4],
            [-1, -4],
            [-2, -2],
            [-6, -1],
            [-4, 0],
            [-7, 1],
            [-1, 2],
            [-6, 3],
            [-3, 3],
            [-7, 6],
            [-3, 6],
            [-5, 7],
            [-1, 7],
            [5, -7],
            [1, -6],
            [6, -5],
            [4, -4],
            [2, -3],
            [7, -2],
            [1, -1],
            [4, -1],
            [2, 1],
            [6, 2],
            [0, 4],
            [4, 4],
            [2, 5],
            [7, 5],
            [5, 6],
            [3, 7]
        ]
    ];
    this.render = function(a, k, l, p, m) {
        e = new module$src$externals$three.default.Mesh(new module$src$externals$three.default.PlaneGeometry(2,
            2), b);
        e.frustumCulled = !1;
        d.children.length = 0;
        d.add(e);
        var h = g[Math.max(0, Math.min(m, 5))];
        m = a.autoClear;
        a.autoClear = !1;
        var r = a.getClearColor().getHex(),
            n = a.getClearAlpha(),
            t = 1 / h.length;
        b.uniforms.tDiffuse.value = f.texture;
        h.forEach(function(e, g) {
            var m = t;
            l.setViewOffset && l.setViewOffset(p.width, p.height, .0625 * e[0], .0625 * e[1], p.width, p.height);
            m += .03125 * (-.5 + (g + .5) / h.length);
            b.uniforms.opacity.value = m;
            a.setClearColor(r, n);
            a.render(k, l, f, !0);
            0 === g && a.setClearColor(0, 0);
            a.render(d, c, p, 0 === g)
        });
        l.clearViewOffset &&
            l.clearViewOffset();
        a.autoClear = m;
        a.setClearColor(r, n)
    };
    this.dispose = function() {
        f && (f.dispose(), f = null)
    };
    this.setSize = function(a, b) {
        f.setSize(a, b)
    }
};
var module$src$3d$passes$SaoPass = {},
    THREE$$module$src$3d$passes$SaoPass = module$src$externals$three.default,
    Shaders$$module$src$3d$passes$SaoPass = module$src$3d$shaders$ShaderFile.default;
module$src$3d$passes$SaoPass.default = function(a) {
    function b(a, b) {
        for (var c = [], d = 0; d <= b; d++) c.push(Math.exp(-(d * d) / (2 * a * a)) / (Math.sqrt(2 * Math.PI) * a));
        return c
    }

    function c(a) {
        m.uniforms.cameraNear.value = a.near;
        m.uniforms.cameraFar.value = a.far;
        m.uniforms.cameraProjectionMatrix.value = a.projectionMatrix;
        m.uniforms.cameraInverseProjectionMatrix.value.getInverse(a.projectionMatrix);
        n.uniforms.cameraNear.value = a.near;
        n.uniforms.cameraFar.value = a.far;
        t.uniforms.cameraNear.value = a.near;
        t.uniforms.cameraFar.value =
            a.far
    }
    var d = a.settings,
        e = new module$src$externals$three.default.MeshDepthMaterial;
    e.depthPacking = module$src$externals$three.default.RGBADepthPacking;
    e.blending = module$src$externals$three.default.NoBlending;
    e.side = module$src$externals$three.default.DoubleSide;
    var f = new module$src$externals$three.default.MeshNormalMaterial;
    f.blending = module$src$externals$three.default.NoBlending;
    f.side = module$src$externals$three.default.DoubleSide;
    var g = new module$src$externals$three.default.WebGLRenderTarget(a.width,
            a.height, {
                minFilter: module$src$externals$three.default.NearestFilter,
                magFilter: module$src$externals$three.default.NearestFilter,
                format: module$src$externals$three.default.RGBAFormat
            }),
        h = g.clone(),
        k = g.clone(),
        l = g.clone(),
        p = {
            defines: {
                SAMPLES: d.getSetting("samples")
            },
            uniforms: {
                tDepth: {
                    type: "t",
                    value: null
                },
                tNormal: {
                    type: "t",
                    value: null
                },
                cameraNear: {
                    type: "f",
                    value: 1
                },
                cameraFar: {
                    type: "f",
                    value: 100
                },
                cameraProjectionMatrix: {
                    type: "m4",
                    value: new module$src$externals$three.default.Matrix4
                },
                cameraInverseProjectionMatrix: {
                    type: "m4",
                    value: new module$src$externals$three.default.Matrix4
                },
                scale: {
                    type: "f",
                    value: .1
                },
                kernelRadius: {
                    type: "f",
                    value: d.getSetting("kernelRadius")
                },
                size: {
                    type: "v2",
                    value: new module$src$externals$three.default.Vector2(a.width, a.height)
                },
                intensity: {
                    type: "f",
                    value: d.getSetting("intensity")
                }
            },
            vertexShader: module$src$3d$shaders$ShaderFile.default.basic_vert,
            fragmentShader: module$src$3d$shaders$ShaderFile.default.sao_frag
        },
        m = new module$src$externals$three.default.ShaderMaterial(p);
    m.uniforms.tDepth.value = h.texture;
    m.uniforms.tNormal.value = k.texture;
    m.needsUpdate = !0;
    p = {
        KERNEL_RADIUS: d.getSetting("kernelRadius")
    };
    a = {
        tAO: {
            type: "t",
            value: null
        },
        tDiffuse: {
            type: "t",
            value: null
        },
        tDepth: {
            type: "t",
            value: null
        },
        size: {
            type: "v2",
            value: new module$src$externals$three.default.Vector2(a.width, a.height)
        },
        sampleWeights: {
            type: "1fv",
            value: b(d.getSetting("standardDev"), d.getSetting("kernelRadius"))
        },
        orientation: {
            type: "i",
            value: 0
        },
        cameraNear: {
            type: "f",
            value: 10
        },
        cameraFar: {
            type: "f",
            value: 1E3
        }
    };
    var q = module$src$3d$shaders$ShaderFile.default.basic_vert,
        r = module$src$3d$shaders$ShaderFile.default.blur_frag,
        n = new module$src$externals$three.default.ShaderMaterial({
            uniforms: module$src$externals$three.default.UniformsUtils.clone(a),
            defines: p,
            vertexShader: q,
            fragmentShader: r
        });
    n.uniforms.tAO.value = g.texture;
    n.uniforms.tDepth.value = h.texture;
    n.uniforms.orientation.value = 0;
    var t = new module$src$externals$three.default.ShaderMaterial({
        uniforms: module$src$externals$three.default.UniformsUtils.clone(a),
        defines: p,
        vertexShader: q,
        fragmentShader: r
    });
    t.uniforms.tAO.value =
        l.texture;
    t.uniforms.tDepth.value = h.texture;
    t.uniforms.orientation.value = 1;
    var u = new module$src$externals$three.default.OrthographicCamera(-1, 1, 1, -1, 0, 1),
        w = new module$src$externals$three.default.Scene,
        v = new module$src$externals$three.default.Mesh(new module$src$externals$three.default.PlaneGeometry(2, 2), null);
    w.add(v);
    this.render = function(a, b, d, q, p) {
        c(d);
        b.traverse(function(a) {
            a.material && !a.material.renderAO && (a.wasItVisible = a.visible, a.visible = !1)
        });
        t.uniforms.tDiffuse.value = q.texture;
        t.needsUpdate = !0;
        q = b.background;
        b.background = null;
        var x = a.getClearColor().getHex(),
            r = a.getClearAlpha();
        a.setClearColor(16777215);
        b.overrideMaterial = e;
        a.render(b, d, h, !0);
        a.setClearColor(7829503);
        b.overrideMaterial = f;
        a.render(b, d, k, !0);
        a.setClearColor(x, r);
        v.material = m;
        a.render(w, u, g, !0);
        v.material = n;
        a.render(w, u, l, !0);
        v.material = t;
        a.render(w, u, p, !0);
        b.overrideMaterial = null;
        b.background = q;
        b.traverse(function(a) {
            a.material && !a.material.renderAO && (a.visible = a.wasItVisible)
        })
    };
    d.registerHook("samples", function(a) {
        m.defines.samples =
            a;
        m.needsUpdate = !0
    });
    d.registerHook("intensity", function(a) {
        m.uniforms.intensity.value = a
    });
    d.registerHook("kernelRadius", function(a) {
        n.defines.KERNEL_RADIUS = a;
        t.defines.KERNEL_RADIUS = a;
        n.uniforms.sampleWeights.value = b(d.getSetting("standardDev"), a);
        t.uniforms.sampleWeights.value = b(d.getSetting("standardDev"), a);
        n.needsUpdate = !0;
        t.needsUpdate = !0
    });
    d.registerHook("standardDev", function(a) {
        n.uniforms.sampleWeights.value = b(a, d.getSetting("kernelRadius"));
        t.uniforms.sampleWeights.value = b(a, d.getSetting("kernelRadius"))
    });
    this.setSize = function(a, b) {
        m.uniforms.size.value.set(a, b);
        n.uniforms.size.value.set(a, b);
        t.uniforms.size.value.set(a, b);
        g.setSize(a, b);
        h.setSize(a, b);
        k.setSize(a, b);
        l.setSize(a, b)
    }
};
var module$src$3d$handlers$subhandlers$BeautyRenderHandler = {},
    THREE$$module$src$3d$handlers$subhandlers$BeautyRenderHandler = module$src$externals$three.default,
    Shaders$$module$src$3d$handlers$subhandlers$BeautyRenderHandler = module$src$3d$shaders$ShaderFile.default,
    MessagePrototype$$module$src$3d$handlers$subhandlers$BeautyRenderHandler = module$src$shared$messages$MessagePrototype.default,
    messagingConstants$$module$src$3d$handlers$subhandlers$BeautyRenderHandler = module$src$shared$constants$MessagingConstants.default;
module$src$3d$handlers$subhandlers$BeautyRenderHandler.default = function(a) {
    function b(a) {
        g.traverse(function(b) {
            if (b.material && "TextGeometry" != b.geometry.type && "ShapeDiverStandardMaterial" == b.material.type && (null == b.material2 && (b.material2 = d.materialHandler.getMaterial(), b.material2.deepCopy(b.material), b.material2.defines.USE_PCSS_SHADOW = "", b.material2.softShadow = !0, b.material2.needsUpdate = !0), b.material.softShadow != a)) {
                var c = b.material;
                b.material = b.material2;
                b.material2 = c;
                for (var e in b.material2) "uuid" !=
                    e && "defines" != e && "vertexShader" != e && "fragmentShader" != e && "softShadow" != e && b.material[e] != b.material2[e] && (b.material[e] = b.material2[e], b.material.needsUpdate = !0);
                for (var f in b.material.defines) "USE_PCSS_SHADOW" == f || b.material2.defines[f] && b.material.defines[f] || (delete b.material.defines[f], b.material.needsUpdate = !0);
                for (var g in b.material2.defines) "USE_PCSS_SHADOW" == g || b.material2.defines[g] && b.material.defines[g] || (b.material.defines[g] = "", b.material.needsUpdate = !0)
            }
        })
    }

    function c(a, c) {
        d.renderingHandler.registerForContinuousRendering("beautyRenderBlending");
        w = performance.now();
        y = 0;
        u.uniforms.tStandard.value = a.texture;
        u.uniforms.tBeauty.value = c.texture;
        f.getSetting("shadows") && b(!1);
        h.render(g, d.cameraHandler.getCamera(), q, !0)
    }
    var d = this,
        e = {},
        f = a.settings,
        g = a.scene,
        h = a.renderer,
        k = h.getPixelRatio();
    a = h.getSize().width * k;
    k *= h.getSize().height;
    var l = !1;
    /(android)/i.test(navigator.userAgent) && -1 < navigator.userAgent.toLowerCase().indexOf("firefox") && (l = !0);
    var p = new module$src$3d$passes$SSAAPass.default({
            width: a,
            height: k
        }),
        m = new module$src$3d$passes$SaoPass.default({
            settings: f.getSection("sao"),
            width: a,
            height: k
        }),
        q = new module$src$externals$three.default.WebGLRenderTarget(a, k, {
            minFilter: module$src$externals$three.default.LinearFilter,
            magFilter: module$src$externals$three.default.LinearFilter,
            format: module$src$externals$three.default.RGBAFormat,
            stencilBuffer: !1
        });
    q.texture.name = "hidden.rt";
    var r = q.clone();
    r.texture.name = "standard.rt";
    var n = q.clone();
    n.texture.name = "ssaa.rt";
    var t = q.clone();
    t.texture.name = "ao.rt";
    var u = new module$src$externals$three.default.ShaderMaterial({
        uniforms: {
            tStandard: {
                value: null
            },
            tBeauty: {
                value: null
            },
            size: {
                type: "v2",
                value: new module$src$externals$three.default.Vector2(512, 512)
            },
            amount: {
                type: "f",
                value: 0
            }
        },
        vertexShader: module$src$3d$shaders$ShaderFile.default.basic_vert,
        fragmentShader: module$src$3d$shaders$ShaderFile.default.blend_frag
    });
    u.uniforms.tStandard.value = r.texture;
    u.uniforms.tBeauty.value = n.texture;
    u.uniforms.size.value.set(a, k);
    u.uniforms.amount.value = 0;
    var w, v, y = 0,
        A = new module$src$externals$three.default.OrthographicCamera(-1, 1, 1, -1, 0, 1),
        x = new module$src$externals$three.default.Scene;
    a = new module$src$externals$three.default.Mesh(new module$src$externals$three.default.PlaneGeometry(2, 2), u);
    x.add(a);
    e.renderStandard = function() {
        h.render(g, d.cameraHandler.getCamera());
        e.sanityCheck()
    };
    e.renderBeauty = function(a) {
        var k = f.getSetting("shadows"),
            l = f.getSetting("ambientOcclusion");
        h.render(g, d.cameraHandler.getCamera());
        p.render(h, g, d.cameraHandler.getCamera(), r, 2);
        k && b(!0);
        l ? (p.render(h, g, d.cameraHandler.getCamera(), n, 2), m.render(h, g, d.cameraHandler.getCamera(), n, t), a && h.render(g, d.cameraHandler.getCamera(),
            q, !0), c(r, t)) : k ? (p.render(h, g, d.cameraHandler.getCamera(), n, 2), a && h.render(g, d.cameraHandler.getCamera(), q, !0), c(r, n)) : h.render(g, d.cameraHandler.getCamera());
        e.sanityCheck()
    };
    e.renderBlending = function() {
        u.uniforms.amount.value = y;
        h.render(x, A, null, !0);
        if (!e.sanityCheck()) return d.renderingHandler.unregisterForContinuousRendering("beautyRenderBlending");
        v = performance.now();
        var a = (v - w) / 1E3;
        w = v;
        y += Math.min(a / 1.5, .1);
        1 <= y && (y = 0, d.renderingHandler.unregisterForContinuousRendering("beautyRenderBlending"),
            e.sanityCheck(), a = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.GENERIC), d.message(module$src$shared$constants$MessagingConstants.default.messageTopics.SCENE_RENDER_BEAUTY_END, a))
    };
    e.sanityCheck = function() {
        var a = !1;
        if (h.info && h.info.programs)
            for (var b = {
                    i: 0
                }, c = h.info.programs.length; b.i < c; b = {
                    i: b.i
                }, b.i++)
                if (h.info.programs[b.i].diagnostics && !1 === h.info.programs[b.i].diagnostics.runnable) {
                    a = !0;
                    d.warn("BeautyRenderHandler.sanityCheck",
                        "An error occured in the current material, fallback material gets activated. Some quality difference may be visible.");
                    for (var e = new module$src$externals$three.default.MeshBasicMaterial, f = "map color side alphaMap transparent opacity".split(" "), k = 0, l = f.length; k < l; k++) e[f[k]] = h.info.programs[b.i].diagnostics.material[f[k]];
                    e.shininess = 128 * e.metalness;
                    g.traverse(function(a) {
                        return function(b) {
                            b.material && b.material.program && b.material.program.id == h.info.programs[a.i].id && (b.material = e)
                        }
                    }(b));
                    delete h.info.programs[b.i].diagnostics
                }
        return !a
    };
    e.updateCustomUniforms = function() {
        g.traverse(function(a) {
            if (a.material && "ShapeDiverStandardMaterial" == a.material.type) {
                a.material.uniforms.lightWorldSize.value = a.material.lightWorldSize;
                a.material.uniforms.lightFrustum.value = a.material.lightFrustum;
                a.material.uniforms.shadowOpacity.value = a.material.shadowOpacity;
                a.material.uniforms.lightReflectivity.value = a.material.lightReflectivity;
                a.material.uniforms.threeDNoiseOpacity.value = a.material.threeDNoiseOpacity;
                a.material.uniforms.threeDNoiseID.value =
                    a.material.threeDNoiseID;
                a.material.uniforms.threeDNoiseScale.value = a.material.threeDNoiseScale;
                a.material.uniforms.threeDNoiseDistanceFade.value = a.material.threeDNoiseDistanceFade;
                if (0 < a.material.threeDNoiseOpacity && "" != a.material.defines["USE_3D_NOISE_F" + a.material.threeDNoiseID] && (0 <= a.material.threeDNoiseID && 3 >= a.material.threeDNoiseID || 999 == a.material.threeDNoiseID)) {
                    for (var b in a.material.defines) 0 === b.indexOf("USE_3D_NOISE_F") && delete a.material.defines[b];
                    a.material.defines["USE_3D_NOISE_F" +
                        a.material.threeDNoiseID] = "";
                    a.material.needsUpdate = !0
                }
                if (0 < a.material.threeDNoiseOpacity && "" != a.material.defines.USE_3D_NOISE) a.material.defines.USE_3D_NOISE = "", a.material.needsUpdate = !0, -1 == a.material.threeDNoiseID && (a.material.threeDNoiseID = 0, a.material.uniforms.threeDNoiseID.value = a.material.threeDNoiseID, a.material.defines.USE_3D_NOISE_F0 = "");
                else if (0 >= a.material.threeDNoiseOpacity && "" == a.material.defines.USE_3D_NOISE) {
                    for (var c in a.material.defines) 0 === c.indexOf("USE_3D_NOISE_F") && delete a.material.defines[c];
                    delete a.material.defines.USE_3D_NOISE;
                    a.material.needsUpdate = !0
                }
                b = (new module$src$externals$three.default.Matrix3).identity();
                a.material.map && (a.material.uniforms.uvTransformMap.value = a.material.map.uvTransform, a.material.map.matrix = b);
                a.material.specularMap && (a.material.uniforms.uvTransformSpecularMap.value = a.material.specularMap.uvTransform, a.material.specularMap.matrix = b);
                a.material.normalMap && (a.material.uniforms.uvTransformNormalMap.value = a.material.normalMap.uvTransform, a.material.normalMap.matrix =
                    b);
                a.material.bumpMap && (a.material.uniforms.uvTransformBumpMap.value = a.material.bumpMap.uvTransform, a.material.bumpMap.matrix = b);
                a.material.roughnessMap && (a.material.uniforms.uvTransformRoughnessMap.value = a.material.roughnessMap.uvTransform, a.material.roughnessMap.matrix = b);
                a.material.metalnessMap && (a.material.uniforms.uvTransformMetalnessMap.value = a.material.metalnessMap.uvTransform, a.material.metalnessMap.matrix = b);
                a.material.alphaMap && (a.material.uniforms.uvTransformAlphaMap.value = a.material.alphaMap.uvTransform,
                    a.material.alphaMap.matrix = b);
                a.material.emissiveMap && (a.material.uniforms.uvTransformEmissiveMap.value = a.material.emissiveMap.uvTransform, a.material.emissiveMap.matrix = b);
                if (a.material.additionalMaps) {
                    a.material.uniforms.mapsSize.value = a.material.additionalMaps.length;
                    0 < a.material.additionalMaps.length && "" != a.material.defines.USE_ADDITIONAL_MAPS && (a.material.defines.USE_ADDITIONAL_MAPS = "", a.material.needsUpdate = !0);
                    for (; 5 > a.material.mapPropertyType.length;) a.material.mapPropertyType.push(-1);
                    for (; 5 >
                        a.material.mapPropertyColor.length;) a.material.mapPropertyColor.push(new module$src$externals$three.default.Color(0));
                    for (; 5 > a.material.uvTransformAddMap.length;) a.material.uvTransformAddMap.push((new module$src$externals$three.default.Matrix3).identity());
                    a.material.uniforms.mapPropertyType.value = a.material.mapPropertyType;
                    a.material.uniforms.mapPropertyColor.value = a.material.mapPropertyColor;
                    a.material.uniforms.uvTransformAddMap.value = a.material.uvTransformAddMap;
                    b = 0;
                    for (c = a.material.additionalMaps.length; b <
                        c; b++) 0 == b && (a.material.uniforms.additionalMaps0.value = a.material.additionalMaps[b]), 1 == b && (a.material.uniforms.additionalMaps1.value = a.material.additionalMaps[b]), 2 == b && (a.material.uniforms.additionalMaps2.value = a.material.additionalMaps[b]), 3 == b && (a.material.uniforms.additionalMaps3.value = a.material.additionalMaps[b]), 4 == b && (a.material.uniforms.additionalMaps4.value = a.material.additionalMaps[b])
                } else a.material.uniforms.mapsSize.value = 0, "" == a.material.defines.USE_ADDITIONAL_MAPS && (delete a.material.defines.USE_ADDITIONAL_MAPS,
                    a.material.needsUpdate = !0);
                l && "" != a.material.defines.LOD_BLACK_LIST && (a.material.defines.LOD_BLACK_LIST = "", a.material.needsUpdate = !0)
            }
        })
    };
    e.setSize = function(a, b) {
        var c = h.getPixelRatio();
        a *= c;
        b *= c;
        m.setSize(a, b);
        p.setSize(a, b);
        q.setSize(a, b);
        r.setSize(a, b);
        n.setSize(a, b);
        t.setSize(a, b);
        u.uniforms.size.value.set(a, b)
    };
    return e
};
var module$src$3d$handlers$RenderingHandler = {},
    THREE$$module$src$3d$handlers$RenderingHandler = module$src$externals$three.default,
    TWEEN$$module$src$3d$handlers$RenderingHandler = module$node_modules$$tweenjs$tween_js$src$Tween.default,
    GlobalUtils$$module$src$3d$handlers$RenderingHandler = module$src$shared$util$GlobalUtils.default,
    toTinyColor$$module$src$3d$handlers$RenderingHandler = module$src$shared$util$toTinyColor.default;
module$src$3d$handlers$RenderingHandler.default = function(a) {
    function b() {
        f.registerForContinuousRendering("unregisteredResizeEvent", !1);
        setTimeout(function() {
            f.unregisterForContinuousRendering("unregisteredResizeEvent")
        }, 100)
    }

    function c() {
        u.clear();
        if (document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement || document.mozFullScreenElement) {
            var a = screen.width;
            var c = screen.height
        } else a = u.domElement.parentNode.offsetWidth, c = u.domElement.parentNode.offsetHeight;
        if (a !=
            l || c != p) b(), l = a, p = c, u.setSize(l, p), e.cameraHandler.updateCameraWithSize(l, p), e.beautyRenderHandler.setSize(l, p);
        e.beautyRenderHandler.updateCustomUniforms();
        1 == w && (w = !1, u.shadowMap.needsUpdate = !0)
    }

    function d(a) {
        requestAnimationFrame(d);
        module$node_modules$$tweenjs$tween_js$src$Tween.default.update(a)
    }
    var e = this,
        f = {},
        g = a.settings,
        h = a.scene,
        k = a.canvas,
        l = k.offsetWidth,
        p = k.offsetHeight,
        m = 0,
        q = !1,
        r = ["startUpId"],
        n = [],
        t = [],
        u = new module$src$externals$three.default.WebGLRenderer({
            antialias: !0,
            alpha: !0,
            preserveDrawingBuffer: !0
        });
    u.setSize(l, p);
    u.setPixelRatio(window.devicePixelRatio);
    u.setClearColor((0, module$src$shared$util$toTinyColor.default)(g.getSetting("clearColor"), "white").toThreeColor(), g.getSetting("clearAlpha"));
    u.shadowMap.enabled = !0;
    u.shadowMap.autoUpdate = !1;
    u.shadowMap.needsUpdate = !0;
    var w = !1;
    u.shadowMap.type = module$src$externals$three.default.PCFShadowMap;
    u.gammaFactor = 1;
    u.gammaInput = !1;
    u.gammaOutput = !0;
    a.canvas.classList.add("sd-canvas-internal");
    a.canvas.appendChild(u.domElement);
    var v = 0;
    window.onresize =
        function() {
            f.registerForContinuousRendering("registeredResizeEvent");
            clearTimeout(v);
            v = setTimeout(function() {
                f.unregisterForContinuousRendering("registeredResizeEvent");
                f.render()
            }, 250)
        };
    e.beautyRenderHandler = module$src$3d$handlers$subhandlers$BeautyRenderHandler.default.call(e, {
        settings: g,
        scene: h,
        renderer: u
    });
    document.body.addEventListener("resize", function() {
        f.render()
    });
    requestAnimationFrame(d);
    f.render = function(a) {
        !e.cameraHandler || 0 != r.length || a && 0 != n.length || (m = 0 == n.length && 1 == t.length && a &&
            -1 != t.indexOf("beautyRenderBlending") ? 2 : 0 == n.length && 0 == t.length ? 1 : 0, 0 == m ? (requestAnimationFrame(function() {
                c();
                e.beautyRenderHandler.renderStandard()
            }), -1 != t.indexOf("beautyRenderBlending") && f.unregisterForContinuousRendering("beautyRenderBlending")) : 2 == m ? requestAnimationFrame(function() {
                c();
                e.beautyRenderHandler.renderBlending()
            }) : 1 == m && requestAnimationFrame(function() {
                c();
                e.beautyRenderHandler.renderBeauty(!a)
            }))
    };
    f.registerForNoRendering = function(a, b) {
        void 0 !== a && (void 0 === b && (b = !1), b && f.render(),
            r.includes(a) || r.push(a))
    };
    f.unregisterForNoRendering = function(a) {
        a = r.indexOf(a); - 1 < a && r.splice(a, 1);
        0 == r.length && f.render()
    };
    f.registerForRestrictedRendering = function(a, b) {
        void 0 !== a && (void 0 === b && (b = !1), n.includes(a) || (n.push(a), b && f.render()))
    };
    f.unregisterForRestrictedRendering = function(a) {
        a = n.indexOf(a); - 1 < a && n.splice(a, 1)
    };
    f.processContinuousRenderingList = function(a) {
        !e.cameraHandler || !a && q || (e.cameraHandler.updateOrbitControls(), 0 < t.length || 0 == m ? (q = !0, f.render(!0), requestAnimationFrame(function() {
                f.processContinuousRenderingList(!0)
            })) :
            q = !1)
    };
    f.registerForContinuousRendering = function(a, b) {
        void 0 !== a && (void 0 === b && (b = !0), t.includes(a) || (t.push(a), b && f.processContinuousRenderingList()))
    };
    f.unregisterForContinuousRendering = function(a) {
        a = t.indexOf(a); - 1 < a && t.splice(a, 1)
    };
    f.updateShadowMap = function() {
        w = !0
    };
    f.getDomElement = function() {
        return u.domElement
    };
    f.getExtension = function(a) {
        return u.extensions.get(a)
    };
    a = function(a, b, c) {
        b !== c && f.render()
    };
    g.registerNotifier("shadows", a);
    g.registerNotifier("ambientOcclusion", a);
    g.registerHook("shadows",
        function(a) {
            if (!module$src$shared$util$GlobalUtils.default.typeCheck(a, "boolean", e.warn, "RenderingHandler.Hook->shadows")) return !1;
            e.lightHandler.setToggleLightShadows(a);
            return !0
        });
    g.registerHook("ambientOcclusion", function(a) {
        return module$src$shared$util$GlobalUtils.default.typeCheck(a, "boolean", e.warn, "RenderingHandler.Hook->ambientOcclusion") ? !0 : !1
    });
    g.registerHook("clearColor", function(a) {
        if (!module$src$shared$util$GlobalUtils.default.typeCheck(a, "color", e.warn, "RenderingHandler.Hook->clearColor")) return !1;
        u.setClearColor((0, module$src$shared$util$toTinyColor.default)(a).toThreeColor());
        f.render();
        return !0
    });
    g.registerHook("clearAlpha", function(a) {
        if (!module$src$shared$util$GlobalUtils.default.typeCheck(a, "notnegative", e.warn, "RenderingHandler.Hook->clearAlpha")) return !1;
        u.setClearAlpha(a);
        f.render();
        return !0
    });
    g.registerHook("pointSize", function(a) {
        if (!module$src$shared$util$GlobalUtils.default.typeCheck(a, "notnegative", e.warn, "RenderingHandler.Hook->pointSize")) return !1;
        h.traverse(function(b) {
            b.hasOwnProperty("material") &&
                b instanceof module$src$externals$three.default.Points && (b.material.size = a)
        });
        f.render();
        return !0
    });
    f.getScreenShot = function() {
        return u.domElement.toDataURL("image/png")
    };
    f.setBlur = function() {
        var a = null;
        return function(b, c) {
            null != c && c.hasOwnProperty("duration") ? (a = a || Promise.resolve(), a = a.then(function() {
                var a = {
                    r: b ? 0 : 3
                };
                return new Promise(function(d) {
                    (new module$node_modules$$tweenjs$tween_js$src$Tween.default.Tween(a)).to({
                        r: b ? 3 : 1
                    }, c.duration).onUpdate(function() {
                        u.domElement.style.filter = "blur(" +
                            a.r + "px)"
                    }).onComplete(function() {
                        u.domElement.style.filter = b ? "blur(3px)" : "";
                        d()
                    }).start()
                })
            })) : a = (a || Promise.resolve()).then(function() {
                u.domElement.style.filter = b ? "blur(3px)" : ""
            })
        }
    }();
    return f
};
var module$src$3d$materials$ShapeDiverStandardMaterial = {
        default: {}
    },
    THREE$$module$src$3d$materials$ShapeDiverStandardMaterial = module$src$externals$three.default,
    Shaders$$module$src$3d$materials$ShapeDiverStandardMaterial = module$src$3d$shaders$ShaderFile.default;
module$src$externals$three.default.ShapeDiverStandardMaterial = function(a) {
    module$src$externals$three.default.MeshStandardMaterial.call(this);
    this.defines = {
        STANDARD: ""
    };
    0 < a.threeDNoiseOpacity && (this.defines.USE_3D_NOISE = "", a.threeDNoiseID || (a.threeDNoiseID = 0), 0 <= a.threeDNoiseID && 3 > a.threeDNoiseID || 999 == a.threeDNoiseID) && (this.defines["USE_3D_NOISE_F" + a.threeDNoiseID] = "");
    this.uniforms = module$src$externals$three.default.UniformsUtils.merge([module$src$externals$three.default.UniformsLib.common, module$src$externals$three.default.UniformsLib.envmap,
        module$src$externals$three.default.UniformsLib.aomap, module$src$externals$three.default.UniformsLib.lightmap, module$src$externals$three.default.UniformsLib.bumpmap, module$src$externals$three.default.UniformsLib.normalmap, module$src$externals$three.default.UniformsLib.displacementmap, module$src$externals$three.default.UniformsLib.roughnessmap, module$src$externals$three.default.UniformsLib.metalnessmap, module$src$externals$three.default.UniformsLib.lights, {
            emissive: {
                value: new module$src$externals$three.default.Color(0)
            },
            roughness: {
                value: .5
            },
            metalness: {
                value: 0
            },
            envMapIntensity: {
                value: 1
            }
        }, {
            lightWorldSize: {
                value: .005
            },
            lightFrustum: {
                value: 6.5
            }
        }, {
            shadowOpacity: {
                value: 1
            }
        }, {
            lightReflectivity: {
                value: 1
            }
        }, {
            threeDNoiseOpacity: {
                value: 0
            },
            threeDNoiseID: {
                value: 0
            },
            threeDNoiseScale: {
                value: 1
            },
            threeDNoiseDistanceFade: {
                value: 0
            }
        }, {
            uvTransformMap: {
                type: "m3",
                value: (new module$src$externals$three.default.Matrix3).identity()
            },
            uvTransformBumpMap: {
                type: "m3",
                value: (new module$src$externals$three.default.Matrix3).identity()
            },
            uvTransformNormalMap: {
                type: "m3",
                value: (new module$src$externals$three.default.Matrix3).identity()
            },
            uvTransformSpecularMap: {
                type: "m3",
                value: (new module$src$externals$three.default.Matrix3).identity()
            },
            uvTransformAlphaMap: {
                type: "m3",
                value: (new module$src$externals$three.default.Matrix3).identity()
            },
            uvTransformEmissiveMap: {
                type: "m3",
                value: (new module$src$externals$three.default.Matrix3).identity()
            },
            uvTransformRoughnessMap: {
                type: "m3",
                value: (new module$src$externals$three.default.Matrix3).identity()
            },
            uvTransformMetalnessMap: {
                type: "m3",
                value: (new module$src$externals$three.default.Matrix3).identity()
            }
        }, {
            mapsSize: {
                type: "i",
                value: 0
            },
            additionalMaps0: {
                type: "t",
                value: null
            },
            additionalMaps1: {
                type: "t",
                value: null
            },
            additionalMaps2: {
                type: "t",
                value: null
            },
            additionalMaps3: {
                type: "t",
                value: null
            },
            additionalMaps4: {
                type: "t",
                value: null
            },
            mapPropertyType: {
                type: "iv1",
                value: [-1, -1, -1, -1, -1]
            },
            mapPropertyColor: {
                type: "v3v",
                value: [new module$src$externals$three.default.Color(0), new module$src$externals$three.default.Color(0), new module$src$externals$three.default.Color(0),
                    new module$src$externals$three.default.Color(0), new module$src$externals$three.default.Color(0)
                ]
            },
            uvTransformAddMap: {
                type: "m3v",
                value: [(new module$src$externals$three.default.Matrix3).identity(), (new module$src$externals$three.default.Matrix3).identity(), (new module$src$externals$three.default.Matrix3).identity(), (new module$src$externals$three.default.Matrix3).identity(), (new module$src$externals$three.default.Matrix3).identity()]
            }
        }
    ]);
    this.lightWorldSize = this.uniforms.lightWorldSize.value;
    this.lightFrustum =
        this.uniforms.lightFrustum.value;
    this.shadowOpacity = this.uniforms.shadowOpacity.value;
    this.lightReflectivity = this.uniforms.lightReflectivity.value;
    this.threeDNoiseID = this.uniforms.threeDNoiseID.value;
    this.threeDNoiseScale = this.uniforms.threeDNoiseScale.value;
    this.threeDNoiseDistanceFade = this.uniforms.threeDNoiseDistanceFade.value;
    this.threeDNoiseOpacity = this.uniforms.threeDNoiseOpacity.value;
    var b = (new module$src$externals$three.default.Matrix3).identity();
    a && (a.map && (this.uvTransformMap = a.map.uvTransform,
        a.map.matrix = b), a.specularMap && (this.uvTransformSpecularMap = a.specularMap.uvTransform, a.specularMap.matrix = b), a.normalMap && (this.uvTransformNormalMap = a.normalMap.uvTransform, a.normalMap.matrix = b), a.bumpMap && (this.uvTransformBumpMap = a.bumpMap.uvTransform, a.bumpMap.matrix = b), a.roughnessMap && (this.uvTransformRoughnessMap = a.roughnessMap.uvTransform, a.roughnessMap.matrix = b), a.metalnessMap && (this.uvTransformMetalnessMap = a.metalnessMap.uvTransform, a.metalnessMap.matrix = b), a.alphaMap && (this.uvTransformAlphaMap =
        a.alphaMap.uvTransform, a.alphaMap.matrix = b), a.emissiveMap && (this.uvTransformEmissiveMap = a.emissiveMap.uvTransform, a.emissiveMap.matrix = b));
    if (a && a.additionalMaps) {
        for (this.mapsSize = a.additionalMaps.length; 5 > a.mapPropertyType.length;) a.mapPropertyType.push(-1);
        for (; 5 > a.mapPropertyColor.length;) a.mapPropertyColor.push(new module$src$externals$three.default.Color(0));
        for (; 5 > a.uvTransformAddMap.length;) a.uvTransformAddMap.push((new module$src$externals$three.default.Matrix3).identity());
        this.mapPropertyType =
            a.mapPropertyType;
        this.mapPropertyColor = a.mapPropertyColor;
        this.uvTransformAddMap = a.uvTransformAddMap;
        this.additionalMaps = a.additionalMaps;
        b = 0;
        for (var c = a.additionalMaps.length; b < c; b++) 0 == b && (this.additionalMaps0 = a.additionalMaps[b]), 1 == b && (this.additionalMaps1 = a.additionalMaps[b]), 2 == b && (this.additionalMaps2 = a.additionalMaps[b]), 3 == b && (this.additionalMaps3 = a.additionalMaps[b]), 4 == b && (this.additionalMaps4 = a.additionalMaps[b])
    } else this.mapsSize = this.uniforms.mapsSize.value;
    this.vertexShader = module$src$3d$shaders$ShaderFile.default.standard_vert;
    this.fragmentShader = module$src$3d$shaders$ShaderFile.default.standard_frag;
    this.type = "ShapeDiverStandardMaterial";
    this.softShadow = !1;
    this.renderAO = a.renderAO;
    this.needsUpdate = !0;
    this.setValues(a)
};
module$src$externals$three.default.ShapeDiverStandardMaterial.prototype = Object.create(module$src$externals$three.default.MeshStandardMaterial.prototype);
module$src$externals$three.default.ShapeDiverStandardMaterial.prototype.constructor = module$src$externals$three.default.ShapeDiverStandardMaterial;
module$src$externals$three.default.ShapeDiverStandardMaterial.prototype.isMeshStandardMaterial = !0;
module$src$externals$three.default.ShapeDiverStandardMaterial.prototype.copy = function(a) {
    module$src$externals$three.default.MeshStandardMaterial.prototype.copy.call(this, a);
    this.defines = a.defines;
    this.uniforms = module$src$externals$three.default.UniformsUtils.clone(a.uniforms);
    this.type = a.type;
    this.softShadow = a.softShadow;
    this.renderAO = a.renderAO;
    return this
};
module$src$externals$three.default.ShapeDiverStandardMaterial.prototype.deepCopy = function(a) {
    module$src$externals$three.default.MeshStandardMaterial.prototype.copy.call(this, a);
    this.defines = Object.assign({}, a.defines);
    this.uniforms = module$src$externals$three.default.UniformsUtils.clone(a.uniforms);
    this.type = a.type;
    this.softShadow = a.softShadow;
    this.renderAO = a.renderAO;
    return this
};
var module$src$shared$materials$MaterialAttributes = {},
    tinycolor$$module$src$shared$materials$MaterialAttributes = module$node_modules$tinycolor2$tinycolor.default,
    THREE$$module$src$shared$materials$MaterialAttributes = module$src$externals$three.default,
    toTinyColor$$module$src$shared$materials$MaterialAttributes = module$src$shared$util$toTinyColor.default,
    loadTexture$$module$src$shared$materials$MaterialAttributes = module$src$shared$singletons$TextureLoader.default.loadTexture,
    GlobalUtils$$module$src$shared$materials$MaterialAttributes =
    module$src$shared$util$GlobalUtils.default;
module$src$shared$materials$MaterialAttributes.default = function() {
    var a = this,
        b = null;
    this.getAlphaMap = function() {
        return b
    };
    this.setAlphaMap = function(a) {
        b = a
    };
    var c = 0;
    this.setAlphaThreshold = function(a) {
        c = a
    };
    this.getAlphaThreshold = function() {
        return c
    };
    var d = null;
    this.getBumpMap = function() {
        return d
    };
    this.setBumpMap = function(a) {
        d = a
    };
    var e = (0, module$src$shared$util$toTinyColor.default)("ffffffff");
    this.getTinyColor = function() {
        return e && e.isValid() ? e.clone() : null
    };
    this.getColorInModelViewInterfaceFormat =
        function() {
            return e.isValid() ? e.toHex8String().replace("#", "0x") : null
        };
    this.getThreeColor = function() {
        return e.isValid() ? e.toThreeColor() : null
    };
    this.setColor = function(a) {
        a = a instanceof module$node_modules$tinycolor2$tinycolor.default ? a.clone() : (0, module$src$shared$util$toTinyColor.default)(a);
        return a.isValid() ? (e = a, !0) : !1
    };
    var f = !1;
    this.getFlatShading = function() {
        return f
    };
    this.setFlatShading = function(a) {
        f = module$src$shared$util$GlobalUtils.default.toBoolean(a)
    };
    var g = 1;
    this.setLightReflectivity = function(a) {
        g =
            a
    };
    this.getLightReflectivity = function() {
        return g
    };
    var h = null;
    this.getMap = function() {
        return h
    };
    this.setMap = function(a) {
        h = a
    };
    var k = 0;
    this.setMetalness = function(a) {
        k = a
    };
    this.getMetalness = function() {
        return k
    };
    var l = null;
    this.getMetalnessMap = function() {
        return l
    };
    this.setMetalnessMap = function(a) {
        l = a
    };
    var p = null;
    this.getNormalMap = function() {
        return p
    };
    this.setNormalMap = function(a) {
        p = a
    };
    var m = .5;
    this.setRoughness = function(a) {
        m = a
    };
    this.getRoughness = function() {
        return m
    };
    var q = null;
    this.setRoughnessMap = function(a) {
        q =
            a
    };
    this.getRoughnessMap = function() {
        return q
    };
    var r = 1;
    this.setShadowOpacity = function(a) {
        r = a
    };
    this.getShadowOpacity = function() {
        return r
    };
    var n = module$src$externals$three.default.DoubleSide;
    this.setSide = function(a) {
        if (a === module$src$externals$three.default.DoubleSide || a == module$src$externals$three.default.FrontSide || a == module$src$externals$three.default.BackSide) n = a
    };
    this.getSide = function() {
        return n
    };
    var t = {};
    this.setThreeDNoise = function(a) {
        t = a
    };
    this.getThreeDNoise = function() {
        return t
    };
    var u = 0,
        w = !1;
    this.setTransparency = function(a) {
        u = Math.max(Math.min(1, a), 0)
    };
    this.getTransparency = function() {
        return u
    };
    this.setTransparent = function(a) {
        w = module$src$shared$util$GlobalUtils.default.toBoolean(a)
    };
    this.getTransparent = function() {
        return w
    };
    var v = function(b, c) {
        if (-1 == ["1.0", "2.0", "3.0"].indexOf(c)) return Promise.reject(Error("Material definition has unknown version."));
        switch (c) {
            case "1.0":
                if (b.hasOwnProperty("diffuse")) {
                    var d = (0, module$src$shared$util$toTinyColor.default)(b.diffuse);
                    d && d.isValid() && a.setColor(d)
                }
                break;
            default:
                b.hasOwnProperty("color") && (d = (0, module$src$shared$util$toTinyColor.default)(b.color)) && d.isValid() && a.setColor(d)
        }
        switch (c) {
            case "1.0":
                null != b.shine && a.setMetalness(Math.min(1, b.shine));
                null != b.shine && a.setRoughness(1 - Math.min(1, b.shine));
                break;
            default:
                b.hasOwnProperty("metalness") && (c = parseFloat(b.metalness), !isNaN(c) && isFinite(c) && a.setMetalness(c)), b.hasOwnProperty("roughness") && (c = parseFloat(b.roughness), !isNaN(c) && isFinite(c) && a.setRoughness(c))
        }
        b.hasOwnProperty("transparency") && (c =
            parseFloat(b.transparency), !isNaN(c) && isFinite(c) && (a.setTransparency(c), a.setTransparent(0 < c)));
        b.hasOwnProperty("alphaThreshold") && (c = parseFloat(b.alphaThreshold), !isNaN(c) && isFinite(c) && a.setAlphaThreshold(c));
        b.hasOwnProperty("shadowOpacity") && (c = parseFloat(b.shadowOpacity), !isNaN(c) && isFinite(c) && a.setShadowOpacity(c));
        b.hasOwnProperty("lightReflectivity") && (c = parseFloat(b.lightReflectivity), !isNaN(c) && isFinite(c) && a.setLightReflectivity(c));
        b.hasOwnProperty("threeDNoise") && (c = {}, c.opacity = b.threeDNoise.opacity ||
            0, c.noiseID = b.threeDNoise.noiseID || 0, c.scale = b.threeDNoise.scale || 1, c.distance = b.threeDNoise.distance || 0, a.setThreeDNoise(c));
        c = function(a) {
            "string" == typeof a && (a = {
                href: a
            });
            if (!a.hasOwnProperty("href") && !a.hasOwnProperty("canvas")) return Promise.reject(Error("Input object is not a valid JSON texture definition."));
            var b = {};
            b.offset = a.offset || [0, 0];
            b.repeat = a.repeat || [1, 1];
            b.rotation = a.rotation || 0;
            b.center = a.center || [0, 0];
            b.color = a.color || null;
            return (0, module$src$shared$singletons$TextureLoader.default.loadTexture)(a.href ||
                a.canvas, b).then(function(a) {
                if (b.color) {
                    var c = (0, module$src$shared$util$toTinyColor.default)(b.color);
                    c && c.isValid() && (a.SDColor = c)
                }
                return a
            }).catch(function(a) {
                return Promise.reject(a)
            })
        };
        if (b.hasOwnProperty("bitmaptexture"))
            if (Array.isArray(b.bitmaptexture)) {
                if (0 == b.bitmaptexture.length) return Promise.resolve(null);
                d = [];
                for (var e = $jscomp.makeIterator(b.bitmaptexture), f = e.next(); !f.done; f = e.next()) d.push(c(f.value));
                d = Promise.all(d).then(function(b) {
                    return a.setMap(b)
                }).catch(function() {
                    return Promise.resolve(null)
                })
            } else d =
                c(b.bitmaptexture).then(function(b) {
                    return a.setMap(b)
                }).catch(function() {
                    return Promise.resolve(null)
                });
        else d = Promise.resolve(null);
        e = b.hasOwnProperty("metalnesstexture") ? c(b.metalnesstexture).then(function(b) {
            a.setMetalnessMap(b)
        }).catch(function() {
            return Promise.resolve(null)
        }) : Promise.resolve(null);
        f = b.hasOwnProperty("roughnesstexture") ? c(b.roughnesstexture).then(function(b) {
            a.setRoughnessMap(b)
        }).catch(function() {
            return Promise.resolve(null)
        }) : Promise.resolve(null);
        var g = b.hasOwnProperty("bumptexture") ?
            c(b.bumptexture).then(function(b) {
                a.setBumpMap(b)
            }).catch(function() {
                return Promise.resolve(null)
            }) : Promise.resolve(null);
        var h = b.hasOwnProperty("normaltexture") ? c(b.normaltexture).then(function(b) {
            a.setNormalMap(b)
        }).catch(function() {
            return Promise.resolve(null)
        }) : Promise.resolve(null);
        c = b.hasOwnProperty("transparencytexture") ? c(b.transparencytexture).then(function(b) {
            a.setAlphaMap(b);
            a.setTransparent(!0)
        }).catch(function() {
            return Promise.resolve(null)
        }) : Promise.resolve(null);
        return Promise.all([e,
            f, d, g, h, c
        ]).then(function() {
            a._json = b;
            return a
        }).catch(function() {
            return Promise.reject(Error("Error loading textures."))
        })
    };
    this.fromJSONMaterialObject = function(a) {
        if (!a.hasOwnProperty("version")) return Promise.reject(Error("Material definition did not have version number defined"));
        if (a.hasOwnProperty("materialpreset")) {
            var b = module$src$shared$util$GlobalUtils.default.deepCopy(module$src$shared$materials$MaterialPresets.default.fromId(a.materialpreset));
            !a.hasOwnProperty("color") || 255 === parseInt(a.color[0]) &&
                255 === parseInt(a.color[1]) && 255 === parseInt(a.color[2]) || (b.color = a.color);
            a.hasOwnProperty("bitmaptexture") && (b.bitmaptexture = a.bitmaptexture);
            a.hasOwnProperty("bumptexture") && (b.bumptexture = a.bumptexture);
            return v(b, "2.0")
        }
        return v(a, a.version)
    };
    this.properties = Object.defineProperty(a, "properties", {
        configurable: !1,
        readable: !0,
        enumerable: !0,
        get: function() {
            var b = {
                    alphaMap: a.getAlphaMap(),
                    bumpMap: a.getBumpMap(),
                    color: a.getThreeColor(),
                    flatShading: a.getFlatShading(),
                    lightReflectivity: a.getLightReflectivity(),
                    metalness: a.getMetalness(),
                    metalnessMap: a.getMetalnessMap(),
                    normalMap: a.getNormalMap(),
                    roughness: a.getRoughness(),
                    roughnessMap: a.getRoughnessMap(),
                    opacity: 1 - a.getTransparency(),
                    shadowOpacity: a.getShadowOpacity(),
                    side: a.getSide(),
                    transparent: a.getTransparent()
                },
                c = a.getThreeDNoise();
            b.threeDNoiseOpacity = c.opacity || 0;
            b.threeDNoiseID = c.noiseID || 0;
            b.threeDNoiseScale = c.scale || 1;
            b.threeDNoiseDistanceFade = c.distance || 0;
            c = a.getMap();
            if (Array.isArray(c) && 0 < c.length) {
                if (b.map = c[0], 1 < c.length) {
                    b.additionalMaps = [];
                    b.mapPropertyType = [];
                    b.mapPropertyColor = [];
                    b.uvTransformAddMap = [];
                    for (var d = 1, e = c.length; d < e; ++d) {
                        var f = c[d];
                        b.additionalMaps.push(f);
                        b.mapPropertyType.push(f.hasOwnProperty("SDColor") ? 1 : 0);
                        var g = f.hasOwnProperty("SDColor") && f.SDColor ? f.SDColor.toThreeColor() : new module$src$externals$three.default.Color;
                        b.mapPropertyColor.push(g);
                        b.uvTransformAddMap.push(f.uvTransform)
                    }
                }
            } else b.map = c;
            return b
        }
    });
    this.clone = function() {
        var b = new module$src$shared$materials$MaterialAttributes.default;
        b.setAlphaMap(a.getAlphaMap());
        b.setBumpMap(a.getBumpMap());
        b.setColor(a.getTinyColor());
        b.setFlatShading(a.getFlatShading());
        b.setLightReflectivity(a.getLightReflectivity());
        b.setMap(a.getMap());
        b.setMetalness(a.getMetalness());
        b.setMetalnessMap(a.getMetalnessMap());
        b.setNormalMap(a.getNormalMap());
        b.setRoughness(a.getRoughness());
        b.setRoughnessMap(a.getRoughnessMap());
        b.setShadowOpacity(a.getShadowOpacity());
        b.setTransparency(a.getTransparency());
        b.setTransparent(a.getTransparent());
        b.setThreeDNoise(a.getThreeDNoise());
        b.setSide(a.getSide());
        return b
    };
    this.toMeshStandardMaterial = function() {
        return new module$src$externals$three.default.MeshStandardMaterial(a.properties)
    }
};
var module$src$3d$handlers$MaterialHandler = {},
    THREE$$module$src$3d$handlers$MaterialHandler = module$src$externals$three.default,
    MaterialAttributes$$module$src$3d$handlers$MaterialHandler = module$src$shared$materials$MaterialAttributes.default,
    Shaders$$module$src$3d$handlers$MaterialHandler = module$src$3d$shaders$ShaderFile.default,
    GlobalUtils$$module$src$3d$handlers$MaterialHandler = module$src$shared$util$GlobalUtils.default;
module$src$3d$handlers$MaterialHandler.default = function(a) {
    function b(a, b) {
        return new Promise(function(c, d) {
            (new module$src$externals$three.default.CubeTextureLoader).load(b, function(b) {
                b.format = module$src$externals$three.default.RGBFormat;
                b.mapping = module$src$externals$three.default.CubeReflectionMapping;
                q && (b.generateMipmaps = !1, b.minFilter = module$src$externals$three.default.LinearFilter, b.magFilter = module$src$externals$three.default.LinearFilter);
                c({
                    name: a,
                    map: b
                })
            }, null, function(a) {
                d(a)
            })
        })
    }

    function c(a) {
        p =
            a.map;
        f.getSetting("environmentMapAsBackground") && (g.background = p);
        g.traverse(function(a) {
            a.material && "ShapeDiverStandardMaterial" == a.material.type && (a.material.envMap = p, a.material.needsUpdate = !0)
        });
        d.renderingHandler.render()
    }
    var d = this,
        e = {},
        f = a.settings,
        g = a.scene,
        h = "default default_bw blurred_lights georgentor georgentor_blur georgentor_blue_blur georgentor_bw_blur mountains ocean piazza_san_marco room_abstract_1 sky storage_room storm subway_entrance subway_entrance_bw_blur white yokohama".split(" "),
        k = ["levelsets"],
        l = "px nx pz nz py ny".split(" "),
        p = null,
        m = [],
        q = !1;
    d.renderingHandler.getExtension("EXT_shader_texture_lod") || (q = !0);
    var r = .005,
        n = 6.5;
    e.adjustToBoundingSphere = function(a) {
        r = a.radius / 25 * .005;
        n = a.radius / 25 * 6.5;
        g.traverse(function(a) {
            a.material && "ShapeDiverStandardMaterial" == a.material.type && (a.material.lightWorldSize = r, a.material.lightFrustum = n)
        })
    };
    f.registerHook("environmentMap", function(a) {
        if (void 0 === a) return d.warn("MaterialHandler.setEnvironmentMap", "No input was provided, the environment map was not set."),
            Promise.resolve(!1);
        if (module$src$shared$util$GlobalUtils.default.typeCheck(a, "string")) var e = a.toLowerCase().replace(/ /g, "_");
        else if (Array.isArray(a)) {
            var f = a;
            if (6 !== f.length) return d.warn("MaterialHandler.setEnvironmentMap", "The number of URLs was not 6, the environment map was not set."), Promise.resolve(!1);
            e = JSON.stringify(f, null, 0)
        }
        for (var g = $jscomp.makeIterator(m), n = g.next(); !n.done; n = g.next())
            if (n = n.value, n.name === a) return c(n), Promise.resolve(!0);
        if (void 0 === f)
            if (f = [], 0 <= h.indexOf(e))
                for (a =
                    0; a < l.length; a++) f.push("https://d363mqea3saz7f.cloudfront.net/envmaps/" + e + "/" + l[a] + ".jpg");
            else if (0 <= k.indexOf(e))
            for (a = 0; a < l.length; a++) f.push("https://d363mqea3saz7f.cloudfront.net/envmaps/" + e + "/" + l[a] + ".png");
        else
            for (a = 0; a < l.length; a++) f.push("https://d363mqea3saz7f.cloudfront.net/envmaps/default/" + l[a] + ".jpg");
        return b(e, f).then(function(a) {
            m.push(a);
            c(a);
            return !0
        }, function() {
            d.warn("MaterialHandler.setEnvironmentMap", "Was not able to load the environment map, the environment map was not set.");
            return !1
        })
    });
    f.updateSettingAsync("environmentMap", f.getSetting("environmentMap"));
    e.getEnvironmentMap = function() {
        return p
    };
    f.registerHook("environmentMapAsBackground", function(a) {
        if (!module$src$shared$util$GlobalUtils.default.typeCheck(a, "boolean", d.warn, "MaterialHandler.Hook->environmentMapAsBackground")) return !1;
        if (d.getSetting("groundPlaneReflectionVisibility") && a) return d.warn("MaterialHandler.Hook->environmentMapAsBackground", "The ground plane reflection and the environment as background do not work together right now."), !1;
        g.background = a ? p : null;
        d.renderingHandler.render();
        return !0
    });
    e.getMaterial = function(a) {
        null == a && (a = {});
        return new module$src$externals$three.default.ShapeDiverStandardMaterial(Object.assign(a, {
            lightWorldSize: r,
            lightFrustum: n,
            envMap: p,
            renderAO: !0
        }))
    };
    e.SDSMfromProperties = function(a) {
        return e.getMaterial(a)
    };
    e.SDSMfromJSON = function(a) {
        var b = new module$src$shared$materials$MaterialAttributes.default;
        return b.fromJSONMaterialObject(a).then(function() {
            return e.getMaterial(b.properties)
        }).catch(function(a) {
            return Promise.reject(a)
        })
    };
    e.changeNoiseFunction = function(a) {
        g.traverse(function(b) {
            b.material && "ShapeDiverStandardMaterial" == b.material.type && (b.material.fragmentShader = module$src$3d$shaders$ShaderFile.default.standard_frag.replace("vec3 noise(vec3 m) { return vec3(0); }", a), b.material.needsUpdate = !0, b.material2.fragmentShader = module$src$3d$shaders$ShaderFile.default.standard_frag.replace("vec3 noise(vec3 m) { return vec3(0); }", a), b.material2.needsUpdate = !0)
        });
        d.renderingHandler.render()
    };
    return e
};
var module$src$3d$controls$OrbitControls = {
        default: {}
    },
    THREE$$module$src$3d$controls$OrbitControls = module$src$externals$three.default;
module$src$externals$three.default.OrbitControls = function(a, b) {
    function c() {
        return Math.pow(.95, n.zoomSpeed)
    }

    function d(a) {
        n.object instanceof module$src$externals$three.default.PerspectiveCamera ? B = a : n.object instanceof module$src$externals$three.default.OrthographicCamera ? N = a : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1)
    }

    function e(a) {
        if (!1 !== n.enabled) {
            a.preventDefault();
            if (a.button === n.mouseButtons.ORBIT) {
                if (!1 === n.enableRotation) return;
                D.set(a.clientX, a.clientY);
                y = v.ROTATE
            } else if (a.button === n.mouseButtons.ZOOM) {
                if (!1 === n.enableZoom) return;
                M.set(a.clientX, a.clientY);
                y = v.DOLLY
            } else if (a.button === n.mouseButtons.PAN) {
                if (!1 === n.enablePan) return;
                T.set(a.clientX, a.clientY);
                y = v.PAN
            }
            y !== v.NONE && (document.addEventListener("mousemove", f, {
                passive: !1
            }, !1), document.addEventListener("mouseup", g, {
                passive: !1
            }, !1), document.addEventListener("mouseout", g, {
                passive: !1
            }, !1), n.dispatchEvent(u))
        }
    }

    function f(a) {
        !1 !== n.enabled && (a.preventDefault(), y === v.ROTATE ?
            !1 !== n.enableRotation && (I.set(a.clientX, a.clientY), G.subVectors(I, D), a = n.domElement === document ? n.domElement.body : n.domElement, 0 != a.clientWidth && 0 != a.clientHeight && (z.theta -= 2 * Math.PI * G.x / a.clientWidth * n.rotationSpeed, z.phi -= 2 * Math.PI * G.y / a.clientHeight * n.rotationSpeed, D.copy(I), n.update())) : y === v.DOLLY ? !1 !== n.enableZoom && (J.set(a.clientX, a.clientY), R.subVectors(J, M), 0 < R.y ? d(c()) : 0 > R.y && d(-c()), M.copy(J), n.update()) : y === v.PAN && !1 !== n.enablePan && (L.set(a.clientX, a.clientY), F.subVectors(L, T), O(F.x * n.panSpeed,
                F.y * n.panSpeed), T.copy(L), n.update()))
    }

    function g(a) {
        !1 !== n.enabled && (document.removeEventListener("mousemove", f, !1), document.removeEventListener("mouseup", g, !1), document.removeEventListener("mouseout", g, !1), n.dispatchEvent(w), y = v.NONE)
    }

    function h(a) {
        if (!1 !== n.enabled && !1 !== n.enableZoom && (y === v.NONE || y === v.ROTATE)) {
            a.preventDefault();
            a.stopPropagation();
            var b = 0;
            a.wheelDelta !== r ? b = a.wheelDelta : a.detail !== r && (b = -a.detail);
            0 < b ? d(-(1 - c())) : 0 > b && d(1 - c());
            n.update();
            n.dispatchEvent(u);
            n.dispatchEvent(w)
        }
    }

    function k(a) {
        if (!1 !== n.enabled && !1 !== n.enableKeys && 0 != n.enableKeyPan && !1 !== n.enableKeyPan) switch (a.keyCode) {
            case n.keys.UP:
                O(0, n.keyPanSpeed);
                n.update();
                break;
            case n.keys.BOTTOM:
                O(0, -n.keyPanSpeed);
                n.update();
                break;
            case n.keys.LEFT:
                O(n.keyPanSpeed, 0);
                n.update();
                break;
            case n.keys.RIGHT:
                O(-n.keyPanSpeed, 0), n.update()
        }
    }

    function l(a) {
        if (!1 !== n.enabled) {
            switch (a.touches.length) {
                case 1:
                    if (!1 === n.enableRotation) return;
                    D.set(a.touches[0].pageX, a.touches[0].pageY);
                    y = v.TOUCH_ROTATE;
                    break;
                case 2:
                    if (!1 === n.enableZoom) return;
                    var b = a.touches[0].pageX - a.touches[1].pageX;
                    a = a.touches[0].pageY - a.touches[1].pageY;
                    M.set(0, Math.sqrt(b * b + a * a));
                    y = v.TOUCH_DOLLY;
                    break;
                case 3:
                    if (!1 === n.enablePan) return;
                    T.set(a.touches[0].pageX, a.touches[0].pageY);
                    y = v.TOUCH_PAN;
                    break;
                default:
                    y = v.NONE
            }
            y !== v.NONE && n.dispatchEvent(u)
        }
    }

    function p(a) {
        if (!1 !== n.enabled) switch (a.preventDefault(), a.stopPropagation(), a.touches.length) {
            case 1:
                if (!1 === n.enableRotation) break;
                if (y !== v.TOUCH_ROTATE) break;
                I.set(a.touches[0].pageX, a.touches[0].pageY);
                G.subVectors(I,
                    D);
                var b = n.domElement === document ? n.domElement.body : n.domElement;
                0 != b.clientWidth && 0 != b.clientHeight && (z.theta -= 2 * Math.PI * G.x / b.clientWidth * n.rotationSpeed, z.phi -= 2 * Math.PI * G.y / b.clientHeight * n.rotationSpeed, D.copy(I), n.update());
                break;
            case 2:
                if (!1 === n.enableZoom) break;
                if (y !== v.TOUCH_DOLLY) break;
                b = a.touches[0].pageX - a.touches[1].pageX;
                a = a.touches[0].pageY - a.touches[1].pageY;
                J.set(0, Math.sqrt(b * b + a * a));
                R.subVectors(J, M);
                0 < R.y ? d(-(1 - c())) : 0 > R.y && d(1 - c());
                M.copy(J);
                n.update();
                break;
            case 3:
                if (!1 === n.enablePan) break;
                if (y !== v.TOUCH_PAN) break;
                L.set(a.touches[0].pageX, a.touches[0].pageY);
                F.subVectors(L, T);
                O(F.x, F.y);
                T.copy(L);
                n.update();
                break;
            default:
                y = v.NONE
        }
    }

    function m(a) {
        !1 !== n.enabled && (n.dispatchEvent(w), y = v.NONE)
    }

    function q(a) {
        a.preventDefault()
    }
    var r;
    this.object = a;
    this.isMoving = !1;
    this.lastMove = 0;
    this.domElement = b !== r ? b : document;
    this.enabled = !0;
    this.target = new module$src$externals$three.default.Vector3;
    this.minDistance = 0;
    this.maxDistance = Infinity;
    this.minZoom = -Infinity;
    this.maxZoom = Infinity;
    this.minPolarAngle =
        0;
    this.maxPolarAngle = Math.PI;
    this.minAzimuthAngle = -Infinity;
    this.maxAzimuthAngle = Infinity;
    this.minPosition = new module$src$externals$three.default.Vector3(-Infinity, -Infinity, -Infinity);
    this.maxPosition = new module$src$externals$three.default.Vector3(Infinity, Infinity, Infinity);
    this.positionSphereCenter = new module$src$externals$three.default.Vector3(0, 0, 0);
    this.positionSphereRadius = Infinity;
    this.minTarget = new module$src$externals$three.default.Vector3(-Infinity, -Infinity, -Infinity);
    this.maxTarget = new module$src$externals$three.default.Vector3(Infinity,
        Infinity, Infinity);
    this.targetSphereCenter = new module$src$externals$three.default.Vector3(0, 0, 0);
    this.targetSphereRadius = Infinity;
    this.enableDamping = !1;
    this.rotateDampingFactor = this.zoomDampingFactor = this.panDampingFactor = .1;
    this.enableZoom = !0;
    this.zoomSpeed = 1;
    this.enableRotation = !0;
    this.rotationSpeed = 1;
    this.enablePan = !0;
    this.panSpeed = 1;
    this.enableKeyPan = !0;
    this.keyPanSpeed = 7;
    this.enableAutoRotation = !1;
    this.autoRotationSpeed = 2;
    this.enableKeys = !0;
    this.keys = {
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        BOTTOM: 40
    };
    this.mouseButtons = {
        ORBIT: module$src$externals$three.default.MOUSE.LEFT,
        PAN: module$src$externals$three.default.MOUSE.RIGHT
    };
    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.zoom0 = this.object.zoom;
    this.getPolarAngle = function() {
        return x.phi
    };
    this.getAzimuthalAngle = function() {
        return x.theta
    };
    this.reset = function() {
        n.target.copy(n.target0);
        n.object.position.copy(n.position0);
        n.object.zoom = n.zoom0;
        n.object.updateProjectionMatrix();
        n.dispatchEvent(t);
        this.isMoving = !0;
        this.lastMove = Date.now();
        n.update();
        y = v.NONE
    };
    this.update = function() {
        var b = new module$src$externals$three.default.Vector3,
            c = (new module$src$externals$three.default.Quaternion).setFromUnitVectors(a.up, new module$src$externals$three.default.Vector3(0, 1, 0)),
            d = c.clone().inverse(),
            e = new module$src$externals$three.default.Vector3,
            f = new module$src$externals$three.default.Quaternion;
        return function() {
            if (0 == n.domElement.parentNode.offsetWidth || 0 == n.domElement.parentNode.offsetHeight) return !1;
            var a = n.object.position;
            b.copy(a).sub(n.target);
            b.applyQuaternion(c);
            x.setFromVector3(b);
            n.enableAutoRotation && y === v.NONE && (z.theta = 0, z.theta -= 2 * Math.PI / 60 / 60 * n.autoRotationSpeed);
            x.theta += z.theta;
            x.phi += z.phi;
            x.theta > Math.PI ? (x.theta -= 2 * Math.PI, n.minAzimuthAngle > x.theta && (x.theta += 2 * Math.PI)) : x.theta < -Math.PI && (x.theta += 2 * Math.PI, n.maxAzimuthAngle < x.theta && (x.theta -= 2 * Math.PI));
            x.theta = Math.max(n.minAzimuthAngle, Math.min(n.maxAzimuthAngle, x.theta));
            x.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, x.phi));
            x.makeSafe();
            n.object instanceof
            module$src$externals$three.default.PerspectiveCamera ? x.radius *= 1 + B : n.object instanceof module$src$externals$three.default.OrthographicCamera && (n.object.left *= 1 + N, n.object.right *= 1 + N, n.object.top *= 1 + N, n.object.bottom *= 1 + N, n.object.scale = module$src$externals$three.default.Vector3(1 + N, 1 + N, 1 + N), n.object.updateProjectionMatrix());
            x.radius = Math.max(n.minDistance, Math.min(n.maxDistance, x.radius));
            n.target.add(K);
            n.target.setComponent(0, Math.max(n.minTarget.x, Math.min(n.maxTarget.x, n.target.x)));
            n.target.setComponent(1,
                Math.max(n.minTarget.y, Math.min(n.maxTarget.y, n.target.y)));
            n.target.setComponent(2, Math.max(n.minTarget.z, Math.min(n.maxTarget.z, n.target.z)));
            if (n.target.distanceTo(n.targetSphereCenter) > n.targetSphereRadius) {
                var g = (new module$src$externals$three.default.Vector3(n.target.x - n.targetSphereCenter.x, n.target.y - n.targetSphereCenter.y, n.target.z - n.targetSphereCenter.z)).normalize();
                n.target.setComponent(0, n.targetSphereCenter.x + g.x * n.targetSphereRadius);
                n.target.setComponent(1, n.targetSphereCenter.y +
                    g.y * n.targetSphereRadius);
                n.target.setComponent(2, n.targetSphereCenter.z + g.z * n.targetSphereRadius)
            }
            b.setFromSpherical(x);
            b.applyQuaternion(d);
            a.copy(n.target).add(b);
            a.setComponent(0, Math.max(n.minPosition.x, Math.min(n.maxPosition.x, a.x)));
            a.setComponent(1, Math.max(n.minPosition.y, Math.min(n.maxPosition.y, a.y)));
            a.setComponent(2, Math.max(n.minPosition.z, Math.min(n.maxPosition.z, a.z)));
            a.distanceTo(n.positionSphereCenter) > n.positionSphereRadius && (g = (new module$src$externals$three.default.Vector3(a.x -
                n.positionSphereCenter.x, a.y - n.positionSphereCenter.y, a.z - n.positionSphereCenter.z)).normalize(), a.setComponent(0, n.positionSphereCenter.x + g.x * n.positionSphereRadius), a.setComponent(1, n.positionSphereCenter.y + g.y * n.positionSphereRadius), a.setComponent(2, n.positionSphereCenter.z + g.z * n.positionSphereRadius));
            n.object.lookAt(n.target);
            !0 === n.enableDamping ? (z.theta *= 1 - n.rotateDampingFactor, z.phi *= 1 - n.rotateDampingFactor, K.x *= 1 - n.panDampingFactor, K.y *= 1 - n.panDampingFactor, K.z *= 1 - n.panDampingFactor, B *=
                1 - n.zoomDampingFactor, N *= 1 - n.zoomDampingFactor) : (z.set(0, 0, 0), K.set(0, 0, 0), N = B = 0);
            if (H || e.distanceToSquared(n.object.position) > A || 8 * (1 - f.dot(n.object.quaternion)) > A || n.object instanceof module$src$externals$three.default.OrthographicCamera && Math.abs(N) > A) return this.isMoving = !0, this.lastMove = Date.now(), e.copy(n.object.position), f.copy(n.object.quaternion), H = !1, n.dispatchEvent(t), !0;
            100 < Date.now() - this.lastMove && (this.isMoving = !1, K.set(0, 0, 0), z.set(0, 0, 0), N = B = 0, n.dispatchEvent(t));
            return !1
        }
    }();
    this.dispose =
        function() {
            n.domElement.removeEventListener("contextmenu", q, !1);
            n.domElement.removeEventListener("mousedown", e, !1);
            n.domElement.removeEventListener("touchstart", l, !1);
            n.domElement.removeEventListener("touchend", m, !1);
            n.domElement.removeEventListener("touchmove", p, !1);
            document.removeEventListener("mousemove", f, !1);
            document.removeEventListener("mouseup", g, !1);
            document.removeEventListener("mouseout",
                g, !1);
            window.removeEventListener("keydown", k, !1)
        };
    var n = this,
        t = {
            type: "change"
        },
        u = {
            type: "start"
        },
        w = {
            type: "end"
        },
        v = {
            NONE: -1,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2,
            TOUCH_ROTATE: 3,
            TOUCH_DOLLY: 4,
            TOUCH_PAN: 5
        },
        y = v.NONE,
        A = .001,
        x = new module$src$externals$three.default.Spherical,
        z = new module$src$externals$three.default.Spherical,
        B = 0,
        N = 0,
        K = new module$src$externals$three.default.Vector3,
        H = !1,
        D = new module$src$externals$three.default.Vector2,
        I = new module$src$externals$three.default.Vector2,
        G = new module$src$externals$three.default.Vector2,
        T = new module$src$externals$three.default.Vector2,
        L = new module$src$externals$three.default.Vector2,
        F = new module$src$externals$three.default.Vector2,
        M = new module$src$externals$three.default.Vector2,
        J = new module$src$externals$three.default.Vector2,
        R = new module$src$externals$three.default.Vector2,
        V = function() {
            var a = new module$src$externals$three.default.Vector3;
            return function(b, c) {
                a.setFromMatrixColumn(c, 0);
                a.multiplyScalar(-b);
                K.add(a)
            }
        }(),
        S = function() {
            var a = new module$src$externals$three.default.Vector3;
            return function(b, c) {
                a.setFromMatrixColumn(c, 1);
                a.multiplyScalar(b);
                K.add(a)
            }
        }(),
        O = function() {
            var a = new module$src$externals$three.default.Vector3;
            return function(b, c) {
                var d = n.domElement === document ? n.domElement.body : n.domElement;
                if (0 != d.clientWidth && 0 != d.clientHeight)
                    if (n.object instanceof module$src$externals$three.default.PerspectiveCamera) {
                        a.copy(n.object.position).sub(n.target);
                        var e = a.length();
                        e *= Math.tan(n.object.fov / 2 * Math.PI / 180);
                        V(2 * b * e / d.clientHeight, n.object.matrix);
                        S(2 * c * e / d.clientHeight,
                            n.object.matrix)
                    } else n.object instanceof module$src$externals$three.default.OrthographicCamera ? (V(b * (n.object.right - n.object.left) / n.object.zoom / d.clientWidth, n.object.matrix), S(c * (n.object.top - n.object.bottom) / n.object.zoom / d.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1)
            }
        }();
    n.domElement.addEventListener("contextmenu", q, {
        passive: !1
    }, !1);
    n.domElement.addEventListener("mousedown", e, {
        passive: !1
    }, !1);
    n.domElement.addEventListener("touchstart", l, {
        passive: !1
    }, !1);
    n.domElement.addEventListener("touchend", m, {
        passive: !1
    }, !1);
    n.domElement.addEventListener("touchmove", p, {
        passive: !1
    }, !1);
    window.addEventListener("keydown", k, {
        passive: !1
    }, !1);
    this.update()
};
module$src$externals$three.default.OrbitControls.prototype = Object.create(module$src$externals$three.default.EventDispatcher.prototype);
module$src$externals$three.default.OrbitControls.prototype.constructor = module$src$externals$three.default.OrbitControls;
Object.defineProperties(module$src$externals$three.default.OrbitControls.prototype, {
    center: {
        get: function() {
            console.warn("THREE.OrbitControls: .center has been renamed to .target");
            return this.target
        }
    },
    noZoom: {
        get: function() {
            console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.");
            return !this.enableZoom
        },
        set: function(a) {
            console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.");
            this.enableZoom = !a
        }
    },
    noRotate: {
        get: function() {
            console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotation instead.");
            return !this.enableRotation
        },
        set: function(a) {
            console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotation instead.");
            this.enableRotation = !a
        }
    },
    noPan: {
        get: function() {
            console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.");
            return !this.enablePan
        },
        set: function(a) {
            console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.");
            this.enablePan = !a
        }
    },
    noKeys: {
        get: function() {
            console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.");
            return !this.enableKeys
        },
        set: function(a) {
            console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.");
            this.enableKeys = !a
        }
    },
    staticMoving: {
        get: function() {
            console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.");
            return !this.enableDamping
        },
        set: function(a) {
            console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.");
            this.enableDamping = !a
        }
    },
    dynamicDampingFactor: {
        get: function() {
            console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.");
            return this.dampingFactor
        },
        set: function(a) {
            console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.");
            this.dampingFactor = a
        }
    }
});
var module$src$3d$handlers$CameraHandler = {},
    THREE$$module$src$3d$handlers$CameraHandler = module$src$externals$three.default,
    TWEEN$$module$src$3d$handlers$CameraHandler = module$node_modules$$tweenjs$tween_js$src$Tween.default,
    GlobalUtils$$module$src$3d$handlers$CameraHandler = module$src$shared$util$GlobalUtils.default,
    threeDManagerConstants$$module$src$3d$handlers$CameraHandler = module$src$3d$ThreeDManagerConstants.default;
module$src$3d$handlers$CameraHandler.default = function(a) {
    var b = this,
        c = {},
        d = a.settings,
        e = a.canvas,
        f = a.scene,
        g = new module$src$externals$three.default.PerspectiveCamera(d.getSetting("fov"), e.offsetWidth / e.offsetHeight, d.getSetting("near"), d.getSetting("far"));
    a = d.getSetting("defaults.perspective.position");
    g.position.set(a.x, a.y, a.z);
    g.up.set(0, 0, 1);
    f.add(g);
    var h = new module$src$externals$three.default.OrbitControls(g, b.renderingHandler.getDomElement());
    h.enableDamping = !0;
    h.dampingFactor = d.getSetting("damping");
    h.panDampingFactor = d.getSetting("damping");
    h.zoomDampingFactor = d.getSetting("damping");
    h.rotateDampingFactor = d.getSetting("damping");
    h.enableRotation = d.getSetting("enableRotation");
    h.rotationSpeed = d.getSetting("rotationSpeed");
    h.enableAutoRotation = d.getSetting("enableAutoRotation");
    h.autoRotationSpeed = d.getSetting("autoRotationSpeed");
    h.enableZoom = d.getSetting("enableZoom");
    h.zoomSpeed = d.getSetting("zoomSpeed");
    h.enablePan = d.getSetting("enablePan");
    h.panSpeed = d.getSetting("panSpeed");
    h.enableKeyPan =
        d.getSetting("enableKeyPan");
    h.keyPanSpeed = 7 * d.getSetting("keyPanSpeed");
    a = d.getSetting("defaults.perspective.target");
    h.target.set(a.x, a.y, a.z);
    h.addEventListener("change", function() {
        m == h && m.isMoving && b.renderingHandler.registerForContinuousRendering("cameraMoving")
    });
    var k = new module$src$externals$three.default.OrthographicCamera(-25, 25, 25, -25, .01, 1E4);
    a = d.getSetting("defaults.orthographic.position");
    k.position.set(a.x, a.y, a.z);
    k.up.set(0, 0, 1);
    var l = new module$src$externals$three.default.OrbitControls(k,
        b.renderingHandler.getDomElement());
    l.enableDamping = !0;
    l.dampingFactor = d.getSetting("damping");
    l.panDampingFactor = d.getSetting("damping");
    l.zoomDampingFactor = d.getSetting("damping");
    l.rotateDampingFactor = d.getSetting("damping");
    l.enableRotation = !1;
    l.enableAutoRotation = !1;
    l.enablePan = !0;
    l.enableKeyPan = !0;
    l.enableZoom = d.getSetting("enableZoom");
    l.zoomSpeed = d.getSetting("zoomSpeed");
    l.addEventListener("change", function() {
        m == l && m.isMoving && b.renderingHandler.registerForContinuousRendering("cameraMoving")
    });
    a = d.getSetting("defaults.orthographic.target");
    l.target.set(a.x, a.y, a.z);
    var p = g;
    var m = h;
    var q = new module$src$externals$three.default.Sphere;
    q.radius = 25;
    c.getCamera = function() {
        return p
    };
    c.updateOrbitControls = function() {
        m.update();
        b.renderingHandler.unregisterForContinuousRendering("cameraMoving");
        m.isMoving && b.renderingHandler.registerForContinuousRendering("cameraMoving", !1)
    };
    c.adjustToBoundingSphere = function(a) {
        q = a;
        k.left = -a.radius * g.aspect;
        k.bottom = -a.radius;
        k.right = a.radius * g.aspect;
        k.top = a.radius;
        k.far = 1E4 * a.radius;
        k.near = .01 * a.radius;
        k.updateProjectionMatrix();
        g.far = 100 * a.radius;
        g.near = .01 * a.radius;
        g.updateProjectionMatrix()
    };
    c.updateCameraWithSize = function(a, b) {
        g.aspect = a / b;
        g.setViewOffset(a, b, 0, 0, a, b);
        g.updateProjectionMatrix()
    };
    d.registerHook("fov", function(a) {
        if (!module$src$shared$util$GlobalUtils.default.typeCheck(a, "notnegative", b.warn, "CameraHandler.Hook->fov")) return !1;
        g.fov = a;
        g.updateProjectionMatrix();
        b.renderingHandler.render();
        return !0
    });
    c.resetCameraPosition = function() {
        return p instanceof
        module$src$externals$three.default.PerspectiveCamera ? c.setCameraPosition(d.getSetting("defaults.perspective.position")) : c.setCameraPosition(d.getSetting("defaults.orthographic.position"))
    };
    c.resetCameraTarget = function() {
        return p instanceof module$src$externals$three.default.PerspectiveCamera ? c.setCameraTarget(d.getSetting("defaults.perspective.target")) : c.setCameraTarget(d.getSetting("defaults.orthographic.target"))
    };
    c.resetCameraPositionAndTarget = function(a) {
        return p instanceof module$src$externals$three.default.PerspectiveCamera ?
            c.setCameraPositionAndTarget(d.getSetting("defaults.perspective.position"), d.getSetting("defaults.perspective.target"), a) : c.setCameraPositionAndTarget(d.getSetting("defaults.orthographic.position"), d.getSetting("defaults.orthographic.target"), a)
    };
    c.setCameraPosition = function(a) {
        if (!module$src$shared$util$GlobalUtils.default.typeCheck(a, "vector3obj", b.warn, "CameraHandler.setCameraPosition")) return !1;
        m.object.position.set(a.x, a.y, a.z);
        b.renderingHandler.render();
        return !0
    };
    c.getCameraPosition = function() {
        return module$src$shared$util$GlobalUtils.default.deepCopy(m.object.position)
    };
    c.setCameraTarget = function(a) {
        if (!module$src$shared$util$GlobalUtils.default.typeCheck(a, "vector3obj", b.warn, "CameraHandler.setCameraTarget")) return !1;
        m.target.set(a.x, a.y, a.z);
        b.renderingHandler.render();
        return !0
    };
    c.getCameraTarget = function() {
        return module$src$shared$util$GlobalUtils.default.deepCopy(m.target)
    };
    c.setCameraPositionAndTarget = function(a, d, e) {
        if (!module$src$shared$util$GlobalUtils.default.typeCheck(a, "vector3any", b.warn, "CameraHandler.setCameraPositionAndTarget") || !module$src$shared$util$GlobalUtils.default.typeCheck(d,
                "vector3any", b.warn, "CameraHandler.setCameraPositionAndTarget")) return Promise.resolve(!1);
        var f = module$src$shared$util$GlobalUtils.default.toVector3(a),
            g = module$src$shared$util$GlobalUtils.default.toVector3(d);
        e = e || {};
        var h = r(e);
        if (module$src$shared$util$GlobalUtils.default.typeCheck(h.duration, "notnegative")) return new Promise(function(a) {
            var e = m.object.position,
                k = m.target,
                l = e.clone().sub(k),
                n = f.clone().sub(g),
                q = l.clone().normalize();
            var p = "cylindrical" === h.coordinates ? new module$src$externals$three.default.Vector3(0,
                0, 1) : (new module$src$externals$three.default.Vector3).crossVectors(q, n);
            p.sub(q.clone().multiplyScalar(q.dot(p)));
            p.normalize();
            1E-12 > p.lengthSq() && (p.set(0, 0, 1), p.sub(q.clone().multiplyScalar(q.dot(p))), p.normalize());
            1E-12 > p.lengthSq() && (p.set(0, 1, 0), p.sub(q.clone().multiplyScalar(q.dot(p))), p.normalize());
            var r = (new module$src$externals$three.default.Vector3).crossVectors(p, q),
                x = (new module$src$externals$three.default.Matrix4).makeBasis(q, r, p);
            q = new module$src$externals$three.default.Matrix4;
            try {
                q.getInverse(x, !0)
            } catch (V) {
                q.identity(), x = q
            }
            l.applyMatrix4(q);
            n.applyMatrix4(q);
            l = module$src$shared$util$GlobalUtils.default.cartesianToPolar(l.x, l.y, l.z);
            n = module$src$shared$util$GlobalUtils.default.cartesianToPolar(n.x, n.y, n.z);
            var u = {
                dR: l[0],
                dTheta: l[1],
                dPhi: l[2],
                targetX: m.target.x,
                targetY: m.target.y,
                targetZ: m.target.z
            };
            (new module$node_modules$$tweenjs$tween_js$src$Tween.default.Tween(u)).easing(h.easing).to({
                dR: n[0],
                dTheta: n[1],
                dPhi: n[2],
                targetX: d.x,
                targetY: d.y,
                targetZ: d.z
            }, h.duration).onUpdate(function() {
                k.set(u.targetX,
                    u.targetY, u.targetZ);
                var a = module$src$shared$util$GlobalUtils.default.polarToCartesian(u.dR, u.dTheta, u.dPhi);
                a = module$src$shared$util$GlobalUtils.default.toVector3(a);
                a.applyMatrix4(x);
                a = k.clone().add(a);
                e.copy(a);
                c.updateOrbitControls();
                b.renderingHandler.render()
            }).onComplete(function() {
                e.copy(f);
                k.copy(g);
                c.updateOrbitControls();
                b.renderingHandler.render();
                a(!0)
            }).start()
        });
        m.object.position.copy(f);
        m.target.copy(g);
        b.renderingHandler.render();
        return Promise.resolve(!0)
    };
    var r = function(a) {
        var b = {};
        module$src$shared$util$GlobalUtils.default.typeCheck(a.duration, "notnegative") ? b.duration = a.duration : b.duration = d.getSetting("cameraMovementDuration");
        module$src$shared$util$GlobalUtils.default.typeCheck(a.coordinates, "string") && (b.coordinates = a.coordinates);
        "spherical" !== b.coordinates && "cylindrical" !== b.coordinates && (b.coordinates = "cylindrical");
        b.easing = null;
        void 0 !== a.easing && (module$src$shared$util$GlobalUtils.default.typeCheck(a.easing, "string") ? b.easing = module$src$shared$util$GlobalUtils.default.getAtPath(module$node_modules$$tweenjs$tween_js$src$Tween.default.Easing,
            a.easing) : "function" === typeof a.easing && (b.easing = a.easing));
        b.easing = b.easing || module$node_modules$$tweenjs$tween_js$src$Tween.default.Easing.Quartic.InOut;
        b.interpolation = null;
        void 0 !== a.interpolation && (module$src$shared$util$GlobalUtils.default.typeCheck(a.interpolation, "string") ? b.interpolation = module$src$shared$util$GlobalUtils.default.getAtPath(module$node_modules$$tweenjs$tween_js$src$Tween.default.Interpolation, a.interpolation) : "function" === typeof a.interpolation && (b.interpolation = a.interpolation));
        b.interpolation = b.interpolation || module$node_modules$$tweenjs$tween_js$src$Tween.default.Interpolation.CatmullRom;
        return b
    };
    c.setCameraPath = function(a, d, e) {
        var f, g;
        if (null == a && null == d) return Promise.resolve(!1);
        a = a || [];
        d = d || [];
        var h = $jscomp.makeIterator([a, d]);
        for (f = h.next(); !f.done; f = h.next()) {
            var k = f.value;
            if (!Array.isArray(k)) return Promise.resolve(!1);
            f = 0;
            for (g = k.length; f < g; ++f) {
                if (!module$src$shared$util$GlobalUtils.default.typeCheck(k[f], "vector3any", b.warn, "CameraHandler.setCameraPath")) return Promise.resolve(!1);
                k[f] = module$src$shared$util$GlobalUtils.default.toVector3(k[f])
            }
        }
        if (0 == a.length)
            for (f = 0, g = d.length; f < g; ++f) a.push({
                x: m.object.position.x,
                y: m.object.position.y,
                z: m.object.position.z
            });
        if (0 == d.length)
            for (f = 0, g = a.length; f < g; ++f) d.push({
                x: m.target.x,
                y: m.target.y,
                z: m.target.z
            });
        var l = r(e),
            n = module$src$shared$util$GlobalUtils.default.cartesianToPolar(m.object.position.x, m.object.position.y, m.object.position.z),
            q = [],
            p = [],
            x = [];
        a.forEach(function(a) {
            a = module$src$shared$util$GlobalUtils.default.cartesianToPolar(a.x,
                a.y, a.z);
            q.push(a[0]);
            p.push(a[1]);
            x.push(a[2])
        });
        var u = [],
            t = [],
            v = [];
        d.forEach(function(a) {
            u.push(a.x);
            t.push(a.y);
            v.push(a.z)
        });
        return new Promise(function(e) {
            var f = {
                objectR: n[0],
                objectTheta: n[1],
                objectPhi: n[2],
                targetX: m.target.x,
                targetY: m.target.y,
                targetZ: m.target.z
            };
            (new module$node_modules$$tweenjs$tween_js$src$Tween.default.Tween(f)).to({
                objectR: q,
                objectTheta: p,
                objectPhi: x,
                targetX: u,
                targetY: t,
                targetZ: v
            }, l.duration).onUpdate(function() {
                var a = module$src$shared$util$GlobalUtils.default.polarToCartesian(f.objectR,
                    f.objectTheta, f.objectPhi);
                m.object.position.set(a[0], a[1], a[2]);
                m.target.set(f.targetX, f.targetY, f.targetZ);
                c.updateOrbitControls();
                b.renderingHandler.render()
            }).onComplete(function() {
                var f = a.length - 1;
                m.object.position.set(a[f].x, a[f].y, a[f].z);
                f = d.length - 1;
                m.target.set(d[f].x, d[f].y, d[f].z);
                c.updateOrbitControls();
                b.renderingHandler.render();
                e(!0)
            }).easing(l.easing).interpolation(l.interpolation).start()
        })
    };
    c.isCameraMoving = function() {
        return m.isMoving
    };
    c.getCameraPositionAndTarget = function() {
        return {
            position: c.getCameraPosition(),
            target: c.getCameraTarget()
        }
    };
    d.registerHook("defaults.perspective.position", function(a) {
        return module$src$shared$util$GlobalUtils.default.typeCheck(a, "vector3obj", b.warn, "CameraHandler.Hook->defaults.perspective.position") ? Promise.resolve(!0) : Promise.resolve(!1)
    });
    d.registerHook("defaults.perspective.target", function(a) {
        return module$src$shared$util$GlobalUtils.default.typeCheck(a, "vector3obj", b.warn, "CameraHandler.Hook->defaults.perspective.target") ? Promise.resolve(!0) : Promise.resolve(!1)
    });
    d.registerHook("defaults.perspective",
        function(a) {
            return module$src$shared$util$GlobalUtils.default.typeCheck(a.position, "vector3obj", b.warn, "CameraHandler.Hook->defaults.perspective") && module$src$shared$util$GlobalUtils.default.typeCheck(a.target, "vector3obj", b.warn, "CameraHandler.Hook->defaults.perspective") ? p instanceof module$src$externals$three.default.PerspectiveCamera ? c.setCameraPositionAndTarget(a.position, a.target, {
                duration: d.getSetting("cameraMovementDuration")
            }) : Promise.resolve(!0) : Promise.resolve(!1)
        });
    d.registerHook("defaults.orthographic.position",
        function(a) {
            return module$src$shared$util$GlobalUtils.default.typeCheck(a, "vector3obj", b.warn, "CameraHandler.Hook->defaults.orthographic.position") ? Promise.resolve(!0) : Promise.resolve(!1)
        });
    d.registerHook("defaults.orthographic.target", function(a) {
        return module$src$shared$util$GlobalUtils.default.typeCheck(a, "vector3obj", b.warn, "CameraHandler.Hook->defaults.orthographic.target") ? Promise.resolve(!0) : Promise.resolve(!1)
    });
    d.registerHook("defaults.orthographic", function(a) {
        return module$src$shared$util$GlobalUtils.default.typeCheck(a.position,
            "vector3obj", b.warn, "CameraHandler.Hook->defaults.orthographic") && module$src$shared$util$GlobalUtils.default.typeCheck(a.target, "vector3obj", b.warn, "CameraHandler.Hook->defaults.orthographic") ? p instanceof module$src$externals$three.default.OrthographicCamera ? c.setCameraPositionAndTarget(a.position, a.target, {
            duration: d.getSetting("cameraMovementDuration")
        }) : Promise.resolve(!0) : Promise.resolve(!1)
    });
    d.registerHook("defaults", function(a) {
        return a.perspective && module$src$shared$util$GlobalUtils.default.typeCheck(a.perspective.position,
            "vector3obj", b.warn, "CameraHandler.Hook->defaults") && module$src$shared$util$GlobalUtils.default.typeCheck(a.perspective.target, "vector3obj", b.warn, "CameraHandler.Hook->defaults") && a.orthographic && module$src$shared$util$GlobalUtils.default.typeCheck(a.orthographic.position, "vector3obj", b.warn, "CameraHandler.Hook->defaults") && module$src$shared$util$GlobalUtils.default.typeCheck(a.orthographic.target, "vector3obj", b.warn, "CameraHandler.Hook->defaults") ? Promise.resolve(!0) : Promise.resolve(!1)
    });
    c.zoomExtents =
        function(a) {
            var e = b.sceneBoundingBox();
            if (0 == e.min.distanceTo(e.max)) {
                var f = Number.MIN_VALUE;
                e = new module$src$externals$three.default.Box3(new module$src$externals$three.default.Vector3(-f, -f, -f), new module$src$externals$three.default.Vector3(f, f, f))
            }
            f = new module$src$externals$three.default.Vector3;
            e.getCenter(f);
            if (d.hasSetting("zoomExtentsFactor")) {
                var g = new module$src$externals$three.default.Vector3;
                g.subVectors(e.max, f);
                g.multiplyScalar(d.getSetting("zoomExtentsFactor"));
                e = new module$src$externals$three.default.Box3((new module$src$externals$three.default.Vector3).subVectors(f,
                    g), (new module$src$externals$three.default.Vector3).addVectors(f, g))
            }
            g = [];
            g.push(e.min);
            g.push(e.max);
            g.push(new module$src$externals$three.default.Vector3(e.max.x, e.min.y, e.min.z));
            g.push(new module$src$externals$three.default.Vector3(e.max.x, e.max.y, e.min.z));
            g.push(new module$src$externals$three.default.Vector3(e.max.x, e.min.y, e.max.z));
            g.push(new module$src$externals$three.default.Vector3(e.min.x, e.max.y, e.max.z));
            g.push(new module$src$externals$three.default.Vector3(e.min.x, e.min.y, e.max.z));
            g.push(new module$src$externals$three.default.Vector3(e.min.x, e.max.y, e.min.z));
            var h = 0;
            e = new module$src$externals$three.default.Vector3;
            m.object.getWorldDirection(e);
            e.normalize();
            var k = new module$src$externals$three.default.Line3(f.clone().addScaledVector(e, -100), f.clone()),
                l = new module$src$externals$three.default.Vector3;
            l.crossVectors(e, m.object.up);
            l.normalize();
            var n = new module$src$externals$three.default.Vector3;
            n.crossVectors(l, e);
            n.normalize();
            for (var q = 0, p = g.length; q < p; q++) {
                var r = new module$src$externals$three.default.Vector3;
                k.closestPointToPoint(g[q], !1, r);
                var u = g[q].clone();
                u.sub(r);
                var t = u.dot(l);
                u = u.dot(n);
                t = Math.max(Math.abs(t / Math.tan(Math.PI / 180 * (.5 * m.object.fov * m.object.aspect - 2))), Math.abs(u / Math.tan(Math.PI / 180 * (.5 * m.object.fov - 2))));
                r = r.clone().sub(f).dot(e);
                h = Math.max(h, t - r)
            }
            e.multiplyScalar(-1 * h);
            g = new module$src$externals$three.default.Vector3;
            g.addVectors(f, e);
            return c.setCameraPositionAndTarget(g, f, a)
        };
    d.registerHook("type", function(a) {
        if ("number" !== typeof a || a < module$src$3d$ThreeDManagerConstants.default.cameraViewTypes.MIN ||
            a > module$src$3d$ThreeDManagerConstants.default.cameraViewTypes.MAX) return !1;
        if (a === module$src$3d$ThreeDManagerConstants.default.cameraViewTypes.PERSPECTIVE) p = g, m = h, d.getSetting("environmentMapAsBackground") && (f.background = b.materialHandler.getEnvironmentMap());
        else {
            p = k;
            k.far = 1E3 * q.radius;
            k.near = q.radius;
            m = l;
            switch (a) {
                case module$src$3d$ThreeDManagerConstants.default.cameraViewTypes.TOP:
                    l.object.position.set(q.center.x, q.center.y, q.center.z + 2 * q.radius);
                    l.target.set(q.center.x, q.center.y, q.center.z -
                        q.radius);
                    break;
                case module$src$3d$ThreeDManagerConstants.default.cameraViewTypes.BOTTOM:
                    l.object.position.set(q.center.x, q.center.y, q.center.z - 2 * q.radius);
                    l.target.set(q.center.x, q.center.y, q.center.z + q.radius);
                    break;
                case module$src$3d$ThreeDManagerConstants.default.cameraViewTypes.RIGHT:
                    l.object.position.set(q.center.x + 2 * q.radius, q.center.y, q.center.z);
                    l.target.set(q.center.x - q.radius, q.center.y, q.center.z);
                    break;
                case module$src$3d$ThreeDManagerConstants.default.cameraViewTypes.LEFT:
                    l.object.position.set(q.center.x -
                        2 * q.radius, q.center.y, q.center.z);
                    l.target.set(q.center.x + q.radius, q.center.y, q.center.z);
                    break;
                case module$src$3d$ThreeDManagerConstants.default.cameraViewTypes.BACK:
                    l.object.position.set(q.center.x, q.center.y + 2 * q.radius, q.center.z);
                    l.target.set(q.center.x, q.center.y - q.radius, q.center.z);
                    break;
                case module$src$3d$ThreeDManagerConstants.default.cameraViewTypes.FRONT:
                    l.object.position.set(q.center.x, q.center.y - 2 * q.radius, q.center.z), l.target.set(q.center.x, q.center.y + q.radius, q.center.z)
            }
            m.target.set(q.center.x,
                q.center.y, q.center.z);
            f.background = null
        }
        b.lightHandler.adaptLightingToCameraType(a);
        b.renderingHandler.render();
        return !0
    });
    d.registerHook("enableOrbitControls", function(a) {
        if (!module$src$shared$util$GlobalUtils.default.typeCheck(a, "boolean", b.warn, "CameraHandler.Hook->enableOrbitControls")) return !1;
        m.enabled = a;
        return !0
    });
    d.registerHook("damping", function(a) {
        if (!module$src$shared$util$GlobalUtils.default.typeCheck(a, "notnegative", b.warn, "CameraHandler.Hook->damping")) return !1;
        a = Math.min(Math.max(.05,
            a), .25);
        m.dampingFactor = a;
        m.panDampingFactor = a;
        m.zoomDampingFactor = a;
        m.rotateDampingFactor = a;
        return !0
    });
    d.registerHook("enableRotation", function(a) {
        if (!module$src$shared$util$GlobalUtils.default.typeCheck(a, "boolean", b.warn, "CameraHandler.Hook->enableRotation")) return !1;
        m.enableRotation = a;
        return !0
    });
    d.registerHook("rotationSpeed", function(a) {
        if (!module$src$shared$util$GlobalUtils.default.typeCheck(a, "number", b.warn, "CameraHandler.Hook->rotationSpeed")) return !1;
        m.rotationSpeed = a;
        return !0
    });
    d.registerHook("enableAutoRotation",
        function(a) {
            if (!module$src$shared$util$GlobalUtils.default.typeCheck(a, "boolean", b.warn, "CameraHandler.Hook->enableAutoRotation")) return !1;
            (m.enableAutoRotation = a) && b.renderingHandler.render();
            return !0
        });
    d.registerHook("autoRotationSpeed", function(a) {
        if (!module$src$shared$util$GlobalUtils.default.typeCheck(a, "number", b.warn, "CameraHandler.Hook->autoRotationSpeed")) return !1;
        m.autoRotationSpeed = a;
        return !0
    });
    d.registerHook("enableZoom", function(a) {
        if (!module$src$shared$util$GlobalUtils.default.typeCheck(a,
                "boolean", b.warn, "CameraHandler.Hook->enableZoom")) return !1;
        m.enableZoom = a;
        return !0
    });
    d.registerHook("zoomSpeed", function(a) {
        if (!module$src$shared$util$GlobalUtils.default.typeCheck(a, "notnegative", b.warn, "CameraHandler.Hook->zoomSpeed")) return !1;
        m.zoomSpeed = a;
        return !0
    });
    d.registerHook("enablePan", function(a) {
        if (!module$src$shared$util$GlobalUtils.default.typeCheck(a, "boolean", b.warn, "CameraHandler.Hook->enablePan")) return !1;
        m.enablePan = a;
        return !0
    });
    d.registerHook("panSpeed", function(a) {
        if (!module$src$shared$util$GlobalUtils.default.typeCheck(a,
                "number", b.warn, "CameraHandler.Hook->panSpeed")) return !1;
        m.panSpeed = a;
        return !0
    });
    d.registerHook("enableKeyPan", function(a) {
        if (!module$src$shared$util$GlobalUtils.default.typeCheck(a, "boolean", b.warn, "CameraHandler.Hook->enableKeyPan")) return !1;
        m.enableKeyPan = a;
        return !0
    });
    d.registerHook("keyPanSpeed", function(a) {
        if (!module$src$shared$util$GlobalUtils.default.typeCheck(a, "number", b.warn, "CameraHandler.Hook->keyPanSpeed")) return !1;
        m.keyPanSpeed = 7 * a;
        return !0
    });
    var n = function(a) {
        if (!module$src$shared$util$GlobalUtils.default.typeCheck(a.min,
                "vector3any", b.warn, "CameraHandler.Hook->restrictions.position.cube") || !module$src$shared$util$GlobalUtils.default.typeCheck(a.max, "vector3any", b.warn, "CameraHandler.Hook->restrictions.position.cube")) return !1;
        m.minPosition = module$src$shared$util$GlobalUtils.default.toVector3(a.min);
        m.minPosition = module$src$shared$util$GlobalUtils.default.toVector3(a.max);
        b.renderingHandler.render();
        return !0
    };
    d.registerHook("restrictions.position.cube", n);
    d.registerHook("restrictions.position.cube.min", function(a) {
        var b =
            d.getSetting("restrictions.position.cube");
        b.min = a;
        return n(b)
    });
    d.registerHook("restrictions.position.cube.max", function(a) {
        var b = d.getSetting("restrictions.position.cube");
        b.max = a;
        return n(b)
    });
    var t = function(a) {
        if (!module$src$shared$util$GlobalUtils.default.typeCheck(a.center, "vector3any", b.warn, "CameraHandler.Hook->restrictions.position.sphere") || !module$src$shared$util$GlobalUtils.default.typeCheck(a.radius, "notnegative", b.warn, "CameraHandler.Hook->restrictions.position.sphere")) return !1;
        m.positionSphereCenter =
            module$src$shared$util$GlobalUtils.default.toVector3(a.center);
        m.positionSphereRadius = a.radius;
        b.renderingHandler.render();
        return !0
    };
    d.registerHook("restrictions.position.sphere", t);
    d.registerHook("restrictions.position.sphere.center", function(a) {
        var b = d.getSetting("restrictions.position.sphere");
        b.center = a;
        return t(b)
    });
    d.registerHook("restrictions.position.sphere.radius", function(a) {
        var b = d.getSetting("restrictions.position.sphere");
        b.radius = a;
        return t(b)
    });
    var u = function(a) {
        if (!module$src$shared$util$GlobalUtils.default.typeCheck(a.min,
                "vector3any", b.warn, "CameraHandler.Hook->restrictions.target.cube") || !module$src$shared$util$GlobalUtils.default.typeCheck(a.max, "vector3any", b.warn, "CameraHandler.Hook->restrictions.target.cube")) return !1;
        m.minTarget = module$src$shared$util$GlobalUtils.default.toVector3(a.min);
        m.maxTarget = module$src$shared$util$GlobalUtils.default.toVector3(a.max);
        b.renderingHandler.render();
        return !0
    };
    d.registerHook("restrictions.target.cube", u);
    d.registerHook("restrictions.target.cube.min", function(a) {
        var b = d.getSetting("restrictions.target.cube");
        b.min = a;
        return u(b)
    });
    d.registerHook("restrictions.target.cube.max", function(a) {
        var b = d.getSetting("restrictions.target.cube");
        b.max = a;
        return u(b)
    });
    var w = function(a) {
        if (!module$src$shared$util$GlobalUtils.default.typeCheck(a.center, "vector3any", b.warn, "CameraHandler.Hook->restrictions.target.sphere") || !module$src$shared$util$GlobalUtils.default.typeCheck(a.radius, "notnegative", b.warn, "CameraHandler.Hook->restrictions.target.sphere")) return !1;
        m.targetSphereCenter = module$src$shared$util$GlobalUtils.default.toVector3(a.center);
        m.targetSphereRadius = a.radius;
        b.renderingHandler.render();
        return !0
    };
    d.registerHook("restrictions.target.sphere", w);
    d.registerHook("restrictions.target.sphere.center", function(a) {
        var b = d.getSetting("restrictions.target.sphere");
        b.center = a;
        return w(b)
    });
    d.registerHook("restrictions.target.sphere.radius", function(a) {
        var b = d.getSetting("restrictions.target.sphere");
        b.radius = a;
        return w(b)
    });
    var v = function(a) {
        if (!(module$src$shared$util$GlobalUtils.default.typeCheck(a.minPolarAngle, "number", b.warn, "CameraHandler.Hook->restrictions.rotation") &&
                module$src$shared$util$GlobalUtils.default.typeCheck(a.maxPolarAngle, "number", b.warn, "CameraHandler.Hook->restrictions.rotation") && module$src$shared$util$GlobalUtils.default.typeCheck(a.minAzimuthAngle, "number", b.warn, "CameraHandler.Hook->restrictions.rotation") && module$src$shared$util$GlobalUtils.default.typeCheck(a.maxAzimuthAngle, "number", b.warn, "CameraHandler.Hook->restrictions.rotation"))) return !1;
        m.minPolarAngle = a.minPolarAngle * Math.PI / 180;
        m.maxPolarAngle = a.maxPolarAngle * Math.PI / 180;
        m.minAzimuthAngle =
            a.minAzimuthAngle * Math.PI / 180;
        m.maxAzimuthAngle = a.maxAzimuthAngle * Math.PI / 180;
        b.renderingHandler.render();
        return !0
    };
    d.registerHook("restrictions.rotation", v);
    d.registerHook("restrictions.rotation.minPolarAngle", function(a) {
        var b = d.getSetting("restrictions.rotation");
        b.minPolarAngle = a;
        return v(b)
    });
    d.registerHook("restrictions.rotation.maxPolarAngle", function(a) {
        var b = d.getSetting("restrictions.rotation");
        b.maxPolarAngle = a;
        return v(b)
    });
    d.registerHook("restrictions.rotation.minAzimuthAngle", function(a) {
        var b =
            d.getSetting("restrictions.rotation");
        b.minAzimuthAngle = a;
        return v(b)
    });
    d.registerHook("restrictions.rotation.maxAzimuthAngle", function(a) {
        var b = d.getSetting("restrictions.rotation");
        b.maxAzimuthAngle = a;
        return v(b)
    });
    var y = function(a) {
        if (!module$src$shared$util$GlobalUtils.default.typeCheck(a.minDistance, "number", b.warn, "CameraHandler.Hook->restrictions.zoom") || !module$src$shared$util$GlobalUtils.default.typeCheck(a.maxDistance, "number", b.warn, "CameraHandler.Hook->restrictions.zoom")) return !1;
        m.minDistance =
            a.minDistance;
        m.maxDistance = a.maxDistance;
        b.renderingHandler.render();
        return !0
    };
    d.registerHook("restrictions.zoom", y);
    d.registerHook("restrictions.zoom.minDistance", function(a) {
        var b = d.getSetting("restrictions.zoom");
        b.minDistance = a;
        return y(b)
    });
    d.registerHook("restrictions.zoom.maxDistance", function(a) {
        var b = d.getSetting("restrictions.zoom");
        b.maxDistance = a;
        return y(b)
    });
    return c
};
var module$src$3d$handlers$subhandlers$DefaultLights = {
    default: {
        default: {
            light1: {
                type: 0,
                properties: {
                    color: 16777215,
                    intensity: .35
                }
            },
            light2: {
                type: 1,
                properties: {
                    direction: {
                        x: .5774,
                        y: -.5774,
                        z: .5774
                    },
                    shadows: !0,
                    intensity: .35
                }
            },
            light3: {
                type: 1,
                properties: {
                    direction: {
                        x: -.25,
                        y: 1,
                        z: 1
                    },
                    shadows: !1,
                    intensity: .25
                }
            }
        },
        default_legacy: {
            light0: {
                type: 999,
                properties: {}
            },
            light1: {
                type: 0,
                properties: {
                    color: 6579300
                }
            },
            light2: {
                type: 1,
                properties: {
                    direction: {
                        x: .5774,
                        y: -.5774,
                        z: .5774
                    },
                    shadows: !0
                }
            }
        },
        test: {
            light1: {
                type: 1,
                properties: {
                    direction: {
                        x: 1,
                        y: 1,
                        z: 1
                    },
                    shadows: !1,
                    intensity: .5
                }
            },
            light2: {
                type: 1,
                properties: {
                    direction: {
                        x: 1,
                        y: -1,
                        z: 1
                    },
                    shadows: !1,
                    intensity: .5
                }
            },
            light3: {
                type: 1,
                properties: {
                    direction: {
                        x: -1,
                        y: -1,
                        z: 1
                    },
                    shadows: !1,
                    intensity: .5
                }
            },
            light4: {
                type: 1,
                properties: {
                    direction: {
                        x: -1,
                        y: 1,
                        z: 1
                    },
                    shadows: !1,
                    intensity: .5
                }
            }
        }
    }
};
var module$src$3d$handlers$LightHandler = {},
    THREE$$module$src$3d$handlers$LightHandler = module$src$externals$three.default,
    threeDManagerConstants$$module$src$3d$handlers$LightHandler = module$src$3d$ThreeDManagerConstants.default,
    GlobalUtils$$module$src$3d$handlers$LightHandler = module$src$shared$util$GlobalUtils.default,
    toTinyColor$$module$src$3d$handlers$LightHandler = module$src$shared$util$toTinyColor.default;
module$src$3d$handlers$LightHandler.default = function(a) {
    function b(b, d, e) {
        a: {
            for (f in e) {
                if (void 0 === q[f]) {
                    c.warn("LightHandler._checkProperties", "Unknown property " + f);
                    var f = !1;
                    break a
                }
                if (!module$src$shared$util$GlobalUtils.default.typeCheck(e[f], q[f], c.warn, "LightHandler._checkProperties", "Property " + f)) {
                    f = !1;
                    break a
                }
            }
            f = !0
        }
        if (!f) return !1;f = b.children[0];
        if (d == g.AMBIENT)
            for (var h in e) f.hasOwnProperty(h) && (f[h] = "color" == h ? (0, module$src$shared$util$toTinyColor.default)(e[h]).toThreeColor() : e[h]);
        else if (d == g.DIRECTIONAL) {
            for (var k in e) f.hasOwnProperty(k) && (f[k] = "color" == k ? (0, module$src$shared$util$toTinyColor.default)(e[k]).toThreeColor() : e[k]);
            e.hasOwnProperty("shadows") && 1 == e.shadows ? (f.shadows = !0, f.castShadow = a.shadows, f.shadow.camera.up.set(0, 0, 1), f.shadow.camera.far = 8 * m.radius, f.shadow.camera.right = 1.5 * m.radius, f.shadow.camera.left = -1.5 * m.radius, f.shadow.camera.top = 1.5 * m.radius, f.shadow.camera.bottom = -1.5 * m.radius, f.shadow.mapSize.width = 2048, f.shadow.mapSize.height = 2048, f.shadow.radius =
                2, f.shadow.bias = -.00175, f.shadow.camera.updateProjectionMatrix()) : e.hasOwnProperty("shadows") && 0 == e.shadows && (f.shadows = !1, f.castShadow = !1);
            e.hasOwnProperty("direction") ? f.direction = module$src$shared$util$GlobalUtils.default.toVector3(e.direction).normalize() : e.hasOwnProperty("position") && e.hasOwnProperty("target") ? f.direction = module$src$shared$util$GlobalUtils.default.toVector3(e.target).sub(module$src$shared$util$GlobalUtils.default.toVector3(e.position)).normalize() : e.hasOwnProperty("position") &&
                (f.direction = module$src$shared$util$GlobalUtils.default.toVector3(m.center).sub(module$src$shared$util$GlobalUtils.default.toVector3(e.position)).normalize());
            f.position = m.center.clone().add(f.direction.clone().multiplyScalar(2.35 * m.radius));
            d = new module$src$externals$three.default.Object3D;
            b.add(d);
            f.target = d;
            f.target.position = m.center.clone();
            if (!e.hasOwnProperty("helper"))
                for (e = 0; e < b.children.length; e++) 1 == b.children[e].helper && b.children[e].update();
            else if (e.hasOwnProperty("helper") && 1 == e.helper) {
                for (e =
                    0; e < b.children.length; e++) 1 == b.children[e].helper && b.remove(b.children[e]);
                e = new module$src$externals$three.default.DirectionalLightHelper(f);
                e.up.set(0, 0, 1);
                e.helper = !0;
                b.add(e)
            } else if (e.hasOwnProperty("helper") && 0 == e.helper)
                for (e = 0; e < b.children.length; e++) 1 == b.children[e].helper && b.remove(b.children[e])
        } else if (d == g.SPOT) {
            for (var l in e) f.hasOwnProperty(l) && (f[l] = "color" == l ? (0, module$src$shared$util$toTinyColor.default)(e[l]).toThreeColor() : e[l]);
            d = new module$src$externals$three.default.Object3D;
            b.add(d);
            f.target = d;
            d = e.hasOwnProperty("position") ? module$src$shared$util$GlobalUtils.default.toVector3(e.position) : void 0;
            h = e.hasOwnProperty("target") ? module$src$shared$util$GlobalUtils.default.toVector3(e.target) : void 0;
            k = e.hasOwnProperty("direction") ? module$src$shared$util$GlobalUtils.default.toVector3(e.direction) : void 0;
            d && h ? (f.position.copy(d), f.target.position.copy(h)) : d && k ? (f.position.copy(d), f.target.position.copy(d.clone().add(k.clone().multiplyScalar(2.35 * m.radius)))) : d ? (f.position.copy(d),
                f.target.position.copy(m.center)) : h && k ? (f.position.copy(h.clone().add(k.clone().multiplyScalar(2.35 * m.radius))), f.target.position.copy(h)) : k && (f.position.copy(m.center.clone().add(k.clone().multiplyScalar(2.35 * m.radius))), f.target.position.copy(m.center));
            e.hasOwnProperty("shadows") && 1 == e.shadows ? (f.shadows = !1, f.castShadow = !1) : e.hasOwnProperty("shadows") && 0 == e.shadows && (f.shadows = !1, f.castShadow = !1);
            if (!e.hasOwnProperty("helper"))
                for (e = 0; e < b.children.length; e++) 1 == b.children[e].helper && b.children[e].update();
            else if (e.hasOwnProperty("helper") && 1 == e.helper) {
                for (e = 0; e < b.children.length; e++) 1 == b.children[e].helper && b.remove(b.children[e]);
                e = new module$src$externals$three.default.SpotLightHelper(f);
                e.up.set(0, 0, 1);
                e.helper = !0;
                b.add(e)
            } else if (e.hasOwnProperty("helper") && 0 == e.helper)
                for (e = 0; e < b.children.length; e++) 1 == b.children[e].helper && b.remove(b.children[e])
        }
        return !0
    }
    var c = this,
        d = {},
        e = a.settings,
        f = a.scene,
        g = {
            AMBIENT: 0,
            DIRECTIONAL: 1,
            SPOT: 2,
            FLASHLIGHT: 999
        },
        h = new module$src$externals$three.default.Object3D;
    f.add(h);
    var k = new module$src$externals$three.default.Object3D;
    h.add(k);
    var l = new module$src$externals$three.default.Object3D;
    h.add(l);
    l.add(new module$src$externals$three.default.AmbientLight(16777215, 1));
    k.visible = c.getSetting("camera.type") == module$src$3d$ThreeDManagerConstants.default.cameraViewTypes.PERSPECTIVE;
    l.visible = c.getSetting("camera.type") != module$src$3d$ThreeDManagerConstants.default.cameraViewTypes.PERSPECTIVE;
    var p = new module$src$externals$three.default.SpotLight(16777215, .4, 0, Math.PI /
        2, 5, 5);
    p.position.set(0, 0, 1);
    p.target = c.cameraHandler.getCamera();
    p.castShadow = !1;
    p.visible = !1;
    var m = new module$src$externals$three.default.Sphere;
    m.radius = 25;
    var q = {
            color: "color",
            intensity: "notnegative",
            shadows: "boolean",
            position: "vector3any",
            target: "vector3any",
            direction: "vector3any",
            distance: "notnegative",
            angle: "notnegative",
            penumbra: "factor",
            decay: "notnegative",
            helper: "boolean"
        },
        r = function(a, d, e) {
            if (d === g.AMBIENT) var f = new module$src$externals$three.default.AmbientLight(16777215, .5);
            else if (d ===
                g.DIRECTIONAL) f = new module$src$externals$three.default.DirectionalLight(16777215, .5), f.direction = (new module$src$externals$three.default.Vector3(1, -1, 1)).normalize();
            else if (d === g.SPOT) f = new module$src$externals$three.default.SpotLight(16777215, .5, 100, Math.PI / 4, .25, .1), f.up.set(0, 0, 1);
            else {
                if (d === g.FLASHLIGHT) {
                    if (0 !== a) return c.warn("LightHandler._addLight", "Invalid light type, for this id."), -1;
                    p.visible = k.visible;
                    c.cameraHandler.getCamera().add(p);
                    c.renderingHandler.updateShadowMap();
                    c.renderingHandler.render();
                    return 0
                }
                c.warn("LightHandler._addLight", "Invalid light type, no light was added to the scene.");
                return -1
            }
            n(a);
            var h = new module$src$externals$three.default.Object3D;
            h.add(f);
            if (!b(h, d, e)) return -1;
            h.lightID = a;
            h.lightType = d;
            k.add(h);
            c.renderingHandler.updateShadowMap();
            c.renderingHandler.render();
            return h.lightID
        },
        n = function(a) {
            0 == a && (p.visible = !1);
            for (var b = 0; b < k.children.length; b++)
                if (k.children[b].lightID == a) return c.renderingHandler.updateShadowMap(), k.remove(k.children[b]), c.renderingHandler.render(), !0;
            return !1
        },
        t = function(a, d) {
            for (var e = 0; e < k.children.length; e++)
                if (k.children[e].lightID == a) {
                    if (!b(k.children[e], k.children[e].lightType, d)) break;
                    c.renderingHandler.updateShadowMap();
                    c.renderingHandler.render();
                    return !0
                }
            return !1
        };
    d.adjustToBoundingSphere = function(a) {
        m = a;
        for (var b = 0; b < k.children.length; b++) {
            var c = k.children[b];
            c.lightType == g.DIRECTIONAL && (c = c.children[0], c.position.set(a.center.x + c.direction.x * a.radius * 2.35, a.center.y + c.direction.y * a.radius * 2.35, a.center.z + c.direction.z * a.radius *
                2.35), c.target.position.set(a.center.x, a.center.y, a.center.x), c.shadows && (c.shadow.camera.far = 8 * a.radius, c.shadow.camera.right = 1.5 * a.radius, c.shadow.camera.left = -1.5 * a.radius, c.shadow.camera.top = 1.5 * a.radius, c.shadow.camera.bottom = -1.5 * a.radius, c.shadow.camera.updateProjectionMatrix()))
        }
    };
    d.adaptLightingToCameraType = function(a) {
        k.visible = a == module$src$3d$ThreeDManagerConstants.default.cameraViewTypes.PERSPECTIVE;
        l.visible = a != module$src$3d$ThreeDManagerConstants.default.cameraViewTypes.PERSPECTIVE;
        e.getSetting("light0.type") == g.FLASHLIGHT && (p.visible = a == module$src$3d$ThreeDManagerConstants.default.cameraViewTypes.PERSPECTIVE);
        return !0
    };
    d.setToggleLightShadows = function(a) {
        for (var b = 0; b < k.children.length; b++) k.children[b].children[0].hasOwnProperty("shadow") && (k.children[b].children[0].castShadow = a)
    };
    d.restoreDefaultConfiguration = function(a) {
        if (!module$src$shared$util$GlobalUtils.default.typeCheck(a, "string")) return c.warn("LightHandler.getDefaultConfiguration", "The given name is not a string."), !1;
        if (!module$src$3d$handlers$subhandlers$DefaultLights.default[a]) return c.warn("LightHandler.getDefaultConfiguration", "The light configuration with name " + a + " does not exist."), !1;
        a = module$src$3d$handlers$subhandlers$DefaultLights.default[a];
        for (var b = 0; 10 > b; b++) e.updateSetting("light" + b, {});
        for (var d in a) e.updateSetting(String(d), a[d]);
        return !0
    };
    e.registerHook("light0", function(a) {
        if (a && a.type && a.properties) {
            for (var b, d = 0; d < k.children.length; d++) 0 == k.children[d].lightID && (b = k.children[d]);
            d = e.getSetting("light0");
            if (d.hasOwnProperty("type") && d.type === a.type && b && b.lightType === a.type) {
                if (!t(0, a.properties)) return !1
            } else if (a.type === g.FLASHLIGHT) {
                if (!r(0, a.type, a.properties)) return !1
            } else return c.warn("LightHandler.Hook->lights.light0", "Light 0 can only be of type Flashlight."), !1
        } else n(0);
        return !0
    });
    e.updateSetting("light0", e.getSetting("light0"));
    (function() {
        for (var a = {
                i: 1
            }; 10 > a.i; a = {
                i: a.i,
                lightName: a.lightName
            }, a.i++) a.lightName = "light" + a.i, e.registerHook(a.lightName, function(a) {
            return function(b) {
                if (b.hasOwnProperty("type") &&
                    b.hasOwnProperty("properties")) {
                    for (var c, d = 0; d < k.children.length; d++) k.children[d].lightID == a.i && (c = k.children[d]);
                    d = e.getSetting(a.lightName);
                    if (d.hasOwnProperty("type") && d.type == b.type && c && c.lightType == b.type) {
                        if (!t(a.i, b.properties)) return !1
                    } else if (!r(a.i, b.type, b.properties)) return !1
                } else n(a.i);
                return !0
            }
        }(a)), e.updateSetting("light" + a.i, e.getSetting("light" + a.i))
    })();
    return d
};
var module$src$3d$controls$DragControls = {
        default: {}
    },
    THREE$$module$src$3d$controls$DragControls = module$src$externals$three.default;
module$src$externals$three.default.DragControls = function(a, b, c) {
    function d() {
        c.addEventListener("mousemove", f, !1);
        c.addEventListener("mousedown", g, !1);
        c.addEventListener("mouseup", h, !1);
        c.addEventListener("mouseleave", h, !1);
        c.addEventListener("touchmove", k, !1);
        c.addEventListener("touchstart", l, !1);
        c.addEventListener("touchend", p, !1)
    }

    function e() {
        c.removeEventListener("mousemove", f, !1);
        c.removeEventListener("mousedown", g, !1);
        c.removeEventListener("mouseup", h, !1);
        c.removeEventListener("mouseleave",
            h, !1);
        c.removeEventListener("touchmove", k, !1);
        c.removeEventListener("touchstart", l, !1);
        c.removeEventListener("touchend", p, !1)
    }

    function f(d) {
        d.preventDefault();
        var e = c.getBoundingClientRect();
        n.x = (d.clientX - e.left) / e.width * 2 - 1;
        n.y = 2 * -((d.clientY - e.top) / e.height) + 1;
        r.setFromCamera(n, b);
        if (w && y.enabled) {
            var f;
            r.ray.intersectPlane(q, u) && (f = u.sub(t));
            y.dispatchEvent({
                type: "drag",
                object: w,
                position: f,
                event: d
            })
        }
        r.setFromCamera(n, b);
        var g = a.indexOf(w);
        f = r.intersectObjects(a.filter(function(a, b) {
            return g !==
                b
        }));
        0 < f.length ? (e = f[0].object, f = f[0].point, e.hasOwnProperty("interactionPlaneNormal") ? q.setFromNormalAndCoplanarPoint(e.interactionPlaneNormal, e.position) : q.setFromNormalAndCoplanarPoint(b.getWorldDirection(q.normal), e.position), v !== e ? (null !== v && y.dispatchEvent({
            type: "hoveroff",
            object: v,
            event: d
        }), y.dispatchEvent({
            type: "hoveron",
            object: e,
            point: f,
            event: d
        }), c.style.cursor = "pointer", v = e) : y.dispatchEvent({
            type: "hover",
            object: e,
            point: f,
            event: d
        })) : null !== v && (y.dispatchEvent({
                type: "hoveroff",
                object: v,
                event: d
            }),
            c.style.cursor = "auto", v = null)
    }

    function g(d) {
        d.preventDefault();
        y.dispatchEvent({
            type: "mousedowncustom",
            event: d
        });
        r.setFromCamera(n, b);
        var e = r.intersectObjects(a);
        0 < e.length ? (w = e[0].object, r.ray.intersectPlane(q, u) && t.copy(u).sub(w.position), c.style.cursor = "move", y.dispatchEvent({
            type: "dragstart",
            object: w,
            event: d
        })) : y.dispatchEvent({
            type: "emptyclick",
            event: d
        })
    }

    function h(a) {
        y.dispatchEvent({
            type: "mouseupcustom",
            event: a
        });
        a.preventDefault();
        w && (y.dispatchEvent({
            type: "dragend",
            object: w,
            event: a
        }), w = null);
        c.style.cursor = "auto"
    }

    function k(a) {
        a.preventDefault();
        a = a.changedTouches[0];
        var d = c.getBoundingClientRect();
        n.x = (a.clientX - d.left) / d.width * 2 - 1;
        n.y = 2 * -((a.clientY - d.top) / d.height) + 1;
        r.setFromCamera(n, b);
        if (w && y.enabled) {
            var e;
            r.ray.intersectPlane(q, u) && (e = u.sub(t));
            y.dispatchEvent({
                type: "drag",
                object: w,
                position: e,
                event: a
            })
        }
    }

    function l(d) {
        d.preventDefault();
        d = d.changedTouches[0];
        var e = c.getBoundingClientRect();
        n.x = (d.clientX - e.left) / e.width * 2 - 1;
        n.y = 2 * -((d.clientY - e.top) / e.height) + 1;
        r.setFromCamera(n,
            b);
        e = r.intersectObjects(a);
        0 < e.length ? (w = e[0].object, q.setFromNormalAndCoplanarPoint(b.getWorldDirection(q.normal), w.position), r.ray.intersectPlane(q, u) && t.copy(u).sub(w.position), c.style.cursor = "move", y.dispatchEvent({
            type: "dragstart",
            object: w,
            event: d
        })) : y.dispatchEvent({
            type: "emptyclick",
            event: d
        })
    }

    function p(a) {
        a.preventDefault();
        w && (y.dispatchEvent({
            type: "dragend",
            object: w,
            event: a
        }), w = null);
        c.style.cursor = "auto"
    }
    if (a instanceof module$src$externals$three.default.Camera) {
        console.warn("THREE.DragControls: Constructor now expects ( objects, camera, domElement )");
        var m = a;
        a = b;
        b = m
    }
    var q = new module$src$externals$three.default.Plane,
        r = new module$src$externals$three.default.Raycaster,
        n = new module$src$externals$three.default.Vector2,
        t = new module$src$externals$three.default.Vector3,
        u = new module$src$externals$three.default.Vector3,
        w = null,
        v = null,
        y = this;
    d();
    this.enabled = !0;
    this.activate = d;
    this.deactivate = e;
    this.dispose = function() {
        e()
    };
    this.setObjects = function(b) {
        a = b
    };
    this.on = function(a, b) {
        console.warn("THREE.DragControls: on() has been deprecated. Use addEventListener() instead.");
        y.addEventListener(a, b)
    };
    this.off = function(a, b) {
        console.warn("THREE.DragControls: off() has been deprecated. Use removeEventListener() instead.");
        y.removeEventListener(a, b)
    };
    this.notify = function(a) {
        console.error("THREE.DragControls: notify() has been deprecated. Use dispatchEvent() instead.");
        y.dispatchEvent({
            type: a
        })
    }
};
module$src$externals$three.default.DragControls.prototype = Object.create(module$src$externals$three.default.EventDispatcher.prototype);
module$src$externals$three.default.DragControls.prototype.constructor = module$src$externals$three.default.DragControls;
var module$src$3d$handlers$subhandlers$HighlightingHandler = {
    default: function(a) {
        function b(a, b, c) {
            a.traverse(function(a) {
                c ? b.apply(a, b.options) : b.remove(a, b.options)
            })
        }

        function c(a, c, d) {
            c && (void 0 !== a.interactionPath ? (a = module$src$3d$PathUtils.default.getPathObject(f, a.interactionPath + ""), a.highlighted != d && (a.highlighted = d, b(a, c, d))) : a.highlighted != d && ((a.highlighted = d) ? c.apply(a, c.options) : c.remove(a, c.options)))
        }
        var d = this,
            e = {},
            f = a.scene,
            g = null,
            h = null,
            k = [],
            l = [],
            p = !1,
            m = !1;
        e.setDragged = function(a) {
            e.setToggleHighlights(!1);
            h = a;
            e.setToggleHighlights(!0);
            return !0
        };
        e.removeDragged = function() {
            e.setToggleHighlights(!1);
            h = null;
            e.setToggleHighlights(!0);
            return !0
        };
        e.getDragged = function() {
            return h
        };
        e.toggleSelected = function(a) {
            e.setToggleHighlights(!1);
            for (var b = -1, c = 0; c < k.length; c++) void 0 !== a.interactionPath ? a.interactionPath === k[c].interactionPath && (b = c) : k[c] == a && (b = c);
            c = !1; - 1 < b ? k.splice(b, 1) : (k.push(a), c = !0);
            m = !0;
            e.setToggleHighlights(!0, c);
            return c
        };
        e.setSelected = function(a) {
            if (!a.interactionGroup) return !1;
            e.setToggleHighlights(!1);
            for (var b = -1, c = 0; c < k.length; c++) void 0 !== a.interactionPath ? a.interactionPath === k[c].interactionPath && (b = c) : k[c] == a && (b = c); - 1 === b && k.push(a);
            m = -1 === b;
            e.setToggleHighlights(!0);
            return !0
        };
        e.removeSelected = function(a) {
            if (!a.interactionGroup) return !1;
            var b = !1;
            e.setToggleHighlights(!1);
            for (var c = -1, d = 0; d < k.length; d++) void 0 !== a.interactionPath ? a.interactionPath === k[d].interactionPath && (c = d) : k[d] == a && (c = d); - 1 !== c && (k.splice(c, 1), b = !0);
            m = -1 !== c;
            e.setToggleHighlights(!0);
            return b
        };
        e.getSelected = function() {
            return k
        };
        e.setHovered = function(a) {
            e.setToggleHighlights(!1);
            g = a;
            e.setToggleHighlights(!0);
            return !0
        };
        e.removeHovered = function() {
            e.setToggleHighlights(!1);
            g = null;
            e.setToggleHighlights(!0);
            return !0
        };
        e.getHovered = function() {
            return g
        };
        e.removeObject = function(a) {
            e.removeSelected(a);
            g === a && (g = null);
            h === a && (h = null);
            a = l.indexOf(a); - 1 != a && l.splice(a, 1);
            return !0
        };
        e.setInteractable = function(a) {
            if (!Array.isArray(a)) return !1;
            e.setToggleHighlights(!1);
            l = a;
            e.setToggleHighlights(!0);
            return !0
        };
        e.setToggleHighlights = function(a) {
            if ("boolean" !==
                typeof a) return d.warn("HighlightingHandler.setToggleHighlights", "Not a boolean. The highlighting was not toggled."), !1;
            if (p == a) return !1;
            p = a;
            if (h) {
                var b = d.interactionGroupHandler.getGroup(h.interactionGroup);
                c(h, b.getDraggableHighlight().active, a)
            }
            b = 0;
            for (var e = k.length; b < e; b++) {
                var f = k[b],
                    q = d.interactionGroupHandler.getGroup(f.interactionGroup);
                c(f, q.getSelectableHighlight().active, a)
            }
            g && !m && (b = d.interactionGroupHandler.getGroup(g.interactionGroup), c(g, b.getHoverableHighlight().active, a));
            if (h)
                for (b =
                    d.interactionGroupHandler.getGroup(h.interactionGroup), e = 0, f = l.length; e < f; e++) l[e].interactionGroup == h.interactionGroup && l[e] != h && c(l[e], b.getDraggableHighlight().passive, a);
            if (g && !m)
                for (b = d.interactionGroupHandler.getGroup(g.interactionGroup), e = 0, f = l.length; e < f; e++) l[e].interactionGroup == g.interactionGroup && l[e] != g && c(l[e], b.getHoverableHighlight().passive, a);
            b = 0;
            for (e = k.length; b < e; b++) {
                f = k[b];
                q = d.interactionGroupHandler.getGroup(f.interactionGroup);
                for (var w = {
                        i$133: 0
                    }, v = l.length; w.i$133 < v; w = {
                        i$133: w.i$133
                    },
                    w.i$133++) l[w.i$133].interactionGroup == f.interactionGroup && (k.includes(l[w.i$133]) || (void 0 !== l[w.i$133].interactionPath ? 0 === k.filter(function(a) {
                    return function(b) {
                        return b.interactionPath === l[a.i$133].interactionPath
                    }
                }(w)).length && c(l[w.i$133], q.getSelectableHighlight().passive, a) : c(l[w.i$133], q.getSelectableHighlight().passive, a)))
            }
            m && (m = p);
            return !0
        };
        this.getToggleHighlights = function() {
            return p
        };
        return e
    }
};
var module$src$3d$handlers$subhandlers$DefaultHighlights = {
    default: [{
        apply: function(a, b) {
            a.material && (a.material.opacity *= b.opacity, a.material.transparent = !0)
        },
        remove: function(a, b) {
            a.material && (a.material.opacity *= 1 / b.opacity, a.material.transparent = !1)
        }
    }, {
        apply: function(a, b) {
            a.material && (a.material.color.r += b.color.r, a.material.color.g += b.color.g, a.material.color.b += b.color.b)
        },
        remove: function(a, b) {
            a.material && (a.material.color.r -= b.color.r, a.material.color.g -= b.color.g, a.material.color.b -= b.color.b)
        }
    }]
};
var module$src$3d$handlers$subhandlers$InteractionGroupHandler = {},
    THREE$$module$src$3d$handlers$subhandlers$InteractionGroupHandler = module$src$externals$three.default,
    toTinyColor$$module$src$3d$handlers$subhandlers$InteractionGroupHandler = module$src$shared$util$toTinyColor.default;
module$src$3d$handlers$subhandlers$InteractionGroupHandler.default = function() {
    var a = this,
        b = {},
        c = [],
        d = function(a) {
            var b = {},
                c = a.name,
                d = a.selectable || !1,
                e = a.draggable || !1,
                l = a.hoverable || !1,
                p = a.selectionMode || "single",
                m = function(a) {
                    if (!a) return null;
                    if ("function" === typeof a.apply && "function" === typeof a.remove) return a;
                    a.name || (a.name = "opacityHighlight");
                    "opacityHighlight" == a.name ? (a.apply = module$src$3d$handlers$subhandlers$DefaultHighlights.default[0].apply, a.remove = module$src$3d$handlers$subhandlers$DefaultHighlights.default[0].remove,
                        a.options) ? a.options.opacity || (a.options.opacity = .5) : a.options = {
                        opacity: .5
                    } : "colorHighlight" == a.name && (a.apply = module$src$3d$handlers$subhandlers$DefaultHighlights.default[1].apply, a.remove = module$src$3d$handlers$subhandlers$DefaultHighlights.default[1].remove, a.options ? a.options.color = a.options.color ? (0, module$src$shared$util$toTinyColor.default)(a.options.color, "red").toThreeColor() : new module$src$externals$three.default.Color(1, 0, 0) : a.options = {
                        color: new module$src$externals$three.default.Color(1,
                            0, 0)
                    });
                    return a.apply && a.remove ? a : null
                },
                q = {
                    active: a.selectableHighlight && a.selectableHighlight.active ? m(a.selectableHighlight.active) : null,
                    passive: a.selectableHighlight && a.selectableHighlight.passive ? m(a.selectableHighlight.passive) : null
                },
                r = {
                    active: a.draggableHighlight && a.draggableHighlight.active ? m(a.draggableHighlight.active) : null,
                    passive: a.draggableHighlight && a.draggableHighlight.passive ? m(a.draggableHighlight.passive) : null
                },
                n = {
                    active: a.hoverableHighlight && a.hoverableHighlight.active ? m(a.hoverableHighlight.active) : null,
                    passive: a.hoverableHighlight && a.hoverableHighlight.passive ? m(a.hoverableHighlight.passive) : null
                };
            b.getName = function() {
                return c
            };
            b.isSelectable = function() {
                return d
            };
            b.isDraggable = function() {
                return e
            };
            b.isHoverable = function() {
                return l
            };
            b.getSelectionMode = function() {
                return p
            };
            b.getSelectableHighlight = function() {
                return q
            };
            b.getDraggableHighlight = function() {
                return r
            };
            b.getHoverableHighlight = function() {
                return n
            };
            return b
        };
    b.addInteractionGroup = function(a) {
        return a.name && !b.isInteractionGroup(a.name) ?
            (c.push(new d(a)), !0) : !1
    };
    b.addOrReplaceInteractionGroup = function(a) {
        c = c.filter(function(b) {
            return b.getName() !== a.name
        });
        return b.addInteractionGroup(a)
    };
    b.removeInteractionGroup = function(b) {
        c = c.filter(function(a) {
            return a.getName() !== b
        });
        a.interactionHandler.removeInteractionGroup(b);
        return !0
    };
    b.isInteractionGroup = function(a) {
        return null == b.getGroup(a) ? !1 : !0
    };
    b.getGroup = function(a) {
        for (var b = 0, d = c.length; b < d; b++)
            if (c[b].getName() == a) return c[b];
        return null
    };
    b.getGroups = function() {
        return c
    };
    return b
};
var module$src$3d$handlers$InteractionHandler = {},
    THREE$$module$src$3d$handlers$InteractionHandler = module$src$externals$three.default,
    messagingConstants$$module$src$3d$handlers$InteractionHandler = module$src$shared$constants$MessagingConstants.default,
    MessagePrototype$$module$src$3d$handlers$InteractionHandler = module$src$shared$messages$MessagePrototype.default,
    GlobalUtils$$module$src$3d$handlers$InteractionHandler = module$src$shared$util$GlobalUtils.default;
module$src$3d$handlers$InteractionHandler.default = function(a) {
    function b(a) {
        for (var b = new Event(a.type), c = $jscomp.makeIterator(a), d = c.next(); !d.done; d = c.next()) d = d.value, b[d] = a[d];
        h.dispatchEvent(b);
        return b
    }
    var c = this,
        d = {},
        e = a.settings,
        f = a.scene,
        g = [],
        h = c.renderingHandler.getDomElement(),
        k = !1,
        l = new module$src$externals$three.default.DragControls(g, c.cameraHandler.getCamera(), h),
        p = new module$src$externals$three.default.Vector3,
        m = new module$src$externals$three.default.Vector3;
    l.addEventListener("dragstart",
        function(a) {
            if (a.object.interactionGroup) {
                var d = c.interactionGroupHandler.getGroup(a.object.interactionGroup);
                if (d && (1 == d.isDraggable() || 1 == d.isSelectable())) {
                    var e = void 0 !== a.object.interactionPath ? module$src$3d$PathUtils.default.getPathObject(f, a.object.interactionPath + "") : a.object;
                    if (1 == d.isDraggable()) {
                        p.copy(a.object.position);
                        m.copy(a.object.position);
                        c.updateSetting("camera.enableOrbitControls", !1);
                        c.renderingHandler.updateShadowMap();
                        c.highlightingHandler.setDragged(a.object);
                        c.renderingHandler.registerForContinuousRendering("interactionInProcess");
                        var g = {
                                type: module$src$shared$constants$MessagingConstants.default.messageTopics.SCENE_DRAG_START,
                                obj: e,
                                scenePath: module$src$3d$PathUtils.default.getObjectPath(e),
                                dragPosStart: p.clone(),
                                clientX: a.event.clientX,
                                clientY: a.event.clientY
                            },
                            h = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.SCENE_INTERACTION, g);
                        c.message(g.type + "." + g.scenePath, h);
                        b(g)
                    }
                    if (1 == d.isSelectable()) {
                        d = {
                            clientX: a.event.clientX,
                            clientY: a.event.clientY
                        };
                        if (c.highlightingHandler.toggleSelected(a.object)) {
                            if (d.type = module$src$shared$constants$MessagingConstants.default.messageTopics.SCENE_SELECT_ON, "single" === c.interactionGroupHandler.getGroup(a.object.interactionGroup).getSelectionMode()) {
                                g = c.highlightingHandler.getSelected();
                                h = 0;
                                for (var k = g.length; h < k; h++)
                                    if (g[h].interactionGroup == a.object.interactionGroup && g[h] != a.object) {
                                        k = void 0 !== g[h].interactionPath ? module$src$3d$PathUtils.default.getPathObject(f, g[h].interactionPath + "") : g[h];
                                        c.highlightingHandler.removeSelected(g[h]);
                                        a = {
                                            type: module$src$shared$constants$MessagingConstants.default.messageTopics.SCENE_SELECT_OFF,
                                            obj: k,
                                            scenePath: module$src$3d$PathUtils.default.getObjectPath(k),
                                            clientX: a.event.clientX,
                                            clientY: a.event.clientY
                                        };
                                        g = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.SCENE_INTERACTION, a);
                                        c.message(a.type + "." + a.scenePath, g);
                                        b(a);
                                        break
                                    }
                            }
                        } else d.type = module$src$shared$constants$MessagingConstants.default.messageTopics.SCENE_SELECT_OFF;
                        d.obj = e;
                        d.scenePath = module$src$3d$PathUtils.default.getObjectPath(e);
                        e = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.SCENE_INTERACTION, d);
                        c.message(d.type + "." + d.scenePath, e);
                        b(d);
                        c.renderingHandler.render()
                    }
                }
            }
        });
    l.addEventListener("drag", function(a) {
        if (a.object.interactionGroup) {
            var d = c.interactionGroupHandler.getGroup(a.object.interactionGroup);
            d && 0 != d.isDraggable() && a.position && (void 0 !== a.object.interactionPath ? (d =
                module$src$3d$PathUtils.default.getPathObject(f, a.object.interactionPath + ""), d.position.add(a.position.clone().sub(m))) : (d = a.object, d.position.copy(a.position)), m.copy(a.position), a = {
                type: module$src$shared$constants$MessagingConstants.default.messageTopics.SCENE_DRAG_MOVE,
                obj: d,
                scenePath: module$src$3d$PathUtils.default.getObjectPath(d),
                dragPosStart: p.clone(),
                dragPosAbs: m.clone(),
                clientX: a.event.clientX,
                clientY: a.event.clientY
            }, a.dragPosRel = a.dragPosAbs.clone().sub(a.dragPosStart), d = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.SCENE_INTERACTION,
                a), c.message(a.type + "." + a.scenePath, d), b(a), c.renderingHandler.updateShadowMap())
        }
    });
    l.addEventListener("dragend", function(a) {
        if (a.object.interactionGroup) {
            var d = c.interactionGroupHandler.getGroup(a.object.interactionGroup);
            if (d && 0 != d.isDraggable()) {
                c.highlightingHandler.removeDragged();
                if (void 0 !== a.object.interactionPath) {
                    var e = module$src$3d$PathUtils.default.getPathObject(f, a.object.interactionPath + "");
                    d = m
                } else e = a.object, d = e.position;
                a = {
                    type: module$src$shared$constants$MessagingConstants.default.messageTopics.SCENE_DRAG_END,
                    obj: e,
                    scenePath: module$src$3d$PathUtils.default.getObjectPath(e),
                    dragPosStart: p.clone(),
                    dragPosAbs: d.clone(),
                    clientX: a.event.clientX,
                    clientY: a.event.clientY
                };
                a.dragPosRel = a.dragPosAbs.clone().sub(a.dragPosStart);
                d = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.SCENE_INTERACTION, a);
                c.message(a.type + "." + a.scenePath, d);
                c.updateSetting("camera.enableOrbitControls", !0);
                c.renderingHandler.unregisterForContinuousRendering("interactionInProcess");
                b(a)
            }
        }
    });
    l.addEventListener("hoveron", function(a) {
        if ((!0 !== k || c.highlightingHandler.getDragged()) && a.object.interactionGroup) {
            var d = c.interactionGroupHandler.getGroup(a.object.interactionGroup);
            d && 0 != d.isHoverable() && (d = void 0 !== a.object.interactionPath ? module$src$3d$PathUtils.default.getPathObject(f, a.object.interactionPath + "") : a.object, c.highlightingHandler.setHovered(a.object), c.renderingHandler.registerForContinuousRendering("hoverInProcess"), a = {
                type: module$src$shared$constants$MessagingConstants.default.messageTopics.SCENE_HOVER_ON,
                obj: d,
                scenePath: module$src$3d$PathUtils.default.getObjectPath(d),
                hoverPos: a.point,
                clientX: a.event.clientX,
                clientY: a.event.clientY
            }, d = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.SCENE_INTERACTION, a), c.message(a.type + "." + a.scenePath, d), b(a))
        }
    });
    l.addEventListener("hover", function(a) {
        if ((!0 !== k || c.highlightingHandler.getDragged()) && a.object.interactionGroup) {
            var d = c.interactionGroupHandler.getGroup(a.object.interactionGroup);
            if (d && 0 != d.isHoverable()) {
                d = void 0 !== a.object.interactionPath ? module$src$3d$PathUtils.default.getPathObject(f, a.object.interactionPath + "") : a.object;
                if (c.highlightingHandler.getHovered() !== a.object) {
                    c.highlightingHandler.setHovered(a.object);
                    c.renderingHandler.registerForContinuousRendering("hoverInProcess");
                    var e = {
                            type: module$src$shared$constants$MessagingConstants.default.messageTopics.SCENE_HOVER_ON,
                            obj: d,
                            scenePath: module$src$3d$PathUtils.default.getObjectPath(d),
                            hoverPos: a.point,
                            clientX: a.event.clientX,
                            clientY: a.event.clientY
                        },
                        g = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.SCENE_INTERACTION, e);
                    c.message(e.type + "." + e.scenePath, g);
                    b(e)
                }
                a = {
                    type: module$src$shared$constants$MessagingConstants.default.messageTopics.SCENE_HOVER_OVER,
                    obj: d,
                    scenePath: module$src$3d$PathUtils.default.getObjectPath(d),
                    hoverPos: a.point,
                    clientX: a.event.clientX,
                    clientY: a.event.clientY
                };
                d = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.SCENE_INTERACTION,
                    a);
                c.message(a.type + "." + a.scenePath, d);
                b(a)
            }
        }
    });
    l.addEventListener("hoveroff", function(a) {
        if (c.highlightingHandler.getHovered() && a.object.interactionGroup) {
            var d = c.interactionGroupHandler.getGroup(a.object.interactionGroup);
            d && 0 != d.isHoverable() && (d = void 0 !== a.object.interactionPath ? module$src$3d$PathUtils.default.getPathObject(f, a.object.interactionPath + "") : a.object, c.highlightingHandler.removeHovered(), a = {
                type: module$src$shared$constants$MessagingConstants.default.messageTopics.SCENE_HOVER_OFF,
                obj: d,
                scenePath: module$src$3d$PathUtils.default.getObjectPath(d),
                clientX: a.event.clientX,
                clientY: a.event.clientY
            }, d = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.SCENE_INTERACTION, a), c.message(a.type + "." + a.scenePath, d), c.renderingHandler.unregisterForContinuousRendering("hoverInProcess"), b(a))
        }
    });
    l.addEventListener("emptyclick", function() {
        for (var a = c.highlightingHandler.getSelected(), d = !1, e = a.length; e--;)
            if ("single" ===
                c.interactionGroupHandler.getGroup(a[e].interactionGroup).getSelectionMode()) {
                d = void 0 !== a[e].interactionPath ? module$src$3d$PathUtils.default.getPathObject(f, a[e].interactionPath + "") : a[e];
                c.highlightingHandler.removeSelected(a[e]);
                d = {
                    type: module$src$shared$constants$MessagingConstants.default.messageTopics.SCENE_SELECT_OFF,
                    obj: d,
                    scenePath: module$src$3d$PathUtils.default.getObjectPath(d)
                };
                var g = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.SCENE_INTERACTION,
                    d);
                c.message(d.type + "." + d.scenePath, g);
                b(d);
                d = !0
            }
        1 == d && c.renderingHandler.render()
    });
    l.addEventListener("mousedowncustom", function() {
        k = !0
    });
    l.addEventListener("mouseupcustom", function() {
        k = !1
    });
    c.highlightingHandler = module$src$3d$handlers$subhandlers$HighlightingHandler.default.call(c, {
        settings: e,
        scene: f
    });
    c.interactionGroupHandler = module$src$3d$handlers$subhandlers$InteractionGroupHandler.default.call(c);
    d.addToInteractionGroup = function(a, b, e, h) {
        var k = module$src$3d$PathUtils.default.getPathObject(f,
            a + "");
        if (!k) return c.warn("InteractionHandler.addToInteractionGroup", "No valid path provided, interactivity was not set."), !1;
        if (!b || !c.interactionGroupHandler.isInteractionGroup(b)) return c.warn("InteractionHandler.addToInteractionGroup", "No valid group provided, interactivity was not set."), !1;
        var m = c.interactionGroupHandler.getGroup(b);
        if (!m) return !1;
        var n = m.isSelectable(b) || m.isDraggable(b) || m.isHoverable(b);
        "global" === e && (k.interactionGroup = b);
        k.traverse(function(c) {
            "Mesh" == c.type && (c.interactionGroup =
                b, "global" === e && (c.interactionPath = a + ""), n && g.push(c))
        });
        h ? d.setInteractionPlaneNormal(a, h) : d.removeInteractionPlaneNormal(a);
        l.setObjects(g);
        c.highlightingHandler.setInteractable(g);
        return !0
    };
    d.removeFromInteractions = function(a) {
        a = module$src$3d$PathUtils.default.getPathObject(f, a + "");
        if (!a) return c.warn("InteractionHandler.removeFromInteractionGroup", "No valid path provided, interactivity was not removed."), !1;
        a.traverse(function(a) {
            for (var d = c.highlightingHandler.getSelected(), e = -1, f = 0; f < d.length; f++) void 0 !==
                a.interactionPath ? a.interactionPath === d[f].interactionPath && (e = f) : d[f] == a && (e = f); - 1 !== e && (c.highlightingHandler.removeObject(a), d = {
                type: module$src$shared$constants$MessagingConstants.default.messageTopics.SCENE_SELECT_OFF,
                obj: a,
                scenePath: module$src$3d$PathUtils.default.getObjectPath(a)
            }, e = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.SCENE_INTERACTION, d), c.message(d.type + "." + d.scenePath, e), b(d));
            a === c.highlightingHandler.getHovered() &&
                (c.highlightingHandler.removeHovered(), c.highlightingHandler.removeObject(a), d = {
                    type: module$src$shared$constants$MessagingConstants.default.messageTopics.SCENE_HOVER_OFF,
                    obj: a,
                    scenePath: module$src$3d$PathUtils.default.getObjectPath(a)
                }, e = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.SCENE_INTERACTION, d), c.message(d.type + "." + d.scenePath, e), c.renderingHandler.unregisterForContinuousRendering("hoverInProcess"), b(d));
            a ===
                c.highlightingHandler.getDragged() && (c.highlightingHandler.removeDragged(), c.highlightingHandler.removeObject(a), d = void 0 !== a.interactionPath ? m : a.position, d = {
                    type: module$src$shared$constants$MessagingConstants.default.messageTopics.SCENE_DRAG_END,
                    obj: a,
                    scenePath: module$src$3d$PathUtils.default.getObjectPath(a),
                    dragPosStart: p.clone(),
                    dragPosAbs: d.clone()
                }, d.dragPosRel = d.dragPosAbs.clone().sub(d.dragPosStart), e = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.SCENE_INTERACTION,
                    d), c.message(d.type + "." + d.scenePath, e), c.updateSetting("camera.enableOrbitControls", !0), c.renderingHandler.unregisterForContinuousRendering("interactionInProcess"), b(d));
            "Mesh" == a.type && (delete a.interactionGroup, delete a.interactionPath, a = g.indexOf(a), -1 < a && g.splice(a, 1))
        });
        l.setObjects(g);
        c.highlightingHandler.setInteractable(g);
        return !0
    };
    d.removeInteractionGroup = function(a) {
        for (var b = g.length; b--;) g[b].interactionGroup == a && (c.highlightingHandler.removeObject(g[b]), delete g[b].interactionGroup,
            delete g[b].interactionPath, g.splice(b, 1));
        l.setObjects(g);
        c.highlightingHandler.setInteractable(g);
        return !0
    };
    d.removeAllInteractivity = function() {
        for (var a = 0, b = g.length; a < b; a++) c.highlightingHandler.removeObject(g[a]), delete g[a].interactionGroup, delete g[a].interactionPath;
        g = [];
        l.setObjects(g);
        c.highlightingHandler.setInteractable(g);
        return !0
    };
    d.setSelectedPaths = function(a, b) {
        a = a || [];
        b = b || [];
        for (var e = d.getSelectedPaths(), h = [], k = [], l = 0, m = g.length; l < m; l++) void 0 !== g[l].interactionPath ? (h.push(g[l].interactionPath),
            k.push("global")) : (h.push(module$src$3d$PathUtils.default.getObjectPath(g[l])), k.push("sub"));
        k = 0;
        for (l = a.length; k < l; k++) {
            if (!0 !== module$src$shared$util$GlobalUtils.default.typeCheck(a[k], "string")) return c.warn("InteractionHandler.setSelectedPaths", "At least one path is not a string."), !1;
            if (!h.includes(a[k])) return c.warn("InteractionHandler.setSelectedPaths", "At least one path is not interactable."), !1
        }
        k = 0;
        for (l = b.length; k < l; k++) {
            if (!0 !== module$src$shared$util$GlobalUtils.default.typeCheck(b[k],
                    "string")) return c.warn("InteractionHandler.setSelectedPaths", "At least one path is not a string."), !1;
            if (!h.includes(b[k])) return c.warn("InteractionHandler.setSelectedPaths", "At least one path is not interactable."), !1
        }
        h = 0;
        for (k = b.length; h < k; h++) e.includes(b[h]) && module$src$3d$PathUtils.default.getPathObject(f, b[h] + "").traverse(function(a) {
            "Mesh" == a.type && c.highlightingHandler.removeSelected(a)
        });
        e = d.getSelectedPaths();
        b = 0;
        for (h = a.length; b < h; b++) e.includes(a[b]) || module$src$3d$PathUtils.default.getPathObject(f,
            a[b] + "").traverse(function(a) {
            if ("Mesh" == a.type) {
                if ("single" === c.interactionGroupHandler.getGroup(a.interactionGroup).getSelectionMode())
                    for (var b = c.highlightingHandler.getSelected(), d = 0, e = b.length; d < e; d++)
                        if (b[d].interactionGroup == a.interactionGroup) {
                            c.highlightingHandler.removeSelected(b[d]);
                            break
                        }
                c.highlightingHandler.setSelected(a)
            }
        });
        c.renderingHandler.render();
        return !0
    };
    d.getSelectedPaths = function() {
        for (var a = c.highlightingHandler.getSelected(), b = [], d = 0, e = a.length; d < e; d++) void 0 !== a[d].interactionPath ?
            b.push(a[d].interactionPath + "") : b.push(module$src$3d$PathUtils.default.getObjectPath(a[d]));
        return b
    };
    d.setInteractionPlaneNormal = function(a, b) {
        a = module$src$3d$PathUtils.default.getPathObject(f, a);
        if (!a) return c.warn("InteractionHandler.setInteractionPlaneNormal", "No valid path provided, interaction plane was not set."), !1;
        a.traverse(function(a) {
            "Mesh" == a.type && (a.interactionPlaneNormal = b)
        });
        return !0
    };
    d.removeInteractionPlaneNormal = function(a) {
        a = module$src$3d$PathUtils.default.getPathObject(f, a);
        if (!a) return c.warn("InteractionHandler.removeInteractionPlaneNormal", "No valid path provided, interaction plane was not removed."), !1;
        a.traverse(function(a) {
            "Mesh" == a.type && a.hasOwnProperty("interactionPlaneNormal") && delete a.interactionPlaneNormal
        });
        return !0
    };
    return d
};
var module$src$3d$ThreeDManager = {},
    THREE$$module$src$3d$ThreeDManager = module$src$externals$three.default,
    TWEEN$$module$src$3d$ThreeDManager = module$node_modules$$tweenjs$tween_js$src$Tween.default,
    GlobalUtils$$module$src$3d$ThreeDManager = module$src$shared$util$GlobalUtils.default,
    messagingConstants$$module$src$3d$ThreeDManager = module$src$shared$constants$MessagingConstants.default,
    threeDManagerConstants$$module$src$3d$ThreeDManager = module$src$3d$ThreeDManagerConstants.default;
module$src$3d$ThreeDManager.default = function(a) {
    function b() {
        var a = new module$src$externals$three.default.Box3;
        h.traverseVisible(function(b) {
            b.hasOwnProperty("SDBoundingBox") && a.union(b.SDBoundingBox)
        });
        0 == a.min.distanceTo(a.max) && (a = new module$src$externals$three.default.Box3(new module$src$externals$three.default.Vector3(-1, -1, -1), new module$src$externals$three.default.Vector3(1, 1, 1)));
        return a
    }

    function c() {
        if (g.getSetting("initialized")) {
            var a = b(),
                c = new module$src$externals$three.default.Sphere;
            a.getBoundingSphere(c);
            m.position.set(0, 0, a.min.z - .005);
            q.position.set(0, 0, a.min.z - .005);
            r.position.set(0, 0, a.min.z - .005);
            g.materialHandler.adjustToBoundingSphere(c);
            g.lightHandler.adjustToBoundingSphere(c);
            g.cameraHandler.adjustToBoundingSphere(c);
            g.renderingHandler.updateShadowMap();
            g.renderingHandler.render()
        }
    }

    function d(a, b) {
        var c = module$src$3d$PathUtils.default.getPathObject(h, a);
        return null == c ? Promise.reject(Error("Could not fade out, geometry, path not found.")) : new Promise(function(d) {
            c.traverseVisible(function(a) {
                a.hasOwnProperty("material") &&
                    (a.material.transparent = !0)
            });
            var e = {
                    opacity: 1
                },
                f = (new module$node_modules$$tweenjs$tween_js$src$Tween.default.Tween(e)).to({
                    opacity: 0
                }, b).onUpdate(function() {
                    c.traverseVisible(function(a) {
                        a.SDMaterialDefinition && a.material && (a.material.opacity = e.opacity * (1 - a.SDMaterialDefinition.getTransparency()))
                    })
                }).onComplete(function() {
                    c.traverseVisible(function(b) {
                        b.SDMaterialDefinition && b.material && (b.material.opacity = 0, g.renderingHandler.unregisterForContinuousRendering("FADE_OUT_" + a))
                    });
                    d()
                });
            g.renderingHandler.registerForContinuousRendering("FADE_OUT_" +
                a, !0);
            f.start()
        })
    }

    function e(a, b) {
        var c = module$src$3d$PathUtils.default.getPathObject(h, a);
        return null == c ? Promise.reject(Error("Could not fade in geometry, path not found")) : new Promise(function(d) {
            c.traverseVisible(function(a) {
                a.SDMaterialDefinition && a.material && (a instanceof module$src$externals$three.default.Tag2D ? a.origOpacity = a.node.style.opacity : a.material.transparent = !0)
            });
            var e = {
                    opacity: 0
                },
                f = (new module$node_modules$$tweenjs$tween_js$src$Tween.default.Tween(e)).to({
                    opacity: 1
                }, b).onUpdate(function() {
                    c.traverseVisible(function(a) {
                        if (a.SDMaterialDefinition &&
                            a.material) {
                            var b = a.SDMaterialDefinition.getTransparent() ? 1 - a.SDMaterialDefinition.getTransparency() : 1;
                            a instanceof module$src$externals$three.default.Tag2D ? a.node.style.opacity = e.opacity * a.origOpacity : a.material.opacity = e.opacity * b
                        }
                    })
                }).onComplete(function() {
                    c.traverseVisible(function(b) {
                        b.SDMaterialDefinition && b.material && (b instanceof module$src$externals$three.default.Tag2D ? (b.node.style.opacity = b.origOpacity, delete b.origOpacity) : (b.material.opacity = 1 - b.SDMaterialDefinition.getTransparency(),
                            b.material.transparent = b.SDMaterialDefinition.getTransparent()), g.renderingHandler.unregisterForContinuousRendering("FADE_IN_" + a), d())
                    })
                });
            g.renderingHandler.registerForContinuousRendering("FADE_IN_" + a, !0);
            f.start()
        })
    }

    function f(a, b) {
        if (b && module$src$shared$util$GlobalUtils.default.typeCheck(b.interactionGroup, "string")) {
            g.highlightingHandler.setToggleHighlights(!1);
            var c = b.interactionGroup,
                d = "sub";
            module$src$shared$util$GlobalUtils.default.typeCheck(b.interactionMode, "string") && "global" === b.interactionMode &&
                (d = "global");
            b = module$src$shared$util$GlobalUtils.default.typeCheck(b.dragPlaneNormal, "vector3any") ? module$src$shared$util$GlobalUtils.default.toVector3(b.dragPlaneNormal) : void 0;
            g.interactionHandler.addToInteractionGroup(a, c, d, b);
            g.highlightingHandler.setToggleHighlights(!0)
        }
    }
    var g = this;
    module$src$externals$three.default.Cache.enabled = !0;
    var h = new module$src$externals$three.default.Scene;
    module$src$3d$PathUtils.default.setScene(h);
    var k = a.canvas,
        l = k.offsetWidth,
        p = k.offsetHeight;
    module$src$shared$mixins$GlobalMixin.default.call(this);
    a && a.loggingHandler ? module$src$shared$util$GlobalUtils.default.inject(a.loggingHandler, g) : module$src$shared$mixins$LoggingMixin.default.call(g);
    module$src$shared$mixins$SettingsMixin.default.call(this, a.settings, module$src$3d$ThreeDManagerConstants.default.defaultSettings);
    a && a.messagingHandler && module$src$shared$util$GlobalUtils.default.inject(a.messagingHandler, g);
    if (! function() {
            try {
                var a = document.createElement("canvas");
                return window.WebGLRenderingContext && (a.getContext("webgl") || a.getContext("experimental-webgl")) ?
                    a.getContext("webgl") || a.getContext("experimental-webgl") : !1
            } catch (w) {
                return !1
            }
        }()) return g.error("ThreeDManager", "Was not able to create WebGL context."), null;
    document.addEventListener("webkitfullscreenchange", function() {
        g.updateSetting("fullscreen", n())
    }, !1);
    document.addEventListener("mozfullscreenchange", function() {
        g.updateSetting("fullscreen", n())
    }, !1);
    document.addEventListener("fullscreenchange", function() {
        g.updateSetting("fullscreen", n())
    }, !1);
    g.renderingHandler = module$src$3d$handlers$RenderingHandler.default.call(g, {
        settings: g.getSection("render"),
        scene: h,
        canvas: k
    });
    g.materialHandler = module$src$3d$handlers$MaterialHandler.default.call(g, {
        settings: g.getSection("material"),
        scene: h
    });
    g.cameraHandler = module$src$3d$handlers$CameraHandler.default.call(g, {
        settings: g.getSection("camera"),
        scene: h,
        canvas: k
    });
    g.lightHandler = module$src$3d$handlers$LightHandler.default.call(g, {
        settings: g.getSection("lights"),
        shadows: g.getSettingShallow("render.shadows"),
        scene: h
    });
    g.interactionHandler = module$src$3d$handlers$InteractionHandler.default.call(g, {
        settings: g.getSection("interaction"),
        scene: h
    });
    var m, q, r, n = function() {
        return !!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement || document.mozFullScreenElement)
    };
    g.subscribeToMessageStream(module$src$shared$constants$MessagingConstants.default.messageTopics.SCENE_VISIBILITY_ON, function(a, d) {
        a = d.getPartsByType(module$src$shared$constants$MessagingConstants.default.messageDataTypes.GENERIC);
        d = 0;
        for (var e = a.length; d < e; d++)
            if (a[d].data && 1 == a[d].data.shownBefore) return;
        g.renderingHandler.unregisterForNoRendering("startUpId");
        a = b();
        d = a.min.distanceTo(a.max);
        if (1 < d) e = parseInt(d), e = e.toString(), e = e.length, e = Math.pow(10, e - 1), d = Math.max(Math.ceil(d / e) * e, 1), e = d / (e / 10);
        else {
            e = 1 - Math.floor(Math.log(d) / Math.log(10)) - 2;
            d = d.toFixed(e + 1);
            var f = parseInt(d.substr(d.length - 1)) + 1;
            d = "0.";
            for (var k = 0; k < e; ++k) d += "0";
            d = parseFloat(d + f);
            e = 10 * f
        }
        m = new module$src$externals$three.default.GridHelper(2 * d, e);
        m.material.opacity = .15;
        m.material.transparent = !0;
        m.isSelectable = !1;
        m.rotateX(Math.PI /
            2);
        m.visible = g.getSetting("gridVisibility");
        e = new module$src$externals$three.default.Object3D;
        e.SDLocalPath = "grid";
        e.add(m);
        h.add(e);
        d = new module$src$externals$three.default.PlaneGeometry(2 * d, 2 * d, 2, 2);
        q = new module$src$externals$three.default.Mesh(d, g.materialHandler.getMaterial({
            color: 13882323,
            side: module$src$externals$three.default.FrontSide,
            roughness: 1,
            metalness: 0
        }));
        q.receiveShadow = !0;
        q.visible = g.getSetting("groundPlaneVisibility");
        e = new module$src$externals$three.default.Object3D;
        e.SDLocalPath =
            "groundplane";
        e.add(q);
        h.add(e);
        r = new module$src$externals$three.default.Reflector(d, {
            clipBias: .003,
            textureWidth: l * window.devicePixelRatio,
            textureHeight: p * window.devicePixelRatio,
            color: 7829367,
            recursion: 1
        });
        r.receiveShadow = !0;
        r.transparent = !0;
        r.visible = g.getSetting("groundPlaneReflectionVisibility");
        r.visible && g.updateSetting("material.environmentMapAsBackground", !1);
        e.add(r);
        m.position.set(0, 0, a.min.z - .005);
        q.position.set(0, 0, a.min.z - .005);
        r.scale.set(1E3, 1E3, 1E3);
        r.position.set(0, 0, a.min.z - .005);
        g.updateSetting("initialized", !0);
        c();
        g.renderingHandler.render()
    });
    this.addGeometry = function(a, b, d) {
        g.renderingHandler.registerForContinuousRendering("geomAddEvent");
        d = d || {};
        if (null != module$src$3d$PathUtils.default.getPathObject(h, a)) return g.renderingHandler.unregisterForContinuousRendering("geomAddEvent"), Promise.reject(Error("Geometry already exists at that path: " + a));
        var l = module$src$3d$PathUtils.default.ensurePath(h, a);
        module$src$shared$util$GlobalUtils.default.typeCheck(d.name, "string") &&
            (l.SDName = d.name);
        module$src$shared$util$GlobalUtils.default.typeCheck(d.visible, "boolean") ? l.visible = d.visible : l.visible = !0;
        var m = d.hasOwnProperty("boundingBox");
        m && (l.SDBoundingBox = d.boundingBox);
        var n = {};
        b = $jscomp.makeIterator(b);
        for (var p = b.next(); !p.done; n = {
                g: n.g
            }, p = b.next()) {
            n.g = p.value;
            ["geometry", "path", "type", "material"].forEach(function(a) {
                return function(b) {
                    if (!a.g.hasOwnProperty(b)) return g.renderingHandler.unregisterForContinuousRendering("geomAddEvent"), Promise.reject(Error("GeometryData object is missing property " +
                        b))
                }
            }(n));
            p = module$src$3d$PathUtils.default.ensurePath(l, n.g.path);
            var q = g.materialHandler.SDSMfromProperties(n.g.material.properties);
            if (null == q) return g.renderingHandler.unregisterForContinuousRendering("geomAddEvent"), Promise.reject(Error("Could not create material from definition."));
            n.g.color && q.color.set(n.g.color.toRgbString());
            n.g.geometry.attributes && n.g.geometry.attributes.hasOwnProperty("color") && (q.vertexColors = module$src$externals$three.default.VertexColors);
            var r = null;
            try {
                switch (n.g.type) {
                    case "mesh":
                        var t = !1;
                        n.g.geometry instanceof module$src$externals$three.default.BufferGeometry ? n.g.geometry.hasOwnProperty("attributes") && n.g.geometry.attributes.hasOwnProperty("uv") && (t = !0) : n.g.geometry instanceof module$src$externals$three.default.Geometry && 0 < n.g.geometry.faceVertexUvs.length && (t = !0);
                        t || (q.map = null, q.alphaMap = null, q.aoMap = null, q.bumpMap = null, q.displacementMap = null, q.emissiveMap = null, q.normalMap = null, q.metalnessMap = null, q.roughnessMap = null);
                        if (n.g.geometry instanceof module$src$externals$three.default.BufferGeometry) n.g.geometry.attributes.hasOwnProperty("normal") &&
                            null != n.g.geometry.attributes.normal || n.g.geometry.computeVertexNormals();
                        else if (n.g.geometry instanceof module$src$externals$three.default.Geometry && 0 < n.g.geometry.faces.length) {
                            var u = n.g.geometry.faces[0];
                            if (null == u.vertexNormals || 0 == u.vertexNormals.length) n.g.geometry.computeFaceNormals(), n.g.geometry.computeVertexNormals()
                        }
                        r = new module$src$externals$three.default.Mesh(n.g.geometry, q);
                        r.castShadow = !0;
                        r.receiveShadow = !0;
                        break;
                    case "points":
                        r = new module$src$externals$three.default.Points(n.g.geometry,
                            new module$src$externals$three.default.PointsMaterial({
                                color: q.color,
                                size: 1
                            }));
                        break;
                    case "line":
                        r = new module$src$externals$three.default.Line(n.g.geometry, new module$src$externals$three.default.LineBasicMaterial({
                            color: q.color
                        }));
                        break;
                    case "tag3d":
                    case "tag2d":
                        r = n.g.geometry;
                        "function" === typeof r.setCanvas && r.setCanvas(k);
                        break;
                    default:
                        continue
                }
            } catch (D) {
                return g.renderingHandler.unregisterForContinuousRendering("geomAddEvent"), Promise.reject(D)
            }
            n.g.hasOwnProperty("initialMatrix") && r.applyMatrix(n.g.initialMatrix);
            r.SDMaterialDefinition = n.g.material;
            "number" === typeof d.duration && 0 < d.duration && ("tag2d" == n.g.type ? r.node.style.opacity = 0 : (r.material.transparent = !0, r.material.opacity = 0));
            p.add(r)
        }
        f(a, d);
        m || (m = new module$src$externals$three.default.Box3, m.setFromObject(l), l.SDBoundingBox = m);
        c();
        if ("number" === typeof d.duration && 0 < d.duration) return g.renderingHandler.unregisterForContinuousRendering("geomAddEvent"), e(a, d.duration);
        g.renderingHandler.unregisterForContinuousRendering("geomAddEvent");
        return Promise.resolve()
    };
    this.removeGeometry = function(a, b) {
        b = b || {};
        if (null == module$src$3d$PathUtils.default.getPathObject(h, a)) return Promise.resolve();
        g.renderingHandler.registerForContinuousRendering("geomRemoveEvent");
        c();
        return ("number" === typeof b.duration && 0 < b.duration ? d(a, b.duration) : Promise.resolve()).then(function() {
            g.interactionHandler.removeFromInteractions(a);
            g.renderingHandler.unregisterForContinuousRendering("geomRemoveEvent");
            if (module$src$3d$PathUtils.default.deletePath(h, a)) return Promise.resolve();
            var b =
                "Could not delete scene path " + a;
            g.error("ThreeDManager.removeGeometry", b);
            return Promise.reject(Error(b))
        }).catch(function(b) {
            g.error("ThreeDManager.removeGeometry", "Exception when removing geometry at path " + a, b);
            return Promise.reject(b)
        })
    };
    this.replaceGeometry = function(a, b, c) {
        c = c || {};
        g.renderingHandler.registerForContinuousRendering("geomReplaceEvent");
        var d = {};
        "number" === typeof c.duration && 0 < c.duration && (d = {
            duration: .5 * c.duration
        });
        ["interactionGroup", "interactionMode", "dragPlaneNormal", "visible"].forEach(function(a) {
            c.hasOwnProperty(a) &&
                (d[a] = c[a])
        });
        return g.removeGeometry(a, d).catch(function(a) {
            g.renderingHandler.unregisterForContinuousRendering("geomReplaceEvent");
            return Promise.reject(a)
        }).then(function() {
            g.addGeometry(a, b, d)
        }).catch(function(a) {
            g.renderingHandler.unregisterForContinuousRendering("geomReplaceEvent");
            return Promise.reject(a)
        }).then(function() {
            g.renderingHandler.unregisterForContinuousRendering("geomReplaceEvent")
        })
    };
    var t = {};
    this.registerHook("fullscreen", function(a) {
        return module$src$shared$util$GlobalUtils.default.typeCheck(a,
            "boolean", g.warn, "ThreeDManager.Hook->fullscreen") ? a && !n() ? (k.requestFullscreen ? k.requestFullscreen() : k.webkitRequestFullscreen ? k.webkitRequestFullscreen() : k.msRequestFullscreen ? k.msRequestFullscreen() : k.mozRequestFullScreen && k.mozRequestFullScreen(), t.left = k.style.left, t.top = k.style.top, k.style.left = "0%", k.style.top = "0%", g.renderingHandler.render(), !0) : !a && n() ? (document.exitFullscreen ? document.exitFullscreen() : document.webkitExitFullscreen ? document.webkitExitFullscreen() : document.msExitFullscreen ?
            document.msExitFullscreen() : document.mozCancelFullScreen && document.mozCancelFullScreen(), module$src$shared$util$GlobalUtils.default.typeCheck(t.left, "string") && (k.style.left = t.left, delete t.left), module$src$shared$util$GlobalUtils.default.typeCheck(t.top, "string") && (k.style.top = t.top, delete t.top), g.renderingHandler.render(), !0) : n() === a ? !0 : !1 : !1
    });
    this.registerHook("groundPlaneVisibility", function(a) {
        if (!module$src$shared$util$GlobalUtils.default.typeCheck(a, "boolean", g.warn, "ThreeDManager.Hook->groundPlaneVisibility")) return !1;
        q && (q.visible = a);
        g.renderingHandler.render();
        return !0
    });
    this.registerHook("groundPlaneReflectionVisibility", function(a) {
        if (!module$src$shared$util$GlobalUtils.default.typeCheck(a, "boolean", g.warn, "ThreeDManager.Hook->groundPlaneReflectionVisibility")) return !1;
        r && (r.visible = a);
        a && (g.warn("ThreeDManager.Hook->groundPlaneReflectionVisibility", "The ground plane reflection and the environment as background do not work together right now."), g.updateSetting("material.environmentMapAsBackground", !1), h.background =
            null);
        g.renderingHandler.render();
        return !0
    });
    this.registerHook("groundPlaneReflectionThreshold", function(a) {
        if (!module$src$shared$util$GlobalUtils.default.typeCheck(a, "number", g.warn, "ThreeDManager.Hook->groundPlaneReflectionThreshold")) return !1;
        r && (r.threshold = a);
        g.renderingHandler.render();
        return !0
    });
    this.registerHook("gridVisibility", function(a) {
        if (!module$src$shared$util$GlobalUtils.default.typeCheck(a, "boolean", g.warn, "ThreeDManager.Hook->gridVisibility")) return !1;
        m && (m.visible = a);
        g.renderingHandler.render();
        return !0
    });
    this.getObjectPath = function(a) {
        return module$src$3d$PathUtils.default.getObjectPath(a)
    };
    this.getPathObject = function(a, b) {
        return module$src$3d$PathUtils.default.getPathObject(a, b)
    };
    this.sceneBoundingBox = function() {
        return b()
    };
    this.setToggleCastShadow = function(a, b) {
        a = module$src$3d$PathUtils.default.getPathObject(h, a);
        if (null == a) return !1;
        a.castShadow = b;
        a.traverse(function(a) {
            a.castShadow = b
        });
        g.renderingHandler.updateShadowMap();
        g.renderingHandler.render();
        return !0
    };
    this.getScene = function() {
        g.warn("ThreeDManager.getScene",
            "Direct access to scene will be removed. Use with care.");
        return h
    }
};
var module$src$shared$scene$OutputVersion = {},
    GlobalUtils$$module$src$shared$scene$OutputVersion = module$src$shared$util$GlobalUtils.default;
module$src$shared$scene$OutputVersion.default = function(a) {
    var b = this,
        c = {},
        d = {};
    this.addOutputVersion = function(a) {
        if (!a.hasOwnProperty("id") || c.hasOwnProperty(a.id)) return !1;
        c[a.id] = a;
        a.hasOwnProperty("name") && (d[a.name] = d[a.name] || [], d[a.name].push(a.id));
        return !0
    };
    this.removeOutputVersion = function(a) {
        if (module$src$shared$util$GlobalUtils.default.typeCheck(a, "string")) {
            c[a] && delete c[a];
            var b = Object.keys(d);
            b = $jscomp.makeIterator(b);
            for (var e = b.next(); !e.done; e = b.next()) {
                e = e.value;
                var f = d[e].indexOf(a); - 1 !== f && d[e].splice(f, 1)
            }
        }
    };
    this.getOutputVersion = function(a) {
        return c[a]
    };
    this.getOutputVersionIdByName = function(a) {
        return d[a]
    };
    this.outputIds = Object.defineProperty(this, "outputIds", {
        enumerable: !0,
        configurable: !1,
        readable: !0,
        get: function() {
            return Object.keys(c)
        }
    });
    this.outputNames = Object.defineProperty(this, "outputNames", {
        enumerable: !0,
        configurable: !1,
        readable: !0,
        get: function() {
            return Object.keys(d)
        }
    });
    this.getCompiledOutputVersion = function(a, c) {
        if ("string" !== typeof a || !c) return null;
        var d = b.getOutputVersion(a);
        if (!d || !Array.isArray(d.geometry) || 0 === d.geometry.length) return null;
        var e = {
            geometry: []
        };
        "id version name bbmin bbmax interactionGroup interactionMode duration dragPlaneNormal visible".split(" ").forEach(function(a) {
            d.hasOwnProperty(a) && (e[a] = d[a])
        });
        a = null;
        if (d.hasOwnProperty("materialId")) {
            var f = this.getOutputVersion(d.materialId);
            f && (a = f.material)
        }
        f = {};
        for (var g = $jscomp.makeIterator(d.geometry), m = g.next(); !m.done; f = {
                geom: f.geom,
                g: f.g
            }, m = g.next()) {
            f.geom = m.value;
            f.g = {};
            "path type geometry texcoord initialMatrix material color".split(" ").forEach(function(a) {
                return function(b) {
                    a.geom.hasOwnProperty(b) &&
                        (a.g[b] = a.geom[b])
                }
            }(f));
            ["path", "type"].forEach(function(a) {
                return function(b) {
                    if (!a.g.hasOwnProperty(b)) return null
                }
            }(f));
            if (!f.g.hasOwnProperty("material")) {
                m = null;
                m = d.hasOwnProperty("material") ? d.material : null !== a ? a : [c];
                var q = f.g.path.split(".");
                if (0 < q.length) {
                    var r = null;
                    q = $jscomp.makeIterator(q);
                    for (var n = q.next(); !n.done; n = q.next())
                        if (n = n.value, n.includes("content_")) {
                            r = n;
                            break
                        }
                    null !== r && (r = r.split("_"), "content" === r[0] && 2 === r.length && (r = parseInt(r[1]), isNaN(r) || (f.g.material = m[r % m.length].clone(),
                        f.geom.hasOwnProperty("flatShade") && f.g.material.setFlatShading(f.geom.flatShade))))
                }
                f.g.hasOwnProperty("material") || (f.g.material = m[0])
            }
            e.geometry.push(f.g)
        }
        return e
    };
    if (null !== a && Array.isArray(a)) {
        a = $jscomp.makeIterator(a);
        for (var e = a.next(); !e.done; e = a.next()) b.addOutputVersion(e.value)
    }
};
var module$src$externals$verb_nurbs = {};
try {
    module$src$externals$verb_nurbs.default = eval("verb")
} catch (a) {
    "function" === typeof require && (module$src$externals$verb_nurbs.default = eval("require('verb-nurbs')"))
};
var module$src$shared$util$verbToThreeConversion = {
        default: {}
    },
    verb$$module$src$shared$util$verbToThreeConversion;
try {
    verb$$module$src$shared$util$verbToThreeConversion = module$src$externals$verb_nurbs.default
} catch (a) {
    verb$$module$src$shared$util$verbToThreeConversion = null
}
if (verb$$module$src$shared$util$verbToThreeConversion) {
    var THREE$156 = module$src$externals$three.default,
        asVector3 = function(a) {
            return a.map(function(a) {
                return new module$src$externals$three.default.Vector3(a[0], a[1], a[2])
            })
        },
        tessellateCurve = function(a) {
            var b = new module$src$externals$three.default.Geometry;
            b.vertices = asVector3(a.tessellate());
            return b
        },
        tessellateSurface = function(a) {
            var b = a.tessellate();
            a = new module$src$externals$three.default.Geometry;
            a.vertices = asVector3(b.points);
            a.faces = b.faces.map(function(a) {
                var c =
                    a.map(function(a) {
                        a = b.normals[a];
                        return new module$src$externals$three.default.Vector3(a[0], a[1], a[2])
                    });
                return new module$src$externals$three.default.Face3(a[0], a[1], a[2], c)
            });
            return a
        };
    verb$$module$src$shared$util$verbToThreeConversion.geom.NurbsCurve.prototype.toThreeGeometry = function() {
        return tessellateCurve(this)
    };
    verb$$module$src$shared$util$verbToThreeConversion.geom.NurbsSurface.prototype.toThreeGeometry = function() {
        return tessellateSurface(this)
    }
};
var module$src$shared$singletons$GLBLoader = {},
    axios$$module$src$shared$singletons$GLBLoader = module$src$externals$axios.default,
    THREE$$module$src$shared$singletons$GLBLoader = module$src$externals$three.default,
    verb$$module$src$shared$singletons$GLBLoader;
try {
    verb$$module$src$shared$singletons$GLBLoader = module$src$externals$verb_nurbs.default
} catch (a) {
    verb$$module$src$shared$singletons$GLBLoader = null
}
var MaterialAttributes$$module$src$shared$singletons$GLBLoader = module$src$shared$materials$MaterialAttributes.default,
    GlobalUtils$$module$src$shared$singletons$GLBLoader = module$src$shared$util$GlobalUtils.default;
module$src$shared$singletons$GLBLoader.default = new function() {
    var a = this;
    this.log = function() {};
    this.warn = function() {};
    this.error = function() {};
    this.loadGeometry = function(a, d, e) {
        e = e || .001;
        return (0, module$src$externals$axios.default)({
            method: "GET",
            url: a,
            timeout: 2E4,
            crossDomain: !0,
            headers: {
                "Access-Control-Allow-Origin": "*"
            },
            responseType: "arraybuffer"
        }).catch(function(a) {
            return a.response ? Promise.reject(Error("Loading glb failed with status " + a.response.status + ".")) : a.request ? Promise.reject(Error("No response to glb download AJAX request.")) :
                Promise.reject(Error("Error setting up the glb download AJAX request."))
        }).then(function(a) {
            return b(a.data, d, e)
        })
    };
    var b = function(b, d, e) {
        return new Promise(function(c, g) {
            for (var f = new DataView(b), k = "", l = 0; 4 > l; ++l) k += String.fromCharCode(f.getUint8(l));
            if ("glTF" != k) g(Error("ShapeDiverGLBLoader got invalid data: glTF magic wrong."));
            else {
                for (var p = f.getUint32(8, !0), m = f.getUint32(12, !0), q = "", r = 0; r < m; ++r) q += String.fromCharCode(f.getUint8(20 + r));
                var n = JSON.parse(q),
                    t = 20 + m;
                if (n.hasOwnProperty("meshes") &&
                    n.hasOwnProperty("bufferViews") && n.hasOwnProperty("accessors")) {
                    var u = {},
                        w = Object.keys(n.accessors),
                        v;
                    for (v in w) {
                        var y = n.accessors[w[v]],
                            A = y.bufferView;
                        if (n.bufferViews.hasOwnProperty(A)) {
                            var x = n.bufferViews[A],
                                z = {};
                            if (!y.hasOwnProperty("type") || !y.hasOwnProperty("count") || !y.hasOwnProperty("componentType")) {
                                g(Error("Invalid JSON format in glTF file. Accessor is missing required property."));
                                return
                            }
                            switch (y.type) {
                                case "SCALAR":
                                    z.itemSize = 1;
                                    break;
                                case "VEC2":
                                    z.itemSize = 2;
                                    break;
                                case "VEC3":
                                    z.itemSize =
                                        3;
                                    break;
                                case "VEC4":
                                    z.itemSize = 4;
                                    break;
                                case "MAT2":
                                    z.itemSize = 4;
                                    break;
                                case "MAT3":
                                    z.itemSize = 9;
                                    break;
                                case "MAT4":
                                    z.itemSize = 16;
                                    break;
                                default:
                                    z.itemSize = 1
                            }
                            var B = t + parseInt(x.byteOffset) + parseInt(y.byteOffset);
                            if (b.length < B + y.count * z.itemSize) {
                                g(Error("Error: buffer length exceeded"));
                                return
                            }
                            var N = void 0,
                                K = void 0,
                                H = void 0,
                                D = y.count * z.itemSize;
                            switch (y.componentType) {
                                case 5120:
                                    z.typedArray = new Int8Array(b, B, D);
                                    break;
                                case 5121:
                                    z.typedArray = new Uint8Array(b, B, D);
                                    break;
                                case 5122:
                                    if (0 == B % 2) z.typedArray =
                                        new Int16Array(b, B, D);
                                    else {
                                        a.warn("Geometry loader encountered unaligned data.");
                                        N = new ArrayBuffer(2 * D);
                                        K = new Int8Array(N);
                                        H = new Int8Array(b, B, 2 * D);
                                        for (var I = 0, G = 2 * D; I < G; ++I) K[I] = H[I];
                                        z.typedArray = new Int16Array(N, 0, y.count * z.itemSize)
                                    }
                                    break;
                                case 5123:
                                    if (0 == B % 2) z.typedArray = new Uint16Array(b, B, D);
                                    else {
                                        a.warn("Geometry loader encountered unaligned data.");
                                        N = new ArrayBuffer(2 * D);
                                        K = new Int8Array(N);
                                        H = new Int8Array(b, B, 2 * D);
                                        for (var T = 0, L = 2 * D; T < L; ++T) K[T] = H[T];
                                        z.typedArray = new Uint16Array(N, 0, D)
                                    }
                                    break;
                                case 5124:
                                    a.warn("Encountered 16 bit integer as type for array buffer. This is illegal for webGL. Ignoring it.");
                                    break;
                                case 5125:
                                    a.warn("Encountered 16 bit unsigned integer as type for array buffer. This is illegal for webGL. Ignoring it.");
                                    break;
                                case 5126:
                                    if (0 == B % 4) z.typedArray = new Float32Array(b, B, D);
                                    else {
                                        a.warn("Geometry loader encountered unaligned data.");
                                        N = new ArrayBuffer(4 * D);
                                        K = new Int8Array(N);
                                        H = new Int8Array(b, B, 4 * D);
                                        for (var F = 0, M = 4 * D; F < M; ++F) K[F] = H[F];
                                        z.typedArray = new Float32Array(N, 0, D)
                                    }
                                    break;
                                default:
                                    z.typedArray = new Float32Array(b, B, D)
                            }
                            u[w[v]] = z
                        }
                    }
                    var J = {};
                    if (n.hasOwnProperty("materials")) {
                        var R = n.materials,
                            V;
                        for (V in R) {
                            if (!R[V].hasOwnProperty("extensions")) {
                                g(Error("ShapeDiverGLBLoader got invalid data: material definition did not contain extensions member."));
                                return
                            }
                            if (!R[V].extensions.hasOwnProperty("KHR_materials_common")) {
                                g(Error("ShapeDiverGLBLoader got invalid data: material definition did not contain KHR_materials_common member."));
                                return
                            }
                            if (!R[V].extensions.KHR_materials_common.hasOwnProperty("technique")) {
                                g(Error("ShapeDiverGLBLoader got invalid data: material definition did not contain technique member."));
                                return
                            }
                            if ("BLINN" != R[V].extensions.KHR_materials_common.technique) {
                                g(Error("ShapeDiverGLBLoader got invalid data: only BLINN material technique is supported, we got " + R[V].extensions.KHR_materials_common.technique));
                                return
                            }
                            if (!R[V].extensions.KHR_materials_common.hasOwnProperty("values")) {
                                g(Error("ShapeDiverGLBLoader got invalid data: material definition did not contain values member."));
                                return
                            }
                            var S = new module$src$shared$materials$MaterialAttributes.default,
                                O = R[V].extensions.KHR_materials_common.values;
                            O.hasOwnProperty("doubleSided") && (O.doubleSided ? S.setSide(module$src$externals$three.default.DoubleSide) : S.setSide(module$src$externals$three.default.FrontSide));
                            if (O.hasOwnProperty("diffuse")) {
                                for (var ba = O.diffuse.slice(0, 3), X = 0; 3 > X; ++X) ba[X] *= 255;
                                S.setColor(ba);
                                S.setTransparency(1 - Math.max(0, Math.min(O.diffuse[3], 1)))
                            }
                            O.hasOwnProperty("shininess") && (S.setMetalness(Math.min(1, O.shininess)), S.setRoughness(1 - Math.min(1, O.shininess)));
                            O.hasOwnProperty("transparency") && S.setTransparency(Math.max(0, Math.min(O.transparency,
                                1)));
                            if (O.hasOwnProperty("transparent")) {
                                var ca = module$src$shared$util$GlobalUtils.default.toBoolean(O.transparent);
                                S.setTransparent(ca);
                                ca || S.setTransparency(0)
                            } else S.setTransparent(0 < S.getTransparency());
                            O.hasOwnProperty("roughness") && S.setRoughness(Math.min(1, Math.max(0, O.roughness)));
                            O.hasOwnProperty("metalness") && (S.setMetalness = Math.min(1, Math.max(0, O.metalness)));
                            J[V] = S
                        }
                    }
                    var E = {},
                        P;
                    for (P in n.meshes)
                        if (n.meshes.hasOwnProperty(P)) {
                            var Y = [],
                                sa = n.meshes[P];
                            if (!sa.hasOwnProperty("primitives")) {
                                g(Error("ShapeDiverGLBLoader got invalid data: primitives property missing."));
                                return
                            }
                            for (var ka = $jscomp.makeIterator(sa.primitives), na = ka.next(); !na.done; na = ka.next()) {
                                var Q = na.value;
                                if (!Q.hasOwnProperty("indices") || !Q.hasOwnProperty("attributes")) {
                                    g(Error("ShapeDiverGLBLoader got invalid data: mesh definition primitive misses indices or attributes."));
                                    return
                                }
                                if (!Q.attributes.hasOwnProperty("POSITION")) {
                                    g(Error("ShapeDiverGLBLoader got invalid data: mesh definition primitive is missing POSITION"));
                                    return
                                }
                                var ta = new module$src$externals$three.default.BufferGeometry;
                                if (!u.hasOwnProperty(Q.indices)) {
                                    g(Error("ShapeDiverGLBLoader got invalid data: accessor for mesh primitives not found."));
                                    return
                                }
                                var Oa = u[Q.indices];
                                ta.setIndex(new module$src$externals$three.default.BufferAttribute(Oa.typedArray, Oa.itemSize));
                                if (!u.hasOwnProperty(Q.attributes.POSITION)) {
                                    g(Error("ShapeDiverGLBLoader got invalid data: accessor for mesh positions not found"));
                                    return
                                }
                                var Ha = u[Q.attributes.POSITION];
                                ta.addAttribute("position", new module$src$externals$three.default.BufferAttribute(Ha.typedArray, Ha.itemSize));
                                var wa = !1;
                                if (Q.attributes.hasOwnProperty("NORMAL")) {
                                    if (u.hasOwnProperty(Q.attributes.NORMAL)) {
                                        for (var C =
                                                u[Q.attributes.NORMAL], W = !1, aa = 0; 10 > aa; ++aa) {
                                            if (.001 < Math.abs(C.typedArray[3 * aa])) {
                                                W = !0;
                                                break
                                            }
                                            if (.001 < Math.abs(C.typedArray[3 * aa + 1])) {
                                                W = !0;
                                                break
                                            }
                                            if (.001 < Math.abs(C.typedArray[3 * aa + 2])) {
                                                W = !0;
                                                break
                                            }
                                        }
                                        W ? ta.addAttribute("normal", new module$src$externals$three.default.BufferAttribute(C.typedArray, C.itemSize)) : ta.computeVertexNormals()
                                    }
                                } else wa = !0;
                                var U = !1;
                                if (Q.attributes.hasOwnProperty("COLOR") && u.hasOwnProperty(Q.attributes.COLOR)) {
                                    var va = u[Q.attributes.COLOR];
                                    ta.addAttribute("color", new module$src$externals$three.default.BufferAttribute(va.typedArray,
                                        va.itemSize, !0));
                                    U = !0
                                }
                                var fa = !1;
                                if (Q.attributes.hasOwnProperty("TEXCOORD_0") && u.hasOwnProperty(Q.attributes.TEXCOORD_0)) {
                                    var ya = u[Q.attributes.TEXCOORD_0];
                                    ta.addAttribute("uv", new module$src$externals$three.default.BufferAttribute(ya.typedArray, ya.itemSize));
                                    fa = !0
                                }
                                var Fa = null;
                                if (Q.hasOwnProperty("material")) {
                                    var Na = Q.material;
                                    J.hasOwnProperty(Na) && (Fa = J[Na])
                                }
                                var Ca = {
                                    geometry: ta,
                                    hasTexCoord: fa,
                                    hasVertexColors: U,
                                    flatShading: wa
                                };
                                null != Fa && (Ca.material = Fa);
                                Y.push(Ca)
                            }
                            E[P] = Y
                        }
                    var da = [],
                        Ga = Object.getOwnPropertyNames(n.nodes);
                    Array.isArray(d) && 0 != d.length && d.every(function(a) {
                        return a && a.isMatrix4
                    }) || (d = [new module$src$externals$three.default.Matrix4]);
                    for (var Da in Ga) {
                        var ma = n.nodes[Ga[Da]],
                            $a = Ga[Da],
                            Va = new module$src$externals$three.default.Matrix4;
                        ma.hasOwnProperty("matrix") && Va.fromArray(ma.matrix);
                        if (ma.hasOwnProperty("meshes"))
                            for (var Ka = 0; Ka < d.length; ++Ka) {
                                var ra = d[Ka],
                                    ua = new module$src$externals$three.default.Matrix4;
                                ua.multiplyMatrices(ra, Va);
                                for (var bb in ma.meshes) {
                                    var ia = ma.meshes[bb];
                                    if (E.hasOwnProperty(ia))
                                        for (var ha =
                                                0, sb = E[ia].length; ha < sb; ++ha) {
                                            var tb = {
                                                path: "transformation_" + Ka + "." + $a + "." + ia + ".primitive_" + ha,
                                                geometry: E[ia][ha].geometry,
                                                texCoord: E[ia][ha].hasTexCoord,
                                                vertexColors: E[ia][ha].hasVertexColors,
                                                initialMatrix: ua,
                                                type: "mesh"
                                            };
                                            E[ia][ha].hasOwnProperty("material") ? (E[ia][ha].flatShading && E[ia][ha].material.setFlatShading(E[ia][ha].flatShading), tb.material = E[ia][ha].material) : tb.flatShade = E[ia][ha].flatShading;
                                            da.push(tb)
                                        }
                                }
                            }
                    }
                    for (var ub = "", vb = 0; 5 > vb; ++vb) ub += String.fromCharCode(f.getUint8(p + vb));
                    if ("sdgTF" !=
                        ub) a.warn("ShapeDiverGLBLoader got invalid data, sdgTF magic wrong : " + ub);
                    else {
                        for (var ab = f.getUint32(p + 13, !0), Hb = "", xc = Math.ceil(ab / 1024), Wa = 0; Wa < xc; ++Wa) {
                            var Ib = 1024;
                            1024 > ab - 1024 * Wa && (Ib = ab - 1024 * Wa);
                            Hb += String.fromCharCode.apply(null, new Uint8Array(b, p + 21 + 1024 * Wa, Ib))
                        }
                        var ea = JSON.parse(Hb),
                            yc = p + 21 + ab;
                        if (ea.hasOwnProperty("accessors")) {
                            u = {};
                            w = Object.getOwnPropertyNames(ea.accessors);
                            for (var Jb in w) {
                                var ja = ea.accessors[w[Jb]],
                                    Z = {};
                                if (!ja.hasOwnProperty("type") || !ja.hasOwnProperty("count") || !ja.hasOwnProperty("componentType")) {
                                    a.warn("ShapeDiverGLBLoader got invalid data for ShapeDiver formats. Returning pure glTF-based object only.");
                                    c(da);
                                    return
                                }
                                switch (ja.type) {
                                    case "SCALAR":
                                        Z.itemSize = 1;
                                        break;
                                    case "VEC2":
                                        Z.itemSize = 2;
                                        break;
                                    case "VEC3":
                                        Z.itemSize = 3;
                                        break;
                                    case "VEC4":
                                        Z.itemSize = 4;
                                        break;
                                    case "VEC7":
                                        Z.itemSize = 7;
                                        break;
                                    case "VEC10":
                                        Z.itemSize = 10;
                                        break;
                                    case "VEC12":
                                        Z.itemSize = 12;
                                        break;
                                    case "MAT2":
                                        Z.itemSize = 4;
                                        break;
                                    case "MAT3":
                                        Z.itemSize = 9;
                                        break;
                                    case "MAT4":
                                        Z.itemSize = 16;
                                        break;
                                    default:
                                        Z.itemSize = 1
                                }
                                var La = yc + parseInt(ja.byteOffset);
                                b.length < La + ja.count * ja.itemSize && a.warn("Error: buffer length exceeded");
                                switch (ja.componentType) {
                                    case 5120:
                                        Z.typedArray =
                                            new Int8Array(b, La, ja.count * Z.itemSize);
                                        break;
                                    case 5121:
                                        Z.typedArray = new Uint8Array(b, La, ja.count * Z.itemSize);
                                        break;
                                    case 5122:
                                        Z.typedArray = new Int16Array(b, La, ja.count * Z.itemSize);
                                        break;
                                    case 5123:
                                        Z.typedArray = new Uint16Array(b, La, ja.count * Z.itemSize);
                                        break;
                                    case 5126:
                                        Z.typedArray = new Float32Array(b, La, ja.count * Z.itemSize);
                                        break;
                                    default:
                                        Z.typedArray = new Float32Array(b, La, ja.count * Z.itemSize)
                                }
                                Z.count = ja.count;
                                u[w[Jb]] = Z
                            }
                            if (ea.hasOwnProperty("spheres")) {
                                var Lb = ea.spheres;
                                if (Lb.hasOwnProperty("attributes")) {
                                    var Mb =
                                        Lb.attributes;
                                    if (Mb.hasOwnProperty("SPHERES"))
                                        for (var Xa = u[Mb.SPHERES], wb, Ma = 0, zc = Xa.count; Ma < zc; ++Ma) wb = new module$src$externals$three.default.SphereBufferGeometry(Xa.typedArray[4 * Ma + 3], 20, 20), wb.translate(Xa.typedArray[4 * Ma], Xa.typedArray[4 * Ma + 1], Xa.typedArray[4 * Ma + 2]), da.push({
                                            path: "sdgtf_sphere_" + (Ma + 1).toString(),
                                            geometry: wb,
                                            texCoord: !1,
                                            type: "mesh"
                                        })
                                }
                            }
                            if (ea.hasOwnProperty("circles")) {
                                var Kb = ea.circles;
                                if (Kb.hasOwnProperty("attributes")) {
                                    var Nb = Kb.attributes;
                                    if (Nb.hasOwnProperty("CIRCLES"))
                                        for (var xa =
                                                u[Nb.CIRCLES], oa = 0, Ac = xa.count; oa < Ac; ++oa) {
                                            var yb = new module$src$externals$three.default.Vector3(xa.typedArray[10 * oa], xa.typedArray[10 * oa + 1], xa.typedArray[10 * oa + 2]),
                                                cb = new module$src$externals$three.default.Vector3(xa.typedArray[10 * oa + 3], xa.typedArray[10 * oa + 4], xa.typedArray[10 * oa + 5]),
                                                db = new module$src$externals$three.default.Vector3(xa.typedArray[10 * oa + 6], xa.typedArray[10 * oa + 7], xa.typedArray[10 * oa + 8]),
                                                Ob = xa.typedArray[10 * oa + 9],
                                                eb = new module$src$externals$three.default.Vector3;
                                            eb.crossVectors(cb, db);
                                            if (0 < Ob) {
                                                var Bc = new module$src$externals$three.default.ArcCurve(0, 0, Ob, 0, 2 * Math.PI, !1),
                                                    fb = (new module$src$externals$three.default.Geometry).setFromPoints(Bc.getPoints(50)),
                                                    Pb = new module$src$externals$three.default.Matrix4;
                                                Pb.set(cb.x, db.x, eb.x, 0, cb.y, db.y, eb.y, 0, cb.z, db.z, eb.z, 0, 0, 0, 0, 1);
                                                fb.applyMatrix(Pb);
                                                fb.translate(yb.x, yb.y, yb.z);
                                                fb.sdgtfType = "circle";
                                                da.push({
                                                    path: "sdgtf_circle_" + (oa + 1).toString(),
                                                    geometry: fb,
                                                    type: "line"
                                                })
                                            } else this.logger.debug("Circle " + oa + " has <= zero radius. Ignoring it.")
                                        }
                                }
                            }
                            if (ea.hasOwnProperty("cylinders")) {
                                var Qb =
                                    ea.cylinders;
                                if (Qb.hasOwnProperty("attributes")) {
                                    var Rb = Qb.attributes;
                                    if (Rb.hasOwnProperty("CYLINDERS"))
                                        for (var Ia = u[Rb.CYLINDERS], Pa, za = 0, Cc = Ia.count; za < Cc; ++za) {
                                            var Qa = new module$src$externals$three.default.Vector3(Ia.typedArray[7 * za], Ia.typedArray[7 * za + 1], Ia.typedArray[7 * za + 2]),
                                                Ea = new module$src$externals$three.default.Vector3(Ia.typedArray[7 * za + 3], Ia.typedArray[7 * za + 4], Ia.typedArray[7 * za + 5]),
                                                zb = Ia.typedArray[7 * za + 6];
                                            this.logger.group(3);
                                            this.logger.debug("Cylinder found:");
                                            this.logger.debug("Bottom:" +
                                                Ea.x + " / " + Ea.y + " / " + Ea.z);
                                            this.logger.debug("Top:" + Qa.x + " / " + Qa.y + " / " + Qa.z);
                                            this.logger.debug("Radius: " + zb);
                                            this.logger.groupEnd(3);
                                            var pa = new module$src$externals$three.default.Vector3;
                                            pa.subVectors(Qa, Ea);
                                            var Dc = Math.abs(pa.dot(new module$src$externals$three.default.Vector3(1, 0, 0))),
                                                Ec = Math.abs(pa.dot(new module$src$externals$three.default.Vector3(0, 1, 0))),
                                                Aa = new module$src$externals$three.default.Vector3;
                                            Dc < Ec ? Aa.crossVectors(pa, new module$src$externals$three.default.Vector3(1, 0, 0)) : Aa.crossVectors(pa,
                                                new module$src$externals$three.default.Vector3(0, 1, 0));
                                            var Ja = new module$src$externals$three.default.Vector3;
                                            Ja.crossVectors(pa, Aa);
                                            pa.normalize();
                                            Aa.normalize();
                                            Ja.normalize();
                                            Pa = new module$src$externals$three.default.CylinderBufferGeometry(zb, zb, Qa.distanceTo(Ea), 50, 1, !0);
                                            Pa.rotateX(.5 * Math.PI);
                                            Pa.translate(0, 0, .5 * Qa.distanceTo(Ea));
                                            var Sb = new module$src$externals$three.default.Matrix4;
                                            this.logger.group(3);
                                            this.logger.debug("Cylinder rotation matrix:");
                                            this.logger.debug(Aa.x + " - " + Ja.x + " - " + pa.x +
                                                " - 0");
                                            this.logger.debug(Aa.y + " - " + Ja.y + " - " + pa.y + " - 0");
                                            this.logger.debug(Aa.z + " - " + Ja.z + " - " + pa.z + " - 0");
                                            this.logger.debug(0, 0, 0, 0);
                                            this.logger.groupEnd(3);
                                            Sb.set(Aa.x, Ja.x, pa.x, 0, Aa.y, Ja.y, pa.y, 0, Aa.z, Ja.z, pa.z, 0, 0, 0, 0, 1);
                                            Pa.applyMatrix(Sb);
                                            Pa.translate(Ea.x, Ea.y, Ea.z);
                                            da.push({
                                                path: "sdgtf_cylinder_" + (za + 1).toString(),
                                                geometry: Pa,
                                                texCoord: !1,
                                                type: "mesh"
                                            })
                                        }
                                }
                            }
                            if (ea.hasOwnProperty("arcs")) {
                                var Tb = ea.arcs;
                                if (Tb.hasOwnProperty("attributes")) {
                                    var Ub = Tb.attributes;
                                    if (Ub.hasOwnProperty("ARCS"))
                                        for (var qa =
                                                u[Ub.ARCS], la = 0, Fc = qa.count; la < Fc; ++la) {
                                            var Ab = new module$src$externals$three.default.Vector3(qa.typedArray[12 * la], qa.typedArray[12 * la + 1], qa.typedArray[12 * la + 2]),
                                                gb = new module$src$externals$three.default.Vector3(qa.typedArray[12 * la + 3], qa.typedArray[12 * la + 4], qa.typedArray[12 * la + 5]),
                                                hb = new module$src$externals$three.default.Vector3(qa.typedArray[12 * la + 6], qa.typedArray[12 * la + 7], qa.typedArray[12 * la + 8]),
                                                Vb = qa.typedArray[12 * la + 9],
                                                Wb = qa.typedArray[12 * la + 10],
                                                Xb = qa.typedArray[12 * la + 11],
                                                ib = new module$src$externals$three.default.Vector3;
                                            ib.crossVectors(gb, hb);
                                            if (0 < Vb) {
                                                var Gc = new module$src$externals$three.default.ArcCurve(0, 0, Vb, Wb, Xb, !1),
                                                    jb = (new module$src$externals$three.default.Geometry).setFromPoints(Gc.getPoints(Math.max(3, Math.round((Xb - Wb) / 2 * 50 * Math.PI)))),
                                                    Yb = new module$src$externals$three.default.Matrix4;
                                                Yb.set(gb.x, hb.x, ib.x, 0, gb.y, hb.y, ib.y, 0, gb.z, hb.z, ib.z, 0, 0, 0, 0, 1);
                                                jb.applyMatrix(Yb);
                                                jb.translate(Ab.x, Ab.y, Ab.z);
                                                jb.sdgtfType = "arc";
                                                da.push({
                                                    path: "sdgtf_arc_" + (la + 1).toString(),
                                                    geometry: jb,
                                                    type: "line"
                                                })
                                            }
                                        }
                                }
                            }
                            if (verb$$module$src$shared$singletons$GLBLoader &&
                                ea.hasOwnProperty("beziercurves")) {
                                var Zb = ea.beziercurves,
                                    $b = 0,
                                    ac;
                                for (ac in Zb) {
                                    var kb = Zb[ac];
                                    if (kb.hasOwnProperty("attributes") && kb.hasOwnProperty("degree")) {
                                        var lb = kb.attributes;
                                        if (lb.hasOwnProperty("KNOTS") && lb.hasOwnProperty("CONTROLPOINTS")) {
                                            for (var mb = u[lb.KNOTS], Bb = [], Ra = 0, Hc = mb.typedArray.length; Ra < Hc; ++Ra) Bb.push(mb.typedArray[Ra]), 0 != Ra && Ra != mb.typedArray.length - 1 || Bb.push(mb.typedArray[Ra]);
                                            for (var nb = u[lb.CONTROLPOINTS], bc = [], Ya = 0, Ic = nb.typedArray.length / 3; Ya < Ic; ++Ya) bc.push([nb.typedArray[3 *
                                                Ya], nb.typedArray[3 * Ya + 1], nb.typedArray[3 * Ya + 2]]);
                                            var Jc = kb.degree,
                                                cc = void 0;
                                            try {
                                                cc = verb$$module$src$shared$singletons$GLBLoader.geom.NurbsCurve.byKnotsControlPointsWeights(Jc, Bb, bc)
                                            } catch (xb) {
                                                a.warn("verb nurbs curve creation failed with error " + xb);
                                                continue
                                            }
                                            var dc = cc.toThreeGeometry(e);
                                            dc.sdgtfType = "beziercurve";
                                            da.push({
                                                path: "sdgtf_curve_" + ($b + 1).toString(),
                                                geometry: dc,
                                                type: "line"
                                            });
                                            ++$b
                                        }
                                    }
                                }
                            }
                            if (verb$$module$src$shared$singletons$GLBLoader && ea.hasOwnProperty("surfacepatches")) {
                                var ec = ea.surfacepatches,
                                    fc = 0,
                                    gc;
                                for (gc in ec) {
                                    var Ba = ec[gc];
                                    if (Ba.hasOwnProperty("attributes") && Ba.hasOwnProperty("degreeU") && Ba.hasOwnProperty("degreeV") && Ba.hasOwnProperty("controlPointCountU") && Ba.hasOwnProperty("controlPointCountV")) {
                                        var Sa = Ba.attributes;
                                        if (Sa.hasOwnProperty("KNOTSU") && Sa.hasOwnProperty("KNOTSV") && Sa.hasOwnProperty("CONTROLPOINTS")) {
                                            for (var ob = u[Sa.KNOTSU], Cb = [], Ta = 0, Kc = ob.typedArray.length; Ta < Kc; ++Ta) Cb.push(ob.typedArray[Ta]), 0 != Ta && Ta != ob.typedArray.length - 1 || Cb.push(ob.typedArray[Ta]);
                                            for (var pb =
                                                    u[Sa.KNOTSV], Db = [], Ua = 0, Lc = pb.typedArray.length; Ua < Lc; ++Ua) Db.push(pb.typedArray[Ua]), 0 != Ua && Ua != pb.typedArray.length - 1 || Db.push(pb.typedArray[Ua]);
                                            for (var Mc = Ba.controlPointCountU, Nc = Ba.controlPointCountV, Eb = u[Sa.CONTROLPOINTS], hc = [], qb = 0, ic = 0; ic < Mc; ++ic) {
                                                for (var jc = [], kc = 0; kc < Nc; ++kc) jc.push([Eb.typedArray[3 * qb], Eb.typedArray[3 * qb + 1], Eb.typedArray[3 * qb + 2]]), ++qb;
                                                hc.push(jc)
                                            }
                                            var Oc = Ba.degreeU,
                                                Pc = Ba.degreeV,
                                                lc = void 0;
                                            try {
                                                lc = verb$$module$src$shared$singletons$GLBLoader.geom.NurbsSurface.byKnotsControlPointsWeights(Oc,
                                                    Pc, Cb, Db, hc)
                                            } catch (xb) {
                                                a.warn("verb surface curve creation failed with error " + xb.message);
                                                continue
                                            }
                                            var Fb = lc.toThreeGeometry(e);
                                            Fb.computeFaceNormals();
                                            Fb.computeVertexNormals();
                                            da.push({
                                                path: "sdgtf_surface_" + (fc + 1).toString(),
                                                geometry: Fb,
                                                texCoord: !1,
                                                type: "mesh"
                                            });
                                            ++fc
                                        }
                                    }
                                }
                            }
                            if (ea.hasOwnProperty("polylines")) {
                                var mc = ea.polylines,
                                    nc = 0,
                                    oc;
                                for (oc in mc) {
                                    var pc = mc[oc];
                                    if (pc.hasOwnProperty("attributes")) {
                                        var qc = pc.attributes;
                                        if (qc.hasOwnProperty("VERTICES")) {
                                            var Qc = u[qc.VERTICES],
                                                Gb = new module$src$externals$three.default.BufferGeometry;
                                            Gb.addAttribute("position", new module$src$externals$three.default.BufferAttribute(Qc.typedArray, 3));
                                            Gb.sdgtfType = "polyline";
                                            da.push({
                                                path: "sdgtf_polyline_" + (nc + 1).toString(),
                                                geometry: Gb,
                                                type: "line"
                                            });
                                            ++nc
                                        }
                                    }
                                }
                            }
                            if (ea.hasOwnProperty("points")) {
                                var rc = ea.points,
                                    sc = 0,
                                    tc;
                                for (tc in rc) {
                                    var uc = rc[tc];
                                    if (uc.hasOwnProperty("attributes")) {
                                        var vc = uc.attributes;
                                        if (vc.hasOwnProperty("POINTS")) {
                                            for (var rb = u[vc.POINTS], wc = new module$src$externals$three.default.Geometry, Za = 0, Rc = rb.typedArray.length / 3; Za < Rc; ++Za) {
                                                var Sc =
                                                    new module$src$externals$three.default.Vector3(rb.typedArray[3 * Za], rb.typedArray[3 * Za + 1], rb.typedArray[3 * Za + 2]);
                                                wc.vertices.push(Sc)
                                            }
                                            da.push({
                                                path: "sdgtf_pointcloud_" + (sc + 1).toString(),
                                                geometry: wc,
                                                type: "points"
                                            });
                                            ++sc
                                        }
                                    }
                                }
                            }
                        } else a.warn("ShapeDiverGLBLoader got invalid data for ShapeDiver formats. Returning pure glTF-based object only.")
                    }
                    c(da)
                } else g(Error("Invalid JSON format in glTF file. Main object is missing required property."))
            }
        })
    }
};
var module$src$3d$loaders$MTLLoader = {
        default: {}
    },
    THREE$$module$src$3d$loaders$MTLLoader = module$src$externals$three.default;
module$src$externals$three.default.MTLLoader = function(a) {
    this.manager = void 0 !== a ? a : module$src$externals$three.default.DefaultLoadingManager
};
module$src$externals$three.default.MTLLoader.prototype = {
    constructor: module$src$externals$three.default.MTLLoader,
    load: function(a, b, c, d) {
        var e = this,
            f = new module$src$externals$three.default.FileLoader(this.manager);
        f.setPath(this.path);
        f.load(a, function(a) {
            b(e.parse(a))
        }, c, d)
    },
    setPath: function(a) {
        this.path = a;
        return this
    },
    setTexturePath: function(a) {
        this.texturePath = a;
        return this
    },
    setBaseUrl: function(a) {
        console.warn("THREE.MTLLoader: .setBaseUrl() is deprecated. Use .setTexturePath( path ) for texture path or .setPath( path ) for general base path instead.");
        return this.setTexturePath(a)
    },
    setCrossOrigin: function(a) {
        this.crossOrigin = a;
        return this
    },
    setMaterialOptions: function(a) {
        this.materialOptions = a;
        return this
    },
    parse: function(a) {
        var b = a.split("\n"),
            c = {},
            d = /\s+/;
        a = {};
        for (var e = 0; e < b.length; e++) {
            var f = b[e];
            f = f.trim();
            if (0 !== f.length && "#" !== f.charAt(0)) {
                var g = f.indexOf(" "),
                    h = 0 <= g ? f.substring(0, g) : f;
                h = h.toLowerCase();
                f = 0 <= g ? f.substring(g + 1) : "";
                f = f.trim();
                "newmtl" === h ? (c = {
                    name: f
                }, a[f] = c) : c && ("ka" === h || "kd" === h || "ks" === h ? (f = f.split(d, 3), c[h] = [parseFloat(f[0]),
                    parseFloat(f[1]), parseFloat(f[2])
                ]) : c[h] = f)
            }
        }
        b = new module$src$externals$three.default.MTLLoader.MaterialCreator(this.texturePath || this.path, this.materialOptions);
        b.setCrossOrigin(this.crossOrigin);
        b.setManager(this.manager);
        b.setMaterials(a);
        return b
    }
};
module$src$externals$three.default.MTLLoader.MaterialCreator = function(a, b) {
    this.baseUrl = a || "";
    this.options = b;
    this.materialsInfo = {};
    this.materials = {};
    this.materialsArray = [];
    this.nameLookup = {};
    this.side = this.options && this.options.side ? this.options.side : module$src$externals$three.default.FrontSide;
    this.wrap = this.options && this.options.wrap ? this.options.wrap : module$src$externals$three.default.RepeatWrapping
};
module$src$externals$three.default.MTLLoader.MaterialCreator.prototype = {
    constructor: module$src$externals$three.default.MTLLoader.MaterialCreator,
    crossOrigin: "anonymous",
    setCrossOrigin: function(a) {
        this.crossOrigin = a;
        return this
    },
    setManager: function(a) {
        this.manager = a
    },
    setMaterials: function(a) {
        this.materialsInfo = this.convert(a);
        this.materials = {};
        this.materialsArray = [];
        this.nameLookup = {}
    },
    convert: function(a) {
        if (!this.options) return a;
        var b = {},
            c;
        for (c in a) {
            var d = a[c],
                e = {};
            b[c] = e;
            for (var f in d) {
                var g = !0,
                    h = d[f],
                    k = f.toLowerCase();
                switch (k) {
                    case "kd":
                    case "ka":
                    case "ks":
                        this.options && this.options.normalizeRGB && (h = [h[0] / 255, h[1] / 255, h[2] / 255]), this.options && this.options.ignoreZeroRGBs && 0 === h[0] && 0 === h[1] && 0 === h[2] && (g = !1)
                }
                g && (e[k] = h)
            }
        }
        return b
    },
    preload: function() {
        for (var a in this.materialsInfo) this.create(a)
    },
    getIndex: function(a) {
        return this.nameLookup[a]
    },
    getAsArray: function() {
        var a = 0,
            b;
        for (b in this.materialsInfo) this.materialsArray[a] = this.create(b), this.nameLookup[b] = a, a++;
        return this.materialsArray
    },
    create: function(a) {
        void 0 === this.materials[a] && this.createMaterial_(a);
        return this.materials[a]
    },
    createMaterial_: function(a) {
        function b(a, b) {
            return "string" !== typeof b || "" === b ? "" : /^https?:\/\//i.test(b) ? b : a + b
        }

        function c(a, c) {
            if (!f[a]) {
                c = d.getTextureParams(c, f);
                var e = d.loadTexture(b(d.baseUrl, c.url));
                e.repeat.copy(c.scale);
                e.offset.copy(c.offset);
                e.wrapS = d.wrap;
                e.wrapT = d.wrap;
                f[a] = e
            }
        }
        var d = this,
            e = this.materialsInfo[a],
            f = {
                name: a,
                side: this.side
            },
            g;
        for (g in e) {
            var h = e[g];
            if ("" !== h) switch (g.toLowerCase()) {
                case "kd":
                    f.color =
                        (new module$src$externals$three.default.Color).fromArray(h);
                    break;
                case "ks":
                    f.specular = (new module$src$externals$three.default.Color).fromArray(h);
                    break;
                case "map_kd":
                    c("map", h);
                    break;
                case "map_ks":
                    c("specularMap", h);
                    break;
                case "norm":
                    c("normalMap", h);
                    break;
                case "map_bump":
                case "bump":
                    c("bumpMap", h);
                    break;
                case "ns":
                    f.shininess = parseFloat(h);
                    break;
                case "d":
                    h = parseFloat(h);
                    1 > h && (f.opacity = h, f.transparent = !0);
                    break;
                case "tr":
                    h = parseFloat(h), this.options && this.options.invertTrProperty && (h = 1 - h), 0 < h && (f.opacity =
                        1 - h, f.transparent = !0)
            }
        }
        this.materials[a] = new module$src$externals$three.default.MeshPhongMaterial(f);
        return this.materials[a]
    },
    getTextureParams: function(a, b) {
        var c = {
            scale: new module$src$externals$three.default.Vector2(1, 1),
            offset: new module$src$externals$three.default.Vector2(0, 0)
        };
        a = a.split(/\s+/);
        var d = a.indexOf("-bm");
        0 <= d && (b.bumpScale = parseFloat(a[d + 1]), a.splice(d, 2));
        d = a.indexOf("-s");
        0 <= d && (c.scale.set(parseFloat(a[d + 1]), parseFloat(a[d + 2])), a.splice(d, 4));
        d = a.indexOf("-o");
        0 <= d && (c.offset.set(parseFloat(a[d +
            1]), parseFloat(a[d + 2])), a.splice(d, 4));
        c.url = a.join(" ").trim();
        return c
    },
    loadTexture: function(a, b, c, d, e) {
        var f = module$src$externals$three.default.Loader.Handlers.get(a),
            g = void 0 !== this.manager ? this.manager : module$src$externals$three.default.DefaultLoadingManager;
        null === f && (f = new module$src$externals$three.default.TextureLoader(g));
        f.setCrossOrigin && f.setCrossOrigin(this.crossOrigin);
        a = f.load(a, c, d, e);
        void 0 !== b && (a.mapping = b);
        return a
    }
};
var module$src$3d$loaders$OBJLoader = {
        default: {}
    },
    THREE$$module$src$3d$loaders$OBJLoader = module$src$externals$three.default;
module$src$externals$three.default.OBJLoader = function() {
    function a() {
        var a = {
            objects: [],
            object: {},
            vertices: [],
            normals: [],
            colors: [],
            uvs: [],
            materialLibraries: [],
            startObject: function(a, b) {
                if (this.object && !1 === this.object.fromDeclaration) this.object.name = a, this.object.fromDeclaration = !1 !== b;
                else {
                    var c = this.object && "function" === typeof this.object.currentMaterial ? this.object.currentMaterial() : void 0;
                    this.object && "function" === typeof this.object._finalize && this.object._finalize(!0);
                    this.object = {
                        name: a || "",
                        fromDeclaration: !1 !== b,
                        geometry: {
                            vertices: [],
                            normals: [],
                            colors: [],
                            uvs: []
                        },
                        materials: [],
                        smooth: !0,
                        startMaterial: function(a, b) {
                            var c = this._finalize(!1);
                            c && (c.inherited || 0 >= c.groupCount) && this.materials.splice(c.index, 1);
                            a = {
                                index: this.materials.length,
                                name: a || "",
                                mtllib: Array.isArray(b) && 0 < b.length ? b[b.length - 1] : "",
                                smooth: void 0 !== c ? c.smooth : this.smooth,
                                groupStart: void 0 !== c ? c.groupEnd : 0,
                                groupEnd: -1,
                                groupCount: -1,
                                inherited: !1,
                                clone: function(a) {
                                    a = {
                                        index: "number" === typeof a ? a : this.index,
                                        name: this.name,
                                        mtllib: this.mtllib,
                                        smooth: this.smooth,
                                        groupStart: 0,
                                        groupEnd: -1,
                                        groupCount: -1,
                                        inherited: !1
                                    };
                                    a.clone = this.clone.bind(a);
                                    return a
                                }
                            };
                            this.materials.push(a);
                            return a
                        },
                        currentMaterial: function() {
                            if (0 < this.materials.length) return this.materials[this.materials.length - 1]
                        },
                        _finalize: function(a) {
                            var b = this.currentMaterial();
                            b && -1 === b.groupEnd && (b.groupEnd = this.geometry.vertices.length / 3, b.groupCount = b.groupEnd - b.groupStart, b.inherited = !1);
                            if (a && 1 < this.materials.length)
                                for (var c = this.materials.length - 1; 0 <= c; c--) 0 >=
                                    this.materials[c].groupCount && this.materials.splice(c, 1);
                            a && 0 === this.materials.length && this.materials.push({
                                name: "",
                                smooth: this.smooth
                            });
                            return b
                        }
                    };
                    c && c.name && "function" === typeof c.clone && (a = c.clone(0), a.inherited = !0, this.object.materials.push(a));
                    this.objects.push(this.object)
                }
            },
            finalize: function() {
                this.object && "function" === typeof this.object._finalize && this.object._finalize(!0)
            },
            parseVertexIndex: function(a, b) {
                a = parseInt(a, 10);
                return 3 * (0 <= a ? a - 1 : a + b / 3)
            },
            parseNormalIndex: function(a, b) {
                a = parseInt(a,
                    10);
                return 3 * (0 <= a ? a - 1 : a + b / 3)
            },
            parseUVIndex: function(a, b) {
                a = parseInt(a, 10);
                return 2 * (0 <= a ? a - 1 : a + b / 2)
            },
            addVertex: function(a, b, c) {
                var d = this.vertices,
                    e = this.object.geometry.vertices;
                e.push(d[a + 0], d[a + 1], d[a + 2]);
                e.push(d[b + 0], d[b + 1], d[b + 2]);
                e.push(d[c + 0], d[c + 1], d[c + 2])
            },
            addVertexPoint: function(a) {
                var b = this.vertices;
                this.object.geometry.vertices.push(b[a + 0], b[a + 1], b[a + 2])
            },
            addVertexLine: function(a) {
                var b = this.vertices;
                this.object.geometry.vertices.push(b[a + 0], b[a + 1], b[a + 2])
            },
            addNormal: function(a, b, c) {
                var d =
                    this.normals,
                    e = this.object.geometry.normals;
                e.push(d[a + 0], d[a + 1], d[a + 2]);
                e.push(d[b + 0], d[b + 1], d[b + 2]);
                e.push(d[c + 0], d[c + 1], d[c + 2])
            },
            addColor: function(a, b, c) {
                var d = this.colors,
                    e = this.object.geometry.colors;
                e.push(d[a + 0], d[a + 1], d[a + 2]);
                e.push(d[b + 0], d[b + 1], d[b + 2]);
                e.push(d[c + 0], d[c + 1], d[c + 2])
            },
            addUV: function(a, b, c) {
                var d = this.uvs,
                    e = this.object.geometry.uvs;
                e.push(d[a + 0], d[a + 1]);
                e.push(d[b + 0], d[b + 1]);
                e.push(d[c + 0], d[c + 1])
            },
            addUVLine: function(a) {
                var b = this.uvs;
                this.object.geometry.uvs.push(b[a + 0], b[a +
                    1])
            },
            addFace: function(a, b, c, d, e, f, q, r, n) {
                var g = this.vertices.length;
                a = this.parseVertexIndex(a, g);
                b = this.parseVertexIndex(b, g);
                c = this.parseVertexIndex(c, g);
                this.addVertex(a, b, c);
                void 0 !== d && "" !== d && (c = this.uvs.length, a = this.parseUVIndex(d, c), b = this.parseUVIndex(e, c), c = this.parseUVIndex(f, c), this.addUV(a, b, c));
                void 0 !== q && "" !== q && (d = this.normals.length, a = this.parseNormalIndex(q, d), b = q === r ? a : this.parseNormalIndex(r, d), c = q === n ? a : this.parseNormalIndex(n, d), this.addNormal(a, b, c));
                0 < this.colors.length &&
                    this.addColor(a, b, c)
            },
            addPointGeometry: function(a) {
                this.object.geometry.type = "Points";
                for (var b = this.vertices.length, c = 0, d = a.length; c < d; c++) this.addVertexPoint(this.parseVertexIndex(a[c], b))
            },
            addLineGeometry: function(a, b) {
                this.object.geometry.type = "Line";
                for (var c = this.vertices.length, d = this.uvs.length, e = 0, f = a.length; e < f; e++) this.addVertexLine(this.parseVertexIndex(a[e], c));
                a = 0;
                for (f = b.length; a < f; a++) this.addUVLine(this.parseUVIndex(b[a], d))
            }
        };
        a.startObject("", !1);
        return a
    }

    function b(a) {
        this.manager =
            void 0 !== a ? a : module$src$externals$three.default.DefaultLoadingManager;
        this.materials = null
    }
    var c = /^[og]\s*(.+)?/,
        d = /^mtllib /,
        e = /^usemtl /;
    b.prototype = {
        constructor: b,
        load: function(a, b, c, d) {
            var e = this,
                f = new module$src$externals$three.default.FileLoader(e.manager);
            f.setPath(this.path);
            f.load(a, function(a) {
                b(e.parse(a))
            }, c, d)
        },
        setPath: function(a) {
            this.path = a;
            return this
        },
        setMaterials: function(a) {
            this.materials = a;
            return this
        },
        parse: function(b) {
            console.time("OBJLoader");
            var f = new a; - 1 !== b.indexOf("\r\n") &&
                (b = b.replace(/\r\n/g, "\n")); - 1 !== b.indexOf("\\\n") && (b = b.replace(/\\\n/g, ""));
            var h = b.split("\n"),
                k, l = "function" === typeof "".trimLeft;
            b = 0;
            for (var p = h.length; b < p; b++) {
                var m = h[b];
                m = l ? m.trimLeft() : m.trim();
                var q = m.length;
                if (0 !== q && (q = m.charAt(0), "#" !== q))
                    if ("v" === q) switch (m = m.split(/\s+/), m[0]) {
                        case "v":
                            f.vertices.push(parseFloat(m[1]), parseFloat(m[2]), parseFloat(m[3]));
                            8 === m.length && f.colors.push(parseFloat(m[4]), parseFloat(m[5]), parseFloat(m[6]));
                            break;
                        case "vn":
                            f.normals.push(parseFloat(m[1]), parseFloat(m[2]),
                                parseFloat(m[3]));
                            break;
                        case "vt":
                            f.uvs.push(parseFloat(m[1]), parseFloat(m[2]))
                    } else if ("f" === q) {
                        m = m.substr(1).trim();
                        var r = m.split(/\s+/);
                        m = [];
                        q = 0;
                        for (k = r.length; q < k; q++) {
                            var n = r[q];
                            0 < n.length && (n = n.split("/"), m.push(n))
                        }
                        r = m[0];
                        q = 1;
                        for (k = m.length - 1; q < k; q++) {
                            n = m[q];
                            var t = m[q + 1];
                            f.addFace(r[0], n[0], t[0], r[1], n[1], t[1], r[2], n[2], t[2])
                        }
                    } else if ("l" === q) {
                    q = m.substring(1).trim().split(" ");
                    k = [];
                    r = [];
                    if (-1 === m.indexOf("/")) k = q;
                    else
                        for (m = 0, n = q.length; m < n; m++) t = q[m].split("/"), "" !== t[0] && k.push(t[0]), "" !==
                            t[1] && r.push(t[1]);
                    f.addLineGeometry(k, r)
                } else if ("p" === q) m = m.substr(1).trim(), m = m.split(" "), f.addPointGeometry(m);
                else if (null !== (k = c.exec(m))) m = (" " + k[0].substr(1).trim()).substr(1), f.startObject(m);
                else if (e.test(m)) f.object.startMaterial(m.substring(7).trim(), f.materialLibraries);
                else if (d.test(m)) f.materialLibraries.push(m.substring(7).trim());
                else if ("s" === q) {
                    if (k = m.split(" "), 1 < k.length ? (m = k[1].trim().toLowerCase(), f.object.smooth = "0" !== m && "off" !== m) : f.object.smooth = !0, m = f.object.currentMaterial()) m.smooth =
                        f.object.smooth
                } else if ("\x00" !== m) throw Error('THREE.OBJLoader: Unexpected line: "' + m + '"');
            }
            f.finalize();
            h = new module$src$externals$three.default.Group;
            h.materialLibraries = [].concat(f.materialLibraries);
            b = 0;
            for (p = f.objects.length; b < p; b++)
                if (l = f.objects[b], m = l.geometry, q = l.materials, k = "Line" === m.type, r = "Points" === m.type, n = !1, 0 !== m.vertices.length) {
                    t = new module$src$externals$three.default.BufferGeometry;
                    t.addAttribute("position", new module$src$externals$three.default.Float32BufferAttribute(m.vertices,
                        3));
                    0 < m.normals.length ? t.addAttribute("normal", new module$src$externals$three.default.Float32BufferAttribute(m.normals, 3)) : t.computeVertexNormals();
                    0 < m.colors.length && (n = !0, t.addAttribute("color", new module$src$externals$three.default.Float32BufferAttribute(m.colors, 3)));
                    0 < m.uvs.length && t.addAttribute("uv", new module$src$externals$three.default.Float32BufferAttribute(m.uvs, 2));
                    for (var u = [], w = 0, v = q.length; w < v; w++) {
                        var y = q[w];
                        m = void 0;
                        if (null !== this.materials)
                            if (m = this.materials.create(y.name), k && m &&
                                !(m instanceof module$src$externals$three.default.LineBasicMaterial)) {
                                var A = new module$src$externals$three.default.LineBasicMaterial;
                                A.copy(m);
                                A.lights = !1;
                                m = A
                            } else if (r && m && !(m instanceof module$src$externals$three.default.PointsMaterial)) {
                            var x = new module$src$externals$three.default.PointsMaterial({
                                size: 10,
                                sizeAttenuation: !1
                            });
                            A.copy(m);
                            m = x
                        }
                        m || (m = k ? new module$src$externals$three.default.LineBasicMaterial : r ? new module$src$externals$three.default.PointsMaterial({
                                size: 1,
                                sizeAttenuation: !1
                            }) : new module$src$externals$three.default.MeshPhongMaterial,
                            m.name = y.name);
                        m.flatShading = y.smooth ? !1 : !0;
                        m.vertexColors = n ? module$src$externals$three.default.VertexColors : module$src$externals$three.default.NoColors;
                        u.push(m)
                    }
                    if (1 < u.length) {
                        w = 0;
                        for (v = q.length; w < v; w++) y = q[w], t.addGroup(y.groupStart, y.groupCount, w);
                        m = k ? new module$src$externals$three.default.LineSegments(t, u) : r ? new module$src$externals$three.default.Points(t, u) : new module$src$externals$three.default.Mesh(t, u)
                    } else m = k ? new module$src$externals$three.default.LineSegments(t, u[0]) : r ? new module$src$externals$three.default.Points(t,
                        u[0]) : new module$src$externals$three.default.Mesh(t, u[0]);
                    m.name = l.name;
                    h.add(m)
                }
            console.timeEnd("OBJLoader");
            return h
        }
    };
    return b
}();
var module$src$3d$loaders$DDSLoader = {
        default: {}
    },
    THREE$$module$src$3d$loaders$DDSLoader = module$src$externals$three.default;
module$src$externals$three.default.DDSLoader = function(a) {
    module$src$externals$three.default.CompressedTextureLoader.call(this, a);
    this._parser = module$src$externals$three.default.DDSLoader.parse
};
module$src$externals$three.default.DDSLoader.prototype = Object.create(module$src$externals$three.default.CompressedTextureLoader.prototype);
module$src$externals$three.default.DDSLoader.prototype.constructor = module$src$externals$three.default.DDSLoader;
module$src$externals$three.default.DDSLoader.parse = function(a, b) {
    function c(a) {
        return a.charCodeAt(0) + (a.charCodeAt(1) << 8) + (a.charCodeAt(2) << 16) + (a.charCodeAt(3) << 24)
    }

    function d(a, b, c, d) {
        var e = c * d * 4;
        a = new Uint8Array(a, b, e);
        e = new Uint8Array(e);
        for (var f = b = 0, g = 0; g < d; g++)
            for (var h = 0; h < c; h++) {
                var k = a[f];
                f++;
                var l = a[f];
                f++;
                var m = a[f];
                f++;
                var n = a[f];
                f++;
                e[b] = m;
                b++;
                e[b] = l;
                b++;
                e[b] = k;
                b++;
                e[b] = n;
                b++
            }
        return e
    }
    var e = {
            mipmaps: [],
            width: 0,
            height: 0,
            format: null,
            mipmapCount: 1
        },
        f = c("DXT1"),
        g = c("DXT3"),
        h = c("DXT5"),
        k = c("ETC1"),
        l = new Int32Array(a, 0, 31);
    if (542327876 !== l[0]) return console.error("THREE.DDSLoader.parse: Invalid magic number in DDS header."), e;
    if (!l[20] & 4) return console.error("THREE.DDSLoader.parse: Unsupported format, must contain a FourCC code."), e;
    var p = l[21],
        m = !1;
    switch (p) {
        case f:
            f = 8;
            e.format = module$src$externals$three.default.RGB_S3TC_DXT1_Format;
            break;
        case g:
            f = 16;
            e.format = module$src$externals$three.default.RGBA_S3TC_DXT3_Format;
            break;
        case h:
            f = 16;
            e.format = module$src$externals$three.default.RGBA_S3TC_DXT5_Format;
            break;
        case k:
            f = 8;
            e.format = module$src$externals$three.default.RGB_ETC1_Format;
            break;
        default:
            if (32 === l[22] && l[23] & 16711680 && l[24] & 65280 && l[25] & 255 && l[26] & 4278190080) m = !0, f = 64, e.format = module$src$externals$three.default.RGBAFormat;
            else return console.error("THREE.DDSLoader.parse: Unsupported FourCC code ", String.fromCharCode(p & 255, p >> 8 & 255, p >> 16 & 255, p >> 24 & 255)), e
    }
    e.mipmapCount = 1;
    l[2] & 131072 && !1 !== b && (e.mipmapCount = Math.max(1, l[7]));
    b = l[28];
    e.isCubemap = b & 512 ? !0 : !1;
    if (e.isCubemap && !(b & 1024 && b & 2048 && b &
            4096 && b & 8192 && b & 16384 && b & 32768)) return console.error("THREE.DDSLoader.parse: Incomplete cubemap faces"), e;
    e.width = l[4];
    e.height = l[3];
    l = l[1] + 4;
    b = e.isCubemap ? 6 : 1;
    for (g = 0; g < b; g++)
        for (h = e.width, k = e.height, p = 0; p < e.mipmapCount; p++) {
            if (m) var q = d(a, l, h, k),
                r = q.length;
            else r = Math.max(4, h) / 4 * Math.max(4, k) / 4 * f, q = new Uint8Array(a, l, r);
            e.mipmaps.push({
                data: q,
                width: h,
                height: k
            });
            l += r;
            h = Math.max(h >> 1, 1);
            k = Math.max(k >> 1, 1)
        }
    return e
};
var module$src$shared$singletons$OBJLoader = {},
    THREE$$module$src$shared$singletons$OBJLoader = module$src$externals$three.default,
    MaterialAttributes$$module$src$shared$singletons$OBJLoader = module$src$shared$materials$MaterialAttributes.default;
module$src$shared$singletons$OBJLoader.default = new function() {
    this.log = function() {};
    this.warn = function() {};
    this.error = function() {};
    module$src$externals$three.default.Loader.Handlers.add(/\.dds$/i, new module$src$externals$three.default.DDSLoader);
    this.loadGeometry = function(a, b, c, d, e, f) {
        var g = function() {
                var a = new module$src$externals$three.default.LoadingManager,
                    f = new module$src$externals$three.default.MTLLoader(a);
                f.setCrossOrigin(!0);
                null != c && f.setPath(c);
                null != d && f.setTexturePath(d);
                var g = module$src$externals$three.default.DoubleSide;
                "front" === e ? g = module$src$externals$three.default.FrontSide : "back" === e && (g = module$src$externals$three.default.BackSide);
                var m = {};
                m.wrap = module$src$externals$three.default.ClampToEdgeWrapping;
                m.side = g;
                f.setMaterialOptions(m);
                return new Promise(function() {
                    var c = null;
                    a.onLoad = function() {
                        return c.hasOwnProperty("materialsInfo") && 0 < Object.keys(c.materialsInfo).length ? h(c) : h()
                    };
                    f.load(b, function(a) {
                        a.preload();
                        c = a
                    }, function() {}, function() {
                        h()
                    })
                })
            },
            h = function(b) {
                return new Promise(function(d, e) {
                    var g = new module$src$externals$three.default.OBJLoader;
                    null != b && g.setMaterials(b);
                    null != c && g.setPath(c);
                    g.load(a, function(a) {
                        Array.isArray(f) && 0 != f.length && f.every(function(a) {
                            return a && a.isMatrix4
                        }) || (f = [new module$src$externals$three.default.Matrix4]);
                        var c = [];
                        a.traverse(function(a) {
                            if (null != a.geometry) {
                                var d = !1;
                                a.geometry instanceof module$src$externals$three.default.BufferGeometry ? a.geometry.hasOwnProperty("attributes") && a.geometry.attributes.hasOwnProperty("uv") && (d = !0) : a.geometry instanceof module$src$externals$three.default.Geometry && 0 < a.geometry.faceVertexUvs.length &&
                                    (d = !0);
                                var e = null;
                                if (null != b && a.hasOwnProperty("material")) {
                                    e = new module$src$shared$materials$MaterialAttributes.default;
                                    e.setSide(a.material.side);
                                    e.setColor(a.material.color);
                                    e.setTransparency(1 - a.material.opacity);
                                    e.setTransparent(a.material.transparent);
                                    a.material.hasOwnProperty("shininess") && (e.setMetalness(Math.min(1, a.material.shininess)), e.setRoughness(1 - Math.min(1, a.material.shininess)));
                                    if (null != a.material.map) {
                                        var g = a.material.map.clone();
                                        g.needsUpdate = !0;
                                        e.setMap(g)
                                    }["alpha", "normal",
                                        "bump"
                                    ].forEach(function(b) {
                                        if (null != a.material[b + "Map"]) {
                                            var c = a.material[b + "Map"].clone();
                                            c.needsUpdate = !0;
                                            e["set" + b.charAt(0).toUpperCase() + b.slice(1) + "Map"].call(this, c)
                                        }
                                    })
                                }
                                g = 0;
                                for (var h = $jscomp.makeIterator(f), k = h.next(); !k.done; k = h.next()) k = {
                                    path: "transformation_" + g,
                                    geometry: a.geometry,
                                    texCoord: d,
                                    initialMatrix: k.value,
                                    type: "mesh"
                                }, null != e && (k.material = e), c.push(k), ++g
                            }
                        });
                        d(c)
                    }, function() {}, function(a) {
                        e(a)
                    })
                })
            };
        return null != b && 0 < b.length ? g : h()
    }
};
var module$src$shared$singletons$THREELoader = {},
    THREE$$module$src$shared$singletons$THREELoader = module$src$externals$three.default;
module$src$shared$singletons$THREELoader.default = new function() {
    this.loadGeometry = function(a, b) {
        var c = [];
        if (a.isMesh) var d = "mesh";
        else if (a.isLine) d = "line";
        else if (a.isPoints) d = "points";
        else return Promise.reject(Error("Unsupported type of THREE.Object3D"));
        Array.isArray(b) && 0 != b.length && b.every(function(a) {
            return a && a.isMatrix4
        }) || (b = [new module$src$externals$three.default.Matrix4]);
        var e = 0;
        b = $jscomp.makeIterator(b);
        for (var f = b.next(); !f.done; f = b.next()) c.push({
            path: "transformation_" + e,
            geometry: a.geometry,
            texCoord: !1,
            initialMatrix: f.value,
            type: d
        }), ++e;
        return Promise.resolve(c)
    }
};
var module$src$shared$singletons$Tag3DLoader = {
        default: {}
    },
    THREE$$module$src$shared$singletons$Tag3DLoader = module$src$externals$three.default,
    toTinyColor$$module$src$shared$singletons$Tag3DLoader = module$src$shared$util$toTinyColor.default,
    _font3d$$module$src$shared$singletons$Tag3DLoader = null;
module$src$shared$singletons$Tag3DLoader.default.load3DTags = function(a) {
    return (new Promise(function(a) {
        null == _font3d$$module$src$shared$singletons$Tag3DLoader ? (new module$src$externals$three.default.FontLoader).load("https://d363mqea3saz7f.cloudfront.net/graphik_regular.typeface.json", function(b) {
            _font3d$$module$src$shared$singletons$Tag3DLoader = b;
            a()
        }.bind(this)) : a()
    })).then(function() {
        var b = [],
            c = {},
            d;
        for (d in a) {
            for (var e = a[d], f = {
                        size: e.size,
                        height: e.size / 10,
                        font: _font3d$$module$src$shared$singletons$Tag3DLoader
                    },
                    g = e.text.split(/\r\n|\r|\n/g), h = "tag3d_" + d, k = [], l = 0; l < g.length; ++l) {
                var p = h + ".line_" + l,
                    m = new module$src$externals$three.default.TextBufferGeometry(g[l], f);
                p = {
                    path: p,
                    geometry: m,
                    texCoord: !1,
                    type: "mesh"
                };
                "default" != e.color && (p.color = (0, module$src$shared$util$toTinyColor.default)(e.color));
                k.push(p)
            }
            f = new module$src$externals$three.default.Object3D;
            h = $jscomp.makeIterator(k);
            for (g = h.next(); !g.done; g = h.next()) f.add(new module$src$externals$three.default.Mesh(g.value.geometry, new module$src$externals$three.default.MeshPhongMaterial));
            h = g = h = void 0;
            c.lineHeight = void 0;
            c.lineHeight = 0;
            g = $jscomp.makeIterator(f.children);
            for (h = g.next(); !h.done; h = g.next()) h = h.value, h = (new module$src$externals$three.default.Box3).setFromObject(h), h = h.max.y - h.min.y, c.lineHeight = Math.max(c.lineHeight, h);
            c.lineHeight *= 1.15;
            k.forEach(function(a) {
                return function(b, c) {
                    b.geometry.translate(0, (-c - 1) * a.lineHeight, 0)
                }
            }(c));
            h = (new module$src$externals$three.default.Box3).setFromObject(f);
            g = h.max.x - h.min.x;
            h = h.max.y - h.min.y;
            f = new module$src$externals$three.default.Vector3(0,
                0, 0);
            switch (e.justification) {
                case "TC":
                    f.x = .5 * -g;
                    break;
                case "TR":
                    f.x = -g;
                    break;
                case "ML":
                    f.y = .5 * h;
                    break;
                case "MC":
                    f.x = .5 * -g;
                    f.y = .5 * h;
                    break;
                case "MR":
                    f.x = -g;
                    f.y = .5 * h;
                    break;
                case "BL":
                    f.y = h;
                    break;
                case "BC":
                    f.x = .5 * -g;
                    f.y = h;
                    break;
                case "BR":
                    f.x = -g, f.y = h
            }
            h = $jscomp.makeIterator(k);
            for (g = h.next(); !g.done; g = h.next()) g.value.geometry.translate(f.x, f.y, f.z);
            if (e.location.hasOwnProperty("xAxis"))
                for (f = new module$src$externals$three.default.Matrix4, f.set(e.location.xAxis.X, e.location.yAxis.X, e.location.normal.X,
                        0, e.location.xAxis.Y, e.location.yAxis.Y, e.location.normal.Y, 0, e.location.xAxis.Z, e.location.yAxis.Z, e.location.normal.Z, 0, 0, 0, 0, 1), h = $jscomp.makeIterator(k), g = h.next(); !g.done; g = h.next()) g = g.value, g.geometry.applyMatrix(f), g.geometry.translate(e.location.origin.X, e.location.origin.Y, e.location.origin.Z);
            Array.prototype.push.apply(b, k);
            c = {
                lineHeight: c.lineHeight
            }
        }
        return b
    })
};
var module$src$3d$Tag2D = {
        default: {}
    },
    THREE$$module$src$3d$Tag2D = module$src$externals$three.default,
    toTinyColor$$module$src$3d$Tag2D = module$src$shared$util$toTinyColor.default,
    unselectableStyle$$module$src$3d$Tag2D = document.createElement("style");
unselectableStyle$$module$src$3d$Tag2D.type = "text/css";
unselectableStyle$$module$src$3d$Tag2D.innerHTML = '@font-face { font-family: "Graphik"; src: url("https://d363mqea3saz7f.cloudfront.net/fonts/Graphik-Regular-Web.woff") format("woff"); }              .sd-tag2d-unselectable {               -webkit-touch-callout: none;               -webkit-user-select: none;               -khtml-user-select: none;               -moz-user-select: none;               -ms-user-select: none;               user-select: none;               cursor: default;               pointer-events: none;               position: absolute;               font-family: "Graphik", "Helvetica Neue", Helvetica, Arial, sans-serif;             }';
document.getElementsByTagName("head")[0].appendChild(unselectableStyle$$module$src$3d$Tag2D);
module$src$externals$three.default.Tag2D = function(a, b) {
    module$src$externals$three.default.Object3D.call(this);
    this.node = document.createElement("div");
    this.node.classList.add("sd-tag2d-unselectable");
    this.node.webkitTouchCallout = "none";
    this.node.webkitUserSelect = "none";
    this.node.khtmlTouchCallout = "none";
    this.node.mozUserSelect = "none";
    this.node.msUserSelect = "none";
    this.node.style.userSelect = "none";
    this.node.innerHTML = a;
    this.position.x = b.x;
    this.position.y = b.y;
    this.position.z = b.z;
    this.updateMatrix(!0);
    this.canvas = null
};
module$src$externals$three.default.Tag2D.prototype = Object.create(module$src$externals$three.default.Object3D.prototype);
module$src$externals$three.default.Tag2D.prototype.constructor = module$src$externals$three.default.Tag2D;
module$src$externals$three.default.Tag2D.fromJSON = function(a) {
    var b = (0, module$src$shared$util$toTinyColor.default)(a.color, "black");
    b = '<span class="sdv-tag2d-span" style="color: ' + b.toHexString() + "; opacity: " + b.getAlpha() + '; display: block">' + a.text + "</span>";
    if (!a.hasOwnProperty("location")) return null;
    ["X", "Y", "Z"].forEach(function(b) {
        if (!a.location.hasOwnProperty(b) || isNaN(parseFloat(a.location[b]))) return null
    });
    return new module$src$externals$three.default.Tag2D(b, new module$src$externals$three.default.Vector3(parseFloat(a.location.X),
        parseFloat(a.location.Y), parseFloat(a.location.Z)))
};
module$src$externals$three.default.Tag2D.prototype.setCanvas = function(a) {
    this.canvas = a;
    null != this.node.parentNode && this.node.parentNode.removeChild(this.node);
    this.canvas.appendChild(this.node)
};
module$src$externals$three.default.Tag2D.prototype.updateMatrixWorld = function() {
    var a = new module$src$externals$three.default.Vector3,
        b = new module$src$externals$three.default.Raycaster,
        c = null,
        d = null;
    return function(e) {
        module$src$externals$three.default.Object3D.prototype.updateMatrixWorld.call(this, e);
        if (null != this.canvas) {
            for (e = this; e.parent;) e = e.parent;
            if ("Scene" === e.type) {
                c = e;
                d = null;
                e = $jscomp.makeIterator(e.children);
                for (var f = e.next(); !f.done; f = e.next())
                    if (f = f.value, f instanceof module$src$externals$three.default.Camera) {
                        d =
                            f;
                        break
                    }
                if (null != d) {
                    a.set(0, 0, 0);
                    this.localToWorld(a);
                    b.ray.direction.copy(a);
                    b.ray.origin.set(0, 0, 0);
                    d.localToWorld(b.ray.origin);
                    b.ray.direction.sub(b.ray.origin);
                    e = b.ray.direction.length();
                    b.ray.direction.normalize();
                    var g = Number.MAX_VALUE;
                    c.traverseVisible(function(a) {
                        a = b.intersectObject(a, !0);
                        a.length && a[0].distance < g && (g = a[0].distance)
                    });
                    g < e ? this.node.style.display = "none" : (a.project(d), this.node.style.display = "", this.node.style.left = Math.round(this.canvas.offsetWidth / 2 * (a.x + 1) - this.node.offsetWidth /
                        2) + "px", this.node.style.top = Math.round(this.canvas.offsetHeight / 2 * (1 - a.y) - this.node.offsetHeight / 2) + "px")
                }
            }
        }
    }
}();
var module$src$app$partials$ViewerAppSceneManager = {},
    THREE$$module$src$app$partials$ViewerAppSceneManager = module$src$externals$three.default,
    toTinyColor$$module$src$app$partials$ViewerAppSceneManager = module$src$shared$util$toTinyColor.default,
    messagingConstants$$module$src$app$partials$ViewerAppSceneManager = module$src$shared$constants$MessagingConstants.default,
    MessagePrototype$$module$src$app$partials$ViewerAppSceneManager = module$src$shared$messages$MessagePrototype.default,
    SubScene$$module$src$app$partials$ViewerAppSceneManager =
    module$src$shared$scene$OutputVersion.default,
    GlobalUtils$$module$src$app$partials$ViewerAppSceneManager = module$src$shared$util$GlobalUtils.default,
    GLBLoader$$module$src$app$partials$ViewerAppSceneManager = module$src$shared$singletons$GLBLoader.default,
    OBJLoader$$module$src$app$partials$ViewerAppSceneManager = module$src$shared$singletons$OBJLoader.default,
    THREELoader$$module$src$app$partials$ViewerAppSceneManager = module$src$shared$singletons$THREELoader.default,
    Tag3DLoader$$module$src$app$partials$ViewerAppSceneManager =
    module$src$shared$singletons$Tag3DLoader.default,
    MaterialAttributes$$module$src$app$partials$ViewerAppSceneManager = module$src$shared$materials$MaterialAttributes.default;
module$src$app$partials$ViewerAppSceneManager.default = function(a) {
    var b = this,
        c = a.threeDManager,
        d = {},
        e = {},
        f = {},
        g = ["canvas", "threeObject", "transformations"],
        h = {},
        k = {},
        l = {},
        p = {},
        m = Promise.resolve(),
        q = {},
        r = {},
        n = {},
        t = ["interactionGroup", "interactionMode", "duration", "dragPlaneNormal", "visible"],
        u = function(a, b, c) {
            b = Error(b);
            b.scope = a;
            b.data = c;
            return Promise.reject(b)
        },
        w = function(a, b) {
            var c;
            var d = function(a, b) {
                return u("SceneManager._addOutputVersion", a, b)
            };
            var e = a.id;
            var k = l[e];
            var m = k.creatorId;
            var n = b.id;
            var p = !1;
            if (f[m] && f[m][n] && (n = f[m][n], n.ov))
                for (c in p = !0, n = n.ov, n) "_json" === c ? (b._json_scene = module$src$shared$util$GlobalUtils.default.deepCopy(b[c], g), module$src$shared$util$GlobalUtils.default.defaults(b._json_scene, n._json, !0)) : "_json_scene" !== c && (b[c] = n[c]);
            p || delete b._json_scene;
            if (!h[m][e].subScene.addOutputVersion(b)) return d("could not add output version to subscene");
            ++k.finishedOutputVersions;
            return k.finishedOutputVersions < k.totalOutputVersions ? Promise.resolve(!0) : y(a)
        },
        v = function(a,
            d, f, g) {
            var h = function(a, b) {
                return u("SceneManager._publishSubScene", a, b)
            };
            var k = f.id;
            g = g || {};
            var l = "boolean" === typeof g.forceUpdate ? g.forceUpdate : !1;
            if (!b.hasSetting("defaultMaterial")) return h("no default material configured");
            var r = n[d + "." + k];
            return (g = q[d]) && g.serial > r ? Promise.resolve(!1) : m = g = m.then(function() {
                var g = null;
                return (new module$src$shared$materials$MaterialAttributes.default).fromJSONMaterialObject(b.getSetting("defaultMaterial")).then(function(a) {
                    g = a
                }, function(a) {
                    return h("could not create default material",
                        a)
                }).then(function() {
                    for (var m = a.outputIds, n = e.hasOwnProperty(d) ? e[d]._subSceneObject : null, x = null !== n ? n.outputIds : [], u = $jscomp.makeIterator(x), z = u.next(); !z.done; z = u.next()) z = z.value, -1 === m.indexOf(z) && (a.addOutputVersion(n.getOutputVersion(z)), m.push(z));
                    u = [];
                    var v = {},
                        w = {};
                    z = {};
                    for (var B = m.length - 1; - 1 < B; z = {
                            compiledOutputVersion: z.compiledOutputVersion,
                            options: z.options,
                            options$208: z.options$208
                        }, --B) {
                        var y = m[B],
                            D = a.getOutputVersion(y);
                        if (D.hasOwnProperty("geometry")) {
                            z.compiledOutputVersion = a.getCompiledOutputVersion(y,
                                g);
                            if (!z.compiledOutputVersion) return h("could not compile output version " + y);
                            w[y] = {};
                            for (var A = {}, N = $jscomp.makeIterator(z.compiledOutputVersion.geometry), K = N.next(); !K.done; A = {
                                    g: A.g,
                                    o: A.o
                                }, K = N.next()) {
                                A.g = K.value;
                                A.o = w[y];
                                K = A.g.path.split(".");
                                K = $jscomp.makeIterator(K);
                                for (var H = K.next(); !H.done; H = K.next()) H = H.value, A.o[H] = A.o[H] || {}, A.o = A.o[H];
                                ["type", "geometry", "material", "initialMatrix"].forEach(function(a) {
                                    return function(b) {
                                        a.g.hasOwnProperty(b) && (a.o[b] = a.g[b])
                                    }
                                }(A));
                                A.o._isSDGeometry = !0
                            }
                            if (-1 ===
                                x.indexOf(y)) {
                                z.options = {};
                                z.compiledOutputVersion.hasOwnProperty("name") && (z.options.name = z.compiledOutputVersion.name);
                                if (z.compiledOutputVersion.hasOwnProperty("bbmin") && z.compiledOutputVersion.hasOwnProperty("bbmax")) try {
                                    var G = new module$src$externals$three.default.Box3(module$src$shared$util$GlobalUtils.default.toVector3(z.compiledOutputVersion.bbmin), module$src$shared$util$GlobalUtils.default.toVector3(z.compiledOutputVersion.bbmax));
                                    z.options.boundingBox = G
                                } catch (ka) {
                                    b.debug("SceneManager._publishSubScene",
                                        "invalid bounding box for output version " + y, ka)
                                }
                                t.forEach(function(a) {
                                    return function(b) {
                                        a.compiledOutputVersion.hasOwnProperty(b) && (a.options[b] = a.compiledOutputVersion[b])
                                    }
                                }(z));
                                u.push(c.addGeometry(d + "." + y, z.compiledOutputVersion.geometry, z.options))
                            } else(A = l) || (A = n.getOutputVersion(y).version !== D.version), !A && D.materialId && (N = a.getOutputVersion(D.materialId), (K = n.getOutputVersion(D.materialId)) && N.version === K.version || (A = !0)), A && (z.options$208 = {}, t.forEach(function(a) {
                                return function(b) {
                                    a.compiledOutputVersion.hasOwnProperty(b) &&
                                        (a.options$208[b] = a.compiledOutputVersion[b])
                                }
                            }(z)), void 0 === z.options$208.duration && (z.options$208.duration = 500), u.push(c.replaceGeometry(d + "." + y, z.compiledOutputVersion.geometry, z.options$208)))
                        } else n && (A = n.getOutputVersion(y)) && A.geometry && u.push(c.removeGeometry(d + "." + y));
                        D.hasOwnProperty("data") && (v[y] = D.data)
                    }
                    return Promise.all(u).then(function() {
                        e[d] = w;
                        e[d]._subSceneObject = a;
                        p[d] = v;
                        q[d] = {
                            serial: r,
                            id: k
                        };
                        var c = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.SUBSCENE_DEFINITION,
                            a, f);
                        b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.SCENE_SUBSCENE_PUBLISHED, c);
                        0 < Object.keys(v).length && (c = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.DATA, v, f), b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.DATA, c));
                        return a
                    })
                })
            })
        },
        y = function(a) {
            var d = function(a, b) {
                return u("SceneManager._finishProcess", a, b)
            };
            var f = a.id;
            var g = l[f];
            var m = g.creatorId;
            k[m] = k[m] || {};
            k[m][f] = h[m][f];
            delete h[m][f];
            0 === Object.keys(h[m]).length && delete h[m];
            var n = k[m][f].subScene,
                p = e[m] ? e[m]._subSceneObject : null,
                q = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_STATUS, {
                    state: module$src$shared$constants$MessagingConstants.default.messageTopics.SCENE_SUBSCENE_READY,
                    progress: .75
                }, a);
            b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS, q);
            return v(n,
                m, a, g.options).then(function(a) {
                delete k[m][f];
                0 === Object.keys(k[m]).length && delete k[m];
                return a
            }, function(b) {
                if (null !== p) return v(p, m, a).then(function() {
                    return d("publishing of subscene failed, restored previous state", b)
                });
                e.hasOwnProperty(m) && delete e[m];
                return c.removeGeometry(m).then(function() {
                    return d("publishing of subscene failed, restored previous state", b)
                })
            }).catch(function(a) {
                return d("publishing of subscene failed", a)
            })
        },
        A = function(a, b) {
            var c = function(a, b) {
                return u("SceneManager._convertOutputVersion",
                    a, b)
            };
            void 0 === b && (b = !1);
            a = a || {};
            if (!b) {
                if (!module$src$shared$util$GlobalUtils.default.typeCheck(a.version, "string")) return c("version missing");
                if (!Array.isArray(a.content)) return c("content array missing")
            }
            var d = {
                id: a.id
            };
            ["version", "name"].concat($jscomp.arrayFromIterable(t)).forEach(function(b) {
                void 0 !== a[b] && null !== a[b] && (d[b] = a[b])
            });
            module$src$shared$util$GlobalUtils.default.typeCheck(a.material, "string") && (d.materialId = a.material);
            module$src$shared$util$GlobalUtils.default.typeCheck(a.bbmin,
                "vector3any") && (d.bbmin = module$src$shared$util$GlobalUtils.default.toVector3(a.bbmin));
            module$src$shared$util$GlobalUtils.default.typeCheck(a.bbmax, "vector3any") && (d.bbmax = module$src$shared$util$GlobalUtils.default.toVector3(a.bbmax));
            var e = (d.bbmin && d.bbmax ? d.bbmin.distanceTo(d.bbmax) : 1) / 1E4,
                f = [],
                h = [];
            b = [];
            if (Array.isArray(a.content))
                for (var k = $jscomp.makeIterator(a.content), l = k.next(); !l.done; l = k.next()) {
                    l = l.value;
                    if (!module$src$shared$util$GlobalUtils.default.typeCheck(l.format, "string")) return c("format of content item missing");
                    switch (l.format) {
                        case "material":
                            if (!l.data) return c("data of material content item missing");
                            l = module$src$shared$util$GlobalUtils.default.deepCopy(l.data, g);
                            f.push(l);
                            break;
                        case "glb":
                        case "obj":
                        case "tag2d":
                        case "tag3d":
                        case "three":
                            h.push(module$src$shared$util$GlobalUtils.default.deepCopy(l, g));
                            break;
                        default:
                            b.push(module$src$shared$util$GlobalUtils.default.deepCopy(l))
                    }
                }
            k = [];
            f = $jscomp.makeIterator(f);
            for (l = f.next(); !l.done; l = f.next()) {
                l = l.value;
                var m = new module$src$shared$materials$MaterialAttributes.default;
                k.push(m.fromJSONMaterialObject(l))
            }
            f = [];
            l = {};
            h = $jscomp.makeIterator(h);
            for (m = h.next(); !m.done; l = {
                    tag2dArray: l.tag2dArray
                }, m = h.next()) {
                m = m.value;
                var n = [];
                if (m.hasOwnProperty("transformations"))
                    for (var p = $jscomp.makeIterator(m.transformations), q = p.next(); !q.done; q = p.next())
                        if (q = q.value, q.isMatrix4) n.push(q.clone());
                        else {
                            var r = new module$src$externals$three.default.Matrix4;
                            r.fromArray(q);
                            n.push(r)
                        }
                m.hasOwnProperty("href") && "glb" === m.format ? f.push(module$src$shared$singletons$GLBLoader.default.loadGeometry(m.href,
                        n, e)) : "obj" === m.format ? m.data && m.data.objUrl && f.push(module$src$shared$singletons$OBJLoader.default.loadGeometry(m.data.objUrl, m.data.mtlUrl, m.data.path, m.data.texturePath, m.data.side, n)) : "three" === m.format ? m.data && m.data.threeObject && f.push(module$src$shared$singletons$THREELoader.default.loadGeometry(m.data.threeObject, n)) : "tag3d" === m.format && m.hasOwnProperty("data") && Array.isArray(m.data) ? f.push(module$src$shared$singletons$Tag3DLoader.default.load3DTags(m.data)) : "tag2d" === m.format && m.hasOwnProperty("data") &&
                    Array.isArray(m.data) && (l.tag2dArray = [], m.data.forEach(function(a) {
                        return function(b, c) {
                            c = {
                                path: "Tag2D_" + c,
                                type: "tag2d",
                                color: (0, module$src$shared$util$toTinyColor.default)(b.color)
                            };
                            b = module$src$externals$three.default.Tag2D.fromJSON(b);
                            null != b && (c.geometry = b, a.tag2dArray.push(c))
                        }
                    }(l)), f.push(Promise.resolve(l.tag2dArray)))
            }
            e = Promise.all(f).then(function(a) {
                a.forEach(function(a, b) {
                    a = $jscomp.makeIterator(a);
                    for (var c = a.next(); !c.done; c = a.next()) c = c.value, c.path = "content_" + b + "." + c.path
                });
                return a
            }).catch(function(a) {
                return c("loading of geometry failed",
                    a)
            });
            k = Promise.all(k).catch(function(a) {
                return c("loading of material failed", a)
            });
            b = Promise.resolve(b);
            return Promise.all([e, k, b]).then(function(b) {
                if (0 < b[0].length) {
                    d.geometry = [];
                    for (var c = $jscomp.makeIterator(b[0]), e = c.next(); !e.done; e = c.next()) {
                        e = $jscomp.makeIterator(e.value);
                        for (var f = e.next(); !f.done; f = e.next()) d.geometry.push(f.value)
                    }
                }
                0 < b[1].length && (d.material = b[1]);
                0 < b[2].length && (d.data = b[2]);
                d._json = a;
                return d
            })
        },
        x = function(a) {
            for (var b in h) delete h[b][a], delete n[b + "." + a];
            delete l[a]
        };
    d.initSubScene = function(a, c, d, e) {
        var f = function(a, c) {
            c instanceof Error ? a = c : (a = Error(a), a.scope = "SceneManager.initSubScene", a.data = c);
            g && (c = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_ERROR, a, d), b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS, c));
            b.error(a.scope, a.message, a);
            return !1
        };
        if (!d || !d.id) return f("invalid token");
        var g = d.id;
        var k = d.serial ? d.serial : Date.now();
        "number" !== typeof k && (k = parseInt(k), isNaN(k) && (k = Date.now()));
        if (r.hasOwnProperty(c) && r[c].serial > k || q.hasOwnProperty(c) && q[c].serial > k) return a = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_ABORT, "Subscene obsolete because of newer request", d), b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS, a), !1;
        if (l.hasOwnProperty(g)) return f("attempt to register duplicate process " +
            g);
        r[c] = {
            serial: k,
            id: g
        };
        n[c + "." + g] = k;
        l[g] = {
            initTime: Date.now(),
            creatorId: c,
            processId: g,
            totalOutputVersions: a,
            finishedOutputVersions: 0,
            options: e
        };
        h[c] = h[c] || {};
        h[c][g] = {
            creatorId: c,
            processId: g,
            subScene: new module$src$shared$scene$OutputVersion.default
        };
        return !0
    };
    d.addJSONOutputVersionToSubScene = function(a, c, e) {
        var f = function(a, c) {
            c instanceof Error ? a = c : (a = Error(a), a.scope = "SceneManager.addJSONOutputVersionToSubScene", a.data = c);
            g && (c = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_ERROR,
                a, e), b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS, c), x(g));
            b.error(a.scope, a.message, a);
            return Promise.reject(a)
        };
        if (!e || !e.id) return f("invalid token");
        var g = e.id;
        return A(a).then(function(a) {
            return d.addOutputVersionToSubScene(a, c, e)
        }, function(a) {
            return f("conversion of output version failed", a)
        })
    };
    d.addOutputVersionToSubScene = function(a, c, d) {
        var e = function(a, c, e) {
            c instanceof Error ? a = c : (a = e ? {
                    message: a
                } : Error(a), a.scope = "SceneManager.addOutputVersionToSubScene",
                a.data = c);
            f && (c = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_ERROR, a, d), b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS, c), x(f));
            if (e) return b.warn(a.scope, a.message, a), Promise.resolve(!1);
            b.error(a.scope, a.message, a);
            return Promise.reject(a)
        };
        if (!a.id) return e("output version without id");
        if (!d || !d.id) return e("invalid token");
        var f = d.id;
        if (!l[f]) return e("unknown process id " +
            f + ", probably process was superseded", void 0, !0);
        var g = l[f];
        if (g.creatorId !== c) return e("unexpected creatorId");
        if (!h[c] || !h[c][f]) return e("no partial subscene for creatorId/processId, probably process was superseded", void 0, !0);
        var k = r[c];
        return k ? k.id !== f ? (x(f), a = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_ABORT, "Subscene obsolete because of newer request", d), b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS,
            a), Promise.resolve(!1)) : w(d, a).then(function(a) {
            if (!1 === a) {
                var c = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_ABORT, "Subscene superseded, not published", d);
                x(d.id)
            } else !0 === a ? c = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_STATUS, {
                state: module$src$shared$constants$MessagingConstants.default.messageTopics.SCENE_SUBSCENE_OUTPUTVERSION,
                progress: .25 + g.finishedOutputVersions / g.totalOutputVersions * .5
            }, d) : (c = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_SUCCESS, "Subscene published", d), c.addPart(module$src$shared$constants$MessagingConstants.default.messageDataTypes.SUBSCENE_DEFINITION, a), x(d.id));
            b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS, c);
            return a
        }, function(a) {
            return e("adding output version failed",
                a)
        }) : e("could not find latest serial for creator id " + c + ", probably process was superseded", void 0, !0)
    };
    d.numberOfPartialSubScenes = function() {
        return Object.keys(h).length
    };
    d.numberOfCompleteSubScenes = function() {
        return Object.keys(k).length
    };
    d.getModelData = function(a) {
        var b = [];
        a = a || {};
        var c = a.creatorId ? [a.creatorId] : Object.keys(p);
        c = $jscomp.makeIterator(c);
        for (var d = c.next(); !d.done; d = c.next())
            if (d = d.value, p.hasOwnProperty(d)) {
                var e = Object.keys(p[d]);
                e = $jscomp.makeIterator(e);
                for (var f = e.next(); !f.done; f =
                    e.next())
                    if (f = f.value, null == a.id || f == a.id)
                        for (var g = $jscomp.makeIterator(p[d][f]), h = g.next(); !h.done; h = g.next())
                            if (h = h.value, null == a.name || h.name == a.name) h = module$src$shared$util$GlobalUtils.default.deepCopy(h), delete h.format, h.plugin = d, h.id = f, b.push(h)
            }
        return b
    };
    d.getGeometryNames = function(a) {
        var b = {};
        (null == a ? Object.keys(e) : [a]).forEach(function(a) {
            if (e.hasOwnProperty(a) && e[a].hasOwnProperty("_subSceneObject")) {
                b[a] = {};
                for (var c = $jscomp.makeIterator(e[a]._subSceneObject.outputNames), d = c.next(); !d.done; d =
                    c.next()) {
                    d = d.value;
                    b[a][d] = [];
                    var f = e[a]._subSceneObject.getOutputVersionIdByName(d);
                    f = $jscomp.makeIterator(f);
                    for (var g = f.next(); !g.done; g = f.next()) {
                        g = g.value;
                        var h = e[a]._subSceneObject.getOutputVersion(g);
                        h && h.hasOwnProperty("geometry") && b[a][d].push(g)
                    }
                }
            }
        });
        return b
    };
    d.getGeometryPathsByName = function(a, b) {
        var c = [];
        (null == b ? Object.keys(e) : [b]).forEach(function(b) {
            if (e.hasOwnProperty(b) && e[b].hasOwnProperty("_subSceneObject")) {
                var d = e[b]._subSceneObject.getOutputVersionIdByName(a);
                d = $jscomp.makeIterator(d);
                for (var f = d.next(); !f.done; f = d.next()) {
                    f = f.value;
                    var g = e[b]._subSceneObject.getOutputVersion(f);
                    g && g.hasOwnProperty("geometry") && c.push(b + "." + f)
                }
            }
        });
        return c
    };
    d.getJSONOutputVersion = function(a, b, c) {
        if (!e.hasOwnProperty(b)) return null;
        var d = e[b]._subSceneObject.getOutputVersion(a);
        if (!d) return null;
        var f = "_json";
        if (!d.hasOwnProperty(f)) return null;
        c && d.hasOwnProperty("_json_scene") && (f = "_json_scene");
        d = module$src$shared$util$GlobalUtils.default.deepCopy(d[f], g);
        d.scenePath = b + "." + a;
        return d
    };
    d.getOutputIds =
        function(a) {
            return e.hasOwnProperty(a) ? e[a]._subSceneObject.outputIds : []
        };
    d.removeOutputIds = function(a, b) {
        Array.isArray(b) || (b = [b]);
        var d = Promise.resolve();
        if (e[a]) {
            var f = e[a],
                g = {};
            b = $jscomp.makeIterator(b);
            for (var h = b.next(); !h.done; g = {
                    id: g.id
                }, h = b.next()) g.id = h.value, f[g.id] && (f._subSceneObject.removeOutputVersion(g.id), delete f[g.id], d = d.then(function(b) {
                return function() {
                    return c.removeGeometry(a + "." + b.id)
                }
            }(g)))
        }
        return d
    };
    d.setPersistentAttributes = function(a, c, h) {
        var k;
        var l = function(a, b) {
            return u("SceneManager.setPersistentAttributes",
                a, b)
        };
        f[c] = f[c] || {};
        f[c][a] = f[c][a] || {};
        f[c][a].json = f[c][a].json || {};
        var m = module$src$shared$util$GlobalUtils.default.deepCopy(f[c][a].json, g);
        h = module$src$shared$util$GlobalUtils.default.deepCopy(h, g);
        for (k in h) null === h[k] ? delete m[k] : m[k] = h[k];
        m.id = a;
        return A(m, !0).then(function(g) {
            f[c][a].json = m;
            f[c][a].ov = g;
            if (!e.hasOwnProperty(c)) return m;
            g = e[c]._subSceneObject.getOutputVersion(a);
            if (!g) return m;
            var h = {
                id: module$src$shared$util$GlobalUtils.default.createRandomId(),
                serial: Date.now()
            };
            var k =
                new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_STATUS, {
                    busy: !1,
                    progress: 0,
                    creator: "SceneManager.setPersistentAttributes"
                }, h);
            b.message(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS, k);
            return d.initSubScene(1, c, h, {
                forceUpdate: !0
            }) ? d.addOutputVersionToSubScene(g, c, h).then(function() {
                return m
            }) : l("ViewerApp.initSubScene failed")
        })
    };
    d.getPersistentAttributes = function(a, b) {
        return f[b] &&
            f[b][a] ? f[b][a].json : null
    };
    d.getCreatorIds = function() {
        return Object.keys(e)
    };
    return d
};
var module$src$app$handlers$ProcessStatusHandler = {},
    GlobalUtils$$module$src$app$handlers$ProcessStatusHandler = module$src$shared$util$GlobalUtils.default,
    MessagePrototype$$module$src$app$handlers$ProcessStatusHandler = module$src$shared$messages$MessagePrototype.default,
    viewerAppConstants$$module$src$app$handlers$ProcessStatusHandler = module$src$app$ViewerAppConstants.default;
module$src$app$handlers$ProcessStatusHandler.default = function(a) {
    var b = this;
    if (a && a.renderingHandler) var c = a.renderingHandler;
    var d = {},
        e = {
            busy: !1,
            progress: 1,
            processes: module$src$shared$util$GlobalUtils.default.deepCopy(d)
        },
        f = {
            getSummary: function() {
                return module$src$shared$util$GlobalUtils.default.deepCopy(e)
            },
            updateViewerStatus: function() {
                var a = e.busy,
                    f = {
                        busy: !1,
                        progress: 1,
                        processes: module$src$shared$util$GlobalUtils.default.deepCopy(d)
                    },
                    k;
                for (k in d) {
                    var l = d[k];
                    l.busy && (f.busy = !0);
                    void 0 !== l.progress &&
                        "number" === typeof l.progress && l.progress < f.progress && 0 <= l.progress && (f.progress = l.progress)
                }
                e = module$src$shared$util$GlobalUtils.default.deepCopy(f);
                e.busy && !a ? (b.debug("ProcessStatusHandler.updateViewerStatus", "Entering busy mode, progress " + 100 * e.progress + "%", f), a = new module$src$shared$messages$MessagePrototype.default(module$src$app$ViewerAppConstants.default.messageDataTypes.APP_STATUS, f), b.message(module$src$app$ViewerAppConstants.default.messageTopics.STATUS_BUSY, a), c && c.setBlur(e.busy, 100)) :
                    !e.busy && a ? (b.debug("ProcessStatusHandler.updateViewerStatus", "Entering idle mode", f), a = new module$src$shared$messages$MessagePrototype.default(module$src$app$ViewerAppConstants.default.messageDataTypes.APP_STATUS, f), b.message(module$src$app$ViewerAppConstants.default.messageTopics.STATUS_IDLE, a), c && c.setBlur(e.busy, 100)) : e.busy && b.debug("ProcessStatusHandler.updateViewerStatus", "Updating busy mode", f)
            },
            updateProcessStatus: function(a, c) {
                var e = a;
                e && "object" === typeof e && module$src$shared$util$GlobalUtils.default.typeCheck(a.id,
                    "string") && (e = a.id);
                if (!module$src$shared$util$GlobalUtils.default.typeCheck(e, "string")) return !1;
                c = c || {};
                if (d.hasOwnProperty(e)) module$src$shared$util$GlobalUtils.default.inject(c, d[e], !0);
                else if (0 === c.progress) d[e] = {
                    initTime: Date.now()
                }, module$src$shared$util$GlobalUtils.default.inject(c, d[e], !0);
                else return b.debug("ProcessStatusHandler.updateProcessStatus", "Ignoring process status message " + e, c), !1;
                f.updateViewerStatus();
                return !0
            },
            forkProcessStatus: function(a, b) {
                var c = a;
                c && "object" === typeof c &&
                    module$src$shared$util$GlobalUtils.default.typeCheck(a.id, "string") && (c = a.id);
                if (!(module$src$shared$util$GlobalUtils.default.typeCheck(c, "string") && d.hasOwnProperty(c) && Array.isArray(b) && b.every(function(a) {
                        return a.startsWith(c + ".")
                    }))) return !1;
                var e = d[c];
                b.forEach(function(a) {
                    d[a] = module$src$shared$util$GlobalUtils.default.deepCopy(e)
                });
                delete d[c];
                return !0
            },
            unregisterProcess: function(a) {
                var c = a;
                c && "object" === typeof c && module$src$shared$util$GlobalUtils.default.typeCheck(a.id, "string") && (c = a.id);
                if (!module$src$shared$util$GlobalUtils.default.typeCheck(c, "string")) return !1;
                if (!d.hasOwnProperty(c)) return b.debug("ProcessStatusHandler.unregisterProcess", "Unregistering unknown process " + c), !1;
                delete d[c];
                f.updateViewerStatus();
                return !0
            }
        };
    return f
};
var module$src$app$handlers$SettingsHandler = {},
    GlobalUtils$$module$src$app$handlers$SettingsHandler = module$src$shared$util$GlobalUtils.default,
    viewerAppConstants$$module$src$app$handlers$SettingsHandler = module$src$app$ViewerAppConstants.default,
    threeDManagerConstants$$module$src$app$handlers$SettingsHandler = module$src$3d$ThreeDManagerConstants.default;
module$src$app$handlers$SettingsHandler.default = function(a) {
    var b = this,
        c = {},
        d = !1,
        e = {};
    a.threeDManager && (a.threeDManager.lightHandler && (e.ambientIntensity = {
        handler: function(b) {
            return a.threeDManager.updateSetting("lights.light1", {
                type: 0,
                properties: {
                    intensity: parseFloat(b)
                }
            })
        }
    }, e.spotlightIntensity = {
        handler: function(b) {
            return a.threeDManager.updateSetting("lights.light2", {
                type: 1,
                properties: {
                    intensity: parseFloat(b)
                }
            })
        }
    }), a.threeDManager.cameraHandler && (e.topView = {
        handler: function(b) {
            return a.threeDManager.updateSetting("camera.type",
                b ? module$src$3d$ThreeDManagerConstants.default.cameraViewTypes.TOP : module$src$3d$ThreeDManagerConstants.default.cameraViewTypes.PERSPECTIVE)
        }
    }), e.ambientOcclusion = {
        handler: a.threeDManager,
        setting: "render.ambientOcclusion",
        type: "boolean"
    }, e.autoRotateSpeed = {
        handler: a.threeDManager,
        setting: "camera.autoRotationSpeed",
        type: "number",
        hook: function(a) {
            return 0 != a ? [
                ["enableAutoRotation", !0]
            ] : []
        }
    }, e.backgroundColor = {
        type: function(a) {
            return module$src$shared$util$GlobalUtils.default.typeCheck(a, "string") &&
                10 === a.length
        },
        hook: function(a) {
            return [
                ["clearColor", a.substring(0, 8).replace("0x", "#")],
                ["clearAlpha", parseInt(a.substring(8, 10), 16) / 255]
            ]
        }
    }, e.camera = {
        handler: a.threeDManager,
        setting: "camera.defaults.perspective",
        type: "object"
    }, e.clearAlpha = {
        handler: a.threeDManager,
        setting: "render.clearAlpha",
        type: "number"
    }, e.clearColor = {
        handler: a.threeDManager,
        setting: "render.clearColor",
        type: "string"
    }, e.controlDamping = {
        handler: a.threeDManager,
        setting: "camera.damping",
        type: "number"
    }, e.disablePan = {
        handler: a.threeDManager,
        setting: "camera.enablePan",
        type: "boolean",
        transform: function(a) {
            return !a
        }
    }, e.disableZoom = {
        handler: a.threeDManager,
        setting: "camera.enableZoom",
        type: "boolean",
        transform: function(a) {
            return !a
        }
    }, e.enableAutoRotation = {
        handler: a.threeDManager,
        setting: "camera.enableAutoRotation",
        type: "boolean"
    }, e.environmentMap = {
        handler: a.threeDManager,
        setting: "material.environmentMap",
        type: function(a) {
            return module$src$shared$util$GlobalUtils.default.typeCheck(a, "string") || module$src$shared$util$GlobalUtils.default.isArrayOfType(a,
                "string") ? !0 : !1
        }
    }, e.fov = {
        handler: a.threeDManager,
        setting: "camera.fov",
        type: "number"
    }, e.pointSize = {
        handler: a.threeDManager,
        setting: "render.pointSize",
        type: function(a) {
            return "number" === typeof a && 0 <= a ? !0 : !1
        }
    }, e.rotateSpeed = {
        handler: a.threeDManager,
        setting: "camera.rotationSpeed",
        type: "number"
    }, e.showEnvironmentMap = {
        handler: a.threeDManager,
        setting: "material.environmentMapAsBackground",
        type: "boolean"
    }, e.showGrid = {
        handler: a.threeDManager,
        setting: "gridVisibility",
        type: "boolean"
    }, e.showGroundPlane = {
        handler: a.threeDManager,
        setting: "groundPlaneVisibility",
        type: "boolean"
    }, e.showShadows = {
        handler: a.threeDManager,
        setting: "render.shadows",
        type: "boolean"
    }, e.version = {
        handler: function(a) {}
    }, e.zoomExtentFactor = {
        handler: a.threeDManager,
        setting: "camera.zoomExtentsFactor",
        type: "number"
    }, e.zoomSpeed = {
        handler: a.threeDManager,
        setting: "camera.zoomSpeed",
        type: "number"
    }, e.bumpAmplitude = {
        handler: function() {
            return !0
        }
    }, e.directUpdates = {
        handler: function() {
            return !0
        }
    }, e.directionallight2Intensity = {
        handler: function() {
            return !0
        }
    }, e.edgeColor = {
        handler: function() {
            return !0
        }
    }, e.edgeColorByObject = {
        handler: function() {
            return !0
        }
    }, e.showEdges = {
        handler: function() {
            return !0
        }
    });
    e.controlOrder = {
        handler: function() {
            return !0
        }
    };
    e.controlNames = {
        handler: function() {
            return !0
        }
    };
    e.parametersHidden = {
        handler: function() {
            return !0
        }
    };
    a.app && (e.defaultMaterialColor = {
        handler: a.app,
        setting: "defaultMaterial.color",
        type: "string"
    });
    c.getStoredSetting = function(a) {
        return d ? module$src$shared$util$GlobalUtils.default.deepCopy(module$src$shared$util$GlobalUtils.default.getAtPath(d,
            a)) : !1
    };
    c.hasStoredSetting = function(a) {
        return d ? void 0 !== module$src$shared$util$GlobalUtils.default.getAtPath(d, a) : !1
    };
    c.restoreSetting = function(a, g) {
        if (e.hasOwnProperty(a)) {
            var f = e[a];
            if (f.hasOwnProperty("handler") && "function" === typeof f.handler) return f.handler(g);
            if (void 0 === f.handler || "object" !== typeof f.handler || !module$src$shared$util$GlobalUtils.default.typeCheck(f.setting, "string") || 0 >= f.setting.length || !f.handler.hasOwnProperty("updateSettingAsync")) {
                if (f.hasOwnProperty("hook") && "function" ===
                    typeof f.hook) return f.hook(g).forEach(function(a) {
                    return c.restoreSetting(a[0], a[1])
                });
                b.debug("SettingsHandler.restoreSetting", "Mapping for property " + a + " not configured correctly", f);
                return !1
            }
            if (void 0 !== f.type && null !== f.type)
                if (module$src$shared$util$GlobalUtils.default.typeCheck(f.type, "string")) {
                    if (typeof g !== f.type)
                        if (module$src$shared$util$GlobalUtils.default.typeCheck(g, "string") && "number" === f.type) {
                            if (g = parseFloat(g), Number.isNaN(g)) return b.warn("SettingsHandler.restoreSetting", "Not restoring setting " +
                                a + " due to NaN", d[a]), !1
                        } else return b.warn("SettingsHandler.restoreSetting", "Not restoring setting " + a + " due to unexpected data type", d[a]), !1
                } else if ("function" === typeof f.type && !f.type(g)) return b.warn("SettingsHandler.restoreSetting", "Not restoring setting " + a + " due to unexpected data type", d[a]), !1;
            f.hasOwnProperty("transform") && "function" === typeof f.transform && (g = f.transform(g));
            f.handler.updateSettingAsync(f.setting, g).then(function(e) {
                e ? f.hasOwnProperty("hook") && "function" === typeof f.hook &&
                    f.hook(g).forEach(function(a) {
                        return c.restoreSetting(a[0], a[1])
                    }) : b.warn("SettingsHandler.restoreSetting", "Setting " + a + " could not be restored", d[a])
            }, function(c) {
                b.warn("SettingsHandler.restoreSetting", "Setting " + a + " could not be restored", d[a], c)
            })
        } else return b.warn("SettingsHandler.restoreSetting", "Unknown setting " + a), !1;
        return !0
    };
    c.restoreSettings = function() {
        if (void 0 === d || "object" !== typeof d) return !1;
        var a = !0,
            b;
        for (b in d) c.restoreSetting(b, d[b]) || (a = !1);
        return a
    };
    c.saveSettings = function() {
        return Promise.reject(Error("to be implemented"))
    };
    c.messageReceiver = function(a, b, e, k) {
        d || e !== module$src$app$ViewerAppConstants.default.messageDataTypes.APP_SETTINGS || (d = b, c.restoreSettings())
    };
    return c
};
var module$src$api$v2$ApiInterfaceV2 = {},
    ApiLightInterface$$module$src$api$v2$ApiInterfaceV2 = function() {
        this.TYPE = {
            AMBIENT: 0,
            DIRECTIONAL: 1,
            SPOT: 2
        };
        this.LIGHTSCENE = {
            DEFAULT: "default",
            DEFAULT_LEGACY: "default_legacy",
            TEST: "test"
        };
        this.get = function() {};
        this.update = function() {};
        this.remove = function() {};
        this.restore = function() {}
    },
    ApiCameraInterface$$module$src$api$v2$ApiInterfaceV2 = function() {
        this.TYPE = {
            PERSPECTIVE: 0,
            TOP: 1,
            BOTTOM: 2,
            RIGHT: 3,
            LEFT: 4,
            BACK: 5,
            FRONT: 6,
            AR: 7
        };
        this.get = function() {};
        this.updateAsync =
            function() {};
        this.animateAsync = function() {};
        this.zoomAsync = function() {};
        this.resetAsync = function() {}
    },
    ApiParameterInterface$$module$src$api$v2$ApiInterfaceV2 = function() {
        this.EVENTTYPE = {
            REGISTERED: "registered",
            VALUE_UPDATE: "value.update"
        };
        this.RESULT = {
            PARAM_NOT_FOUND: "param_not_found",
            NO_VALUE: "no_value",
            VALUE_REJECT: "value_reject",
            VALUE_EXISTS: "value_exists",
            VALUE_OK: "value_ok",
            PLUGIN_NOT_FOUND: "plugin_not_found",
            ERROR: "error",
            LIVE: "live",
            CACHE: "cache",
            LOAD: "load",
            ABORT: "abort"
        };
        this.TYPE = {
            FLOAT: "Float",
            INT: "Int",
            EVEN: "Even",
            ODD: "Odd",
            STRING: "String",
            COLOR: "Color",
            STRINGLIST: "StringList",
            BOOL: "Bool",
            TIME: "Time"
        };
        this.VISUALIZATION = {
            SLIDER: "slider",
            SEQUENCE: "sequence",
            CYCLE: "cycle",
            DROPDOWN: "dropdown",
            CHECKLIST: "checklist",
            CLOCK: "clock",
            CALENDAR: "calendar"
        };
        this.get = function() {};
        this.updateAsync = function() {};
        this.canGoBackInHistory = function() {};
        this.canGoForwardInHistory = function() {};
        this.goBackInHistoryAsync = function() {};
        this.goForwardInHistoryAsync = function() {};
        this.addEventListener = function() {};
        this.removeEventListener = function() {}
    },
    ApiExportInterface$$module$src$api$v2$ApiInterfaceV2 = function() {
        this.RESULT = {
            EXPORT_NOT_FOUND: "export_not_found",
            PLUGIN_NOT_FOUND: "plugin_not_found",
            ERROR: "error",
            CACHE: "cache",
            LOAD: "load"
        };
        this.EVENTTYPE = {
            AVAILABLE: "available",
            REGISTERED: "registered",
            STATUS: "status"
        };
        this.get = function() {};
        this.requestAsync = function() {};
        this.addEventListener = function() {};
        this.removeEventListener = function() {}
    },
    ApiPluginInterface$$module$src$api$v2$ApiInterfaceV2 = function() {
        this.STATUS = {
            NONE: "none",
            READY: "ready",
            FAILED: "failed",
            LOADED: "loaded",
            ACTIVE: "active",
            UNLOADED: "unloaded"
        };
        this.get = function() {};
        this.registerPluginAsync = function() {};
        this.refreshPluginAsync = function() {};
        this.deregisterPluginAsync = function() {}
    },
    ApiStateInterface$$module$src$api$v2$ApiInterfaceV2 = function() {
        this.EVENTTYPE = {
            BUSY: "busy",
            IDLE: "idle"
        };
        this.get = function() {};
        this.setBusy = function() {};
        this.addEventListener = function() {};
        this.removeEventListener = function() {}
    },
    ApiSceneInterface$$module$src$api$v2$ApiInterfaceV2 =
    function() {
        this.lights = new ApiLightInterface$$module$src$api$v2$ApiInterfaceV2;
        this.camera = new ApiCameraInterface$$module$src$api$v2$ApiInterfaceV2;
        this.FORMAT = {
            GLB: "glb",
            OBJ: "obj",
            THREE: "three",
            DATA: "data",
            MATERIAL: "material",
            TAG2D: "tag2d",
            TAG3D: "tag3d"
        };
        this.EVENTTYPE = {
            DRAG_START: "drag.start",
            DRAG_MOVE: "drag.move",
            DRAG_END: "drag.end",
            HOVER_ON: "hover.on",
            HOVER_OVER: "hover.over",
            HOVER_OFF: "hover.off",
            SELECT_ON: "select.on",
            SELECT_OFF: "select.off",
            VISIBILITY_ON: "visibility.on",
            VISIBILITY_OFF: "visibility.off"
        };
        this.INTERACTIONMODETYPE = {
            GLOBAL: "global",
            SUB: "sub"
        };
        this.SELECTIONMODETYPE = {
            SINGLE: "single",
            MULTIPLE: "multiple"
        };
        this.updateAsync = function() {};
        this.get = function() {};
        this.getData = function() {};
        this.getScreenshot = function() {};
        this.updateSelected = function() {};
        this.getSelected = function() {};
        this.removeAsync = function() {};
        this.render = function() {};
        this.updatePersistentAsync = function() {};
        this.getPersistent = function() {};
        this.updateInteractionGroups = function() {};
        this.getInteractionGroups = function() {};
        this.addEventListener =
            function() {};
        this.removeEventListener = function() {}
    };
module$src$api$v2$ApiInterfaceV2.default = function() {
    this.state = new ApiStateInterface$$module$src$api$v2$ApiInterfaceV2;
    this.parameters = new ApiParameterInterface$$module$src$api$v2$ApiInterfaceV2;
    this.exports = new ApiExportInterface$$module$src$api$v2$ApiInterfaceV2;
    this.plugins = new ApiPluginInterface$$module$src$api$v2$ApiInterfaceV2;
    this.scene = new ApiSceneInterface$$module$src$api$v2$ApiInterfaceV2;
    this.getSettingDefinitions = function() {};
    this.getSettings = function() {};
    this.getSetting = function() {};
    this.updateSettingAsync = function() {};
    this.updateSettingsAsync = function() {};
    this.getRuntimeId = function() {}
};
var module$src$api$v2$ApiImplementationV2 = {},
    messagingConstants$$module$src$api$v2$ApiImplementationV2 = module$src$shared$constants$MessagingConstants.default,
    pluginConstantsGlobal$$module$src$api$v2$ApiImplementationV2 = module$src$shared$constants$PluginConstantsGlobal.default,
    GlobalUtils$$module$src$api$v2$ApiImplementationV2 = module$src$shared$util$GlobalUtils.default,
    MessagePrototype$$module$src$api$v2$ApiImplementationV2 = module$src$shared$messages$MessagePrototype.default,
    ApiInterfaceV2$$module$src$api$v2$ApiImplementationV2 =
    new module$src$api$v2$ApiInterfaceV2.default,
    APIResponse$$module$src$api$v2$ApiImplementationV2 = function(a, b, c) {
        var d = {};
        void 0 !== a && null !== a && (module$src$shared$util$GlobalUtils.default.typeCheck(a, "string") ? d.err = Error(a) : a instanceof Error ? d.err = a : a.hasOwnProperty("m") ? (d.err = Error(a.m), a.hasOwnProperty("d") && (d.err.data = Error(a.d))) : (d.err = Error(), d.err.data = a));
        void 0 !== b && null !== b && (d.data = b);
        void 0 !== c && null !== c && (d.payload = c);
        return d
    },
    LightApi$$module$src$api$v2$ApiImplementationV2 = function(a,
        b) {
        function c() {
            for (var a = [], b = 1; 10 > b; b++) {
                var c = g.getSetting("lights.light" + b);
                c && c.hasOwnProperty("type") && c.hasOwnProperty("properties") && (c.properties.id = b, c.properties.type = c.type, a.push(c.properties))
            }
            return a
        }

        function d() {
            for (var a = 1; 10 > a; a++) {
                var b = g.getSetting("lights.light" + a);
                if (!(b && b.type && b.properties)) return a
            }
            return -1
        }

        function e(a) {
            return !module$src$shared$util$GlobalUtils.default.typeCheck(a, "number") || 1 > a || 9 < a ? !1 : !0
        }
        var f = this;
        this.TYPE = ApiInterfaceV2$$module$src$api$v2$ApiImplementationV2.scene.lights.TYPE;
        this.LIGHTSCENE = ApiInterfaceV2$$module$src$api$v2$ApiImplementationV2.scene.lights.LIGHTSCENE;
        var g = b.threeDManager;
        this.get = function() {
            return APIResponse$$module$src$api$v2$ApiImplementationV2(null, c())
        };
        this.update = function(a) {
            a = a || [];
            Array.isArray(a) || (a = [a]);
            var b = {};
            a = $jscomp.makeIterator(a);
            for (var h = a.next(); !h.done; b = {
                    light: b.light
                }, h = a.next()) {
                b.light = h.value;
                if (!module$src$shared$util$GlobalUtils.default.typeCheck(b.light, "object")) return APIResponse$$module$src$api$v2$ApiImplementationV2("Invalid light definition");
                if (!Object.keys(f.TYPE).find(function(a) {
                        return function(b) {
                            return f.TYPE[b] === a.light.type
                        }
                    }(b))) return APIResponse$$module$src$api$v2$ApiImplementationV2("Unknown light type" + b.light.type);
                b.light = module$src$shared$util$GlobalUtils.default.deepCopy(b.light);
                h = b.light.type;
                delete b.light.type;
                var p = void 0;
                if (b.light.hasOwnProperty("id")) {
                    if (!e(b.light.id)) return APIResponse$$module$src$api$v2$ApiImplementationV2("Invalid light id" + b.light.id);
                    p = b.light.id;
                    delete b.light.id
                } else if (p = d(), !e(p)) return APIResponse$$module$src$api$v2$ApiImplementationV2("All available light ids used");
                if (!g.updateSetting("lights.light" + p, {
                        type: h,
                        properties: b.light
                    })) return APIResponse$$module$src$api$v2$ApiImplementationV2("Error ", c())
            }
            return f.get()
        };
        this.remove = function(a) {
            return e(a) ? g.updateSetting("lights.light" + a, {}) ? f.get() : APIResponse$$module$src$api$v2$ApiImplementationV2("Error removing light " + a) : APIResponse$$module$src$api$v2$ApiImplementationV2("Invalid light id")
        };
        this.restore = function(a) {
            return Object.keys(f.LIGHTSCENE).find(function(b) {
                    return f.LIGHTSCENE[b] === a
                }) ? g.lightHandler.restoreDefaultConfiguration(a) ?
                f.get() : APIResponse$$module$src$api$v2$ApiImplementationV2("Error restoring light scene") : APIResponse$$module$src$api$v2$ApiImplementationV2("Unknown light scene")
        }
    },
    CameraApi$$module$src$api$v2$ApiImplementationV2 = function(a, b) {
        this.TYPE = ApiInterfaceV2$$module$src$api$v2$ApiImplementationV2.scene.camera.TYPE;
        var c = b.threeDManager,
            d = function() {
                return {
                    position: c.cameraHandler.getCameraPosition(),
                    target: c.cameraHandler.getCameraTarget()
                }
            };
        this.get = function() {
            return APIResponse$$module$src$api$v2$ApiImplementationV2(null,
                d())
        };
        this.updateAsync = function(a, b) {
            return c.cameraHandler.setCameraPositionAndTarget(a.position, a.target, b).then(function(a) {
                return a ? APIResponse$$module$src$api$v2$ApiImplementationV2(null, d()) : APIResponse$$module$src$api$v2$ApiImplementationV2("Setting new camera target and position failed", d())
            })
        };
        this.animateAsync = function(a, b) {
            if (!Array.isArray(a)) return Promise.resolve(APIResponse$$module$src$api$v2$ApiImplementationV2("First parameter must be an array of CameraDefinitions"));
            var e = [],
                f = [];
            a.forEach(function(a) {
                e.push(a.position);
                f.push(a.target)
            });
            return c.cameraHandler.setCameraPath(e, f, b).then(function(a) {
                return a ? APIResponse$$module$src$api$v2$ApiImplementationV2(null, d()) : APIResponse$$module$src$api$v2$ApiImplementationV2("Camera path animation failed", d())
            })
        };
        this.zoomAsync = function(a, b) {
            return c.cameraHandler.zoomExtents(b).then(function(a) {
                return a ? APIResponse$$module$src$api$v2$ApiImplementationV2(null, d()) : APIResponse$$module$src$api$v2$ApiImplementationV2("Zooming to extents failed",
                    d())
            })
        };
        this.resetAsync = function(a) {
            return c.cameraHandler.resetCameraPositionAndTarget(a).then(function(a) {
                return a ? APIResponse$$module$src$api$v2$ApiImplementationV2(null, d()) : APIResponse$$module$src$api$v2$ApiImplementationV2("Resetting camera position or target failed", d())
            })
        }
    },
    StateApi$$module$src$api$v2$ApiImplementationV2 = function(a, b) {
        var c = this;
        this.EVENTTYPE = ApiInterfaceV2$$module$src$api$v2$ApiImplementationV2.state.EVENTTYPE;
        var d = b.processStatusHandler;
        this.get = function() {
            var a = d.getSummary();
            return APIResponse$$module$src$api$v2$ApiImplementationV2(null, a)
        };
        this.setBusy = function(b, c) {
            var e = {};
            if (c) {
                if ("number" !== typeof c || 0 > c || 1 < c) return APIResponse$$module$src$api$v2$ApiImplementationV2("progess must be a number between 0 and 1", d.getSummary());
                e.progress = c
            }
            b ? (e.busy = !0, d.updateProcessStatus(a.getRuntimeId(), e)) : d.unregisterProcess(a.getRuntimeId());
            return this.get()
        };
        this.addEventListener = function(b, d) {
            if (!Object.keys(c.EVENTTYPE).find(function(a) {
                    return c.EVENTTYPE[a] === b
                })) return APIResponse$$module$src$api$v2$ApiImplementationV2("Unsupported event type");
            var e = a.subscribeToMessageStream(module$src$shared$constants$MessagingConstants.default.messageTopics.STATUS + "." + b, function(a, c) {
                a = new Event(b);
                a.api = c.api;
                c.token && (a.token = c.token);
                var e = {};
                e[module$src$shared$constants$MessagingConstants.default.messageDataTypes.APP_STATUS] = {
                    progress: 1
                };
                for (var f in e) {
                    var g = c.getUniquePartByType(f);
                    if (g) {
                        g.data && (g = g.data);
                        var h = e[f] ? e[f] : g,
                            k;
                        for (k in h) a[k] = g[k]
                    }
                }
                d(a)
            });
            return APIResponse$$module$src$api$v2$ApiImplementationV2(null, e)
        };
        this.removeEventListener =
            function(b) {
                return APIResponse$$module$src$api$v2$ApiImplementationV2(null, a.unsubscribeFromMessageStream(b))
            }
    },
    SceneApi$$module$src$api$v2$ApiImplementationV2 = function(a, b) {
        var c = this;
        this.FORMAT = ApiInterfaceV2$$module$src$api$v2$ApiImplementationV2.scene.FORMAT;
        this.EVENTTYPE = ApiInterfaceV2$$module$src$api$v2$ApiImplementationV2.scene.EVENTTYPE;
        this.INTERACTIONMODETYPE = ApiInterfaceV2$$module$src$api$v2$ApiImplementationV2.scene.INTERACTIONMODETYPE;
        this.SELECTIONMODETYPE = ApiInterfaceV2$$module$src$api$v2$ApiImplementationV2.scene.SELECTIONMODETYPE;
        var d = b.sceneManager,
            e = b.threeDManager,
            f = b.messagingHandler;
        this.lights = new LightApi$$module$src$api$v2$ApiImplementationV2(a, {
            threeDManager: e
        });
        this.camera = new CameraApi$$module$src$api$v2$ApiImplementationV2(a, {
            threeDManager: e
        });
        this.updateAsync = function(b, e, k) {
            Array.isArray(b) || (b = [b]);
            var g = e || a.getRuntimeId(),
                h = [],
                m = [];
            b = $jscomp.makeIterator(b);
            for (e = b.next(); !e.done; e = b.next()) {
                var q = e.value;
                if (!q || !q.id) return Promise.resolve(APIResponse$$module$src$api$v2$ApiImplementationV2("Asset without id property",
                    null, k));
                m.push(q.id);
                e = module$src$shared$util$GlobalUtils.default.deepCopy(q, ["canvas", "threeObject", "transformations"]);
                if (q = d.getJSONOutputVersion(q.id, g, !1)) {
                    var r = Object.keys(q);
                    r = $jscomp.makeIterator(r);
                    for (var n = r.next(); !n.done; n = r.next()) n = n.value, e.hasOwnProperty(n) || "version" === n || (e[n] = q[n])
                }
                e.hasOwnProperty("version") || (e.version = module$src$shared$util$GlobalUtils.default.createRandomId());
                h.push(e)
            }
            var t = module$src$shared$constants$MessagingConstants.default.makeMessageToken();
            t.payload =
                k;
            return (new Promise(function(a, b) {
                var e = new module$src$shared$messages$MessagePrototype.default(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_STATUS, {
                    busy: !1,
                    progress: 0
                }, t);
                f.message(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS, e);
                if (d.initSubScene(h.length, g, t)) {
                    e = [];
                    for (var k = $jscomp.makeIterator(h), l = k.next(); !l.done; l = k.next()) e.push(d.addJSONOutputVersionToSubScene(l.value, g, t));
                    return Promise.all(e).then(function() {
                        for (var e = [], f = {}, h = $jscomp.makeIterator(m), k = h.next(); !k.done; f = {
                                asset$212: f.asset$212
                            }, k = h.next()) f.asset$212 = d.getJSONOutputVersion(k.value, g, !0), f.asset$212 && (f.asset$212.addEventListener = function(a) {
                            return function(b, d) {
                                if (!module$src$shared$util$GlobalUtils.default.typeCheck(b, "string") || 0 >= b.length) return APIResponse$$module$src$api$v2$ApiImplementationV2("Event type must be a string");
                                var e = b;
                                b.endsWith(a.asset$212.scenePath) || (e = b + "." + a.asset$212.scenePath);
                                return c.addEventListener(e, d)
                            }
                        }(f), e.push(f.asset$212));
                        e.length == m.length ? a(e) : b("Failed to publish all assets, unknown error.")
                    }, function(a) {
                        b(a)
                    })
                }
                b(Error("Could not initialize subscene."))
            })).then(function(a) {
                return APIResponse$$module$src$api$v2$ApiImplementationV2(null, a, k)
            }, function(a) {
                return Promise.resolve(APIResponse$$module$src$api$v2$ApiImplementationV2(a, null, k))
            })
        };
        this.get = function(b, c, e) {
            b = b || {};
            "object" !== typeof b && (b = {});
            var f = [];
            f = module$src$shared$util$GlobalUtils.default.typeCheck(c, "string") ? [c] : [a.getRuntimeId()];
            c = [];
            f = $jscomp.makeIterator(f);
            for (var g = f.next(); !g.done; g = f.next()) {
                g = g.value;
                var h = b.hasOwnProperty("id") ? [b.id] : d.getOutputIds(g);
                h = $jscomp.makeIterator(h);
                for (var k = h.next(); !k.done; k = h.next()) {
                    k = d.getJSONOutputVersion(k.value, g, e);
                    if (null === k) return APIResponse$$module$src$api$v2$ApiImplementationV2(void 0, []);
                    c.push(k)
                }
            }
            f = Object.keys(b);
            e = {};
            f = $jscomp.makeIterator(f);
            for (g = f.next(); !g.done; e = {
                    f: e.f
                }, g = f.next()) e.f = g.value, c = c.filter(function(a) {
                return function(c) {
                    return c[a.f] === b[a.f]
                }
            }(e));
            return APIResponse$$module$src$api$v2$ApiImplementationV2(null,
                c)
        };
        this.getData = function(a, b) {
            a = module$src$shared$util$GlobalUtils.default.deepCopy(a);
            module$src$shared$util$GlobalUtils.default.typeCheck(b, "string") && (a.plugin = b);
            b = d.getModelData(a);
            return APIResponse$$module$src$api$v2$ApiImplementationV2(null, b)
        };
        this.getScreenshot = function() {
            return e.renderingHandler.getScreenShot()
        };
        this.updateSelected = function(a, b) {
            return e.interactionHandler.setSelectedPaths(a, b)
        };
        this.getSelected = function() {
            return e.interactionHandler.getSelectedPaths()
        };
        this.removeAsync =
            function(b, e, f) {
                e = e || a.getRuntimeId();
                var g = c.get(b, e, !0);
                g.payload = f;
                if (g.err) return g;
                b = [];
                for (var h = $jscomp.makeIterator(g.data), k = h.next(); !k.done; k = h.next()) b.push(k.value.id);
                return d.removeOutputIds(e, b).then(function() {
                    return APIResponse$$module$src$api$v2$ApiImplementationV2(null, g.data, f)
                }, function(a) {
                    return Promise.resolve(APIResponse$$module$src$api$v2$ApiImplementationV2(a, null, f))
                })
            };
        this.updatePersistentAsync = function(b, c, e) {
            Array.isArray(b) || (b = [b]);
            c = c || a.getRuntimeId();
            var f = [];
            b = $jscomp.makeIterator(b);
            for (var g = b.next(); !g.done; g = b.next()) {
                g = g.value;
                if (void 0 === g || "object" !== typeof g) return Promise.resolve(APIResponse$$module$src$api$v2$ApiImplementationV2("Unexpected asset format", null, e));
                if (!g.hasOwnProperty("id")) return Promise.resolve(APIResponse$$module$src$api$v2$ApiImplementationV2('Asset does not have "id" attribute.', null, e));
                f.push(d.setPersistentAttributes(g.id, c, g))
            }
            return Promise.all(f).then(function(a) {
                return APIResponse$$module$src$api$v2$ApiImplementationV2(null,
                    a, e)
            }).catch(function(a) {
                return Promise.resolve(APIResponse$$module$src$api$v2$ApiImplementationV2(a, null, e))
            })
        };
        this.getPersistent = function(b, e) {
            e = e || a.getRuntimeId();
            var f = c.get(b, e, !1);
            if (f.err) return f;
            b = [];
            f = $jscomp.makeIterator(f.data);
            for (var g = f.next(); !g.done; g = f.next())(g = d.getPersistentAttributes(g.value.id, e)) && b.push(g);
            return APIResponse$$module$src$api$v2$ApiImplementationV2(null, b)
        };
        this.updateInteractionGroups = function(a) {
            Array.isArray(a) || (a = [a]);
            var b = {};
            a = $jscomp.makeIterator(a);
            for (var c = a.next(); !c.done; b = {
                    g: b.g,
                    group: b.group
                }, c = a.next()) {
                b.group = c.value;
                if (!b.group || !b.group.id) return APIResponse$$module$src$api$v2$ApiImplementationV2("Interaction group without id property");
                b.g = {};
                ["hoverable", "selectable", "draggable"].forEach(function(a) {
                    return function(b) {
                        a.g[b] = a.group[b] || !1
                    }
                }(b));
                b.group.selectionMode && (b.g.selectionMode = b.group.selectionMode);
                b.g.name = b.group.id;
                c = function(a) {
                    var b = ["active", "passive"],
                        c;
                    for (c in b)
                        if (b = a[c]) {
                            if ("object" !== typeof b) return "Effect has invalid type. Should be object.";
                            if (!b.name) return "Effect has no name property.";
                            if (-1 == ["colorHighlight", "opacityHighlight"].indexOf(b.name)) return "Invalid effect type name."
                        }
                };
                if (b.g.hoverable && b.group.hoverEffect) {
                    var d = c(b.group.hoverEffect);
                    if (d) return APIResponse$$module$src$api$v2$ApiImplementationV2(d);
                    b.g.hoverableHighlight = b.group.hoverEffect
                }
                if (b.g.selectable && b.group.selectionEffect) {
                    if (d = c(b.group.selectionEffect)) return APIResponse$$module$src$api$v2$ApiImplementationV2(d);
                    b.g.selectableHighlight = b.group.selectionEffect
                }
                if (b.g.draggable &&
                    b.group.dragEffect) {
                    if (c = c(b.group.dragEffect)) return APIResponse$$module$src$api$v2$ApiImplementationV2(c);
                    b.g.draggableHighlight = b.group.dragEffect
                }
                c = e.interactionGroupHandler;
                c.isInteractionGroup(b.g.name) && (d = c.getGroup(b.g.name), b.g.hasOwnProperty("hoverable") || (b.g.hoverable = d.isHoverable()), b.g.hasOwnProperty("selectable") || (b.g.selectable = d.isSelectable()), b.g.hasOwnProperty("selectionMode") || (b.g.selectionMode = d.getSelectionMode()), b.g.hasOwnProperty("draggable") || (b.g.draggable = d.isDraggable()),
                    b.g.hasOwnProperty("hoverEffect") || (b.g.hoverEffect = d.getHoverableHighlight()), b.g.hasOwnProperty("selectionEffect") || (b.g.selectionEffect = d.getSelectableHighlight()), b.g.hasOwnProperty("dragEffect") || (b.g.dragEffect = d.getDraggableHighlight()));
                c.addOrReplaceInteractionGroup(b.g)
            }
            return APIResponse$$module$src$api$v2$ApiImplementationV2(null, !0)
        };
        this.getInteractionGroups = function() {
            var a = e.interactionGroupHandler.getGroups(),
                b = [],
                c = {};
            a = $jscomp.makeIterator(a);
            for (var d = a.next(); !d.done; c = {
                    g: c.g
                },
                d = a.next()) d = d.value, c.g = {}, c.g.id = d.getName(), c.g.hoverable = d.isHoverable(), c.g.selectable = d.isSelectable(), c.g.selectionMode = d.getSelectionMode(), c.g.draggable = d.isDraggable(), c.g.hoverEffect = d.getHoverableHighlight(), c.g.selectionEffect = d.getSelectableHighlight(), c.g.dragEffect = d.getDraggableHighlight(), ["dragEffect", "hoverEffect", "selectionEffect"].forEach(function(a) {
                return function(b) {
                    if (a.g[b]) {
                        var c = a.g[b],
                            d = {};
                        ["active", "passive"].forEach(function(a) {
                            if (c[a] && (d[a] = {
                                        name: c[a].name
                                    }, c[a].options &&
                                    (d[a].options = {}, d[a].options.opacity && (d[a].options.opacity = c[a].options.opacity), c[a].options.color))) {
                                var b = c[a].options.color;
                                ["r", "g", "b"].every(function(a) {
                                    return b.hasOwnProperty(a)
                                }) && (d[a].options.color = [255 * b.r, 255 * b.g, 255 * b.b])
                            }
                        });
                        a.g[b] = d
                    }
                }
            }(c)), b.push(c.g);
            return APIResponse$$module$src$api$v2$ApiImplementationV2(null, b)
        };
        this.addEventListener = function(b, d) {
            if (!module$src$shared$util$GlobalUtils.default.typeCheck(b, "string") || 0 >= b.length) return APIResponse$$module$src$api$v2$ApiImplementationV2("Event type must be a string");
            var e;
            if (!Object.keys(c.EVENTTYPE).find(function(a) {
                    a = c.EVENTTYPE[a];
                    return b.startsWith(a) ? (e = a, !0) : !1
                })) return APIResponse$$module$src$api$v2$ApiImplementationV2("Unsupported event type");
            var f = a.subscribeToMessageStream(module$src$shared$constants$MessagingConstants.default.messageTopics.SCENE + "." + b, function(a, b) {
                a = new Event(e);
                a.api = b.api;
                b.token && (a.token = b.token);
                var c = {};
                c[module$src$shared$constants$MessagingConstants.default.messageDataTypes.SCENE_INTERACTION] = null;
                c[module$src$shared$constants$MessagingConstants.default.messageDataTypes.GENERIC] =
                    null;
                for (var f in c) {
                    var g = b.getUniquePartByType(f);
                    if (g) {
                        g.data && (g = g.data);
                        var h = c[f] ? c[f] : g,
                            k;
                        for (k in h) a[k] = g[k]
                    }
                }
                d(a)
            });
            return APIResponse$$module$src$api$v2$ApiImplementationV2(null, f)
        };
        this.removeEventListener = function(b) {
            return APIResponse$$module$src$api$v2$ApiImplementationV2(null, a.unsubscribeFromMessageStream(b))
        };
        this.render = function() {
            e.renderingHandler.render()
        }
    },
    ParameterApi$$module$src$api$v2$ApiImplementationV2 = function(a, b) {
        var c = this;
        this.RESULT = ApiInterfaceV2$$module$src$api$v2$ApiImplementationV2.parameters.RESULT;
        this.TYPE = ApiInterfaceV2$$module$src$api$v2$ApiImplementationV2.parameters.TYPE;
        this.VISUALIZATION = ApiInterfaceV2$$module$src$api$v2$ApiImplementationV2.parameters.VISUALIZATION;
        this.EVENTTYPE = ApiInterfaceV2$$module$src$api$v2$ApiImplementationV2.parameters.EVENTTYPE;
        var d = b.parameterHandler;
        this.get = function(a) {
            return (a = d.getParameterDefinitionsAndValues(a)) ? APIResponse$$module$src$api$v2$ApiImplementationV2(null, a) : APIResponse$$module$src$api$v2$ApiImplementationV2("Failed to get parameter definitions")
        };
        var e = function(a) {
            return !a || "object" !== typeof a || !module$src$shared$util$GlobalUtils.default.typeCheck(a.id, "string") && !module$src$shared$util$GlobalUtils.default.typeCheck(a.idOrName, "string") && !module$src$shared$util$GlobalUtils.default.typeCheck(a.name, "string") || a.plugin && !module$src$shared$util$GlobalUtils.default.typeCheck(a.plugin, "string") || void 0 === a.value ? !1 : !0
        };
        this.updateAsync = function(b, c) {
            Array.isArray(b) || (b = [b]);
            for (var f = $jscomp.makeIterator(b), g = f.next(); !g.done; g = f.next())
                if (!e(g.value)) return Promise.resolve(APIResponse$$module$src$api$v2$ApiImplementationV2("Invalid input, expecting array of ParameterUpdateObject.",
                    null, c));
            var l = module$src$shared$util$GlobalUtils.default.deepCopy(b),
                p = module$src$shared$constants$MessagingConstants.default.makeMessageToken();
            p.payload = c;
            return new Promise(function(b) {
                var e = a.setProcessCallback(p.id, function(d, f) {
                        if (f.hasOwnProperty("parts"))
                            for (d = $jscomp.makeIterator(f.parts), f = d.next(); !f.done; f = d.next()) {
                                f = f.value;
                                if (f.type == module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_SUCCESS) {
                                    a.clearProcessCallback(e);
                                    b(APIResponse$$module$src$api$v2$ApiImplementationV2(null,
                                        l, c));
                                    break
                                }
                                if (f.type == module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_ABORT) {
                                    a.clearProcessCallback(e);
                                    b(APIResponse$$module$src$api$v2$ApiImplementationV2(f.data, null, c));
                                    break
                                }
                                if (f.type == module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_ERROR) {
                                    a.clearProcessCallback(e);
                                    b(APIResponse$$module$src$api$v2$ApiImplementationV2(f.data, null, c));
                                    break
                                }
                            }
                    }),
                    f = d.setMultipleParameterValues(l, p);
                if (f.err) a.error("ApiImplementationV2.ParameterApi.updateAsync",
                    "_parameterHandler.setMultipleParameterValues returned error", f), a.clearProcessCallback(e), b(APIResponse$$module$src$api$v2$ApiImplementationV2({
                    m: "Failed to set parameter values",
                    d: f
                }, null, c));
                else {
                    f.warn && a.warn("ApiImplementationV2.ParameterApi.updateAsync", "_parameterHandler.setMultipleParameterValues returned warning", f);
                    var g = {};
                    f = $jscomp.makeIterator(f.params);
                    for (var h = f.next(); !h.done; g = {
                            p: g.p
                        }, h = f.next()) g.p = h.value, l.find(function(a) {
                        return function(b) {
                            return b.id === a.p.id && b.plugin ===
                                a.p.plugin
                        }
                    }(g)).result = g.p.result
                }
            })
        };
        this.canGoBackInHistory = function() {
            return d.canGoBackInHistory()
        };
        this.canGoForwardInHistory = function() {
            return d.canGoForwardInHistory()
        };
        this.goBackInHistoryAsync = function(b) {
            var c = module$src$shared$constants$MessagingConstants.default.makeMessageToken();
            c.payload = b;
            return new Promise(function(e) {
                var f = a.setProcessCallback(c.id, function(c, g) {
                    if (g.hasOwnProperty("parts"))
                        for (c = $jscomp.makeIterator(g.parts), g = c.next(); !g.done; g = c.next()) {
                            g = g.value;
                            if (g.type ==
                                module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_SUCCESS) {
                                a.clearProcessCallback(f);
                                e(APIResponse$$module$src$api$v2$ApiImplementationV2(null, d.getParameterState(), b));
                                break
                            }
                            if (g.type == module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_ABORT) {
                                a.clearProcessCallback(f);
                                e(APIResponse$$module$src$api$v2$ApiImplementationV2(g.data, null, b));
                                break
                            }
                            if (g.type == module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_ERROR) {
                                a.clearProcessCallback(f);
                                e(APIResponse$$module$src$api$v2$ApiImplementationV2(g.data, null, b));
                                break
                            }
                        }
                });
                d.goBackInHistory(c) || (a.error("ApiImplementationV2.goBackInHistoryAsync", "_parameterHandler.goBackInHistory returned false"), a.clearProcessCallback(f), e(APIResponse$$module$src$api$v2$ApiImplementationV2("Failed to go back in history", null, b)))
            })
        };
        this.goForwardInHistoryAsync = function(b) {
            var c = module$src$shared$constants$MessagingConstants.default.makeMessageToken();
            c.payload = b;
            return new Promise(function(e) {
                var f = a.setProcessCallback(c.id,
                    function(c, g) {
                        if (g.hasOwnProperty("parts"))
                            for (c = $jscomp.makeIterator(g.parts), g = c.next(); !g.done; g = c.next()) {
                                g = g.value;
                                if (g.type == module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_SUCCESS) {
                                    a.clearProcessCallback(f);
                                    e(APIResponse$$module$src$api$v2$ApiImplementationV2(null, d.getParameterState(), b));
                                    break
                                }
                                if (g.type == module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_ABORT) {
                                    a.clearProcessCallback(f);
                                    e(APIResponse$$module$src$api$v2$ApiImplementationV2(g.data,
                                        null, b));
                                    break
                                }
                                if (g.type == module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_ERROR) {
                                    a.clearProcessCallback(f);
                                    e(APIResponse$$module$src$api$v2$ApiImplementationV2(g.data, null, b));
                                    break
                                }
                            }
                    });
                d.goForwardInHistory(c) || (a.error("ApiImplementationV2.goForwardInHistoryAsync", "_parameterHandler.goForwardInHistory returned false"), a.clearProcessCallback(f), e(APIResponse$$module$src$api$v2$ApiImplementationV2("Failed to go forward in history", null, b)))
            })
        };
        this.addEventListener =
            function(b, d) {
                if (!Object.keys(c.EVENTTYPE).find(function(a) {
                        return c.EVENTTYPE[a] === b
                    })) return APIResponse$$module$src$api$v2$ApiImplementationV2("Unsupported event type");
                var e = a.subscribeToMessageStream(module$src$shared$constants$MessagingConstants.default.messageTopics.PARAMETER + "." + b, function(a, c) {
                    a = new Event(b);
                    a.api = c.api;
                    c.token && (a.token = c.token);
                    a.parameter = {};
                    var e = {};
                    e[module$src$shared$constants$MessagingConstants.default.messageDataTypes.PARAMETER_DEFINITION] = null;
                    e[module$src$shared$constants$MessagingConstants.default.messageDataTypes.PARAMETER_UPDATE] =
                        null;
                    for (var f in e) {
                        var g = c.getUniquePartByType(f);
                        if (g) {
                            g.data && (g = g.data);
                            var h = e[f] ? e[f] : g,
                                k;
                            for (k in h) a.parameter[k] = g[k]
                        }
                    }
                    d(a)
                });
                return APIResponse$$module$src$api$v2$ApiImplementationV2(null, e)
            };
        this.removeEventListener = function(b) {
            return APIResponse$$module$src$api$v2$ApiImplementationV2(null, a.unsubscribeFromMessageStream(b))
        }
    },
    ExportApi$$module$src$api$v2$ApiImplementationV2 = function(a, b) {
        var c = this;
        this.RESULT = ApiInterfaceV2$$module$src$api$v2$ApiImplementationV2.exports.RESULT;
        this.EVENTTYPE =
            ApiInterfaceV2$$module$src$api$v2$ApiImplementationV2.exports.EVENTTYPE;
        var d = b.exportHandler;
        this.get = function() {
            return APIResponse$$module$src$api$v2$ApiImplementationV2(null, d.getExportDefinitions())
        };
        var e = function(a) {
            return !a || "object" !== typeof a || !module$src$shared$util$GlobalUtils.default.typeCheck(a.id, "string") && !module$src$shared$util$GlobalUtils.default.typeCheck(a.idOrName, "string") && !module$src$shared$util$GlobalUtils.default.typeCheck(a.name, "string") || a.plugin && "string" !== typeof a.plugin ?
                !1 : !0
        };
        this.requestAsync = function(b, c) {
            if (!e(b)) return Promise.resolve(APIResponse$$module$src$api$v2$ApiImplementationV2("Invalid input, expecting an ExportRequestObject.", null, c));
            var f = d.getUniqueExportByRequestObject(b);
            if (void 0 === f) return Promise.resolve(APIResponse$$module$src$api$v2$ApiImplementationV2("Invalid input, ExportRequestObject did not match a unique export definition.", null, c));
            var g = module$src$shared$constants$MessagingConstants.default.makeMessageToken();
            g.payload = c;
            b.silent &&
                (g.attributes = {
                    silent: !0
                });
            return new Promise(function(b) {
                var e = a.setProcessCallback(g.id, function(d, g) {
                        if (g.hasOwnProperty("parts"))
                            for (d = $jscomp.makeIterator(g.parts), g = d.next(); !g.done; g = d.next()) {
                                g = g.value;
                                if (g.type == module$src$shared$constants$MessagingConstants.default.messageDataTypes.EXPORT_RESULT) {
                                    module$src$shared$util$GlobalUtils.default.defaults(f, g.data, !0);
                                    a.clearProcessCallback(e);
                                    b(APIResponse$$module$src$api$v2$ApiImplementationV2(null, f, c));
                                    break
                                }
                                if (g.type == module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_ABORT) {
                                    a.clearProcessCallback(e);
                                    b(APIResponse$$module$src$api$v2$ApiImplementationV2(g.data, null, c));
                                    break
                                }
                                if (g.type == module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_ERROR) {
                                    a.clearProcessCallback(e);
                                    b(APIResponse$$module$src$api$v2$ApiImplementationV2(g.data, null, c));
                                    break
                                }
                            }
                    }),
                    h = d.requestExport(f, g);
                f.resultcode = h;
                h !== module$src$shared$constants$PluginConstantsGlobal.default.requestExportResults.CACHE && h !== module$src$shared$constants$PluginConstantsGlobal.default.requestExportResults.LOAD && (a.error("ApiImplementationV2.ExportApi.requestAsync",
                    "_exportHandler.requestExport returned error", h), a.clearProcessCallback(e), b(APIResponse$$module$src$api$v2$ApiImplementationV2({
                    m: "Failed to request export",
                    d: h
                }, f, c)))
            })
        };
        this.addEventListener = function(b, d) {
            if (!Object.keys(c.EVENTTYPE).find(function(a) {
                    return c.EVENTTYPE[a] === b
                })) return APIResponse$$module$src$api$v2$ApiImplementationV2("Unsupported event type");
            var e = a.subscribeToMessageStream(module$src$shared$constants$MessagingConstants.default.messageTopics.EXPORT + "." + b, function(a, c) {
                a = new Event(b);
                a.api = c.api;
                c.token && (a.token = c.token);
                a.export = {};
                var e = {};
                e[module$src$shared$constants$MessagingConstants.default.messageDataTypes.EXPORT_DEFINITION] = null;
                e[module$src$shared$constants$MessagingConstants.default.messageDataTypes.EXPORT_RESULT] = null;
                e[module$src$shared$constants$MessagingConstants.default.messageDataTypes.EXPORT_STATUS] = null;
                for (var f in e) {
                    var g = c.getUniquePartByType(f);
                    if (g) {
                        g.data && (g = g.data);
                        var h = e[f] ? e[f] : g,
                            k;
                        for (k in h) a.export[k] = g[k]
                    }
                }
                d(a)
            });
            return APIResponse$$module$src$api$v2$ApiImplementationV2(null,
                e)
        };
        this.removeEventListener = function(b) {
            return APIResponse$$module$src$api$v2$ApiImplementationV2(null, a.unsubscribeFromMessageStream(b))
        }
    },
    PluginApi$$module$src$api$v2$ApiImplementationV2 = function(a, b) {
        this.STATUS = ApiInterfaceV2$$module$src$api$v2$ApiImplementationV2.plugins.STATUS;
        var c = b.pluginHandler,
            d = b.messagingHandler,
            e = b.parameterHandler;
        this.get = function() {
            return APIResponse$$module$src$api$v2$ApiImplementationV2(null, c.getStatusDescription())
        };
        this.registerPluginAsync = function(a) {
            return new Promise(function(b) {
                var e =
                    a.getRuntimeId(),
                    f = [],
                    g = function(c, g) {
                        (c = g.getUniquePartByType(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PLUGIN_RUNTIME_ID)) && c.data === e && (f.forEach(function(a) {
                            d.unsubscribeFromMessageStream(a)
                        }), b(APIResponse$$module$src$api$v2$ApiImplementationV2(null, a.getStatusDescription())))
                    };
                f.push(d.subscribeToMessageStream(module$src$shared$constants$MessagingConstants.default.messageTopics.PLUGIN_ACTIVE, g));
                f.push(d.subscribeToMessageStream(module$src$shared$constants$MessagingConstants.default.messageTopics.PLUGIN_FAILED,
                    g));
                void 0 === c.registerPlugin(a) && (f.forEach(function(a) {
                    d.unsubscribeFromMessageStream(a)
                }), b(APIResponse$$module$src$api$v2$ApiImplementationV2(null, a.getStatusDescription())))
            })
        };
        this.refreshPluginAsync = function(b, c) {
            var d = module$src$shared$constants$MessagingConstants.default.makeMessageToken();
            d.payload = c;
            return new Promise(function(f) {
                var g = a.setProcessCallback(d.id, function(b, d) {
                    if (d.hasOwnProperty("parts"))
                        for (b = $jscomp.makeIterator(d.parts), d = b.next(); !d.done; d = b.next()) {
                            d = d.value;
                            if (d.type ==
                                module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_SUCCESS) {
                                a.clearProcessCallback(g);
                                f(APIResponse$$module$src$api$v2$ApiImplementationV2(null, e.getParameterState(), c));
                                break
                            }
                            if (d.type == module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_ABORT) {
                                a.clearProcessCallback(g);
                                f(APIResponse$$module$src$api$v2$ApiImplementationV2(d.data, null, c));
                                break
                            }
                            if (d.type == module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_ERROR) {
                                a.clearProcessCallback(g);
                                f(APIResponse$$module$src$api$v2$ApiImplementationV2(d.data, null, c));
                                break
                            }
                        }
                });
                e.refreshPlugin(b, d).err && (a.error("ApiImplementationV2.refreshPluginAsync", "_parameterHandler.refreshPlugin failed"), a.clearProcessCallback(g), f(APIResponse$$module$src$api$v2$ApiImplementationV2("Failed to refresh plugin " + b, null, c)))
            })
        };
        this.deregisterPluginAsync = function() {
            return Promise.reject("not implemented yet")
        }
    };
module$src$api$v2$ApiImplementationV2.default = function(a, b) {
    var c = this,
        d = module$src$shared$util$GlobalUtils.default.deepCopy(b);
    d.runtimeId && module$src$shared$util$GlobalUtils.default.typeCheck(d.runtimeId, "string") || (d.runtimeId = module$src$shared$util$GlobalUtils.default.createRandomId());
    this.getRuntimeId = function() {
        return d.runtimeId
    };
    b = a.app;
    var e = a.containerHandler,
        f = a.exportHandler,
        g = a.messagingHandler,
        h = a.parameterHandler,
        k = a.pluginHandler,
        l = a.processStatusHandler,
        p = a.sceneManager,
        m = a.threeDManager;
    module$src$shared$util$GlobalUtils.default.inject(a.loggingHandler, c);
    var q = {};
    this.clearProcessCallback = function(a) {
        if (!q.hasOwnProperty(a)) return !1;
        g.unsubscribeFromMessageStream(q[a].subToken);
        delete q[a];
        return !0
    };
    this.setProcessCallback = function(a, b) {
        if (!q.hasOwnProperty(a)) {
            var d = g.subscribeToMessageStream(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS + "." + a, function(d, e) {
                var f = d.substring(d.indexOf(".") + 1);
                if (q.hasOwnProperty(a)) {
                    var g = q[a],
                        h = e.getUniquePartByType(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_FORK);
                    if (h && Array.isArray(h.data)) {
                        if (h.data.every(function(b) {
                                return b.startsWith(a + ".")
                            })) {
                            var k = g.procTokens;
                            k = k.splice(k.indexOf(f), 1);
                            k = k.concat(h.data);
                            g.procTokens = k
                        } else c.error("ApiImplementationV2.setProcessCallback", "Forked process token must be a sub-token of " + a);
                        try {
                            b(d, e)
                        } catch (N) {
                            c.error("ApiImplementationV2.setProcessCallback", "Exception in process callback:", N)
                        }
                    } else {
                        h = e.getUniquePartByType(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_ERROR);
                        k = e.getUniquePartByType(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_ABORT);
                        var l = e.getUniquePartByType(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_SUCCESS);
                        h ? g.procTokenStat[f] = module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_ERROR : k ? g.procTokenStat[f] = module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_ABORT : l && (g.procTokenStat[f] = module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_SUCCESS);
                        g.procTokens.every(function(a) {
                                return g.procTokenStat.hasOwnProperty(a)
                            }) &&
                            (c.debug("ApiImplementationV2.setProcessCallback", "Clearing process callback for token " + a), c.clearProcessCallback(a));
                        try {
                            b(d, e)
                        } catch (N) {
                            c.error("ApiImplementationV2.setProcessCallback", "Exception in process callback:", N)
                        }
                    }
                } else c.warn("ApiImplementationV2.setProcessCallback", "Message for unknown token:", e)
            });
            q[a] = {
                subToken: d,
                procTokens: [a],
                procTokenStat: {}
            };
            return a
        }
    };
    this.subscribeToMessageStream = function(a, b) {
        return g.subscribeToMessageStream(a, function(a, d) {
            try {
                d = d || {}, d.api = c, b(a, d)
            } catch (v) {
                c.warn("ApiImplementationV2.subscribeToMessageStream",
                    "Exception in callback for topic " + a, v, d)
            }
        })
    };
    this.unsubscribeFromMessageStream = function(a) {
        return g.unsubscribeFromMessageStream(a)
    };
    this.state = new StateApi$$module$src$api$v2$ApiImplementationV2(c, {
        containerHandler: e,
        processStatusHandler: l
    });
    this.parameters = new ParameterApi$$module$src$api$v2$ApiImplementationV2(c, {
        parameterHandler: h,
        messagingHandler: g
    });
    this.plugins = new PluginApi$$module$src$api$v2$ApiImplementationV2(c, {
        pluginHandler: k,
        messagingHandler: g,
        parameterHandler: h
    });
    this.exports = new ExportApi$$module$src$api$v2$ApiImplementationV2(c, {
        exportHandler: f
    });
    this.scene = new SceneApi$$module$src$api$v2$ApiImplementationV2(c, {
        sceneManager: p,
        threeDManager: m,
        messagingHandler: g
    });
    var r = {};
    r.loggingLevel = {
        handler: b,
        setting: "loggingLevel",
        desc: "Level of log messages shown on the console, allowed values: -1 (none), 0 (error), 1 (warn), 2 (info), 3 (debug)",
        type: function(a) {
            return module$src$shared$util$GlobalUtils.default.typeCheck(a, "number") && -1 <= a && 3 >= a
        }
    };
    r.messageLoggingLevel = {
        handler: b,
        setting: "messageLoggingLevel",
        desc: "Log level to be used for logging internal messages, allowed values: -1 (none), 0 (error), 1 (warn), 2 (info), 3 (debug)",
        type: function(a) {
            return module$src$shared$util$GlobalUtils.default.typeCheck(a, "number") && -1 <= a && 3 >= a
        }
    };
    r["scene.camera.autoRotationSpeed"] = {
        handler: m,
        setting: "camera.autoRotationSpeed",
        desc: "Speed of autoration, can be negative, also refer to enableAutoRotation",
        type: "number"
    };
    r["scene.camera.cameraMovementDuration"] = {
        handler: m,
        setting: "camera.cameraMovementDuration",
        desc: "Default duration of camera movements",
        type: "notnegative"
    };
    r["scene.camera.damping"] = {
        handler: m,
        setting: "camera.damping",
        desc: "How much to damp camera movements by the user",
        type: "notnegative"
    };
    r["scene.camera.defaults.perspective"] = {
        handler: m,
        setting: "camera.defaults.perspective",
        desc: "Default position and target for the perspective camera",
        type: function(a) {
            return a && module$src$shared$util$GlobalUtils.default.typeCheck(a.position, "vector3obj") && module$src$shared$util$GlobalUtils.default.typeCheck(a.target, "vector3obj")
        }
    };
    r["scene.camera.defaults.perspective.position"] = {
        handler: m,
        setting: "camera.defaults.perspective.position",
        desc: "Default position for the perspective camera",
        type: "vector3any",
        transform: function(a) {
            return module$src$shared$util$GlobalUtils.default.toVector3(a)
        }
    };
    r["scene.camera.defaults.perspective.target"] = {
        handler: m,
        setting: "camera.defaults.perspective.target",
        desc: "Default target for the perspective camera",
        type: "vector3any",
        transform: function(a) {
            return module$src$shared$util$GlobalUtils.default.toVector3(a)
        }
    };
    r["scene.camera.defaults.orthographic"] = {
        handler: m,
        setting: "camera.defaults.orthographic",
        desc: "Default position and target for the orthographic camera",
        type: function(a) {
            return a && module$src$shared$util$GlobalUtils.default.typeCheck(a.position, "vector3obj") && module$src$shared$util$GlobalUtils.default.typeCheck(a.target, "vector3obj")
        }
    };
    r["scene.camera.defaults.orthographic.position"] = {
        handler: m,
        setting: "camera.defaults.orthographic.position",
        desc: "Default position for the orthographic camera",
        type: "vector3any",
        transform: function(a) {
            return module$src$shared$util$GlobalUtils.default.toVector3(a)
        }
    };
    r["scene.camera.defaults.orthographic.target"] = {
        handler: m,
        setting: "camera.defaults.orthographic.target",
        desc: "Default target for the orthographic camera",
        type: "vector3any",
        transform: function(a) {
            return module$src$shared$util$GlobalUtils.default.toVector3(a)
        }
    };
    r["scene.camera.enableAutoRotation"] = {
        handler: m,
        setting: "camera.enableAutoRotation",
        desc: "Enable / disable automatic rotation of the camera, also refer to autoRotationSpeed",
        type: "boolean"
    };
    r["scene.camera.enableKeyPan"] = {
        handler: m,
        setting: "camera.enableKeyPan",
        desc: "Enable / disable panning using the keyboard, also refer to enablePan",
        type: "boolean"
    };
    r["scene.camera.enableOrbitControls"] = {
        handler: m,
        setting: "camera.enableOrbitControls",
        desc: "Enable / disable orbit controls",
        type: "boolean"
    };
    r["scene.camera.enablePan"] = {
        handler: m,
        setting: "camera.enablePan",
        desc: "Enable / disable panning in general, also refer to enableKeyPan",
        type: "boolean"
    };
    r["scene.camera.enableRotation"] = {
        handler: m,
        setting: "camera.enableRotation",
        desc: "Enable / disable camera rotation",
        type: "boolean"
    };
    r["scene.camera.enableZoom"] = {
        handler: m,
        setting: "camera.enableZoom",
        desc: "Enable / disable zooming",
        type: "boolean"
    };
    r["scene.camera.fov"] = {
        handler: m,
        setting: "camera.fov",
        desc: "Camera frustum vertical field of view angle, unit degree",
        type: function(a) {
            return "number" === typeof a && 0 < a && 180 > a ? !0 : !1
        }
    };
    r["scene.camera.keyPanSpeed"] = {
        handler: m,
        setting: "camera.keyPanSpeed",
        desc: "Speed of panning when using the keyboard",
        type: "number"
    };
    r["scene.camera.restrictions.position.cube"] = {
        handler: m,
        setting: "camera.restrictions.position.cube",
        desc: "Restriction of the camera position inside a cube, minimum and maximum corner of the cube"
    };
    r["scene.camera.restrictions.position.cube.min"] = {
        handler: m,
        setting: "camera.restrictions.position.cube.min",
        desc: "Restriction of the camera position inside a cube, minimum corner of the cube",
        type: "vector3any"
    };
    r["scene.camera.restrictions.position.cube.max"] = {
        handler: m,
        setting: "camera.restrictions.position.cube.max",
        desc: "Restriction of the camera position inside a cube, maximum corner of the cube",
        type: "vector3any"
    };
    r["scene.camera.restrictions.position.sphere"] = {
        handler: m,
        setting: "camera.restrictions.position.sphere",
        desc: "Restriction of the camera position inside a sphere, center and radius of the sphere"
    };
    r["scene.camera.restrictions.position.sphere.center"] = {
        handler: m,
        setting: "camera.restrictions.position.sphere.center",
        desc: "Restriction of the camera position inside a sphere, center of the sphere",
        type: "vector3any"
    };
    r["scene.camera.restrictions.position.sphere.radius"] = {
        handler: m,
        setting: "camera.restrictions.position.sphere.radius",
        desc: "Restriction of the camera position inside a sphere, radius of the sphere",
        type: "notnegative"
    };
    r["scene.camera.restrictions.target.cube"] = {
        handler: m,
        setting: "camera.restrictions.target.cube",
        desc: "Restriction of the camera target inside a cube, minimum and maximum corner of the cube"
    };
    r["scene.camera.restrictions.target.cube.min"] = {
        handler: m,
        setting: "camera.restrictions.target.cube.min",
        desc: "Restriction of the camera target inside a cube, minimum corner of the cube",
        type: "vector3any"
    };
    r["scene.camera.restrictions.target.cube.max"] = {
        handler: m,
        setting: "camera.restrictions.target.cube.max",
        desc: "Restriction of the camera target inside a cube, maximum corner of the cube",
        type: "vector3any"
    };
    r["scene.camera.restrictions.target.sphere"] = {
        handler: m,
        setting: "camera.restrictions.target.sphere",
        desc: "Restriction of the camera target inside a sphere, center and radius of the sphere"
    };
    r["scene.camera.restrictions.target.sphere.center"] = {
        handler: m,
        setting: "camera.restrictions.target.sphere.center",
        desc: "Restriction of the camera target inside a sphere, center of the sphere",
        type: "vector3any"
    };
    r["scene.camera.restrictions.target.sphere.radius"] = {
        handler: m,
        setting: "camera.restrictions.target.sphere.radius",
        desc: "Restriction of the camera target inside a sphere, radius of the sphere",
        type: "notnegative"
    };
    r["scene.camera.restrictions.rotation"] = {
        handler: m,
        setting: "camera.restrictions.rotation",
        desc: "Minimum and maximum polar and azimuth angle of the camera position with respect to the camera target, unit degree",
        type: function(a) {
            return a && Object.keys(a).every(function(b) {
                return "number" === typeof a[b]
            })
        }
    };
    r["scene.camera.restrictions.rotation.minPolarAngle"] = {
        handler: m,
        setting: "camera.restrictions.rotation.minPolarAngle",
        desc: "Minimum polar angle of the camera position with respect to the camera target, unit degree",
        type: function(a) {
            return "number" === typeof a && 0 <= a && 180 >= a ? !0 : !1
        }
    };
    r["scene.camera.restrictions.rotation.maxPolarAngle"] = {
        handler: m,
        setting: "camera.restrictions.rotation.maxPolarAngle",
        desc: "Maximum polar angle of the camera position with respect to the camera target, unit degree",
        type: function(a) {
            return "number" ===
                typeof a && 0 <= a && 180 >= a ? !0 : !1
        }
    };
    r["scene.camera.restrictions.rotation.minAzimuthAngle"] = {
        handler: m,
        setting: "camera.restrictions.rotation.minAzimuthAngle",
        desc: "Minimum azimuth angle of the camera position with respect to the camera target, unit degree",
        type: "number"
    };
    r["scene.camera.restrictions.rotation.maxAzimuthAngle"] = {
        handler: m,
        setting: "camera.restrictions.rotation.maxAzimuthAngle",
        desc: "Maximum azimuth angle of the camera position with respect to the camera target, unit degree",
        type: "number"
    };
    r["scene.camera.restrictions.zoom"] = {
        handler: m,
        setting: "camera.restrictions.zoom",
        desc: "Minimum and maximum distance between camera position and target",
        type: function(a) {
            return a && module$src$shared$util$GlobalUtils.default.typeCheck(a.minDistance, "notnegative") && module$src$shared$util$GlobalUtils.default.typeCheck(a.maxDistance, "notnegative")
        }
    };
    r["scene.camera.restrictions.zoom.minDistance"] = {
        handler: m,
        setting: "camera.restrictions.zoom.minDistance",
        desc: "Minimum distance between camera position and target",
        type: "notnegative"
    };
    r["scene.camera.restrictions.zoom.maxDistance"] = {
        handler: m,
        setting: "camera.restrictions.zoom.maxDistance",
        desc: "Maximum distance between camera position and target",
        type: "notnegative"
    };
    r["scene.camera.rotationSpeed"] = {
        handler: m,
        setting: "camera.rotationSpeed",
        desc: "Speed of camera rotation",
        type: "number"
    };
    r["scene.camera.panSpeed"] = {
        handler: m,
        setting: "camera.panSpeed",
        desc: "Speed of panning",
        type: "number"
    };
    r["scene.camera.type"] = {
        handler: m,
        setting: "camera.type",
        desc: "Set camera type",
        type: function(a) {
            return "number" === typeof a && a >= ApiInterfaceV2$$module$src$api$v2$ApiImplementationV2.scene.camera.TYPE.PERSPECTIVE && a <= ApiInterfaceV2$$module$src$api$v2$ApiImplementationV2.scene.camera.TYPE.AR ? !0 : !1
        }
    };
    r["scene.camera.zoomExtentsFactor"] = {
        handler: m,
        setting: "camera.zoomExtentsFactor",
        desc: "Factor to apply to the bounding box before zooming to extents",
        type: "number"
    };
    r["scene.camera.zoomSpeed"] = {
        handler: m,
        setting: "camera.zoomSpeed",
        desc: "Speed of zooming",
        type: "notnegative"
    };
    r["scene.fullscreen"] = {
        handler: m,
        setting: "fullscreen",
        desc: "Enable / disable fullscreen mode",
        type: "boolean"
    };
    r["scene.gridVisibility"] = {
        handler: m,
        setting: "gridVisibility",
        desc: "Show / hide the grid",
        type: "boolean"
    };
    r["scene.groundPlaneVisibility"] = {
        handler: m,
        setting: "groundPlaneVisibility",
        desc: "Show / hide the ground plane",
        type: "boolean"
    };
    r["scene.groundPlaneReflectionVisibility"] = {
        handler: m,
        setting: "groundPlaneReflectionVisibility",
        desc: "Enable / disable the reflectivity of the groundplane ",
        type: "boolean"
    };
    r["scene.groundPlaneReflectionThreshold"] = {
        handler: m,
        setting: "groundPlaneReflectionThreshold",
        desc: "Allows to control the distance to objects that are still reflected by the groundplane ",
        type: function(a) {
            return "number" === typeof a && 0 <= a
        }
    };
    r["scene.material.default.color"] = {
        handler: b,
        setting: "defaultMaterial.color",
        desc: "Color of the default material",
        type: function(a) {
            return module$src$shared$util$GlobalUtils.default.typeCheck(a, "color") ? !0 : !1
        }
    };
    r["scene.material.environmentMapAsBackground"] = {
        handler: m,
        setting: "material.environmentMapAsBackground",
        desc: "Show / hide the environment map in the background",
        type: "boolean"
    };
    r["scene.material.environmentMap"] = {
        handler: m,
        setting: "material.environmentMap",
        desc: "Name of the environment map to use, or an array of 6 URLs making up the cube mapped environment map",
        type: function(a) {
            return "string" === typeof a || module$src$shared$util$GlobalUtils.default.isArrayOfType(a, "string") && 6 === a.length
        }
    };
    r["scene.render.ambientOcclusion"] = {
        handler: m,
        setting: "render.ambientOcclusion",
        desc: "Enable / disable ambient occlusion for rendering",
        type: "boolean"
    };
    r["scene.render.clearAlpha"] = {
        handler: m,
        setting: "render.clearAlpha",
        desc: "Set background alpha value",
        type: function(a) {
            return "number" === typeof a && 0 <= a && 1 >= a ? !0 : !1
        }
    };
    r["scene.render.clearColor"] = {
        handler: m,
        setting: "render.clearColor",
        desc: "Set background color",
        type: function(a) {
            return module$src$shared$util$GlobalUtils.default.typeCheck(a, "color") ? !0 : !1
        }
    };
    r["scene.render.pointSize"] = {
        handler: m,
        setting: "render.pointSize",
        desc: "Set size of point objects",
        type: function(a) {
            return "number" ===
                typeof a && 0 <= a ? !0 : !1
        }
    };
    r["scene.render.shadows"] = {
        handler: m,
        setting: "render.shadows",
        desc: "Enable / disable shadows for rendering",
        type: "boolean"
    };
    r["scene.show"] = {
        handler: b,
        setting: "showScene",
        desc: "Show / hide the scene",
        type: "boolean"
    };
    this.getSettingDefinitions = function() {
        var a = {};
        Object.keys(r).forEach(function(b) {
            var c = r[b],
                d = {
                    description: c.desc
                };
            c.type && (d.type = c.type);
            c = module$src$shared$util$GlobalUtils.default.deepCopy(d);
            a[b] = c
        });
        return a
    };
    this.getSettings = function(a) {
        Array.isArray(a) ||
            (a = Object.keys(r));
        var b = {};
        a.forEach(function(a) {
            var c = r[a];
            void 0 !== c && (c = c.handler.getSetting(c.setting), module$src$shared$util$GlobalUtils.default.forceAtPath(b, a, c))
        });
        return b
    };
    this.getSetting = function(a) {
        a = r[a];
        if (void 0 !== a) return a.handler.getSetting(a.setting)
    };
    this.updateSettingAsync = function(a, b) {
        a = r[a];
        if (void 0 === a) return Promise.resolve(APIResponse$$module$src$api$v2$ApiImplementationV2("Setting does not exist", !1));
        if (void 0 !== a.type && null !== a.type)
            if (module$src$shared$util$GlobalUtils.default.typeCheck(a.type,
                    "string")) {
                if (module$src$shared$util$GlobalUtils.default.typeCheck(b, "m.type")) return Promise.resolve(APIResponse$$module$src$api$v2$ApiImplementationV2("Setting has wrong value type", !1))
            } else if ("function" === typeof a.type && !a.type(b)) return Promise.resolve(APIResponse$$module$src$api$v2$ApiImplementationV2("Setting has wrong value type", !1));
        a.hasOwnProperty("transform") && "function" === typeof a.transform && (b = a.transform(b));
        return a.handler.updateSettingAsync(a.setting, b).then(function(a) {
            return a ?
                Promise.resolve(APIResponse$$module$src$api$v2$ApiImplementationV2(null, !0)) : Promise.resolve(APIResponse$$module$src$api$v2$ApiImplementationV2("Update of setting failed", !1))
        }, function() {
            return Promise.resolve(APIResponse$$module$src$api$v2$ApiImplementationV2("Update of setting failed", !1))
        })
    };
    this.updateSettingsAsync = function(a) {
        var b = [];
        module$src$shared$util$GlobalUtils.default.getPaths(a, b);
        var d = {},
            e = Promise.resolve(),
            f = {};
        b = $jscomp.makeIterator(b);
        for (var g = b.next(); !g.done; f = {
                path: f.path
            },
            g = b.next()) f.path = g.value, e = e.then(function(b) {
            return function() {
                return c.updateSettingAsync(b.path, module$src$shared$util$GlobalUtils.default.getAtPath(a, b.path))
            }
        }(f)), e = e.then(function(a) {
            return function(b) {
                b.err ? module$src$shared$util$GlobalUtils.default.forceAtPath(d, a.path, !1) : module$src$shared$util$GlobalUtils.default.forceAtPath(d, a.path, !0)
            }
        }(f), function(a) {
            return function() {
                module$src$shared$util$GlobalUtils.default.forceAtPath(d, a.path, !1)
            }
        }(f));
        return e.then(function() {
            return APIResponse$$module$src$api$v2$ApiImplementationV2(null,
                d)
        })
    };
    this.utils = module$src$shared$util$GlobalUtils.default
};
var module$src$api$v1$ApiInterfaceV1 = {
    default: function() {
        this.STATUSCODE = {
            READY: 0,
            BUSY: 1,
            INITIALIZING: 2,
            ERROR: 3
        };
        this.TYPE = {
            FLOAT: "Float",
            INT: "Int",
            EVEN: "Even",
            ODD: "Odd",
            STRING: "String",
            COLOR: "Color",
            STRINGLIST: "StringList",
            BOOL: "Bool",
            TIME: "Time"
        };
        this.VISUALIZATION = {
            SLIDER: "slider",
            SEQUENCE: "sequence",
            CYCLE: "cycle",
            DROPDOWN: "dropdown",
            CHECKLIST: "checklist",
            CLOCK: "clock",
            CALENDAR: "calendar"
        };
        this.activateTopView = function() {};
        this.addDraggableShape = function() {};
        this.cameraPath = function() {};
        this.changeEnvMap =
            function() {};
        this.clearMessagingCallback = function() {};
        this.clearProcessCallback = function() {};
        this.deregisterPlugin = function() {};
        this.disablePan = function() {};
        this.disableZoom = function() {};
        this.fadeInViewer = function() {};
        this.findTexturedGeometry = function() {};
        this.getApiVersion = function() {};
        this.getBackgroundColor = function() {};
        this.getCamera = function() {};
        this.getDraggableShapePosition = function() {};
        this.getExportDefinitions = function() {};
        this.getGeometryNames = function() {};
        this.getGeometryPathsByName = function() {};
        this.getModelData = function() {};
        this.getParameterDefinitions = function() {};
        this.getParameterValues = function() {};
        this.getScreenshot = function() {};
        this.getStatus = function() {};
        this.hideControls = function() {};
        this.hideFullscreenToggle = function() {};
        this.loadStaticMesh = function() {};
        this.refreshPlugin = function() {};
        this.registerPlugin = function() {};
        this.removeDraggableShape = function() {};
        this.removeExternalTexture = function() {};
        this.removeStaticMesh = function() {};
        this.requestExport = function() {};
        this.requestSceneUpdate =
            function() {};
        this.resetCamera = function() {};
        this.restrictCamera = function() {};
        this.restrictPan = function() {};
        this.restrictZoom = function() {};
        this.setAutoRotate = function() {};
        this.setAutoRotation = function() {};
        this.setAutoRotationSpeed = function() {};
        this.setBackgroundColor = function() {};
        this.setButtonColor = function() {};
        this.setCamera = function() {};
        this.setCommandResultCallback = function() {};
        this.setExternalTexture = function() {};
        this.setFOV = function() {};
        this.setPointSize = function() {};
        this.setToggleAmbientOcclusion =
            function() {};
        this.setToggleCastShadow = function() {};
        this.setControlDamping = function() {};
        this.setDamping = function() {};
        this.setEdgeColor = function() {};
        this.setEdgeColorByObject = function() {};
        this.setIgnoreMouse = function() {};
        this.setMessagingCallback = function() {};
        this.setParameterValue = function() {};
        this.setParameterValues = function() {};
        this.setProcessCallback = function() {};
        this.setRotateSpeed = function() {};
        this.setRotationSpeed = function() {};
        this.setZoomExtentFactor = function() {};
        this.setZoomSpeed = function() {};
        this.showControls = function() {};
        this.showEdges = function() {};
        this.showFullscreenToggle = function() {};
        this.showGrid = function() {};
        this.showGroundPlane = function() {};
        this.showShadows = function() {};
        this.showStaticMesh = function() {};
        this.toggleDisablePan = function() {};
        this.toggleDisableZoom = function() {};
        this.toggleFullscreen = function() {};
        this.toggleSceneBackground = function() {};
        this.toggleShadows = function() {};
        this.toggleTopView = function() {};
        this.zoomExtents = function() {}
    }
};
var module$src$api$v1$ApiImplementationV1 = {},
    pluginConstants$$module$src$api$v1$ApiImplementationV1 = module$src$shared$constants$PluginConstantsGlobal.default,
    messagingConstants$$module$src$api$v1$ApiImplementationV1 = module$src$shared$constants$MessagingConstants.default,
    GlobalUtils$$module$src$api$v1$ApiImplementationV1 = module$src$shared$util$GlobalUtils.default,
    threeDManagerConstants$$module$src$api$v1$ApiImplementationV1 = module$src$3d$ThreeDManagerConstants.default,
    toTinyColor$$module$src$api$v1$ApiImplementationV1 =
    module$src$shared$util$toTinyColor.default,
    ApiInterfaceV1$$module$src$api$v1$ApiImplementationV1 = new module$src$api$v1$ApiInterfaceV1.default,
    THREE$$module$src$api$v1$ApiImplementationV1 = module$src$externals$three.default;
module$src$api$v1$ApiImplementationV1.default = function(a) {
    var b = this,
        c = a.app,
        d = a.containerHandler,
        e = a.exportHandler,
        f = a.messagingHandler,
        g = a.parameterHandler,
        h = a.pluginHandler,
        k = a.processStatusHandler,
        l = a.sceneManager,
        p = a.threeDManager;
    module$src$shared$util$GlobalUtils.default.inject(a.loggingHandler, b);
    var m = c.api({
            version: 2
        }),
        q = m.getRuntimeId();
    module$src$shared$mixins$GlobalMixin.default.call(this);
    this.STATUSCODE = ApiInterfaceV1$$module$src$api$v1$ApiImplementationV1.STATUSCODE;
    this.TYPE = ApiInterfaceV1$$module$src$api$v1$ApiImplementationV1.TYPE;
    this.VISUALIZATION = ApiInterfaceV1$$module$src$api$v1$ApiImplementationV1.VISUALIZATION;
    var r = {},
        n, t = function(a, c) {
            if ("function" === typeof n) try {
                n(a, c)
            } catch (B) {
                b.error("ApiImplementationV1._callCommandResultCallback", "Exception in callback:", a, B)
            }
            return c
        },
        u = {};
    a = function(a) {
        if (a.dragPosAbs && a.scenePath) {
            var b = a.scenePath.split(".");
            u[b[1]] = a.dragPosAbs
        }
    };
    m.scene.addEventListener(m.scene.EVENTTYPE.DRAG_MOVE + "." + q, a);
    m.scene.addEventListener(m.scene.EVENTTYPE.DRAG_END + "." + q, a);
    var w = [],
        v, y = function(a) {
            if ("function" ===
                typeof v) try {
                v(a)
            } catch (z) {
                b.error("ApiImplementationV1._sendExternalMsg", "Exception in messaging callback (" + a + "):", z)
            }
        };
    (function() {
        var a = module$src$shared$constants$MessagingConstants.default.messageTopics.SCENE_SUBSCENE_PUBLISHED;
        a = f.subscribeToMessageStream(a, function() {
            y("GeometryUpdateDone")
        });
        w = w.concat(a);
        a = module$src$shared$constants$MessagingConstants.default.messageTopics.PLUGIN_ACTIVE;
        a = f.subscribeToMessageStream(a, function(a, b) {
            if (a = b.getUniquePartByType(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PLUGIN_RUNTIME_ID)) a =
                h.getPluginByRuntimeId(a.data).getShortName() + "Loaded", y(a)
        });
        w = w.concat(a)
    })();
    this.activateTopView = function(a) {
        a = p.updateSetting("camera.type", a ? module$src$3d$ThreeDManagerConstants.default.cameraViewTypes.TOP : module$src$3d$ThreeDManagerConstants.default.cameraViewTypes.PERSPECTIVE);
        return t("activateTopView", a)
    };
    this.addDraggableShape = function(a, c, d, e, f) {
        if (!(module$src$shared$util$GlobalUtils.default.typeCheck(a, "string") && module$src$shared$util$GlobalUtils.default.typeCheck(c, "string") && module$src$shared$util$GlobalUtils.default.typeCheck(d,
                "notnegative") && module$src$shared$util$GlobalUtils.default.typeCheck(e, "color") && module$src$shared$util$GlobalUtils.default.typeCheck(f, "vector3obj"))) return t("addDraggableShape", !1);
        var g = m.scene.get({
            id: a
        }, q);
        if (g.err || 0 < g.data.length) return t("addDraggableShape", !1);
        var h;
        "box" === c ? h = new module$src$externals$three.default.BoxBufferGeometry(d, d, d) : "sphere" === c ? h = new module$src$externals$three.default.SphereBufferGeometry(.5 * d, 20, 20) : "dodecahedron" === c && (h = new module$src$externals$three.default.DodecahedronBufferGeometry(.5 *
            d));
        if (void 0 === h) return t("addDraggableShape", !1);
        c = m.scene.updateInteractionGroups({
            id: q,
            draggable: !0,
            selectable: !1,
            hoverable: !1
        });
        !0 !== c.data ? (b.error("ApiImplementationV1._createInteractionGroup", "Could not add interaction group", c.err), c = !1) : c = !0;
        if (!c) return t("addDraggableShape", !1);
        e = [{
            id: a,
            name: a,
            material: a + "_m",
            interactionGroup: q,
            content: [{
                format: "three",
                data: {
                    threeObject: new module$src$externals$three.default.Mesh(h)
                },
                transformations: (new module$src$externals$three.default.Matrix4).makeTranslation(f.x,
                    f.y, f.z)
            }]
        }, {
            id: a + "_m",
            content: [{
                format: "material",
                data: {
                    version: "3.0",
                    color: e
                }
            }]
        }];
        m.scene.updateAsync(e, q);
        u[a] = module$src$shared$util$GlobalUtils.default.toVector3(f);
        return t("addDraggableShape", !0)
    };
    this.cameraPath = function(a, b, c) {
        if (a.length !== b.length || 0 >= a.length) return t("cameraPath", !1);
        var d = {};
        c && (d.duration = c);
        p.cameraHandler.setCameraPath(a, b, d);
        return t("cameraPath", !0)
    };
    this.changeEnvMap = function(a) {
        p.updateSettingAsync("material.environmentMap", a);
        return !0
    };
    this.clearMessagingCallback =
        function() {
            v = void 0
        };
    this.clearProcessCallback = function(a) {
        if (!r.hasOwnProperty(a)) return !1;
        f.unsubscribeFromMessageStream(r[a].subToken);
        delete r[a];
        return !0
    };
    this.deregisterPlugin = function(a) {
        return h.deregisterPlugin(a)
    };
    this.disablePan = function(a) {
        if (p.getSetting("camera.enablePan") === !a) return t("disablePan", !1);
        a = p.updateSetting("camera.enablePan", !a);
        return t("disablePan", a)
    };
    this.disableZoom = function(a) {
        if (p.getSetting("camera.enableZoom") === !a) return t("disableZoom", !1);
        a = p.updateSetting("camera.enableZoom", !a);
        return t("disableZoom", a)
    };
    this.fadeInViewer = function() {
        d.showScene(!0);
        return !0
    };
    this.findTexturedGeometry = function() {
        var a = b.getGeometryNames(),
            c = [],
            d, e;
        for (d in a)
            for (e in a[d]) c.push(e);
        return t("findTexturedGeometry", c)
    };
    this.getApiVersion = function() {
        return "1.0.0"
    };
    this.getBackgroundColor = function() {
        var a = p.getSetting("render.clearColor"),
            b = p.getSetting("render.clearAlpha");
        a = (0, module$src$shared$util$toTinyColor.default)(a);
        a.setAlpha(b);
        return a.toString("hex8")
    };
    this.getCamera = function() {
        var a =
            p.cameraHandler.getCameraPositionAndTarget();
        return t("getCamera", a)
    };
    this.getDraggableShapePosition = function(a) {
        return u.hasOwnProperty(a) ? t("getDraggableShapePosition", u[a]) : t("getDraggableShapePosition", !1)
    };
    this.getExportDefinitions = function() {
        var a = e.getExportDefinitions();
        t("getExportDefinitions", a)
    };
    this.getGeometryNames = function(a) {
        return l.getGeometryNames(a)
    };
    this.getGeometryPathsByName = function(a, b) {
        return l.getGeometryPathsByName(a, b)
    };
    this.getModelData = function(a) {
        var b = {};
        l.getModelData(a).forEach(function(a) {
            b[a.id] =
                a
        });
        return t("getModelData", b)
    };
    this.getParameterDefinitions = function(a) {
        a = g.getParameterDefinitions(a);
        return t("getParameterDefinitions", a)
    };
    this.getParameterValues = function() {
        var a = g.getParameterValuesCompat();
        return t("getParameterValues", a)
    };
    this.getScreenshot = function() {
        var a = p.renderingHandler.getScreenShot();
        return t("getScreenshot", a)
    };
    this.getStatus = function() {
        var a = h.getStatusDescription();
        if (!a.every(function(a) {
                return a.status !== module$src$shared$constants$PluginConstantsGlobal.default.pluginStatuses.FAILED
            })) return a = {
            statusCode: 3,
            statusText: "Error",
            statusInfo: "At least one plugin failed"
        }, t("getStatus", a);
        if (!a.every(function(a) {
                return a.status === module$src$shared$constants$PluginConstantsGlobal.default.pluginStatuses.ACTIVE
            })) return a = {
            statusCode: 2,
            statusText: "Initializing",
            statusInfo: "The viewer is still initializing"
        }, t("getStatus", a);
        if (k.getSummary().busy) return a = {
            statusCode: 1,
            statusText: "Busy",
            statusInfo: "Viewer is processing a parameter update"
        }, t("getStatus", a);
        a = {
            statusCode: 0,
            statusText: "Ready",
            statusInfo: "Viewer is fully loaded, geometry is being displayed"
        };
        return t("getStatus", a)
    };
    this.hideControls = function() {
        b.error("ApiImplementationV1.hideControls", "Not implemented yet")
    };
    this.hideFullscreenToggle = function() {
        b.error("ApiImplementationV1.hideFullscreenToggle", "Not implemented yet")
    };
    this.loadStaticMesh = function(a, b, c, d, e, f) {
        if (4 > arguments.length || !module$src$shared$util$GlobalUtils.default.typeCheck(d, "string") || 0 === d.length) d = module$src$shared$util$GlobalUtils.default.createRandomId();
        if (!module$src$shared$util$GlobalUtils.default.typeCheck(b, "string") ||
            0 === b.length) return !1;
        var g = m.scene.get({
            id: d
        }, q);
        if (g.err || 0 < g.data.length) return !1;
        g = [{
            id: d,
            material: "material_1",
            version: "1",
            duration: 0,
            content: [{
                format: "obj",
                data: {
                    objUrl: b
                }
            }]
        }];
        module$src$shared$util$GlobalUtils.default.typeCheck(c, "string") && (g[0].content.data.mtlUrl = c);
        module$src$shared$util$GlobalUtils.default.typeCheck(a, "string") && (g[0].content.data.path = a);
        module$src$shared$util$GlobalUtils.default.typeCheck(e, "string") && (g[0].content.data.texturePath = e);
        module$src$shared$util$GlobalUtils.default.typeCheck(f,
            "string") && (g[0].content.data.side = f);
        m.scene.updateAsync(g, q);
        return !0
    };
    this.refreshPlugin = function(a, b) {
        b = module$src$shared$constants$MessagingConstants.default.makeMessageToken(b);
        return g.refreshPlugin(a, b).err ? !1 : !0
    };
    this.registerPlugin = function(a) {
        return h.registerPlugin(a)
    };
    this.removeExternalTexture = function(a, c) {
        if (!module$src$shared$util$GlobalUtils.default.typeCheck(a, "string")) return t("removeExternalTexture", !1);
        var d = "color alpha roughness metalness normal bump".split(" ");
        if ("string" ===
            typeof c) try {
            c = JSON.parse(c), Array.isArray(c) || (c = [c])
        } catch (D) {
            c = d
        } else Array.isArray(c) || (c = d);
        c.includes("color") && (c.splice(c.findIndex(function(a) {
            return "color" === a
        }), 1), c.push("bitmap"));
        c.includes("alpha") && (c.splice(c.findIndex(function(a) {
            return "alpha" === a
        }), 1), c.push("transparency"));
        d = b.getGeometryNames();
        var e;
        for (e in d)
            if (d[e].hasOwnProperty(a)) {
                var f = e;
                break
            }
        if (!f) return t("removeExternalTexture", !1);
        a = m.scene.get({
            name: a
        }, f);
        if (a.err || 1 >= a.data.length) return t("removeExternalTexture", !1);
        a = a.data.filter(function(a) {
            return a.material
        });
        if (1 !== a.length) return t("removeExternalTexture", !1);
        a = m.scene.getPersistent({
            id: a[0].material
        }, f);
        if (a.err || 1 !== a.data.length) return t("removeExternalTexture", !1);
        a = module$src$shared$util$GlobalUtils.default.deepCopy(a.data[0]);
        if (!Array.isArray(a.content) || 0 >= a.content.length || "material" !== a.content[0].format) return t("removeExternalTexture", !1);
        var g = a.content[0].data;
        c.forEach(function(a) {
            delete g[a + "texture"]
        });
        m.scene.updatePersistentAsync([a],
            f);
        return t("removeExternalTexture", !0)
    };
    this.removeDraggableShape = function(a) {
        if (!u.hasOwnProperty(a)) return t("removeDraggableShape", !1);
        m.scene.removeAsync({
            id: a
        }, q);
        delete u[a];
        return t("removeDraggableShape", !0)
    };
    this.removeStaticMesh = function(a) {
        if (!module$src$shared$util$GlobalUtils.default.typeCheck(a, "string") || 0 < !a.length) return !1;
        var b = m.scene.get({
            id: a
        }, q);
        if (b.err || 1 !== b.data.length) return !1;
        m.scene.removeAsync({
            id: a
        }, q);
        return !0
    };
    this.requestExport = function(a, b, c, d) {
        if ("string" === typeof a) a = {
            idOrName: a
        }, "string" === typeof c && (a.plugin = c);
        else if (!a || "object" !== typeof a || !module$src$shared$util$GlobalUtils.default.typeCheck(a.id, "string") && !module$src$shared$util$GlobalUtils.default.typeCheck(a.idOrName, "string") && !module$src$shared$util$GlobalUtils.default.typeCheck(a.name, "string") || a.plugin && "string" !== typeof a.plugin) return t("requestExport", !1);
        d = module$src$shared$constants$MessagingConstants.default.makeMessageToken(d);
        c = e.requestExport(a, d);
        return c !== module$src$shared$constants$PluginConstantsGlobal.default.requestExportResults.CACHE &&
            c !== module$src$shared$constants$PluginConstantsGlobal.default.requestExportResults.LOAD ? t("requestExport", !1) : t("requestExport", !0)
    };
    this.requestSceneUpdate = function() {
        var a = h.getStatusDescription(),
            b = !0;
        a = $jscomp.makeIterator(a);
        for (var c = a.next(); !c.done; c = a.next()) c = c.value, c.status === module$src$shared$constants$PluginConstantsGlobal.default.pluginStatuses.ACTIVE && g.refreshPlugin(c.id).err && (b = !1);
        return b
    };
    this.resetCamera = function(a, b) {
        var c = {
            duration: 0
        };
        void 0 === a && (a = !0);
        a && (c.duration = b ? b :
            800);
        p.cameraHandler.resetCameraPositionAndTarget(c);
        return !0
    };
    this.restrictCamera = function(a, b, c) {
        if ("number" === typeof a)
            if (0 === a) a = "x";
            else if (1 === a) a = "y";
        else if (2 === a) a = "z";
        else return t("restrictCamera", !1);
        else if ("string" === typeof a) {
            if ("x" !== a && "y" !== a && "z" !== a) return t("restrictCamera", !1)
        } else return t("restrictCamera", !1);
        var d = "min";
        b && (d = "max");
        if ("number" !== typeof c) return t("restrictCamera", !1);
        b = p.getSetting("camera.restrictions.position.cube");
        b[d][a] = c;
        c = p.updateSetting("camera.restrictions.position.cube",
            b);
        return t("restrictCamera", c)
    };
    this.restrictPan = function(a, b, c) {
        if ("number" === typeof a)
            if (0 === a) a = "x";
            else if (1 === a) a = "y";
        else if (2 === a) a = "z";
        else return t("restrictPan", !1);
        else if ("string" === typeof a) {
            if ("x" !== a && "y" !== a && "z" !== a) return !1
        } else return t("restrictPan", !1);
        var d = "min";
        b && (d = "max");
        if ("number" !== typeof c) return t("restrictPan", !1);
        b = p.getSetting("camera.restrictions.target.cube");
        b[d][a] = c;
        c = p.updateSetting("camera.restrictions.target.cube", b);
        return t("restrictPan", c)
    };
    this.restrictZoom =
        function(a, b) {
            a = p.updateSetting("camera.restrictions.zoom", {
                minDistance: a,
                maxDistance: b
            });
            return t("restrictZoom", a)
        };
    this.setAutoRotate = function(a) {
        if ("number" === typeof a) {
            var c = b.setAutoRotationSpeed(a);
            a = p.updateSetting("camera.enableAutoRotation", 0 !== a);
            return t("setAutoRotate", c || a)
        }
        return "boolean" === typeof a ? (c = p.updateSetting("camera.enableAutoRotation", a), t("setAutoRotate", c)) : t("setAutoRotate", !1)
    };
    this.setAutoRotation = function(a) {
        return b.setAutoRotate(a)
    };
    this.setAutoRotationSpeed = function(a) {
        return "number" !==
            typeof a ? !1 : p.updateSetting("camera.autoRotationSpeed", a)
    };
    this.setBackgroundColor = function(a) {
        a = (0, module$src$shared$util$toTinyColor.default)(a);
        return a.isValid() && p.updateSetting("render.clearColor", a.toString("hex6")) && p.updateSetting("render.clearAlpha", a.getAlpha()) ? t("setBackgroundColor", !0) : t("setBackgroundColor", !1)
    };
    this.setButtonColor = function() {
        b.error("ApiImplementationV1.setButtonColor", "Not implemented yet")
    };
    this.setExternalTexture = function(a, c) {
        if (!module$src$shared$util$GlobalUtils.default.typeCheck(a,
                "string")) return t("setExternalTexture", !1);
        if ("string" === typeof c) try {
                c = JSON.parse(c)
            } catch (D) {
                c = {
                    color: c
                }
            } else if (c && "object" === typeof c) c = module$src$shared$util$GlobalUtils.default.deepCopy(c);
            else return t("setExternalTexture", !1);
        c.color && (c.bitmap = c.color, delete c.color);
        c.alpha && (c.transparency = c.alpha, delete c.alpha);
        var d = b.getGeometryNames();
        for (f in d)
            if (d[f].hasOwnProperty(a)) {
                var e = f;
                break
            }
        if (!e) return t("setExternalTexture", !1);
        a = m.scene.get({
            name: a
        }, e);
        if (a.err || 1 >= a.data.length) return t("setExternalTexture", !1);
        a = a.data.filter(function(a) {
            return a.material
        });
        if (1 !== a.length) return t("setExternalTexture", !1);
        d = a[0];
        a = m.scene.get({
            id: d.material
        }, e);
        if (a.err || 1 !== a.data.length || !Array.isArray(a.data[0].content) || 0 >= a.data[0].content.length) return t("setExternalTexture", !1);
        var f = {};
        f.content = module$src$shared$util$GlobalUtils.default.deepCopy(a.data[0].content);
        if ("material" !== f.content[0].format) return t("setExternalTexture", !1);
        var g = f.content[0].data;
        "bitmap metalness roughness bump normal transparency".split(" ").forEach(function(a) {
            if (c[a] &&
                module$src$shared$util$GlobalUtils.default.typeCheck(c[a], "string")) {
                var b = a + "texture";
                g[b] && "object" === typeof g[b] ? g[b].href = c[a] : g[b] = c[a]
            }
        });
        f.id = d.material;
        m.scene.updatePersistentAsync([f], e);
        return t("setExternalTexture", !0)
    };
    this.setCamera = function(a, b, c, d) {
        var e = {
            duration: 0
        };
        void 0 === c && (c = !0);
        c && (e.duration = d ? d : 800);
        a = p.cameraHandler.setCameraPositionAndTarget(a, b, e);
        return t("setCamera", a)
    };
    this.setCommandResultCallback = function(a) {
        n = a
    };
    this.setFOV = function(a) {
        a = p.updateSetting("camera.fov",
            a);
        return t("setFOV", a)
    };
    this.setPointSize = function(a) {
        "number" !== typeof a && (a = 1);
        a = p.updateSetting("render.pointSize", a);
        return t("setPointSize", a)
    };
    this.setToggleAmbientOcclusion = function(a) {
        return p.updateSetting("render.ambientOcclusion", a)
    };
    this.setToggleCastShadow = function(a, b) {
        p.setToggleCastShadow(a, b)
    };
    this.setControlDamping = function(a) {
        a = p.updateSetting("camera.damping", a);
        return t("setControlDamping", a)
    };
    this.setDamping = function(a) {
        return b.setControlDamping(a)
    };
    this.setEdgeColor = function() {
        b.warn("ApiImplementationV1.setEdgeColor",
            "Not implemented");
        return !1
    };
    this.setEdgeColorByObject = function() {
        b.warn("ApiImplementationV1.setEdgeColorByObject", "Not implemented");
        return !1
    };
    this.setIgnoreMouse = function() {
        b.error("ApiImplementationV1.setIgnoreMouse", "Not implemented yet")
    };
    this.setMessagingCallback = function(a) {
        v = a
    };
    var A = function(a) {
        return !a || "object" !== typeof a || "string" !== typeof a.id && "string" !== typeof a.idOrName && "string" !== typeof a.name || a.plugin && "string" !== typeof a.plugin || void 0 === a.value ? !1 : !0
    };
    this.setParameterValue =
        function(a, c) {
            if ("string" === typeof a) a = {
                idOrName: a,
                value: c
            };
            else if (A(a)) var d = c;
            else return t("setParameterValue", !1);
            d = module$src$shared$constants$MessagingConstants.default.makeMessageToken(d);
            c = g.setParameterValue(a, d);
            if (c.err) return b.error("ApiImplementationV1.setParameterValue", "_parameterHandler.setParameterValue returned error", c), t("setParameterValue", !1);
            if (c.warn) return b.warn("ApiImplementationV1.setParameterValue", "_parameterHandler.setParameterValue returned warning", c), t("setParameterValue", !1);
            b.debug("ApiImplementationV1.setParameterValue", "_parameterHandler.setParameterValue returned", c);
            return t("setParameterValue", !0)
        };
    this.setParameterValues = function(a, c) {
        var d = [];
        if (!Array.isArray(a)) return t("setParameterValues", !1);
        if (a.every(function(a) {
                return "string" === typeof a
            })) {
            if (!Array.isArray(c) || c.length !== a.length) return !1;
            for (var e = 0; e < a.length; e++) d.push({
                idOrName: a[e],
                value: c[e]
            })
        } else if (a.every(function(a) {
                return A(a)
            })) {
            d = a;
            var f = c
        }
        f = module$src$shared$constants$MessagingConstants.default.makeMessageToken(f);
        a = g.setMultipleParameterValues(d, f);
        if (a.err) return b.error("ApiImplementationV1.setParameterValues", "_parameterHandler.setParameterValue returned error", a), t("setParameterValues", !1);
        if (a.warn) return b.warn("ApiImplementationV1.setParameterValues", "_parameterHandler.setParameterValue returned warning", a), t("setParameterValues", !1);
        b.debug("ApiImplementationV1.setParameterValues", "_parameterHandler.setParameterValue returned", a);
        return t("setParameterValues", !0)
    };
    this.setProcessCallback = function(a,
        c) {
        if (!r.hasOwnProperty(a)) {
            var d = f.subscribeToMessageStream(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS + "." + a, function(d, e) {
                var f = d.substring(d.indexOf(".") + 1);
                if (r.hasOwnProperty(a)) {
                    var g = r[a],
                        h = e.getUniquePartByType(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_FORK);
                    if (h && Array.isArray(h.data)) {
                        if (h.data.every(function(b) {
                                return b.startsWith(a + ".")
                            })) {
                            var k = g.procTokens;
                            k = k.splice(k.indexOf(f), 1);
                            k = k.concat(h.data);
                            g.procTokens =
                                k
                        } else b.error("ApiImplementationV1.setProcessCallback", "Forked process token must be a sub-token of " + a);
                        try {
                            c(d, e)
                        } catch (L) {
                            b.error("ApiImplementationV1.setProcessCallback", "Exception in process callback:", L)
                        }
                    } else {
                        h = e.getUniquePartByType(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_ERROR);
                        k = e.getUniquePartByType(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_ABORT);
                        var l = e.getUniquePartByType(module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_SUCCESS);
                        h ? g.procTokenStat[f] = module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_ERROR : k ? g.procTokenStat[f] = module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_ABORT : l && (g.procTokenStat[f] = module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_SUCCESS);
                        g.procTokens.every(function(a) {
                            return g.procTokenStat.hasOwnProperty(a)
                        }) && (b.debug("ApiImplementationV1.setProcessCallback", "Clearing process callback for token " + a), b.clearProcessCallback(a));
                        try {
                            c(d, e)
                        } catch (L) {
                            b.error("ApiImplementationV1.setProcessCallback", "Exception in process callback:", L)
                        }
                    }
                } else b.warn("ApiImplementationV1.setProcessCallback", "Message for unknown token:", e)
            });
            r[a] = {
                subToken: d,
                procTokens: [a],
                procTokenStat: {}
            };
            return a
        }
    };
    this.setRotateSpeed = function(a) {
        a = p.updateSetting("camera.rotationSpeed", a);
        return t("setRotateSpeed", a)
    };
    this.setRotationSpeed = function(a) {
        return b.setRotateSpeed(a)
    };
    this.setZoomExtentFactor = function(a) {
        a = p.updateSetting("camera.zoomExtentsFactor",
            a);
        return t("setZoomExtentFactor", a)
    };
    this.setZoomSpeed = function(a) {
        a = p.updateSetting("camera.zoomSpeed", a);
        return t("setZoomSpeed", a)
    };
    this.showControls = function() {
        b.error("ApiImplementationV1.showControls", "Not implemented yet")
    };
    this.showEdges = function() {
        b.warn("ApiImplementationV1.showEdges", "Not implemented");
        return !1
    };
    this.showFullscreenToggle = function() {
        b.error("ApiImplementationV1.showFullscreenToggle", "Not implemented yet")
    };
    this.showGrid = function(a) {
        "boolean" !== typeof a && (a = !0);
        if (p.getSettingShallow("gridVisibility") ==
            a) return t("showGrid", !1);
        a = p.updateSetting("gridVisibility", a);
        return t("showGrid", a)
    };
    this.showGroundPlane = function(a) {
        "boolean" !== typeof a && (a = !0);
        if (p.getSettingShallow("groundPlaneVisibility") == a) return t("showGroundPlane", !1);
        a = p.updateSetting("groundPlaneVisibility", a);
        return t("showGroundPlane", a)
    };
    this.showShadows = function(a) {
        "boolean" !== typeof a && (a = !0);
        if (p.getSettingShallow("render.shadows") == a) return t("showShadows", !1);
        a = p.updateSetting("render.shadows", a);
        return t("showShadows", a)
    };
    this.showStaticMesh = function(a, b) {
        if (!module$src$shared$util$GlobalUtils.default.typeCheck(a, "string") || 0 === a.length || !module$src$shared$util$GlobalUtils.default.typeCheck(b, "boolean")) return !1;
        var c = m.scene.get({
            id: a
        }, q);
        if (c.err || 1 !== c.data.length) return !1;
        m.scene.updateAsync({
            id: a,
            visible: b
        }, q);
        return !0
    };
    this.toggleDisablePan = function() {
        var a = p.getSettingShallow("camera.enablePan");
        return p.updateSetting("camera.enablePan", !a)
    };
    this.toggleDisableZoom = function() {
        var a = p.getSettingShallow("camera.enableZoom");
        a = p.updateSetting("camera.enableZoom", !a);
        return t(a)
    };
    this.toggleFullscreen = function(a) {
        var b = p.getSettingShallow("fullscreen");
        if ("boolean" !== typeof a) a = !b;
        else if (a === b) return !1;
        return p.updateSetting("fullscreen", a)
    };
    this.toggleSceneBackground = function(a) {
        "boolean" !== typeof a && (a = !0);
        return p.updateSetting("material.environmentMapAsBackground", a)
    };
    this.toggleShadows = function() {
        var a = p.getSettingShallow("render.shadows");
        return p.updateSetting("render.shadows", !a)
    };
    this.toggleTopView = function() {
        var a =
            p.getSettingShallow("camera.type") === module$src$3d$ThreeDManagerConstants.default.cameraViewTypes.PERSPECTIVE ? module$src$3d$ThreeDManagerConstants.default.cameraViewTypes.TOP : module$src$3d$ThreeDManagerConstants.default.cameraViewTypes.PERSPECTIVE;
        return p.updateSetting("camera.type", a)
    };
    this.zoomExtents = function(a, b) {
        var c = {
            duration: 0
        };
        void 0 === a && (a = !0);
        a && (c.duration = b ? b : 800);
        p.cameraHandler.zoomExtents(c);
        return !0
    };
    return this
};
var module$src$app$conf$DispatchingConstants = {},
    callbackParamTypes$$module$src$app$conf$DispatchingConstants = {
        TYPE: "type",
        DATA: "data",
        TOKEN: "token",
        ORIGIN: "origin",
        TOPIC: "topic",
        PLUGIN: "plugin"
    },
    callbackParamTypesDefault$$module$src$app$conf$DispatchingConstants = [callbackParamTypes$$module$src$app$conf$DispatchingConstants.TOKEN, callbackParamTypes$$module$src$app$conf$DispatchingConstants.DATA, callbackParamTypes$$module$src$app$conf$DispatchingConstants.TYPE, callbackParamTypes$$module$src$app$conf$DispatchingConstants.ORIGIN],
    dispatchingConstants$$module$src$app$conf$DispatchingConstants = {
        callbackParamTypes: callbackParamTypes$$module$src$app$conf$DispatchingConstants,
        callbackParamTypesDefault: callbackParamTypesDefault$$module$src$app$conf$DispatchingConstants
    },
    GlobalUtils$$module$src$app$conf$DispatchingConstants = module$src$shared$util$GlobalUtils.default;
module$src$app$conf$DispatchingConstants.default = module$src$shared$util$GlobalUtils.default.deepCopy(dispatchingConstants$$module$src$app$conf$DispatchingConstants);
var module$src$app$conf$DispatchingConfig = {},
    GlobalUtils$$module$src$app$conf$DispatchingConfig = module$src$shared$util$GlobalUtils.default;
module$src$app$conf$DispatchingConfig.default = function() {
    var a = {};
    this.getConfig = function() {
        return module$src$shared$util$GlobalUtils.default.deepCopy(a)
    };
    this.addPartListener = function(b, c, d, e) {
        a.hasOwnProperty(b) && "object" === typeof a[b] || (a[b] = {});
        b = a[b];
        b.hasOwnProperty("partListeners") && Array.isArray(b.partListeners) || (b.partListeners = []);
        var f = {};
        f.type = c;
        f.cb = d;
        f.params = e;
        b.partListeners.push(f);
        return !0
    }
};
var module$src$app$conf$DefaultDispatching = {},
    messagingConstants$$module$src$app$conf$DefaultDispatching = module$src$shared$constants$MessagingConstants.default,
    dispatchingConstants$$module$src$app$conf$DefaultDispatching = module$src$app$conf$DispatchingConstants.default,
    DispatchingConfig$$module$src$app$conf$DefaultDispatching = module$src$app$conf$DispatchingConfig.default,
    defaultDispatching$$module$src$app$conf$DefaultDispatching = new module$src$app$conf$DispatchingConfig.default;
defaultDispatching$$module$src$app$conf$DefaultDispatching.addPartListener(module$src$shared$constants$MessagingConstants.default.messageTopics.PARAMETER_REGISTER, module$src$shared$constants$MessagingConstants.default.messageDataTypes.PARAMETER_DEFINITION, "parameterManager.registerMultipleParameters", [module$src$app$conf$DispatchingConstants.default.callbackParamTypes.DATA, module$src$app$conf$DispatchingConstants.default.callbackParamTypes.PLUGIN, module$src$app$conf$DispatchingConstants.default.callbackParamTypes.TOKEN]);
defaultDispatching$$module$src$app$conf$DefaultDispatching.addPartListener(module$src$shared$constants$MessagingConstants.default.messageTopics.PARAMETER_REGISTER, module$src$shared$constants$MessagingConstants.default.messageDataTypes.APP_SETTINGS, "parameterManager.registerConfig", [module$src$app$conf$DispatchingConstants.default.callbackParamTypes.DATA, module$src$app$conf$DispatchingConstants.default.callbackParamTypes.PLUGIN, module$src$app$conf$DispatchingConstants.default.callbackParamTypes.TOKEN]);
defaultDispatching$$module$src$app$conf$DefaultDispatching.addPartListener(module$src$shared$constants$MessagingConstants.default.messageTopics.PLUGIN_ACTIVE, module$src$shared$constants$MessagingConstants.default.messageDataTypes.PLUGIN_RUNTIME_ID, "parameterManager.refreshPluginInitial", [module$src$app$conf$DispatchingConstants.default.callbackParamTypes.PLUGIN, module$src$app$conf$DispatchingConstants.default.callbackParamTypes.TOKEN]);
defaultDispatching$$module$src$app$conf$DefaultDispatching.addPartListener(module$src$shared$constants$MessagingConstants.default.messageTopics.EXPORT_REGISTER, module$src$shared$constants$MessagingConstants.default.messageDataTypes.EXPORT_DEFINITION, "exportManager.registerMultipleExports", [module$src$app$conf$DispatchingConstants.default.callbackParamTypes.DATA, module$src$app$conf$DispatchingConstants.default.callbackParamTypes.PLUGIN, module$src$app$conf$DispatchingConstants.default.callbackParamTypes.TOKEN]);
defaultDispatching$$module$src$app$conf$DefaultDispatching.addPartListener(module$src$shared$constants$MessagingConstants.default.messageTopics.SCENE_SUBSCENE_INIT, module$src$shared$constants$MessagingConstants.default.messageDataTypes.SUBSCENE_INIT, "sceneManager.initSubScene", [module$src$app$conf$DispatchingConstants.default.callbackParamTypes.DATA, module$src$app$conf$DispatchingConstants.default.callbackParamTypes.PLUGIN, module$src$app$conf$DispatchingConstants.default.callbackParamTypes.TOKEN]);
defaultDispatching$$module$src$app$conf$DefaultDispatching.addPartListener(module$src$shared$constants$MessagingConstants.default.messageTopics.SCENE_SUBSCENE_OUTPUTVERSION, module$src$shared$constants$MessagingConstants.default.messageDataTypes.SUBSCENE_OUTPUTVERSION_JSON, "sceneManager.addJSONOutputVersionToSubScene", [module$src$app$conf$DispatchingConstants.default.callbackParamTypes.DATA, module$src$app$conf$DispatchingConstants.default.callbackParamTypes.PLUGIN, module$src$app$conf$DispatchingConstants.default.callbackParamTypes.TOKEN]);
defaultDispatching$$module$src$app$conf$DefaultDispatching.addPartListener(module$src$shared$constants$MessagingConstants.default.messageTopics.SCENE_SUBSCENE_OUTPUTVERSION, module$src$shared$constants$MessagingConstants.default.messageDataTypes.SUBSCENE_OUTPUTVERSION_OBJ, "sceneManager.addOutputVersionToSubScene", [module$src$app$conf$DispatchingConstants.default.callbackParamTypes.DATA, module$src$app$conf$DispatchingConstants.default.callbackParamTypes.PLUGIN, module$src$app$conf$DispatchingConstants.default.callbackParamTypes.TOKEN]);
defaultDispatching$$module$src$app$conf$DefaultDispatching.addPartListener(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS, module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_STATUS, "processStatusHandler.updateProcessStatus");
defaultDispatching$$module$src$app$conf$DefaultDispatching.addPartListener(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS, module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_SUCCESS, "processStatusHandler.unregisterProcess");
defaultDispatching$$module$src$app$conf$DefaultDispatching.addPartListener(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS, module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_ABORT, "processStatusHandler.unregisterProcess");
defaultDispatching$$module$src$app$conf$DefaultDispatching.addPartListener(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS, module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_ERROR, "processStatusHandler.unregisterProcess");
defaultDispatching$$module$src$app$conf$DefaultDispatching.addPartListener(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS, module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_FORK, "processStatusHandler.forkProcessStatus");
defaultDispatching$$module$src$app$conf$DefaultDispatching.addPartListener(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS, module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_INITIAL, "containerHandler.messageReceiver");
defaultDispatching$$module$src$app$conf$DefaultDispatching.addPartListener(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS, module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_SUCCESS, "containerHandler.messageReceiver");
defaultDispatching$$module$src$app$conf$DefaultDispatching.addPartListener(module$src$shared$constants$MessagingConstants.default.messageTopics.PROCESS, module$src$shared$constants$MessagingConstants.default.messageDataTypes.PROCESS_ERROR, "containerHandler.messageReceiver");
defaultDispatching$$module$src$app$conf$DefaultDispatching.addPartListener(module$src$shared$constants$MessagingConstants.default.messageTopics.SETTINGS_REGISTER, module$src$shared$constants$MessagingConstants.default.messageDataTypes.APP_SETTINGS, "settingsHandler.messageReceiver");
module$src$app$conf$DefaultDispatching.default = defaultDispatching$$module$src$app$conf$DefaultDispatching.getConfig();
var module$src$app$ViewerApp = {},
    viewerAppConstants$$module$src$app$ViewerApp = module$src$app$ViewerAppConstants.default;
module$src$app$ViewerApp.default = function(a) {
    var b = this;
    module$src$shared$mixins$GlobalMixin.default.call(this);
    module$src$shared$mixins$SettingsMixin.default.call(this, a, module$src$app$ViewerAppConstants.default.defaultSettings);
    module$src$shared$mixins$LoggingMixin.default.call(this);
    module$src$app$partials$ViewerAppLoggingPartial.default.call(this);
    var c = {
        error: b.error,
        warn: b.warn,
        info: b.info,
        debug: b.debug
    };
    module$src$shared$mixins$MessagingMixin.default.call(this);
    module$src$app$partials$ViewerAppMessagingPartial.default.call(this);
    this.pluginManager = module$src$app$partials$ViewerAppPluginManager.default.call(b);
    this.parameterManager = module$src$app$partials$ViewerAppParameterManager.default.call(b, {
        pluginManager: b.pluginManager
    });
    this.exportManager = module$src$app$partials$ViewerAppExportManager.default.call(b, {
        pluginManager: b.pluginManager,
        parameterManager: b.parameterManager
    });
    this.containerHandler = module$src$app$handlers$ContainerHandler.default.call(b, {
        container: a.container
    });
    this.getContainer = function() {
        return a.container
    };
    a.container ? this.threeDManager = new module$src$3d$ThreeDManager.default({
        canvas: a.container,
        loggingHandler: c,
        messagingHandler: {
            message: b.message,
            subscribeToMessageStream: b.subscribeToMessageStream,
            unsubscribeFromMessageStream: b.unsubscribeFromMessageStream
        }
    }) : void 0 === this.threeDManager && (this.threeDManager = {}, this.threeDManager.addGeometry = function() {}, this.threeDManager.replaceGeometry = function() {}, this.threeDManager.removeGeometry = function() {});
    this.sceneManager = module$src$app$partials$ViewerAppSceneManager.default.call(b, {
        threeDManager: b.threeDManager
    });
    this.processStatusHandler = module$src$app$handlers$ProcessStatusHandler.default.call(b, {
        renderingHandler: b.threeDManager.renderingHandler
    });
    this.settingsHandler = module$src$app$handlers$SettingsHandler.default.call(b, {
        threeDManager: b.threeDManager,
        parameterManager: b.parameterManager,
        app: b
    });
    this.api = function(a) {
        return new(a && a.version && (2 === a.version || "2" === a.version) ? module$src$api$v2$ApiImplementationV2.default : module$src$api$v1$ApiImplementationV1.default)({
            containerHandler: b.containerHandler,
            exportHandler: b.exportManager,
            parameterHandler: b.parameterManager,
            pluginHandler: b.pluginManager,
            processStatusHandler: b.processStatusHandler,
            sceneManager: b.sceneManager,
            settingsHandler: b.settingsHandler,
            threeDManager: b.threeDManager,
            messagingHandler: {
                message: b.message,
                subscribeToMessageStream: b.subscribeToMessageStream,
                unsubscribeFromMessageStream: b.unsubscribeFromMessageStream
            },
            loggingHandler: c,
            app: b
        }, a)
    };
    this.setupDispatching(module$src$app$conf$DefaultDispatching.default);
    this.containerHandler.init();
    a.build_version && a.build_date && b.info("ShapeDiver Viewer App", a.build_version + ", " + a.build_date);
    return this
};
var module$build$package = {},
    GlobalUtils$$module$build$package = module$src$shared$util$GlobalUtils.default,
    build_data$$module$build$package = module$build$build_data.default,
    CreatePackagedViewer$$module$build$package = function() {
        var a = this;
        this.constants = module$src$app$ViewerAppConstants.default;
        this.plugins = {
            runtimeIds: []
        };
        this.plugins.CommPlugin = module$src$plugins$comm$CommPlugin.default;
        this.plugins.PluginPrototype = module$src$plugins$PluginPrototype.default;
        this.utils = module$src$shared$util$GlobalUtils.default;
        this.getBuildData = function() {
            return module$src$shared$util$GlobalUtils.default.deepCopy(module$build$build_data.default)
        };
        this.ParametricViewer = function(b) {
            b = b || {};
            for (var c in module$build$build_data.default) b[c] = module$build$build_data.default[c];
            var d = b.ticket;
            delete b.ticket;
            var e = b.modelViewUrl;
            delete b.modelViewUrl;
            var f = new module$src$app$ViewerApp.default(b);
            c = f.api(b.api);
            c.getApiV1 = function(a) {
                a = a || {};
                a.version = 1;
                return f.api(a)
            };
            c.getApiV2 = function(a) {
                a = a || {};
                a.version = 2;
                return f.api(a)
            };
            b.exposeViewer && (c.getViewer = function() {
                console.warn("Direct access to the ShapeDiver viewer will be disabled for release builds. Use it responsibly.");
                return f
            });
            d && (b = {
                runtimeId: "CommPlugin_1",
                ticket: d,
                loggingLevel: b.loggingLevel,
                messageLoggingLevel: b.messageLoggingLevel
            }, "string" === typeof e && 0 < e.length && (b.modelViewUrl = e), b = new a.plugins.CommPlugin(b), (b = c.getApiV1().registerPlugin(b)) && a.plugins.runtimeIds.push(b));
            return c
        };
        return this
    };
module$build$package.default = new CreatePackagedViewer$$module$build$package;
var SDVApp = module$build$package.default;

//# sourceMappingURL=sdv.concat.min.js.map